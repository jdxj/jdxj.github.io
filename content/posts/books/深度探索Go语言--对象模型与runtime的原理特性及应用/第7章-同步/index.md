---
title: "第7章 同步"
date: 2023-02-20T21:55:24+08:00
draft: true
---

## 7.1 Happens Before

多核情况下避免并发读写的条件

- w happens before r。
- 没有其他针对v的写操作happens after w且before r。

图7-1 多线程并发事件示意图

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P275_11721.jpg)

### 7.1.1 并发

{{< embedcode go "code/main.go" >}}

如果编译器生成的指令与源码中语句的顺序严格一致，上述生产者协程和消费者协程在单核CPU上并发执行是可以保证结果正确的。一旦编译器对生成指令的顺序
进行优化调整，或者程序在多核CPU上执行，就不能保证结果正确了

### 7.1.2 并行

抽象地解释并发，指的是多个事件在宏观上是同时发生的，但是并不一定要在同一时刻发生，而并行就不一样了，从微观角度来看，并行的两个事件至少有某一
时刻是同时发生的，所以在单核CPU上的多线程只存在并发，不存在并行。只有在多核CPU上，线程才有可能并行执行。

## 7.2 内存乱序

- 处理器普遍具有乱序执行的特性，目的都是为了更优的性能。
- 编译器和CPU都会考虑指令间的依赖关系，在不会改变当前线程行为的前提下进行顺序调整，因此在单个线程内依然是逻辑有序的，语句间原本满足的
  happens before条件不会被破坏，但这种有序性只是在单个线程内，并不会保证线程间的有序性。

### 7.2.1 编译期乱序

指的是编译器对最终生成的机器指令进行了顺序调整

### 7.2.2 执行期乱序

CPU在执行期间也可能会对指令的顺序进行调整

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P278_11801.jpg)

协程一和协程二中的两条赋值语句形式相似，对应到x86汇编就是三条内存操作指令，按照顺序及分类分别是Store、Load、Store

图7-2 协程一和协程二的赋值语句对应的汇编指令

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P280_11851.jpg)

一般的内存属于write-back cacheable内存，简称WB内存。对于WB内存而言，Store和Load指令并不是直接操作内存中的数据的，而是先把指定的内存单元
填充到高速缓存中，然后读写高速缓存中的数据。

Load指令的大致流程是，先尝试从高速缓存中读取，如果缓存命中，则读操作就完成了。如果缓存未命中，则先填充对应的Cache Line，
然后从Cache Line中读取

图7-3 Load指令的执行流程

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P280_11855.jpg)

Store指令的大致流程类似，先尝试写高速缓存，如果缓存命中，则写操作就完成了。如果缓存未命中，则先填充对应的Cache Line，然后写到Cache Line中

图7-4 Store指令执行流程

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P281_11861.jpg)

在多核心的CPU上，Store操作会变得更复杂一些。

- 每个CPU核心都拥有自己的高速缓存，例如x86的L1 Cache。写操作会修改当前核心的高速缓存, 被修改的数据可能存在于多个核心的高速缓存中，CPU需要
  保证各个核心间的缓存一致性。
- 目前主流的缓存一致性协议是MESI协议，MESI这个名字取自缓存单元可能的4种状态，分别是已修改的Modified，独占的Exclusive，共享的Shared和无
  效的Invalid。

当一个CPU核心要对自身高速缓存的某个单元进行修改时，它需要先通知其他CPU核心把各自高速缓存中对应的单元置为Invalid，再把自己的这个单元置为
Exclusive，然后就可以进行修改了。

图7-5 一个CPU核心修改高速缓存数据单元的过程

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P281_11865.jpg)

这个过程涉及多核间的内部通信，是一个相对较慢的过程，为了避免当前核心因为等待而阻塞，CPU在设计上又引入了Store Buffer。当前核心向其他核心发出
通知以后，可以先把要写的值放在Store Buffer中，然后继续执行后面的指令，等到其他核心完成响应以后，当前核心再把Store Buffer中的值合并到高速
缓存中

图7-6 引入Store Buffer后CPU修改高速缓存数据单元的过程

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P282_11871.jpg)

虽然高速缓存会保证多核一致性，但是Store Buffer却是各个核心私有的，因此对其他核心不可见。在Store-Load乱序中，从微观时序上，Load指令可能是
在另一个线程的Store之后执行，但此时多核间通信尚未完成，对应的缓存单元还没有被置为Invalid，Store Buffer也没有被合并到高速缓存中，所以Load
读到的是修改前的值。

图7-7 写入Store Buffer后合并到高速缓存前Load数据

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P283_11877.jpg)

当协程一执行最后一条Store指令时，b就被赋值为0。同样地，协程二会将a赋值为0。即使Store Buffer合并到高速缓存，x和y都被修改为新值，也已经晚了

图7-8 合并到高速缓存后的数据状态

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P283_11880.jpg)

理论上可能出现的乱序有4种

- Load-Load，相邻的两条Load指令，后面的比前面的先读到数据。
- Load-Store，Load指令在前，Store指令在后，但是Store操作先变成全局可见，Load指令在此之后才读到数据。
- Store-Load，Store指令在前，Load指令在后，但是Load指令先读到了数据，Store操作在此之后才变成全局可见。这个我们已经在x86平台见证过了。
- Store-Store，相邻的两条Store指令，后面的比前面的先变成全局可见。

所谓的全局可见，指的是在多核CPU上对所有核心可见。

### 7.2.3 内存排序指令

执行期乱序会给结果带来很大的不确定性，这对于应用程序来讲是不能接受的，完全按照指令顺序执行又会使性能变差。为了解决这一问题，CPU提供了内存排序
指令，应用程序在必要的时候能够通过这些指令来避免发生乱序。以目前的Intel x86处理器为例，提供了LFENCE、SFENCE和MFENCE这3条内存排序指令

> 难以理解

## 7.3 常见的锁


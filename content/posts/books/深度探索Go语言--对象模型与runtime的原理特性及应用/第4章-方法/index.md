---
title: "第4章 方法"
date: 2023-02-14T20:38:20+08:00
draft: false
---

{{< embedcode go "code/4_1.go" >}}

## 4.1 接收者类型

为了排除编译器内联优化造成的干扰，下面采用只编译不链接的方式来得到OBJ文件，然后对编译得到的OBJ文件进行反编译分析

```shell
$ go tool compile -trimpath="`pwd`=>" -l -p gom point.go
```

通过go tool nm可以查看该文件中实现了哪些函数，nm会输出OBJ文件中定义或使用到的符号信息

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P107_6683.jpg)

point.o中一共实现了3个方法

- 第1个是Point的SetX()方法，它的接收者类型是∗Point
- 第3个是Point的X()方法，它的接收者类型是Point
- 第二个方法是一个接收者类型为∗Point的X()方法

### 4.1.1 值类型

反编译Point.X()

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P107_6693.jpg)

- 第4行代码用SP作为基址并加上8字节偏移，把该地址处的一个float64复制到X0寄存器中。
- 第5行代码用SP作为基址并加上16字节偏移，把X0中的float64复制到该地址处。
- 第6行代码就是普通的返回指令。

图4-1 调用Point.X()方法后的栈帧布局

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P108_6700.jpg)

值类型的接收者实际上是作为第1个参数通过栈来传递的，与普通的函数调用并没有什么不同。

Go语言允许通过方法的完全限定名称(Full Qualified Name)把方法当成一个普通函数那样调用，只不过需要把接收者作为第1个参数显式地传递

```go
p := Point{x: 10}
Point.X(p)
```

可以认为p.X()这种写法只是编译器提供的语法糖，本质上会被转换为Point.X(p)这种普通的函数调用，而接收者就是隐含的第1个参数。

### 4.1.2 指针类型

反编译SetX()

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P108_6718.jpg)

- 第4行代码用SP作为基址加上16字节偏移，把该地址处的一个float64复制到X0寄存器中。
- 第5行代码用SP作为基址加上8字节偏移，把该地址处的一个64位数值复制到AX寄存器中。
- 第6行代码用AX作为基址，把X0寄存器中的float64复制到该地址处。
- 第8行是返回指令

图4-2 调用Point.SetX()方法后的栈帧布局

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P109_6724.jpg)

跟值类型接收者类似，指针类型的接收者也是作为第1个参数来传递的，只不过传递的是一个地址。

可以通过完全限定名称把指针接收者方法作为一个普通函数那样调用

```go
p := &Point{}
(*Point).SetX(p, 10)
```

### 4.1.3 包装方法

查看自动生成的(*Point).X方法的汇编

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P110_6743.jpg)

有autogenerated字样

汇编(*Point).X的伪代码

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P110_6757.jpg)

- 第1个if语句块通过比较栈指针SP和gp.stackguard0来判断是否需要栈增长。
- 第2个if用于检测是否正处于panic流程中，这种情况下当前方法应该是被某个defer直接或间接地调用了，要按需修改gp._panic.argp的值，因为当前方
  法是编译器自动包装的，通过修改argp来跳过包装方法的栈帧，使后面调用的原始方法中的recover能够生效。
- 第3个if用于检测p是否为nil，因为包装方法需要根据p的地址得到∗p的值，如果地址为nil就调用runtime.panicwrap。
- 最后一步才是调用原始的Point.X()方法并传递∗p的值作为参数。

编译器会为代码中定义的值接收者方法生成指针接收者的包装方法，这在语义上是可行的，但反过来却不可以，因为通过传递的值是无法得到原始变量的地址的。

看一下实际调用的是不是包装方法, 先添加一个函数

```go
func PointX(p *Point) float64 {
	return p.X()
}
```

反编译

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P111_6785.jpg)

可以看到p.X()实际上会在调用端对指针解引用，然后调用值接收者方法，并**没有调用编译器生成的包装方法**。

栈分析

```
28 return value of PointX (float64)
20 arg of PointX (address of p)
18 return address of PointX
10 bp                                -|
08 return value of X (float64)        | stack of PointX
00 arg of X (p)                      -|
```

## 4.2 Method Value

把一个函数存储在一个变量中，这个变量就是一个Function Value。相应地，把一个方法存储在一个变量中，这个变量就是个Method Value。

### 4.2.1 基于类型

```go
x := Point.X
```

方法其实就是个普通的函数，接收者是隐含的第1个参数，所以这里可以推断，基于类型的Method Value就是个普通的Function Value，本质上是个两级指
针，而且第二级的指针是在编译阶段静态分配的。

```go
func GetX() func(Point) float64 {
	return Point.X
}
```

上述代码可以成功编译，说明Point.X()函数可以被赋值给func(Point)float64类型的Function Value。接下来反编译GetX()函数

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P113_6825.jpg)

第4行代码用IP作为基址加上一个偏移0来得到一个地址，这个0只作为预留的一个32位整数，等到链接阶段，链接器会填写上实际的偏移值。第4行代码得到的
地址被用作返回值，也就是最终的Function Value，而该地址处就是第二级指针

### 4.2.2 基于对象

可以把一个对象的某个方法赋值给一个变量，这样就会得到一个基于对象的Method Value

```go
p := Point{x: 10}
x := p.X
```

从语义角度来看，与基于类型的Method Value不同，基于对象的Method Value隐式地包含了对象的数据，所以在上述代码中调用x时不需要再显式地传递接
收者参数。第3章中已经了解了闭包的实现原理，所以这里推断x是个指向闭包对象的指针，通过闭包的捕获列表捕获了对象p。

示例函数

```go
func X(p Point) func() float64 {
	return p.X
}
```

反编译

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P114_6853.jpg)

伪代码

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P114_6861.jpg)

编译器为返回值自动定义了一个struct，第1个成员是一个函数指针，第2个成员是一个Point对象。对应到闭包对象的结构，捕获列表中是Point类型的对象，
闭包函数是gom.Point.X-fm()函数，也是由编译器自动生成的。反编译这个闭包函数

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P115_6874.jpg)

伪代码

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P115_6882.jpg)

主要逻辑就是通过DX寄存器得到闭包对象的地址，再以捕获列表里的Point对象的值作为参数调用Point.X()方法，并把Point.X()方法的返回值作为自己的
返回值。

进一步探索会发现，闭包是捕获对象的值还是捕获地址，跟Method Value对应的方法接收者类型一致。上述示例中Point.X()方法的接收者为值类型，所以闭
包捕获的也是值类型，如果换成接收者为指针类型的∗Point.SetX()方法，闭包捕获列表中就会相应地变成指针类型。

至此可以进行一下总结，基于类型的Method Value和基于对象的Method Value本质上都是Function Value，只不过前者是简单的两级指针，而后者通常是
个闭包（考虑编译器优化）。

## 4.3 组合式继承

{{< embedcode go "code/4_2.go" >}}

### 4.3.1 嵌入值

图4-3 Point2d内存布局示意图

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P116_6905.jpg)

再次用nm命令查看一下OBJ文件中为Point2d类型实现了哪些函数和方法

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P116_6913.jpg)

最后一个函数是由编译器自动生成的，用于判断两个Point2d对象是否相等

反编译Point2d.X()后的伪代码

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P117_6930.jpg)

以p.Point为参数来调用Point.X()方法的代码，也就说明这是个包装方法，因此可以推测，编译器对于继承来的方法都是通过生成相应的包装方法来调用原始
方法的方式实现的。

反编译(∗Point2d).SetX()

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P117_6941.jpg)

- 第1条指令把接收者的值复制到AX寄存器中。
- 第2条指令尝试访问AX存储的地址处的数据，如果接收者为空指针就会触发空指针异常。
- 第3条指令把AX的值复制到栈上接收者参数的位置，这一行其实可以优化掉。
- 第4条指令用于跳转到(∗Point).SetX()方法的起始地址。

反编译一下(∗Point2d).X()方法，对照汇编整理出的伪代码如下：

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P118_6964.jpg)

可以看到除了接收者为指针类型外，代码逻辑与Point2d.X()方法基本一致

### 4.3.2 嵌入指针

{{< embedcode go "code/4_3.go" >}}

图4-4 Point2d与Point的内存布局关系

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P119_6983.jpg)

再用nm命令查看一下OBJ文件中为Point2d类型实现了哪些函数和方法

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P119_6991.jpg)

这里值得注意的是Point2d.SetX()方法，它的存在意味着虽然接收者Point2d是通过值的形式传递的，但是通过Point2d的值可以得到原始Point对象的地址，
所以依然可以对原始Point对象进行修改。

看一下在嵌入指针的情况下(∗Point2d).SetX()方法还会不会被优化处理

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P119_6999.jpg)

- 编译器还进行了优化处理，第1行指令把栈上的接收者参数复制到AX寄存器中，其实也就是Point2d对象的地址。
- 第2行指令把Point2d的第1个字段的值复制到AX寄存器中，也就是Point对象的地址。
- 第3行指令把AX的值复制回栈上的接收者参数处。
- 第4行指令用于跳转到(∗Point).SetX()方法的起始地址。

至于其他3种方法，编译器都会生成相应的包装方法, 伪代码

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P120_16336.jpg)

因为在嵌入指针的情况下总是能够得到基类对象的地址，所以子类中的值接收者方法可以调用基类中的指针接收者方法，编译器会尽可能把符合逻辑的包装方法
都生成出来。

### 4.3.3 多重继承

首先定义两种类型A和B

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P120_7032.jpg)

定义一种类型C，将A和B以值的形式嵌入

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P121_7054.jpg)

通过nm命令查看编译生成的OBJ文件中都实现了哪些方法

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P121_7062.jpg)

发现只有A和B的方法，编译器没有为C生成任何方法。结合Go语言官方文档的说明，因为同时嵌入A和B而且嵌套的层次相同，所以编译器不知道应该让包装方法
继承自谁，这种情况只能由程序员手工实现。

定义一种类型D，把A以嵌入值的形式嵌入D中，然后把C中的A改成D

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P122_7073.jpg)

再次通过nm命令查看

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P122_7081.jpg)

这次类型C成功地继承了这一组方法，对这些方法进行反编译就能确定是继承自类型B，因为B的嵌套层次比A要浅，编译器优先选择短路径。

## 4.4 本章小结

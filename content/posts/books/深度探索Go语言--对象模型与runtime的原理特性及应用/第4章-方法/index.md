---
title: "第4章 方法"
date: 2023-02-14T20:38:20+08:00
draft: true
---

{{< embedcode go "code/4_1/main.go" >}}

## 4.1 接收者类型

为了排除编译器内联优化造成的干扰，下面采用只编译不链接的方式来得到OBJ文件，然后对编译得到的OBJ文件进行反编译分析

```shell
$ go tool compile -trimpath="`pwd`=>" -l -p gom point.go
```

通过go tool nm可以查看该文件中实现了哪些函数，nm会输出OBJ文件中定义或使用到的符号信息

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P107_6683.jpg)

point.o中一共实现了3个方法

- 第1个是Point的SetX()方法，它的接收者类型是∗Point
- 第3个是Point的X()方法，它的接收者类型是Point
- 第二个方法是一个接收者类型为∗Point的X()方法

### 4.1.1 值类型

反编译Point.X()

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P107_6693.jpg)

- 第4行代码用SP作为基址并加上8字节偏移，把该地址处的一个float64复制到X0寄存器中。
- 第5行代码用SP作为基址并加上16字节偏移，把X0中的float64复制到该地址处。
- 第6行代码就是普通的返回指令。

图4-1 调用Point.X()方法后的栈帧布局

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P108_6700.jpg)

值类型的接收者实际上是作为第1个参数通过栈来传递的，与普通的函数调用并没有什么不同。

Go语言允许通过方法的完全限定名称(Full Qualified Name)把方法当成一个普通函数那样调用，只不过需要把接收者作为第1个参数显式地传递

```go
p := Point{x: 10}
Point.X(p)
```

可以认为p.X()这种写法只是编译器提供的语法糖，本质上会被转换为Point.X(p)这种普通的函数调用，而接收者就是隐含的第1个参数。

### 4.1.2 指针类型

反编译SetX()

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P108_6718.jpg)

- 第4行代码用SP作为基址加上16字节偏移，把该地址处的一个float64复制到X0寄存器中。
- 第5行代码用SP作为基址加上8字节偏移，把该地址处的一个64位数值复制到AX寄存器中。
- 第6行代码用AX作为基址，把X0寄存器中的float64复制到该地址处。
- 第8行是返回指令

图4-2 调用Point.SetX()方法后的栈帧布局

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P109_6724.jpg)

跟值类型接收者类似，指针类型的接收者也是作为第1个参数来传递的，只不过传递的是一个地址。

可以通过完全限定名称把指针接收者方法作为一个普通函数那样调用

```go
p := &Point{}
(*Point).SetX(p, 10)
```

### 4.1.3 包装方法

查看自动生成的(*Point).X方法的汇编

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P110_6743.jpg)

有autogenerated字样

汇编(*Point).X的伪代码

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P110_6757.jpg)

- 第1个if语句块通过比较栈指针SP和gp.stackguard0来判断是否需要栈增长。
- 第2个if用于检测是否正处于panic流程中，这种情况下当前方法应该是被某个defer直接或间接地调用了，要按需修改gp._panic.argp的值，因为当前方
  法是编译器自动包装的，通过修改argp来跳过包装方法的栈帧，使后面调用的原始方法中的recover能够生效。
- 第3个if用于检测p是否为nil，因为包装方法需要根据p的地址得到∗p的值，如果地址为nil就调用runtime.panicwrap。
- 最后一步才是调用原始的Point.X()方法并传递∗p的值作为参数。

编译器会为代码中定义的值接收者方法生成指针接收者的包装方法，这在语义上是可行的，但反过来却不可以，因为通过传递的值是无法得到原始变量的地址的。

看一下实际调用的是不是包装方法, 先添加一个函数

```go
func PointX(p *Point) float64 {
	return p.X()
}
```

反编译

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P111_6785.jpg)

可以看到p.X()实际上会在调用端对指针解引用，然后调用值接收者方法，并**没有调用编译器生成的包装方法**。

栈分析

```
28 return value of PointX (float64)
20 arg of PointX (address of p)
18 return address of PointX
10 bp                                -|
08 return value of X (float64)        | stack of PointX
00 arg of X (p)                      -|
```

## 4.2 Method Value

把一个函数存储在一个变量中，这个变量就是一个Function Value。相应地，把一个方法存储在一个变量中，这个变量就是个Method Value。

### 4.2.1 基于类型

```go
x := Point.X
```

方法其实就是个普通的函数，接收者是隐含的第1个参数，所以这里可以推断，基于类型的Method Value就是个普通的Function Value，本质上是个两级指
针，而且第二级的指针是在编译阶段静态分配的。

```go
func GetX() func(Point) float64 {
	return Point.X
}
```

上述代码可以成功编译，说明Point.X()函数可以被赋值给func(Point)float64类型的Function Value。接下来反编译GetX()函数

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P113_6825.jpg)

第4行代码用IP作为基址加上一个偏移0来得到一个地址，这个0只作为预留的一个32位整数，等到链接阶段，链接器会填写上实际的偏移值。第4行代码得到的
地址被用作返回值，也就是最终的Function Value，而该地址处就是第二级指针

### 4.2.2 基于对象

可以把一个对象的某个方法赋值给一个变量，这样就会得到一个基于对象的Method Value

```go
p := Point{x: 10}
x := p.X
```

从语义角度来看，与基于类型的Method Value不同，基于对象的Method Value隐式地包含了对象的数据，所以在上述代码中调用x时不需要再显式地传递接
收者参数。第3章中已经了解了闭包的实现原理，所以这里推断x是个指向闭包对象的指针，通过闭包的捕获列表捕获了对象p。

示例函数

```go
func X(p Point) func() float64 {
	return p.X
}
```

反编译

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P114_6853.jpg)

伪代码

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P114_6861.jpg)

编译器为返回值自动定义了一个struct，第1个成员是一个函数指针，第2个成员是一个Point对象。对应到闭包对象的结构，捕获列表中是Point类型的对象，
闭包函数是gom.Point.X-fm()函数，也是由编译器自动生成的。反编译这个闭包函数

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P115_6874.jpg)

伪代码

![](https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P115_6882.jpg)

主要逻辑就是通过DX寄存器得到闭包对象的地址，再以捕获列表里的Point对象的值作为参数调用Point.X()方法，并把Point.X()方法的返回值作为自己的
返回值。

进一步探索会发现，闭包是捕获对象的值还是捕获地址，跟Method Value对应的方法接收者类型一致。上述示例中Point.X()方法的接收者为值类型，所以闭
包捕获的也是值类型，如果换成接收者为指针类型的∗Point.SetX()方法，闭包捕获列表中就会相应地变成指针类型。

至此可以进行一下总结，基于类型的Method Value和基于对象的Method Value本质上都是Function Value，只不过前者是简单的两级指针，而后者通常是
个闭包（考虑编译器优化）。

## 4.3 组合式继承

---
title: "2-10 SQL中的层级"
date: 2023-03-16T20:55:07+08:00
---

# 谓词逻辑中的层级、集合论中的层级

对于EXISTS来说，层级的差别与EXISTS谓词及其参数有关，因此属于谓词逻辑中的阶。而GROUP BY中的阶与元素和集合的区别有关，因此属于集合论中的阶。

# 为什么聚合后不能再引用原表中的列

Teams

![](https://res.weread.qq.com/wrepub/epub_26211874_403)

首先，我们还是以组为单位进行聚合查询。

```sql
    --以组为单位进行聚合查询
    SELECT team, AVG(age)
      FROM Teams
     GROUP BY team;


    team  AVG(age)
    ----  --------
    A          23.3
    B          34.5
    C          30.0
    D          25.5
```

那么如果我们把它改成下面这样，结果会怎么样呢？

```sql
    --以组为单位进行聚合查询？
    SELECT team, AVG(age), age
      FROM Teams
     GROUP BY team;
```

标准SQL规定，在对表进行聚合查询的时候，只能在SELECT子句中写下面3种内容。

1. 通过GROUP BY子句指定的聚合键
2. 聚合函数（SUM、AVG等）
3. 常量

表Teams中的“age”列存储了每位成员的年龄信息。但是需要注意的是，这里的年龄只是每个人的属性，而不是小组的属性。所谓小组，指的是由多个人组成的
集合。因此，小组的属性只能是平均或者总和等统计性质的属性。

![](https://res.weread.qq.com/wrepub/epub_26211874_404)

GROUP BY的作用是将一个个元素划分成若干个子集。这样看的话，关系模型中“列”的正式名称叫作“**属性**”，其实也是有道理的。

下面这条语句的错误也是相同的原因造成的。

```sql
    --错误
    SELECT team, AVG(age), member
      FROM Teams
     GROUP BY team;
```

向小组询问姓名是不会得到回答的。如果非要在结果中包含“member”列的值，那么只能像下面这样使用聚合函数。

```sql
    --正确
    SELECT team, AVG(age), MAX(member)
      FROM Teams
     GROUP BY team;
```

MAX(member)会计算出小组成员中以字典序排序后最后一个人的姓名，因此这无疑是小组的属性。

如果稍微扩展一下这条查询语句，我们还可以求出“小组中年龄最大的成员”，SQL语句如下所示。

```sql
    SELECT team, MAX(age),
          (SELECT MAX(member)
              FROM Teams T2
            WHERE T2.team = T1.team
              AND T2.age = MAX(T1.age)) AS oldest
      FROM Teams T1
     GROUP BY team;


    team  max(age) oldest
    ----- -------- ------
    A      28      大木
    B      40      山田
    C      30      桥田
    D      28      野野宫
```

这条语句的关键点有两个。

- 第一个是，子查询中的WHERE子句里使用了MAX(T1.age)这样的聚合函数作为条件。我们在初学SQL时，会学到不可以在WHERE子句中使用聚合函数，但是在
  本题中却是可以的。原因是，这里对外层的表T1也进行了聚合，这样一来我们就可以在SELECT子句中通过聚合函数来引用“age”列了（不能反过来在子查询
  中直接引用“age”列）。
- 另一个是，当一个小组中年龄最大的成员有多人时，必须选出其中一个人作为代表。这个是通过子查询中SELECT子句里的MAX(member)来实现的。例如，D
  小组中野野宫和鬼塚两人的年龄都是最大的，但是结果中只出现了野野宫一人。如果不使用MAX函数，那么子查询会返回多条数据，这样就会出现执行错误。

# 单元素集合也是集合

只有一个元素的集合，在集合论中叫作单元素集合（singleton）。一般来说，单元素集合的属性和其唯一元素的属性是一样的。

![](https://res.weread.qq.com/wrepub/epub_26211874_406)

现在的集合论认为单元素集合是一种正常的集合。单元素集合和空集一样，主要是为了保持理论的完整性而定义的。因此对于以集合论为基础的SQL来说，当然也
需要严格地区分元素和单元素集合。因此，元素a和集合{a}之间存在着非常醒目的层级差别。

```sql
a ≠ {a}
```

**这两个层级的区别分别对应着SQL中的WHERE子句和HAVING子句的区别。**

- WHERE子句用于处理“行”这种0阶的对象
- 而HAVING子句用来处理“集合”这种1阶的对象。

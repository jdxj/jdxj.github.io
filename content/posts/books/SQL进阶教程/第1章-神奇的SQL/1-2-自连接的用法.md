---
title: "1-2 自连接的用法"
date: 2023-02-25T18:47:15+08:00
---

# 可重排列、排列、组合

Products

![](https://res.weread.qq.com/wrepub/epub_26211874_35)

有序对(排列)

- <1, 2> != <2, 1>

无序对(组合)

- {1, 2} == {2, 1}

通过交叉连接生成笛卡儿积（直积）生成有序对

```sql
    --用于获取可重排列的SQL语句
    SELECT P1.name AS name_1, P2.name AS name_2
      FROM Products P1, Products P2;
```

执行结果

```sql
    name_1       name_2
    ------      ------
    苹果         苹果
    苹果         橘子
    苹果         香蕉
    橘子         苹果
    橘子         橘子
    橘子         香蕉
    香蕉         苹果
    香蕉         橘子
    香蕉         香蕉
```

去掉<苹果, 苹果>这种

```sql
    --用于获取排列的SQL语句
    SELECT P1.name AS name_1, P2.name AS name_2
      FROM Products P1, Products P2
     WHERE P1.name <> P2.name;
```

执行结果

```sql
    name_1       name_2
    ------       ------
    苹果         橘子
    苹果         香蕉
    橘子         苹果
    橘子         香蕉
    香蕉         苹果
    香蕉         橘子
```

不能有（苹果，苹果）这样的组合

![](https://res.weread.qq.com/wrepub/epub_26211874_38)

去掉<苹果, 橘子>, <橘子, 苹果>这种

```sql
    --用于获取组合的SQL语句
    SELECT P1.name AS name_1, P2.name AS name_2
      FROM Products P1, Products P2
     WHERE P1.name > P2.name;
```

执行结果

```sql
    name_1       name_2
    ------       ------
    苹果          橘子
    香蕉          橘子
    香蕉          苹果
```

获取3个以上元素的组合

```sql
    --用于获取组合的SQL语句：扩展成3列
    SELECT P1.name AS name_1, P2.name AS name_2, P3.name AS name_3
      FROM Products P1, Products P2, Products P3
     WHERE P1.name > P2.name
      AND P2.name > P3.name;
```

执行结果

```sql
    name_1    name_2     name_3
    -------   --------   --------
    香蕉       苹果        橘子
```

# 删除重复行

删除重复行

![](https://res.weread.qq.com/wrepub/epub_26211874_42)

使用由数据库独自实现的行ID

- 只有Oracle(rowid)和PostgreSQL(oid)才能使用, 其他数据库需要自己创建主键

```sql
    --用于删除重复行的SQL语句(1)：使用极值函数
    DELETE FROM Products P1
     WHERE rowid < ( SELECT MAX(P2.rowid)
                      FROM Products P2
                      WHERE P1.name = P2. name
                        AND P1.price = P2.price ) ;
```

```sql
    --用于删除重复行的SQL语句(2)：使用非等值连接
    DELETE FROM Products P1
     WHERE EXISTS ( SELECT ＊
                      FROM Products P2
                    WHERE P1.name = P2.name
                      AND P1.price = P2.price
                      AND P1.rowid < P2.rowid );
```

# 查找局部不一致的列

假设有下面这样一张住址表，主键是人名

Addresses

![](https://res.weread.qq.com/wrepub/epub_26211874_48)

前田夫妇。这两个人并没有分居，只是夫人的住址写错了而已, 需要修改一下

> 所以这个表结构设计的不对

找出像前田夫妇这样的“是同一家人但住址却不同的记录”, 用非等值自连接来实现，代码会非常简洁

```sql
    --用于查找是同一家人但住址却不同的记录的SQL语句
    SELECT DISTINCT A1.name, A1.address
      FROM Addresses A1, Addresses A2
     WHERE A1.family_id = A2.family_id
      AND A1.address <> A2.address ;
```

> 感觉这里的DISTINCT没什么用.

从下面这张商品表里找出价格相等的商品的组合。

Products

![](https://res.weread.qq.com/wrepub/epub_26211874_49)

```sql
    --用于查找价格相等但商品名称不同的记录的SQL语句
    SELECT DISTINCT P1.name, P1.price
      FROM Products P1, Products P2
     WHERE P1.price = P2.price
      AND P1.name <> P2.name;
```

执行结果

```sql
    name       price
    ------    ------
    苹果          50
    葡萄          50
    草莓         100
    橘子         100
    香蕉         100
```

> 这里确实应该用DISTINCT.

# 排序

按照价格从高到低的顺序, 让价格相同的商品位次也一样

Products

![](https://res.weread.qq.com/wrepub/epub_26211874_51)

使用窗口函数

```sql
    --排序：使用窗口函数
    SELECT name, price,
          RANK() OVER (ORDER BY price DESC) AS rank_1,
          DENSE_RANK() OVER (ORDER BY price DESC) AS rank_2
      FROM Products;
```

商品则有两种排序方法，一种是跳过之后的位次，另一种是不跳过之后的位次。

- rank_1跳过了之后的位次，rank_2没有跳过
- MySQL8支持窗口函数

执行结果

```sql
    name         price    rank_1    rank_2
    -------    ------   -------   -------
    橘子          100          1          1
    西瓜           80          2          2
    苹果           50          3          3
    香蕉           50          3          3
    葡萄           50          3          3
    柠檬           30          6          4
```

不依赖于具体数据库来实现的方法

```sql
    --排序从1开始。如果已出现相同位次，则跳过之后的位次
    SELECT P1.name,
          P1.price,
          (SELECT COUNT(P2.price)
              FROM Products P2
            WHERE P2.price > P1.price) + 1 AS rank_1
      FROM Products P1
      ORDER BY rank_1;
```

> 查询比当前水果价格还要大的水果数n, n+1就是rank

执行结果

```sql
    name    price     rank
    -----   ------   ------
    橘子      100         1
    西瓜       80         2
    苹果       50         3
    葡萄       50         3
    香蕉       50         3
    柠檬       30         6
```

如果使用COUNT(DISTINCT P2.price)可以实现不跳过之后的位次

自连接的写法

```sql
    --排序：使用自连接
    SELECT P1.name,
          MAX(P1.price) AS price,
          COUNT(P2.name) +1 AS rank_1
      FROM Products P1 LEFT OUTER JOIN Products P2
        ON P1.price < P2.price
     GROUP BY P1.name
     ORDER BY rank_1;
```

> 查询当前水果价格能连接多少个n(p1.price<p2.price), n+1就是排名.

# 本节小结

与多表之间进行的普通连接相比，自连接的性能开销更大（特别是与非等值连接结合使用的时候），因此用于自连接的列推荐使用主键或者在相关列上建立索引。

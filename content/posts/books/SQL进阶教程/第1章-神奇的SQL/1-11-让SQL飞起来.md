---
title: "1-11 让SQL飞起来"
date: 2023-03-09T21:13:35+08:00
draft: false
summary: 推荐看
---

# 使用高效的查询

## 参数是子查询时，使用EXISTS代替IN

Class_A

![](https://res.weread.qq.com/wrepub/epub_26211874_275)

Class_B

![](https://res.weread.qq.com/wrepub/epub_26211874_276)

从Class_A表中查出同时存在于Class_B表中的员工, 使用EXISTS的SQL语句更快一些

```sql
    --慢
    SELECT ＊
      FROM Class_A
     WHERE id IN (SELECT id
                    FROM Class_B);

    --快
    SELECT ＊
      FROM Class_A  A
     WHERE EXISTS
            (SELECT ＊
              FROM Class_B  B
              WHERE A.id = B.id);
```

两个结果都如下所示

```sql
    id name
    -- ----
    1  田中
    2  铃木
```

使用EXISTS时更快的原因有以下两个。

- 如果连接列（id）上建立了索引，那么查询Class_B时不用查实际的表，只需查索引就可以了。
- 如果使用EXISTS，那么只要查到一行数据满足条件就会终止查询，不用像使用IN时一样扫描全表。在这一点上NOT EXISTS也一样。

其他

- 使用in会生成临时表, exists不会
- in的可读性更好
- 如果确信in也能很快, 就没必要改成exists
- 很多数据库改善了in的性能

## 参数是子查询时，使用连接代替IN

```sql
    --使用连接代替IN
    SELECT A.id, A.name
      FROM Class_A A INNER JOIN Class_B B
        ON A.id = B.id;
```

至少用到了id上的索引

# 避免排序

会排序的运算

- GROUP BY子句
- ORDER BY子句
- 聚合函数（SUM、COUNT、AVG、MAX、MIN）
- DISTINCT
- 集合运算符（UNION、INTERSECT、EXCEPT）
- 窗口函数（RANK、ROW_NUMBER等）

## 灵活使用集合运算符的ALL可选项

SQL中有UNION、INTERSECT、EXCEPT三个集合运算符。在默认的使用方式下，这些运算符会为了排除掉重复数据而进行排序。

```sql
    SELECT ＊ FROM Class_A
     UNION
    SELECT ＊ FROM Class_B;
```

```sql
    id name
    -- -----
    1  田中
    2  铃木
    3  伊集院
    4  西园寺
```

如果不在乎结果中是否有重复数据，或者事先知道不会有重复数据，请使用UNION ALL代替UNION。这样就不会进行排序了。

```sql
    SELECT ＊ FROM Class_A
    UNION ALL
    SELECT ＊ FROM Class_B;
```

![](https://res.weread.qq.com/wrepub/epub_26211874_279)

集合运算符ALL可选项的实现情况

- Oracle使用MINUS代替EXCEPT
- MySQL连INTERSECT和EXCEPT运算本身还没有实现

![](https://res.weread.qq.com/wrepub/epub_26211874_280)

> mysql8 了, 应该再搜一下看有没有

## 使用EXISTS代替DISTINCT

如果需要对两张表的连接结果进行去重，可以考虑使用EXISTS代替DISTINCT，以避免排序。

Items

![](https://res.weread.qq.com/wrepub/epub_26211874_281)

SalesHistory

![](https://res.weread.qq.com/wrepub/epub_26211874_282)

使用distinct
```sql
    SELECT I.item_no
      FROM Items I INNER JOIN SalesHistory SH
        ON I. item_no = SH. item_no;
```

```sql
    item_no
    -------
        10
        10
        20
        20
        30
        30
        30
```

为了排除重复数据，我们需要使用DISTINCT。

```sql
    SELECT DISTINCT I.item_no
      FROM Items I INNER JOIN SalesHistory SH
        ON I. item_no = SH. item_no;

    item_no
    -------
        10
        20
        30
```

使用exists

```sql
    SELECT item_no
      FROM Items I
     WHERE EXISTS
              (SELECT ＊
                  FROM SalesHistory SH
                WHERE I.item_no = SH.item_no);
```

## 在极值函数中使用索引（MAX/MIN）

使用这两个函数时都会进行排序。但是如果参数字段上建有索引，则只需要扫描索引，不需要扫描整张表。

```sql
    --这样写需要扫描全表
    SELECT MAX(item)
      FROM Items;
```

```sql
    --这样写能用到索引
    SELECT MAX(item_no)
      FROM Items;
```

对于联合索引，只要查询条件是联合索引的第一个字段，索引就是有效的，所以也可以对表SalesHistory的sale_date字段使用极值函数。

## 能写在WHERE子句里的条件不要写在HAVING子句里

下面两条SQL语句返回的结果是一样的。

```sql
    --聚合后使用HAVING子句过滤
    SELECT sale_date, SUM(quantity)
      FROM SalesHistory
     GROUP BY sale_date
    HAVING sale_date = '2007-10-01';
```

```sql
    --聚合前使用WHERE子句过滤
    SELECT sale_date, SUM(quantity)
      FROM SalesHistory
     WHERE sale_date = '2007-10-01'
     GROUP BY sale_date;
```

```sql
    sale_date          sum(quantity)
    --------------    --------------
    '2007-10-01'                   17
```

从性能上来看，第二条语句写法效率更高。原因通常有两个。

- 第一个是在使用GROUP BY子句聚合时会进行排序，如果事先通过WHERE子句筛选出一部分行，就能够减轻排序的负担。
- 第二个是在WHERE子句的条件里可以使用索引。HAVING子句是针对聚合后生成的视图进行筛选的，但是很多时候聚合后的视图都没有继承原表的索引结构。

## 在GROUP BY子句和ORDER BY子句中使用索引

特别是，在一些数据库中，如果操作对象的列上建立的是唯一索引，那么排序过程本身都会被省略掉。

# 真的用到索引了吗

假设我们在一个叫作col_1的列上建立了索引，然后来看一看下面这条SQL语句。这条SQL语句本来是想使用索引，但实际上执行时却进行了全表扫描。

## 在索引字段上进行运算

```sql
    SELECT ＊
      FROM SomeTable
     WHERE col_1 ＊ 1.1 > 100;
```

把运算的表达式放到查询条件的右侧，就能用到索引了

```sql
    WHERE col_1 > 100 / 1.1
```

在查询条件的左侧使用函数时，也不能用到索引

```sql
    SELECT ＊
      FROM SomeTable
     WHERE SUBSTR(col_1, 1, 1) = 'a';
```

## 使用IS NULL谓词

通常，索引字段是不存在NULL的，所以指定IS NULL和IS NOT NULL的话会使得索引无法使用，进而导致查询性能低下。

```sql
    SELECT ＊
      FROM  SomeTable
     WHERE  col_1 IS NULL;
```

**关于索引字段不存在NULL的原因，简单来说是NULL并不是值。非值不会被包含在值的集合中**

如果需要使用类似IS NOT NULL的功能，又想用到索引，那么可以使用下面的方法，假设“col_1”列的最小值是1。

```sql
    --IS NOT NULL的代替方案
    SELECT ＊
      FROM  SomeTable
     WHERE  col_1 > 0;
```

## 使用否定形式

下面这几种否定形式不能用到索引。

- <>
- !=
- NOT IN

下面的SQL语句也会进行全表扫描。

```sql
    SELECT ＊
      FROM  SomeTable
     WHERE  col_1 <> 100;
```

## 使用OR

在col_1和col_2上分别建立了不同的索引，或者建立了（col_1, col_2）这样的联合索引时，如果使用OR连接条件，那么要么用不到索引，要么用到了但是
效率比AND要差很多。

```sql
    SELECT ＊
      FROM  SomeTable
     WHERE  col_1 > 100
        OR  col_2 = 'abc';
```

如果无论如何都要使用OR，那么有一种办法是位图索引。但是这种索引的话更新数据时的性能开销会增大，所以使用之前需要权衡一下利弊。

## 使用联合索引时，列的顺序错误

假设存在这样顺序的一个联合索引“col_1, col_2, col_3”。

```sql
    ○   SELECT ＊ FROM SomeTable WHERE col_1 = 10 AND col_2 = 100 AND col_3 = 500;
    ○   SELECT ＊ FROM SomeTable WHERE col_1 = 10 AND col_2 = 100 ;
    ×   SELECT ＊ FROM SomeTable WHERE col_1 = 10 AND col_3 = 500 ;
    ×   SELECT ＊ FROM SomeTable WHERE col_2 = 100 AND col_3 = 500 ;
    ×   SELECT ＊ FROM SomeTable WHERE col_2 = 100 AND col_1 = 10 ;
```

联合索引中的第一列（col_1）必须写在查询条件的开头，而且索引中列的顺序不能颠倒。有些数据库里顺序颠倒后也能使用索引，但是性能还是比顺序正确时
差一些。

**如果无法保证查询条件里列的顺序与索引一致，可以考虑将联合索引拆分为多个索引。**

## 使用LIKE谓词进行后方一致或中间一致的匹配

使用LIKE谓词时，只有前方一致的匹配才能用到索引。

```sql
    ×   SELECT  ＊   FROM  SomeTable  WHERE  col_1  LIKE'%a';
    ×   SELECT  ＊   FROM  SomeTable  WHERE  col_1  LIKE'%a%';
    ○   SELECT  ＊   FROM  SomeTable  WHERE  col_1  LIKE'a%';
```

## 进行默认的类型转换

对char类型的“col_1”列指定条件的示例

```sql
    ×   SELECT ＊ FROM SomeTable WHERE col_1 = 10;
    ○   SELECT ＊ FROM SomeTable WHERE col_1 ='10';
    ○   SELECT ＊ FROM SomeTable WHERE col_1 = CAST(10, AS CHAR(2));
```

- 默认的类型转换不仅会增加额外的性能开销，还会导致索引不可用
- 在需要类型转换时显式地进行类型转换吧（别忘了转换要写在条件表达式的右边）。

# 减少中间表

频繁使用中间表会带来两个问题，一是展开数据需要耗费内存资源，二是原始表中的索引不容易使用到

## 灵活使用HAVING子句

不习惯使用HAVING子句的数据库工程师可能会倾向于像下面这样先生成一张中间表，然后在WHERE子句中指定筛选条件。

![](https://res.weread.qq.com/wrepub/epub_26211874_286)

```sql
    sale_date       tot_qty
    ------------   ---------
    07-10-01               10
    07-10-03               32
    07-10-04               22
```

对聚合结果指定筛选条件时不需要专门生成中间表

```sql
    SELECT sale_date, MAX(quantity)
      FROM SalesHistory
     GROUP BY sale_date
    HAVING MAX(quantity) >= 10;
```

HAVING子句和聚合操作是同时执行的，所以比起生成中间表后再执行的WHERE子句，效率会更高一些，而且代码看起来也更简洁。

## 需要对多个字段使用IN谓词时，将它们汇总到一处

SQL-92中加入了行与行比较的功能。这样一来，比较谓词＝、＜、＞和IN谓词的参数就不能是标量值，而应是值列表了。

这里对多个字段使用了IN谓词，“id”列是主键。

```sql
    SELECT id, state, city
      FROM Addresses1 A1
     WHERE state IN (SELECT state
                      FROM Addresses2 A2
                      WHERE A1.id = A2.id)
      AND city  IN (SELECT city
                      FROM Addresses2 A2
                      WHERE A1.id = A2.id);
```

如果像下面这样把字段连接在一起，那么就能把逻辑写在一处了。

```sql
    SELECT ＊
      FROM Addresses1 A1
     WHERE id || state || city
        IN (SELECT id || state|| city
              FROM Addresses2 A2);
```

这样一来，子查询不用考虑关联性，而且只执行一次就可以。此外，如果所用的数据库实现了行与行的比较，那么我们也可以像下面这样，在IN中写多个字段的
组合。

```sql
    SELECT ＊
      FROM Addresses1 A1
     WHERE (id, state, city)
        IN (SELECT id, state, city
              FROM Addresses2 A2);
```

这种方法与前面的连接字段的方法相比有两个优点。

- 一是不用担心连接字段时出现的类型转换问题
- 二是这种方法不会对字段进行加工，因此可以使用索引。

## 先进行连接再进行聚合

连接和聚合同时使用时，先进行连接操作可以避免产生中间表。原因是，从集合运算的角度来看，连接做的是“乘法运算”。连接表双方是一对一、一对多的关系
时，连接运算后数据的行数不会增加。而且，因为在很多设计中多对多的关系都可以分解成两个一对多的关系，因此这个技巧在大部分情况下都可以使用。

## 合理地使用视图

如果没有经过深入思考就定义复杂的视图，可能会带来巨大的性能问题。特别是视图的定义语句中包含以下运算的时候，SQL会非常低效，执行速度也会变得非常
慢。

- 聚合函数（AVG、COUNT、SUM、MIN、MAX）
- 集合运算符（UNION、INTERSECT、EXCEPT等）

越来越多的数据库为了解决视图的这个缺点，实现了物化视图（materialized view）等技术。当视图的定义变得复杂时，可以考虑使用一下。

# 本节小结

不管是减少排序还是使用索引，抑或是避免中间表的使用，都是为了减少对硬盘的访问。

下面是本节要点。

1. 参数是子查询时，使用EXISTS或者连接代替IN。
2. 使用索引时，条件表达式的左侧应该是原始字段。
3. 在SQL中排序无法显式地指定，但是请注意很多运算都会暗中进行排序。
4. 尽量减少没用的中间表。

---
title: "1-6 用关联子查询比较行与行"
date: 2023-03-01T21:54:29+08:00
---

使用SQL进行行间比较时，发挥主要作用的技术是关联子查询，特别是与自连接相结合的“自关联子查询”

# 增长、减少、维持现状

Sales

![](https://res.weread.qq.com/wrepub/epub_26211874_153)

年营业额的趋势

![](https://res.weread.qq.com/wrepub/epub_26211874_154)

使用SQL输出与上一年相比营业额是增加了还是减少了，抑或是没有变化。

先试试求出“不变”这种情况

- 1993
- 1995

用面向过程语言来解决，应该是下面这样的思路

1. 按年份递增的顺序排序。
2. 循环地将每一行与前一行的“sale”列进行比较。

使用SQL时的解题思路需要用面向集合的方式进行思考

- 在表Sales的基础上，再加一个存储了上一年数据的集合（S2）

```sql
    --求与上一年营业额一样的年份(1)：使用关联子查询
    SELECT year, sale
      FROM Sales S1
     WHERE sale = (SELECT sale
                    FROM Sales S2
                    WHERE S2.year = S1.year -1)
     ORDER BY year;
```

> 今年的sale==去年的sale

执行结果

```sql
    year   sale
    -----  ----
    1993   52
    1995   50
```

![](https://res.weread.qq.com/wrepub/epub_26211874_155)

使用自连接

```sql
    --求与上一年营业额一样的年份(2)：使用自连接
    SELECT S1.year, S1.sale
      FROM Sales S1,
          Sales S2
     WHERE S2.sale = S1.sale
      AND S2.year = S1.year -1
     ORDER BY year;
```

接下来请将这个例子扩展一下，求出每一年相比上一年营业额是增加了还是减少了，抑或是没有变化。

# 用列表展示与上一年的比较结果

```sql
    --求出是增长了还是减少了，抑或是维持现状(1)：使用关联子查询
    SELECT S1.year, S1.sale,
          CASE WHEN sale =
                (SELECT sale
                    FROM Sales S2
                  WHERE S2.year = S1.year -1) THEN'→'--持平
                WHEN sale >
                (SELECT sale
                    FROM Sales S2
                  WHERE S2.year = S1.year -1) THEN'↑'--增长
                WHEN sale <
                (SELECT sale
                    FROM Sales S2
                  WHERE S2.year = S1.year -1) THEN'↓'--减少
          ELSE'—'END AS var
      FROM Sales S1
     ORDER BY year;
```

执行结果

```sql
    year    sale  var
    ------  ----  ---
    1990      50  —
    1991      51  ↑
    1992      52  ↑
    1993      52  →
    1994      50  ↓
    1995      50  →
    1996      49  ↓
    1997      55  ↑
```

用自连接来实现

```sql
    --求出是增长了还是减少了，抑或是维持现状(2)：使用自连接查询（最早的年份不会出现在结果里）
    SELECT S1.year, S1.sale,
          CASE WHEN S1.sale = S2.sale THEN'→'
                WHEN S1.sale > S2.sale THEN'↑'
                WHEN S1.sale < S2.sale THEN'↓'
          ELSE'—'END AS var
      FROM Sales S1, Sales S2
     WHERE S2.year = S1.year -1
     ORDER BY year;
```

结果没有1990年之前的数据

# 时间轴有间断时：和过去最临近的时间进行比较

Sales2：有年份缺失

![](https://res.weread.qq.com/wrepub/epub_26211874_159)

“过去最临近的年份”需要满足下面两个条件

1. 与该年份相比是过去的年份。
2. 在满足条件1的年份中，年份最早的一个。

```sql
    --查询与过去最临近的年份营业额相同的年份
    SELECT year, sale
      FROM Sales2 S1
     WHERE sale =
      (SELECT sale
          FROM Sales2 S2
        WHERE S2.year =
          (SELECT MAX(year)  --条件2：在满足条件1的年份中，年份最早的一个
              FROM Sales2 S3
            WHERE S1.year > S3.year))  --条件1：与该年份相比是过去的年份
     ORDER BY year;
```

执行结果

```sql
    year   sale
    -----  ----
    1992     50
    1997     55
```

查询与过去最临近的年份营业额相同的年份：同时使用自连接

```sql
    SELECT S1.year AS year,
          S1.year AS year
      FROM Sales2 S1, Sales2 S2
     WHERE S1.sale = S2.sale
      AND S2.year = (SELECT MAX(year)
                        FROM Sales2 S3
                      WHERE S1.year > S3.year)
     ORDER BY year;
```

查询每一年与过去最临近的年份之间的营业额之差

```sql
    --求每一年与过去最临近的年份之间的营业额之差(1)：结果里不包含最早的年份
    SELECT S2.year AS pre_year,
          S1.year AS now_year,
          S2.sale AS pre_sale,
          S1.sale AS now_sale,
          S1.sale - S2.sale  AS diff
      FROM Sales2 S1, Sales2 S2
     WHERE S2.year = (SELECT MAX(year)
                        FROM Sales2 S3
                      WHERE S1.year > S3.year)
     ORDER BY now_year;
```

执行结果

```sql
    pre_year  now_year  pre_sale  now_sale  diff
    --------  --------  --------  --------  ----
    1990           1992         50         50     0    --50-50  = 0
    1992           1993         50         52     2    --52-50  = 2
    1993           1994         52         55     3    --55-52  = 3
    1994           1997         55         55     0    --55-55  = 0
```

如果想让结果里出现1990年的数据，可以使用“自外连接”来实现。

```sql
    --求每一年与过去最临近的年份之间的营业额之差(2)：使用自外连接。结果里包含最早的年份
    SELECT S2.year AS pre_year, S1.year AS now_year,
          S2.sale AS pre_sale, S1.sale AS now_sale,
          S1.sale - S2.sale AS diff
      FROM Sales2 S1 LEFT OUTER JOIN Sales2 S2
        ON S2.year = (SELECT MAX(year)
                        FROM Sales2 S3
                      WHERE S1.year > S3.year)
     ORDER BY now_year;
```

执行结果

```sql
    pre_year  now_year  pre_sale  now_sale  diff
    --------  --------  --------  --------  -----
                  1990                   50           --1990年也会出现
    1990           1992         50         50       0
    1992           1993         50         52       2
    1993           1994         52         55       3
    1994           1997         55         55       0
```

# 移动累计值和移动平均值

Accounts

![](https://res.weread.qq.com/wrepub/epub_26211874_161)

求截止到那个时间点的账户余额。我们首先可以使用窗口函数来实现。

```sql
    --求累计值：使用窗口函数
    SELECT prc_date, prc_amt,
          SUM(prc_amt) OVER (ORDER BY prc_date) AS onhand_amt
      FROM Accounts;
```

如果使用标准SQL-92，我们可以像下面这样写SQL语句。

```sql
    --求累计值：使用冯·诺依曼型递归集合
    SELECT prc_date, A1.prc_amt,
          (SELECT SUM(prc_amt)
            FROM Accounts A2
            WHERE A1.prc_date >= A2.prc_date ) AS onhand_amt
      FROM Accounts A1
     ORDER BY prc_date;
```

执行结果

```sql
    prc_date    prc_amt  onhand_amt
    ----------  -------  ----------
    2006-10-26    12000       12000  --12000
    2006-10-28     2500       14500  --12000 + 2500
    2006-10-31   -15000        -500  --12000 + 2500 + (-15000)
    2006-11-03     34000       33500  --12000 + 2500 + (-15000) + 34000
    2006-11-04    -5000      28500  -- 下同
    2006-11-06     7200      35700  --    ：
    2006-11-11    11000      46700  --    ：
```

移动累计值。所谓移动，指的是将累计的数据行数固定（本例中为3行），一行一行地偏移，如下表所示。

> 滑动窗口, 窗口大小为3行

目标区间一行一行地偏移

![](https://res.weread.qq.com/wrepub/epub_26211874_162)

如果使用窗口函数，可以像下面这样通过指定ROWS关键字来指定数据行数。

```sql
    --求移动累计值(1)：使用窗口函数
    SELECT prc_date, prc_amt,
          SUM(prc_amt) OVER (ORDER BY prc_date
                            ROWS 2 PRECEDING) AS onhand_amt
      FROM Accounts;
```

如果使用关联子查询，我们还可以像下面这样用标量子查询来计算行数。

```sql
    --求移动累计值(2)：不满3行的时间区间也输出
    SELECT prc_date, A1.prc_amt,
          (SELECT SUM(prc_amt)
            FROM Accounts A2
            WHERE A1.prc_date >= A2.prc_date
              AND (SELECT COUNT(＊)
                    FROM Accounts A3
                    WHERE A3.prc_date
                      BETWEEN A2.prc_date AND A1.prc_date  ) <= 3 )
                  AS mvg_sum
      FROM Accounts A1
     ORDER BY prc_date;
```

执行结果

```sql
    prc_date    prc_amt  mvg_sum
    ----------  -------  -------
    2006-10-26    12000    12000   --12000
    2006-10-28     2500    14500   --12000 + 2500
    2006-10-31   -15000     -500   --12000 + 2500 + (-15000)
    2006-11-03    34000    21500   --2500 + (-15000) + 34000
    2006-11-04    -5000    14000   --下同
    2006-11-06     7200    36200   --  ：
    2006-11-11    11000    13200   --  ：
```

使用HAVING子句找出元素数刚好为3行的集合

```sql
    --移动累计值(3)：不满3行的区间按无效处理
    SELECT prc_date, A1.prc_amt,
     (SELECT SUM(prc_amt)
        FROM Accounts A2
      WHERE A1.prc_date >= A2.prc_date
        AND (SELECT COUNT(＊)
                FROM Accounts A3
              WHERE A3.prc_date
                BETWEEN A2.prc_date AND A1.prc_date  ) <= 3
      HAVING  COUNT(＊) =3) AS mvg_sum  --不满3行数据的不显示
      FROM Accounts A1
     ORDER BY prc_date;
```

执行结果

```sql
    prc_date    prc_amt   mvg_sum
    ----------  -------   -------
    2006-10-26    12000             --不满3行数据，所以不显示
    2006-10-28     2500             --不满3行数据，所以不显示
    2006-10-31   -15000      -500   --凑够了3行，所以输出
    2006-11-03    34000     21500
    2006-11-04    -5000     14000
    2006-11-06     7200     36200
    2006-11-11    11000     13200
```

去掉聚合后的明细数据

```sql
    --去掉聚合并输出
    SELECT A1.prc_date AS A1_date,
          A2.prc_date AS A2_date,
          A2.prc_amt AS amt
      FROM Accounts A1,  Accounts A2
     WHERE A1.prc_date >= A2.prc_date
      AND (SELECT COUNT(＊)
              FROM Accounts A3
            WHERE A3.prc_date BETWEEN A2.prc_date  AND A1.prc_date  ) <= 3
     ORDER BY A1_date, A2_date;
```

执行结果

```sql
    A1_date     A2_date     amt
    ----------  ----------  -------
    2006-10-26  2006-10-26   12000


    2006-10-28  2006-10-26   12000
    2006-10-28  2006-10-28    2500


    2006-10-31  2006-10-26   12000
    2006-10-31  2006-10-28    2500     …S1:-500
    2006-10-31  2006-10-31  -15000


    2006-11-03  2006-10-28    2500
    2006-11-03  2006-10-31  -15000     …S2:21500
    2006-11-03  2006-11-03   34000


    2006-11-04  2006-10-31  -15000
    2006-11-04  2006-11-03   34000     …S3:14000
    2006-11-04  2006-11-04   -5000


    2006-11-06  2006-11-03   34000
    2006-11-06  2006-11-04   -5000     …S4:36200
    2006-11-06  2006-11-06    7200


    2006-11-11  2006-11-04   -5000
    2006-11-11  2006-11-06    7200     …S5:13200
    2006-11-11  2006-11-11   11000
```

存在部分交集的集合簇

![](https://res.weread.qq.com/wrepub/epub_26211874_163)

到目前为止，我们主要思考了累计值的求法，所以使用的是SUM函数。如果求移动平均值（moving average），那么将SUM函数改写成AVG函数就可以了。

# 查询重叠的时间区间

Reservations

![](https://res.weread.qq.com/wrepub/epub_26211874_165)
![](https://res.weread.qq.com/wrepub/epub_26211874_166)

日期的重叠类型

![](https://res.weread.qq.com/wrepub/epub_26211874_167)

```sql
    --求重叠的住宿期间
    SELECT reserver, start_date, end_date
      FROM Reservations R1
     WHERE EXISTS
          (SELECT ＊

                FROM Reservations R2
               WHERE R1.reserver <> R2.reserver  --与自己以外的客人进行比较
                 AND ( R1.start_date BETWEEN R2.start_date AND R2.end_date
                                    --条件(1)：自己的入住日期在他人的住宿期间内
                    OR R1.end_date  BETWEEN R2.start_date AND R2.end_date));
                                    --条件(2)：自己的离店日期在他人的住宿期间内
```

执行结果

```sql
    reserver  start_date  end_date
    --------  ----------  ----------
    荒木       2006-10-28  2006-10-31
    堀         2006-10-31  2006-11-01
    山本       2006-11-03  2006-11-04
    内田       2006-11-03  2006-11-05
```

如果想求“与任何住宿期间都不重叠的日期”，我们只需要把EXISTS谓词改写成NOT EXISTS谓词就可以了。

如果山本的入住日期不是11月3号，而是推迟了一天，即11月4号，那么查询结果里将不会出现内田。这是因为，内田的入住日期和离店日期都不再与任何人重叠，
于是条件(1)和条件(2)就都不满足了。换句话说，像内田这种自己的住宿期间完全包含了他人的住宿期间的情况，会被这条SQL语句排除掉。如果想把这样的住
宿期间也输出，我们需要追加条件。

```sql
    --升级版：把完全包含别人的住宿期间的情况也输出
    SELECT reserver, start_date, end_date
     FROM Reservations R1
    WHERE EXISTS
          (SELECT ＊
              FROM Reservations R2
            WHERE R1.reserver <> R2.reserver
              AND (  (     R1.start_date BETWEEN R2.start_date
                                            AND R2.end_date
                        OR R1.end_date   BETWEEN R2.start_date
                                            AND R2.end_date)
                    OR (    R2.start_date BETWEEN R1.start_date
                                            AND R1.end_date
                        AND R2.end_date   BETWEEN R1.start_date
                                            AND R1.end_date)));
```

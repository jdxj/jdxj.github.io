---
title: "1-5 外连接的用法"
date: 2023-02-28T21:44:37+08:00
draft: false
---

# 用外连接进行行列转换(1)（行→列）：制作交叉表

员工学习过的培训课程的表Courses

![](https://res.weread.qq.com/wrepub/epub_26211874_109)

课程学习记录一览表（表头：课程；侧栏：员工姓名）

![](https://res.weread.qq.com/wrepub/epub_26211874_110)

用外连接的思路来思考

```sql
    --水平展开求交叉表(1)：使用外连接
    SELECT C0.name,
      CASE WHEN C1.name IS NOT NULL THEN'○'ELSE NULL END AS "SQL入门",
      CASE WHEN C2.name IS NOT NULL THEN'○'ELSE NULL END AS "UNIX基础",
      CASE WHEN C3.name IS NOT NULL THEN'○'ELSE NULL END AS "Java中级"
      FROM  (SELECT DISTINCT name FROM  Courses) C0   --这里的C0是侧栏
      LEFT OUTER JOIN
        (SELECT name FROM Courses WHERE course = 'SQL入门’) C1
        ON  C0.name = C1.name
          LEFT OUTER JOIN
            (SELECT name FROM Courses WHERE course = 'UNIX基础’) C2
            ON  C0.name = C2.name

        LEFT OUTER JOIN
          (SELECT name FROM Courses WHERE course = 'Java中级’) C3
          ON  C0.name = C3.name;
```

C0：主表

![](https://res.weread.qq.com/wrepub/epub_26211874_111)

C1:SQL

![](https://res.weread.qq.com/wrepub/epub_26211874_112)

C2:UNIX

![](https://res.weread.qq.com/wrepub/epub_26211874_113)

C3:Java

![](https://res.weread.qq.com/wrepub/epub_26211874_114)

一般情况下，外连接都可以用标量子查询替代

```sql
    --水平展开(2)：使用标量子查询
    SELECT C0.name,
          (SELECT '○'
              FROM Courses C1
            WHERE course = 'SQL入门’
              AND C1.name = C0.name) AS "SQL入门",
          (SELECT '○'
              FROM Courses C2
            WHERE course = 'UNIX基础’

                AND C2.name = C0.name) AS "UNIX基础",
            (SELECT '○'
               FROM Courses C3
              WHERE course = 'Java中级’
                AND C3.name = C0.name) AS "Java中级"
        FROM (SELECT DISTINCT name FROM Courses) C0;  --这里的C0是表侧栏
```

例如想加入第4列“PHP入门”时，只需要在SELECT子句的最后加上下面这条语句就可以了（如果采用前面的写法，则必需修改SELECT子句和FROM子句两个地方）。

```sql
    (SELECT '○'
      FROM Courses C4
      WHERE course = 'PHP入门’
        AND C4.name = C0.name ) AS "PHP入门"
```

这种做法不仅利于应对需求变更，对于需要动态生成SQL的系统也是很有好处的。缺点是性能不太好，目前在SELECT子句中使用标量子查询（或者关联子查询）
的话，性能开销还是相当大的。

嵌套使用CASE表达式

```sql
    --水平展开(3)：嵌套使用CASE表达式
    SELECT name,
      CASE WHEN SUM(CASE WHEN course = 'SQL入门’THEN 1 ELSE NULL END) = 1
          THEN'○'ELSE NULL END AS "SQL入门",
      CASE WHEN SUM(CASE WHEN course = 'UNIX基础’THEN 1 ELSE NULL END) = 1
          THEN'○'ELSE NULL END AS "UNIX基础",
      CASE WHEN SUM(CASE WHEN course = 'Java中级’THEN 1 ELSE NULL END) = 1
          THEN'○'ELSE NULL END AS "Java中级"
      FROM Courses
     GROUP BY name;
```

# 用外连接进行行列转换(2)（列→行）：汇总重复项于一列

一张让数据库工程师想哭的表Personnel：员工子女信息

![](https://res.weread.qq.com/wrepub/epub_26211874_116)

使用UNION ALL来实现。

```sql
    --列数据转换成行数据：使用UNION ALL
    SELECT employee, child_1 AS child FROM Personnel
    UNION ALL
    SELECT employee, child_2 AS child FROM Personnel
    UNION ALL
    SELECT employee, child_3 AS child FROM Personnel;
```

执行结果

```sql
    employee    child
    ----------  -------
    赤井          一郎
    赤井          二郎

    赤井          三郎
    工藤          春子
    工藤          夏子
    工藤
    铃木          夏子
    铃木
    铃木
    吉田
    吉田
    吉田
```

希望得到员工子女列表

![](https://res.weread.qq.com/wrepub/epub_26211874_117)

来生成一个存储子女列表的视图

```sql
    CREATE VIEW Children(child)
    AS SELECT child_1 FROM Personnel
      UNION
      SELECT child_2 FROM Personnel
      UNION
      SELECT child_3 FROM Personnel;

    child
    -----
    一郎
    二郎
    三郎
    春子
    夏子
```

员工列表为主表进行外连接操作

```sql
    --获取员工子女列表的SQL语句（没有孩子的员工也要输出）
    SELECT EMP.employee, CHILDREN.child
      FROM Personnel EMP
          LEFT OUTER JOIN Children
            ON CHILDREN.child IN (EMP.child_1, EMP.child_2, EMP.child_3);
```

# 在交叉表里制作嵌套式表侧栏

年龄层级主表：TblAge

![](https://res.weread.qq.com/wrepub/epub_26211874_119)

性别主表：TblSex

![](https://res.weread.qq.com/wrepub/epub_26211874_120)

人口分布表：TblPop

![](https://res.weread.qq.com/wrepub/epub_26211874_121)

包含嵌套式表侧栏的统计表

![](https://res.weread.qq.com/wrepub/epub_26211874_122)

目标表的侧栏是年龄层级和性别，所以我们需要使用表TblAge和表TblSex作为主表。

```sql
    --使用外连接生成嵌套式表侧栏：错误的SQL语句
    SELECT  MASTER1.age_class AS age_class,
            MASTER2.sex_cd    AS sex_cd,
            DATA.pop_tohoku   AS pop_tohoku,
            DATA.pop_kanto    AS pop_kanto
      FROM (SELECT age_class, sex_cd,
                SUM(CASE WHEN pref_name IN (’青森’, ’秋田’)
                          THEN population ELSE NULL END) AS pop_tohoku,
                SUM(CASE WHEN pref_name IN (’东京’, ’千叶’)
                          THEN population ELSE NULL END) AS pop_kanto
              FROM TblPop
            GROUP BY age_class, sex_cd) DATA
            RIGHT OUTER JOIN TblAge MASTER1--外连接1：和年龄层级主表进行外连接
                ON MASTER1.age_class = DATA.age_class
            RIGHT OUTER JOIN TblSex MASTER2--外连接2：和性别主表进行外连接
                ON MASTER2.sex_cd = DATA.sex_cd;
```

> 内部的sql先生成age_class, sex_cd, pop_tohoku, pop_kanto, 之后再关联名称

执行结果

```sql
    age_class  sex_cd  pop_tohoku  pop_kanto
    ---------  ------  ----------  ---------
    1           m              1100        1800
    1           f              1300        2500
    3           m              1000
    3           f              1800        2100
```

结果里没有年龄层为2的原因是TblPop没有数据.

```sql
    --停在第1个外连接处时：结果里包含年龄层级为2的数据
    SELECT MASTER1.age_class AS age_class,
          DATA.sex_cd        AS sex_cd,
          DATA.pop_tohoku   AS pop_tohoku,
          DATA.pop_kanto    AS pop_kanto
      FROM (SELECT age_class, sex_cd,
                SUM(CASE WHEN pref_name IN (’青森’, ’秋田’)
                          THEN population ELSE NULL END) AS pop_tohoku,
                SUM(CASE WHEN pref_name IN (’东京’, ’千叶’)
                          THEN population ELSE NULL END) AS pop_kanto

                FROM TblPop
               GROUP BY age_class, sex_cd) DATA
               RIGHT OUTER JOIN TblAge MASTER1
                  ON MASTER1.age_class = DATA.age_class;
```

执行结果

```sql
    age_class  sex_cd  pop_tohoku  pop_kanto
    ---------  ------  ----------  ---------
    1           m              1100        1800
    1           f              1300        2500
    2                                          --存在年龄层级为2的数据
    3           m              1000
    3           f              1800        2100
```

原因也不难理解。表TblPop里本来就没有年龄层级为2的数据，自然也没有相应的性别信息m或f，于是“性别编号”列只能是NULL。因此与性别主表进行外连接时，
连接条件会变成ON MASTER2.sex_cd =NULL，结果是unknown

如果不允许进行两次外连接，那么调整成一次就可以了。

```sql
    --使用外连接生成嵌套式表侧栏：正确的SQL语句
    SELECT MASTER.age_class AS age_class,
          MASTER.sex_cd    AS sex_cd,
          DATA.pop_tohoku  AS pop_tohoku,
          DATA.pop_kanto   AS pop_kanto
     FROM (SELECT age_class, sex_cd
            FROM TblAge CROSS JOIN TblSex ) MASTER  --使用交叉连接生成两张主表的笛卡儿积
        LEFT OUTER JOIN
          (SELECT age_class, sex_cd,
                SUM(CASE WHEN pref_name IN (’青森’, ’秋田’)
                        THEN population ELSE NULL END) AS pop_tohoku,
                SUM(CASE WHEN pref_name IN (’东京’, ’千叶’)
                        THEN population ELSE NULL END) AS pop_kanto
            FROM TblPop
            GROUP BY age_class, sex_cd) DATA
              ON  MASTER.age_class = DATA.age_class
            AND  MASTER.sex_cd    = DATA.sex_cd;
```

执行结果

```sql
    age_class  sex_cd  pop_tohoku  pop_kanto
    ---------  ------  ----------  ---------
    1           m              1100        1800
    1           f              1300        2500
    2           m
    2           f
    3           m              1000
    3           f              1800        2100
```

# 作为乘法运算的连接

交叉连接相当于乘法运算

Items

![](https://res.weread.qq.com/wrepub/epub_26211874_125)

SalesHistory

![](https://res.weread.qq.com/wrepub/epub_26211874_126)

先使用这两张表生成一张统计表，以商品为单位汇总出各自的销量。我们期望的结果是像下面这样的。

```sql
    item_no   total_qty
    -------   ---------
        10           36
        20           32
        30           22
        40
```

恐怕很多人会想到下面这种做法。

```sql
    --解答(1)：通过在连接前聚合来创建一对一的关系
    SELECT I.item_no, SH.total_qty
      FROM Items I LEFT OUTER JOIN
            (SELECT item_no, SUM(quantity) AS total_qty
                FROM SalesHistory
              GROUP BY item_no) SH
        ON I.item_no = SH.item_no;
```

以商品编号为主键的临时视图（SH）

![](https://res.weread.qq.com/wrepub/epub_26211874_127)

```sql
    --解答(2)：先进行一对多的连接再聚合
    SELECT I.item_no, SUM(SH.quantity) AS total_qty
      FROM Items I LEFT OUTER JOIN SalesHistory SH
        ON I.item_no = SH.item_no  一对多的连接
     GROUP BY I.item_no;
```

**一对一或一对多关系的两个集合，在进行连接操作后行数不会（异常地）增加。**

# 全外连接

标准SQL里定义了外连接的三种类型

- 左外连接（LEFT OUTER JOIN）
- 右外连接（RIGHT OUTER JOIN）
- 全外连接（FULL OUTER JOIN）

左外连接和右外连接没有功能上的区别。用作主表的表写在运算符左边时用左外连接，写在运算符右边时用右外连接。

全外连接

Class_A

![](https://res.weread.qq.com/wrepub/epub_26211874_131)

Class_B

![](https://res.weread.qq.com/wrepub/epub_26211874_132)

可以理解成“把两张表都当作主表来使用”的连接。

```sql
    --全外连接保留全部信息
    SELECT COALESCE(A.id, B.id) AS id,
          A.name AS A_name,
          B.name AS B_name
      FROM Class_A  A  FULL OUTER JOIN Class_B  B
        ON A.id = B.id;
```

执行结果

```sql
    id    A_name  B_name
    ----  ------  ------
    1     田中     田中
    2     铃木     铃木
    3     伊集院
    4              西园寺
```

COALESCE是SQL的标准函数，可以接受多个参数，功能是返回第一个非NULL的参数。

如果所用的数据库不支持全外连接，可以分别进行左外连接和右外连接，再把两个结果通过UNION合并起来，也能达到同样的目的

```sql
    --数据库不支持全外连接时的替代方案
    SELECT A.id AS id, A.name, B.name
      FROM Class_A  A   LEFT OUTER JOIN Class_B  B
        ON A.id = B.id

    UNION
    SELECT B.id AS id, A.name, B.name
      FROM Class_A  A  RIGHT OUTER JOIN Class_B  B
        ON A.id = B.id;
```

我们还可以换个角度，把表连接看成集合运算。内连接相当于求集合的积（INTERSECT，也称交集），全外连接相当于求集合的和（UNION，也称并集）。

内连接相当于求集合的积（INTERSECT）

![](https://res.weread.qq.com/wrepub/epub_26211874_134)

全外连接相当于求集合的和（UNION）

![](https://res.weread.qq.com/wrepub/epub_26211874_135)

# 用外连接进行集合运算

## 用外连接求差集：A－B

```sql
    SELECT A.id AS id,  A.name AS A_name
      FROM Class_A  A LEFT OUTER JOIN Class_B B
        ON A.id = B.id
     WHERE B.name IS NULL;
```

执行结果

```sql
    id    A_name
    ----  ------
    3     伊集院
```

用外连接求差集（A-B）

![](https://res.weread.qq.com/wrepub/epub_26211874_139)

## 用外连接求差集：B－A

```sql
    SELECT B.id AS id, B.name AS B_name
      FROM Class_A  A  RIGHT OUTER JOIN Class_B B
        ON A.id = B.id
     WHERE A.name IS NULL;
```

执行结果

```sql
    id    B_name
    ----  ------
    4     西园寺
```

用外连接求差集（B-A）

![](https://res.weread.qq.com/wrepub/epub_26211874_141)

## 用全外连接求异或集

SQL没有定义求异或集的运算符，如果用集合运算符，可以有两种方法。

- 一种是(A UNION B) EXCEPT (A INTERSECT B)
- 另一种是(A EXCEPT B) UNION (B EXCEPT A)。两种方法都比较麻烦，性能开销也会增大。

```sql
    SELECT COALESCE(A.id, B.id) AS id,
          COALESCE(A.name , B.name ) AS name
      FROM Class_A  A  FULL OUTER JOIN Class_B  B
        ON A.id = B.id
     WHERE A.name IS NULL
        OR B.name IS NULL;
```

执行结果

```sql
    id    name
    ----  -----
    3     伊集院
    4     西园寺
```

用全外连接求异或集

![](https://res.weread.qq.com/wrepub/epub_26211874_143)

关系除法运算也可以通过外连接来实现。使用1-4节里的表Items和表ShopItems

```sql
    --用外连接进行关系除法运算：差集的应用
    SELECT DISTINCT shop
      FROM ShopItems SI1
    WHERE NOT EXISTS
          (SELECT I.item
            FROM Items I LEFT OUTER JOIN ShopItems SI2
              ON I.item   = SI2.item
              AND SI1.shop = SI2.shop
            WHERE SI2.item IS NULL) ;
```

执行结果

```sql
    shop
    ----
    仙台
    东京
```

# 本节小结

1. SQL不是用来生成报表的语言，所以不建议用它来进行格式转换。
2. 必要时考虑用外连接或CASE表达式来解决问题。
3. 生成嵌套式表侧栏时，如果先生成主表的笛卡儿积再进行连接，很容易就可以完成。
4. 从行数来看，表连接可以看成乘法。因此，当表之间是一对多的关系时，连接后行数不会增加。
5. 外连接的思想和集合运算很像，使用外连接可以实现各种集合运算。

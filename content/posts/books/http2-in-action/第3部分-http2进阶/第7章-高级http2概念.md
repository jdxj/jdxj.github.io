---
title: "第7章 高级HTTP/2概念"
date: 2023-03-27T21:19:09+08:00
---

## 7.1 流状态

图7.1　可以使用类似的方式表述HTTP/1.1的连接和HTTP/2的流

![](https://res.weread.qq.com/wrepub/epub_32517945_234)

HTTP/2的流会经过一些生命周期状态。客户端发送HEADERS帧以开启一个HTTP请求，服务器响应此请求，然后流结束。这个过程经历如下状态

- 空闲。流刚被创建或者引用时的状态。实际上，大多数流处在这个状态的时间都很短，因为如果不想使用一个流，你也不会引用它，所以大多空闲的流会被直接使用，
  然后直接进入下一个状态：打开。
- 打开。当流被用以发送HEADERS帧时，就是打开的状态，此时流可以用来做双向的消息传递。只要客户端还在发送数据，流都保持在这个状态。
- 半关闭。当客户端使用END_STREAM标志位，表明请求的HEADERS帧已经包含了请求的所有数据时，流就变成半关闭的状态，此时流只能被用来给客户端发送响应
  数据，客户端不能使用它再发送数据（除非像WINDOW_UPDATE这种控制帧）。
- 关闭。当服务器完成数据发送，并在最后一个帧上使用END_STREAM标志时，流就变成关闭状态，此时不可以再使用流。

不会有新的帧由服务端发起）。这时，一个流启动另外一个流（使用承诺的流ID），这个新的承诺的流会经过一个类似的状态流转过程(服务端推送)

- 空闲。当承诺（要推送）的流最初被创建，或者被另外一个流上的PUSH_PROMISE帧引用的时候的状态。
- 保留。推送流直接进入保留状态，直到服务器准备好要推送的资源。
- 半关闭。当服务器开始推送响应时，承诺的（推送）流进入半关闭状态，流只能用于发送推送的数据。
- 关闭。当服务器发送完数据，在最后一个DATA帧上使用END_STREAM标志时，流会变成关闭状态，此时不能再使用流。

图7.2　HTTP/2流状态

![](https://res.weread.qq.com/wrepub/epub_32517945_235)

## 7.2 流量控制

当接收方没有准备好处理数据时（可能是因为忙而无法处理数据），可以使用流量控制来停止发送方的数据发送。进行流量控制是非常有必要的，因为这样可以让客户
端以不同的速度处理数据。高速的服务器或许可以快速地发送数据，但如果低速的客户端（如手机）跟不上它的速度，它会在内存中缓存数据，当缓存区满了的时候，
它就开始丢弃数据包，并要求服务端重发。这就导致服务端、网络和客户端浪费一些资源。

### 7.2.1 流量控制示例

![](https://res.weread.qq.com/wrepub/epub_32517945_236)

在两个SETTINGS帧中间，出现第一个WINDOW_UPDATE帧

![](https://res.weread.qq.com/wrepub/epub_32517945_237)

这个帧说明，Facebook准备接收10 420 225个8位字节，因为这个帧使用的流ID为0，所以这是会应用到所有流的连接层的限制

然后nghttp确认收到服务端的设置

![](https://res.weread.qq.com/wrepub/epub_32517945_238)

首个请求使用HEADERS帧发送，并使用流ID 13：

![](https://res.weread.qq.com/wrepub/epub_32517945_239)

然后服务端确认收到SETTTINGS帧，之后使用另外一个WINDOW_UPDATE帧将流13的窗口大小增加到10 420 224个8位字节

![](https://res.weread.qq.com/wrepub/epub_32517945_240)

nghttp开始接收资源的HEADERS和DATA帧

![](https://res.weread.qq.com/wrepub/epub_32517945_241)

把这些DATA帧的大小加起来（1353 + 2571 + 8144 + 5563 + 2572 +1491+ 2581 + 4072 + 5572），结果是33 919，所以nghttp告诉服务器它在连接
层（流ID为0）和流13上已经消费掉了这么多数据

![](https://res.weread.qq.com/wrepub/epub_32517945_242)

客户端通过一个非常友好的GOAWAY帧关闭连接：

![](https://res.weread.qq.com/wrepub/epub_32517945_243)

### 7.2.2 在服务器上设置流量控制

## 7.3 流优先级

流优先级：提示还是命令

流优先级由请求方指定（比如客户端），但由响应方（比如服务器）最终决定发送什么帧。所以，优先级是一种建议或提示，完全由响应方决定要不要忽略优先级，并
且以响应方认为的顺序返回数据。规范中说得很明确，“发送优先级……只是一个建议。”

HTTP/2定义了两种不同的方法来设置优先级：

- 流依赖
- 流权重

可以在请求的HEADERS帧中设置这些优先级，或者在其他时间使用单独的PRIORITY帧来设置。

### 7.3.1 流依赖关系

图7.3　HTTP/2流依赖的示例

![](https://res.weread.qq.com/wrepub/epub_32517945_245)

- 所有的流都默认依赖于流0, 它是控制流，没有依赖。
- 这个依赖结构并不意味着子流被它们的父依赖阻塞。
- 多个流可以有同一个依赖

图7.4　多个流可以依赖同一个父流

![](https://res.weread.qq.com/wrepub/epub_32517945_246)

- 目前不支持这种多依赖的概念。

图7.5　HTTP/2不支持依赖多个父流

![](https://res.weread.qq.com/wrepub/epub_32517945_247)

- 新增的流还可以是排他的。

图7.6　添加一个新的critical.css依赖，使用或者不使用排他的标志

![](https://res.weread.qq.com/wrepub/epub_32517945_248)

### 7.3.2 流权重

图7.7　基于权重的流优先级

![](https://res.weread.qq.com/wrepub/epub_32517945_249)

如果main.js比main.css先完成传输（或者还不能发送main.js），则image.jpg得到50％的资源，因为它使用main.js的份额。为了防止这种情况发生，并且让
CSS和JS比图片的权重更高，更合理的依赖图可能是图7.8中所示的更扁平的样子。

图7.8　基于权重的依赖

![](https://res.weread.qq.com/wrepub/epub_32517945_250)

为了使优先级模型更简单，一些客户端会使用PRIORITY帧预设置一些假流，并为它们设置对应的优先级，然后将请求挂在这些流下面。

图7.9　使用假流来挂载请求，以合理设计优先级

![](https://res.weread.qq.com/wrepub/epub_32517945_251)

这些假流仅用于优先级排序，永远不会被用来直接发送请求。在nghttp连接的开始，会给流3、5、7、9和11设置优先级

![](https://res.weread.qq.com/wrepub/epub_32517945_252)

图7.10　nghttp流优先级

![](https://res.weread.qq.com/wrepub/epub_32517945_254)

### 7.3.3 为什么优先级策略如此复杂

事实是，优先级问题本身就是复杂的, 然而，没有规定一定要支持流优先级策略

### 7.3.4 Web服务器和浏览器中的优先级策略

给Web服务器添加优先级策略

表7.1　流行的HTTP/2 Web服务器对优先级策略的支持

![](https://res.weread.qq.com/wrepub/epub_32517945_255)

给Web浏览器设置优先级策略

## 7.4 HTTP/2一致性测试

### 7.4.1 服务端一致性测试

[H2spec](https://github.com/summerwind/h2spec)是一个HTTP/2一致性测试工具

![](https://res.weread.qq.com/wrepub/epub_32517945_262)

`-k` 忽略证书错误
![](https://res.weread.qq.com/wrepub/epub_32517945_263)

表7.2　常见Web服务器的HTTP/2一致性

![](https://res.weread.qq.com/wrepub/epub_32517945_265)

表7.3　常见CDN的HTTP/2一致性

![](https://res.weread.qq.com/wrepub/epub_32517945_266)

### 7.4.2 客户端一致性测试

## 总结

- HTTP/2中有一些高深的概念很少被提及，因为很多人只关注普通概念。
- 本章中所讲的大部分底层细节不受服务器管理员和网站开发者的控制。
- HTTP/2的流有不同的状态，其状态图显示了不同状态间的转换。
- HTTP/2支持流级别的流量控制，而不是由TCP在连接层管理（HTTP/1.1是这样）。
- HTTP/2引入了流优先级的概念，客户端可以用它来向服务端建议返回请求的优先级。
- HTTP/2的流优先级策略基于依赖关系或权重，你可以使用其中一种，或者结合使用两者。
- 不同的浏览器和服务器使用流优先级的方式不同。
- 很多HTTP/2的实现不严格遵守规范。

---
title: "第8章 Hpack首部压缩"
date: 2023-03-28T20:58:39+08:00
draft: true
---

## 8.1 为什么需要首部压缩

- 大量重复首部数据
- 压缩后再加密(https)效率高些

## 8.2 压缩的运作方式

### 8.2.1 查表法

将冗长的、重复的数据拿出来，使用引用来代替。解压缩时使用查询表中的原始文本替换引用。此过程可以是动态的，它对于结构一致的数据尤其有效。

一个简单的GET请求

![](https://res.weread.qq.com/wrepub/epub_32517945_272)

这个请求有64个字符，如果你有一个这样的查询表

![](https://res.weread.qq.com/wrepub/epub_32517945_273)

则可以将这段文本编码为如下

![](https://res.weread.qq.com/wrepub/epub_32517945_274)

### 8.2.2 更高效的编码技术

- ascii
- utf-8
- uft-16
- huffman

### 8.2.3 Lookback（反查）压缩

反查压缩在当前位置放置引用，指向重复文本。

![](https://res.weread.qq.com/wrepub/epub_32517945_277)

这段文本可以被压缩为

![](https://res.weread.qq.com/wrepub/epub_32517945_278)

文本中每个重复的部分都使用一个引用来代替，它标明解码器在之前多远处可以找到重复的文本，重复的文本有多长。

## 8.3 HTTP正文压缩

HTTP正文压缩通常用于文本数据。媒体数据一般通过指定的格式提前压缩过了，不需要再压缩。例如JPEG

浏览器通过accept-encodingHTTP首部告诉服务器它所支持的压缩算法

![](https://res.weread.qq.com/wrepub/epub_32517945_280)

服务器选取其中一个算法压缩响应的正文，在响应首部中，它告诉浏览器使用哪种算法压缩资源：

![](https://res.weread.qq.com/wrepub/epub_32517945_281)

基于deflate的压缩算法有一个主要问题：被证实是不安全的。它的问题是，你可以使用数据长度来猜测内容

- CRIME（Compression Ratio Info-leak Made Easy）

## 8.4 HTTP/2的HPACK首部压缩

HTTP工作组制定了一个新的规范，叫作HPACK（不是简写），它基于查询表和Huffman编码，但（关键）不是基于反查的压缩方法。

HPACK规范明确指出

HPACK格式被有意保持简单且死板。这两个特征都会减少因为实现错误所带来的互操作风险，或者安全问题。没有定义扩展机制，如要改变当前格式，只能使用一个完
整的替代品。

### 8.4.1 HPACK静态表

HPACK有一个静态表，包含61个常见的HTTP首部名称

表8.3　HPACK静态表的一部分

![](https://res.weread.qq.com/wrepub/epub_32517945_285)

### 8.4.2 HPACK动态表

除了静态表以外，HPACK还有一个连接级的动态表，从位置62开始（跟在静态表之后），最大到SETTINGS帧的SETTINGS_HEADER_TABLE_SIZE所定义的大小。

### 8.4.3 HPACK首部类型

要不要将首部添加到动态表是可以设置的。HPACK首部分为4类

**索引首部字段类型**

索引首部字段类型（以1开始）是对表直接查询（包含静态表和动态表），所以当**首部名称和值都在表中**时才使用该类型。这个首部包含一个表索引的值，其最少
会被补齐到7位

图8.2　索引首部字段类型格式

![](https://res.weread.qq.com/wrepub/epub_32517945_289)

**带递增索引的字符串首部字段**

- 这个类型以01开头，当**首部值不在表中**，要将其添加到动态表中以备后续使用时，使用此类型。
- 这个类型包含首部名（可能是在表中的首部名索引，或者是不在表中的具体的首部名）和首部值。

如果使用一个索引的首部名（首部名已经在索引表中），则使用01之后的6个比特位定义索引的值，后面跟首部本身的值

图8.4　带递增索引的字符串首部字段 格式1

![](https://res.weread.qq.com/wrepub/epub_32517945_291)

首部值的字符串可以使用Huffman编码，也可以不用（取决于编码是否会让它更短）。如果使用Huffman编码，则图中H位会被设置为1，如果使用ASCII编码，则H位
为0。

对于不在索引表中的新首部名称，在01之后的6个比特位全部被设置为0，然后首部名称和首部值都会以长度/值组合的格式给出

图8.6　带递增索引的字符串首部字段 格式2

![](https://res.weread.qq.com/wrepub/epub_32517945_293)

**不索引的字符串首部字段**

这个类型以0000开头，适用于可能会在每个请求中**变化的首部**(e.g.`:path`值范围更加不确定)

图8.8　不索引的字符串首部字段 格式1

![](https://res.weread.qq.com/wrepub/epub_32517945_295)

图8.9　不索引的字符串首部字段 格式2

![](https://res.weread.qq.com/wrepub/epub_32517945_296)

**从不索引的字符串首部字段**

这个类型以0001开头，但是这个值一定不能在任何后续的重新编码流程中被添加到动态表（比如当服务器在两个HTTP/2实现之间充当代理的时候）。这个首部类型用
于敏感信息（比如用户名、密码），我们不希望它们被存储在一个共享的HTTP首部索引中。这个首部用来指示，在传输时如何处理重新编码和当前编码。

应该将cookie存储在HPACK表中吗

- cookie是敏感数据，并且看起来正是最后这种类型适用的对象。不存储的缺点是，对后续请求cookie的压缩减少了。
- cookie会很大，而且重复，所以理想情况下，应该将它们压缩。

图8.11　从不索引的字符串首部字段 格式1

![](https://res.weread.qq.com/wrepub/epub_32517945_298)

图8.12　从不索引的字符串首部字段 格式2

![](https://res.weread.qq.com/wrepub/epub_32517945_299)

### 8.4.4 Huffman编码表

表8.4　HPACK Huffman编码表中的部分编码

![](https://res.weread.qq.com/wrepub/epub_32517945_300)

### 8.4.5 Huffman编码脚本

### 8.4.6 为什么Huffman编码不总是最佳的

对于一些值，Huffman编码的结果会比ASCII编码更大。

## 8.5 HPACK压缩实例

## 8.6 客户端和服务端对HPACK的实现

## 8.7 HPACK的价值

## 总结

- 有不同的方法压缩数据。
- HTTP首部中包含敏感数据，如cookie，所以它们不能和HTTP正文使用相同的压缩方法，因为这些方法不能抵御各种攻击，可能泄露数据。
- HPACK是一种压缩格式，是专门为HTTP/2的HTTP首部压缩实现的。
- HPACK有一个专用的二进制格式，使用由预先定义的常见首部名称（还有一些值）组成的静态表，和在会话过程中创建的动态表。
- 没有引用索引表的首部值可以使用ASCII编码或者Huffman编码来传输。
- Huffman编码通常占用更少的空间。
- 在HPACK中可以使用多种方法来发送HTTP首部，浏览器可能使用不同的方式来编码HTTP首部。

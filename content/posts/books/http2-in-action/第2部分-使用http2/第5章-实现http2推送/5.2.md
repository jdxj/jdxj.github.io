---
title: "5.2 如何推送"
date: 2023-03-25T11:32:00+08:00
---

### 5.2.1 使用HTTP link首部推送

nginx

![](https://res.weread.qq.com/wrepub/epub_32517945_149)

[例子来源](https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/)

```nginx configuration
server {
    listen 443 ssl http2 default_server;

    ssl_certificate ssl/certificate.pem;
    ssl_certificate_key ssl/key.pem;

    root /var/www/html;
    http2_push_preload on;

    location = /demo.html {
        add_header Set-Cookie "session=1";
        add_header Link $resources;
    }
}

map $http_cookie $resources {
    "~*session=1" "";
    default "</style.css>; as=style; rel=preload, </image1.jpg>; as=image; rel=preload, </image2.jpg>; as=image; rel=preload";
}
```

- rel=preload属性来指示Web服务器，要将这个资源推送过去
- as=style部分（指示资源的类型）是可选的。这个as属性可以用来决定优先级

preload HTTP首部和HTTP/2推送

- http/2之前, 这个首部允许浏览器直接获取资源，不用等着下载、读取、解析整个页面之后才决定是否下载另一个资源。
- HTTP/2的实现重新修改了preload link首部的使用目的，实现服务端推送
- 如果想使用原来的preload方式，但不让服务器推送资源，通常可以使用nopush属性

![](https://res.weread.qq.com/wrepub/epub_32517945_151)

通常只有HTTP首部支持HTTP/2推送。HTTP/2推送通常忽略HTML中的标签，因为对于服务器来说，解析HTML并提取这些首部，比从HTTP首部中获取这些信息要复杂
得多，也要花更多时间。

### 5.2.2 查看HTTP/2推送

图5.6　在Chrome开发者工具Network标签中查看HTTP/2推送的资源

![](https://res.weread.qq.com/wrepub/epub_32517945_157)

图5.7　与图5.6中一样的页面加载，但是没有服务端推送

![](https://res.weread.qq.com/wrepub/epub_32517945_158)

图5.8　在WebPagetest中的一个推送资源

![](https://res.weread.qq.com/wrepub/epub_32517945_159)

使用nghttp发送Web请求

![](https://res.weread.qq.com/wrepub/epub_32517945_160)

在连接之后，使用SETTINGS和PRIORITY帧完成连接设置。nghttp2使用HEADERS帧发出页面请求

![](https://res.weread.qq.com/wrepub/epub_32517945_161)

在收到返回的页面之前，会收到一个PUSH_PROMISE帧。需要注意的是，nghttp先展示收到帧的内容，然后才是帧的详情：

![](https://res.weread.qq.com/wrepub/epub_32517945_162)

> 有点疑惑, 客户端发送HEADERS帧(stream_id=13)请求页面, 为啥返回的PUSH_PROMISE帧还是用stream_id=13
> 
> 猜测是因为h2是1对多模型, 1个请求可以有多个响应, 这些响应处于同一流中

PUSH_PROMISE帧和浏览器在请求资源时发送的HEADERS帧类似，但有两点区别

- 这个帧由服务端发送到客户端，而不是由客户端发送到服务端。
- 它包含一个promised_stream_id，代表所要推送资源的流ID，表明要推送的资源将要通过流2发送。服务端发起的流ID（当前只用以推送）是偶数。

在这之后，服务器返回开始时请求的资源(stream_id=13)，使用HEADERS帧，后面跟着DATA帧。然后服务器在stream_id=2上推送资源，使用一个HEADERS帧，
后面跟着DATA帧

![](https://res.weread.qq.com/wrepub/epub_32517945_163)

### 5.2.3 使用link首部从下游系统推送

图5.9　在HTTP/2下，从下游的应用服务器推送link首部

![](https://res.weread.qq.com/wrepub/epub_32517945_164)

图5.10　使用link首部从后端应用服务器推送资源

![](https://res.weread.qq.com/wrepub/epub_32517945_165)

创建一个简单的node服务，使用HTTP/1.1

![](https://res.weread.qq.com/wrepub/epub_32517945_166)

> html中的link只是表示渲染页面时需要common.css, 重点在setHeader中.

该页面在HEAD标签中引用一个样式表（通过link首部引用这个样式表）。在另外一个窗口中使用curl来查看结果：

![](https://res.weread.qq.com/wrepub/epub_32517945_169)

图5.11　在link首部中引用的资源下游系统可以推送

![](https://res.weread.qq.com/wrepub/epub_32517945_171)

**Web服务器不能给其他域名推送资源**

### 5.2.4 更早推送

Chrome开发者工具中不显示未使用到的推送资源如果被页面用到，推送的资源会在Chrome开发者工具Network标签页中显示。预加载器会使用preload提示

图5.12　加载后端处理时间较长的网页

![](https://res.weread.qq.com/wrepub/epub_32517945_174)

图5.13　更早推送以尽量利用可能被浪费的时间

![](https://res.weread.qq.com/wrepub/epub_32517945_175)

修改这个简单的NodeJS服务来模拟延迟

![](https://res.weread.qq.com/wrepub/epub_32517945_176)

如果再次使用nghttp来调用这段代码的服务，然后使用grep过滤输出，只显示recv frame相关的行，你会看到，在连接建立之后有一个10 s的延迟，直到
PUSH_PROMISE帧被发送（对应前面代码中的10 s的sleep）

![](https://res.weread.qq.com/wrepub/epub_32517945_177)

如果改变Apache的推送配置，使用H2PushResource而不是等待link首部，则推送会直接发生，不需要10 s的延迟，因为要推送的资源不再被主资源所阻塞

![](https://res.weread.qq.com/wrepub/epub_32517945_178)

> 也就是说应用程序添加link首部会导致类似队头阻塞问题, 所以nginx中的http2_push_preload应该是指示nginx提前推送.
> 
> 所以nginx应该记住哪些资源提前推送了?

**使用Web服务器的更早推送指令（如H2PushResource）的缺点是，你不能再使用应用来发起这些推送**

- 为了解决这个问题，有了一个新的HTTP状态码——103 Early Hints, 其允许通过preload HTTP link首部来提前指示是否需要一个资源。

在HTTP/1.1中，这个代码看起来像是两个请求挨着

![](https://res.weread.qq.com/wrepub/epub_32517945_179)

图5.14　使用状态码103告诉Web服务器更早推送资源

![](https://res.weread.qq.com/wrepub/epub_32517945_180)

在nghttp中，场景可能看起来像这样

![](https://res.weread.qq.com/wrepub/epub_32517945_181)

> http 103为啥也返回给了客户端, 之前以为是103是给nginx看的.
>
> 书中提到:
> 
> Apache支持处理103响应，它会处理其中的link首部来推送资源，但是它故意不将103响应发送给浏览器，因为一些浏览器不支持这些响应，可能会发生错误。

对103状态码的支持比较少还有一个原因，它需要在一个请求中发送多个响应。

### 5.2.5 使用其他方式推送

应用服务器自己也可以使用http/2推送

需要在全链路上支持推送吗

- 需要考虑客户端, 中间代理, 应用服务对http/2的支持情况
- HTTP/2规范声明：中间节点可以从服务端接收推送的资源，并选择不将它们推送到客户端。换句话说，如何利用推送的信息取决于中间节点。同样，中间节点可以
  选择向客户端推送额外的资源，而不需要后端服务器做任何操作。
- 实际上，让边缘节点服务器使用HTTP link首部（用不用103 Early Hints均可）来处理推送逻辑会更简单。

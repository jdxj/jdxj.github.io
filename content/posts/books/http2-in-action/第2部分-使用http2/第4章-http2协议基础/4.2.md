---
title: "4.2 如何创建一个HTTP/2连接"
date: 2023-03-25T11:05:25+08:00
---

- 使用HTTPS协商。
- 使用HTTP Upgrade首部。
- 和之前的连接保持一致。

理论上，HTTP/2支持基于未加密的HTTP（也就是h2c）创建连接，也支持基于加密的HTTPS（即h2）创建连接。实际上，所有的Web浏览器仅支持基于HTTPS（h2）
建立HTTP/2连接，所以浏览器使用第一个方法来协商HTTP/2。服务器之间的HTTP/2连接可以基于未加密的HTTP（h2c）或者HTTPS（h2）。

### 4.2.1 使用HTTPS协商

HTTPS需要经过一个协议协商阶段来建立连接，在建立连接并交换HTTP消息之前，它们需要协商SSL/TLS协议、加密的密码，以及其他的设置。这个过程比较灵活，
可以引入新的HTTPS协议和密码，只要客户端和服务端都支持就行。在HTTPS握手的过程中，可以同时完成HTTP/2协商，这就不需要在建立连接时增加一次跳转。

HTTPS握手

公钥私钥加密被称为非对称加密, 但它比较慢，所以这种加密方式用于协商一个对称加密的密钥，以便在创建连接之后使用对称密钥加密消息。

图4.4　HTTPS握手 (TLSv1.2, 与TLSv1.3略微不同)

![](https://res.weread.qq.com/wrepub/epub_32517945_82)

握手过程涉及4类消息：

1. 客户端发送一个ClientHello消息，用于详细说明自己的加密能力。不加密此消息，因为加密方法还没有达成一致。
2. 服务器返回一个SeverHello消息，用于选择客户端所支持的HTTPS协议（如TLSv1.2）。基于客户端在ClientHello中声明的密码，和服务器本身支持的密码，
   服务器返回此连接的加密密码（如ECDHE-RSA-AES128-GCM-SHA256）。
    - 之后提供服务端HTTPS证书（ServerCertificate）。
    - 然后是基于所选密码加密的密钥信息（ServerKeyExchange）
    - 以及是否需要客户端发送客户端证书（CertificateRequest，大多数网站不需要）的说明。
    - 最后，服务端宣告本步骤结束（ServerHelloDone）。
3. 客户端校验服务端证书，如果需要发送客户端证书（ClientCertificate，大多数网站不需要）。
    - 然后发送密钥信息（ClientKeyExchange）。这些信息通过服务端证书中的公钥加密，所以只有服务端可以通过密钥解密消息。
    - 如果使用客户端证书，则会发送一个**CertificateVerify消息，此消息使用私钥签名**，以证明客户端对证书的拥有权。
    - 客户端使用ServerKeyExchange和ClientKeyExchange信息来定义一个加密过的对称加密密钥，然后发送一个ChangeCipherSpec消息通知服务端加密开
      始
    - 最后发送一个Finished消息。

> 配置客户端证书需要私钥吗?

4. 服务端也切换到加密连接上（ChangeCipherSpec），然后发送一个加密过的Finished消息。

当HTTPS会话建立完成后，在同一个连接上的HTTP消息就不再需要这个协商过程了。类似地，后续的连接（不管是并发的额外连接，还是后来重新打开的连接）可以
跳过其中的某些步骤 —— 如果它复用上次的加密密钥，这个过程就叫作**TLS会话恢复**。

TLSv1.3可以将协商过程中的消息往返减少到1个（如果复用之前的协商结果，则可以降到0个）

**ALPN**

ALPN给ClientHello和ServerHello消息添加了功能扩展，客户端可以用它来声明应用层协议支持（“嗨，我支持h2和http/1，你用哪个都行。”），服务端
可以用它来确认在HTTPS协商之后所使用的应用层协议（“好的，我们用h2吧”）。

图4.5　使用ALPN的HTTPS握手

![](https://res.weread.qq.com/wrepub/epub_32517945_83)

NPN

在使用NPN时，客户端决定最终使用的协议，而在使用ALPN时，服务端决定最终使用的协议。

图4.6　使用NPN的HTTPS握手

![](https://res.weread.qq.com/wrepub/epub_32517945_84)

现在不再推荐使用NPN，应该使用ALPN。

使用ALPN进行HTTPS握手的示例(curl)

![](https://res.weread.qq.com/wrepub/epub_32517945_85)

### 4.2.2 使用HTTP Upgrade首部

通过发送Upgrade首部，客户端可以请求将现有的HTTP/1.1连接升级为HTTP/2。这个首部应该只用于未加密的HTTP连接（h2c）。基于加密的HTTPS连接的
HTTP/2（h2）不得使用此方法进行HTTP/2协商，它必须使用ALPN。我们已经说过多次，Web浏览器只支持基于加密连接的HTTP/2，所以它们不会使用这个方法。

示例1：一个不成功的Upgrade请求

客户端支持并想要使用HTTP/2，发送一个带Upgrade首部的请求：

![](https://res.weread.qq.com/wrepub/epub_32517945_87)

这样的请求必须包含一个HTTP2-Settings首部，它是一个Base-64编码的HTTP/2 SETTINGS帧

不支持HTTP/2的服务器可以像之前一样返回一个HTTP/1.1消息，就像Upgrade首部没有发送一样：

![](https://res.weread.qq.com/wrepub/epub_32517945_88)

示例2：一个成功的Upgrade请求

支持HTTP/2的服务器可以返回一个HTTP/1.1 101响应以表明它将切换协议，而不是忽略升级请求，并返回HTTP/1.1 200响应：

![](https://res.weread.qq.com/wrepub/epub_32517945_89)

然后服务器直接切换到HTTP/2，发送SETTINGS帧（见4.3.3节），之后以HTTP/2格式发送响应。

示例3：服务端请求的升级

当客户端认为服务器不支持HTTP/2时，它会发送不带Upgrade的请求：

![](https://res.weread.qq.com/wrepub/epub_32517945_90)

一个支持HTTP/2的服务端可以返回一个200响应，但是在响应首部中添加Upgrade来说明自己支持HTTP/2。这个时候，它是一个升级建议，而不是升级请求，因为只
有客户端才发起升级请求。

如下是一个服务端宣告支持h2（基于HTTPS的HTTP/2）和h2c（基于纯文本的HTTP/2）的示例：

![](https://res.weread.qq.com/wrepub/epub_32517945_91)

客户端可以利用这个信息来完成协议升级，并在下一个请求中发送一个Upgrade首部

![](https://res.weread.qq.com/wrepub/epub_32517945_92)

发送Upgrade首部的问题

由于所有的浏览器都只支持基于HTTPS的HTTP/2，因此这个Upgrade方法可能永远不会被浏览器使用，这会带来问题。

- 应用服务器可能会发送一个Upgrade首部，帮助升级到HTTP/2以提升性能。反向代理Web服务器可能会透传这个首部。浏览器会收到升级建议，并决定升级。但是
  与客户端直接连接的这个反向代理Web服务器并不支持HTTP/2。
- 在类似的场景中，可能反向代理已经和Web浏览器使用HTTP/2交互，但使用HTTP/1.1将请求代理到后端应用服务器。应用服务器可能会发出升级建议，如果其被反
  向代理透传，浏览器就会困惑，因为当前已经使用HTTP/2通信了，服务端还在建议升级到HTTP/2。

### 4.2.3 使用先验知识

有不同的方法可以让客户端事先知道服务器是否支持HTTP/2。如果你使用反向代理来卸载HTTPS，则可能会通过基于纯文本的HTTP/2（h2c）与后端服务器通信，因
为你知道它们支持HTTP/2。或者，可以根据Alt-Svc首部（HTTP/1.1）或ALTSVC帧（参见4.3.4节）推断先前的连接信息。

### 4.2.4 HTTP Alternative Services

第4种方法是使用HTTP Alternative Services（替代服务），它没有被包含在原来的标准中，在HTTP/2发布之后，将其列为单独的标准。此标准允许服务器使用
HTTP/1.1协议（通过Alt-Svc HTTP首部）通知客户端，它所请求的资源在另一个位置（例如，另一个IP或端口），可以使用不同的协议访问它们。该协议可以使用
先验知识启用HTTP/2。

### 4.2.5 HTTP/2前奏消息

不管使用哪种方法启用HTTP/2连接，在HTTP/2连接上发送的第一个消息必须是HTTP/2连接前奏，或者说是“魔法”字符串。此消息是客户端在HTTP/2连接上发送的
第一个消息。它是一个24个八位字节的序列，以十六进制表示法显示如下：

这个序列被转换为ASCII字符串后如下所示：

![](https://res.weread.qq.com/wrepub/epub_32517945_95)
![](https://res.weread.qq.com/wrepub/epub_32517945_96)

这个无意义的看起来像HTTP/1样式的消息，目的是兼容，客户端向不支持HTTP/2的服务端发送HTTP/2消息的情况。然后服务器会尝试解析此消息，就像收到其他
HTTP消息时一样。因为它无法识别这个无意义的方法（PRI）和HTTP版本（HTTP/2.0），所以解析会失败，从而拒绝此消息。注意，此消息前奏是官方规范中唯一一
处使用HTTP/2.0的地方，在其他地方都是HTTP/2，正如4.1节中所讨论的。而对于支持HTTP/2的服务器，可以根据这个收到的前奏消息推断出客户端支持HTTP/2，
它不会拒绝这个神奇的消息，它必须发送SETTINGS帧作为其第一条消息（可以为空）。

为什么是PRI和SM

在早期的草稿中，HTTP/2规范中的消息前奏使用FOO和BAR或者BA表示，它们是编程中常见的占位符。但是在规范草稿的第4个版本中，这个占位符变成了PRI SM，
但是没有说为什么。

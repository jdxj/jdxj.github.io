---
title: "第5章 跳跃表"
date: 2023-04-21T16:26:08+08:00
---

## 5.1 跳跃表的实现

图5-1 一个跳跃表

![](https://res.weread.qq.com/wrepub/epub_622000_45)

图片最左边的是zskiplist结构

- header：指向跳跃表的表头节点
- tail：指向跳跃表的表尾节点
- level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）
- length：记录跳跃表的长度，跳跃表目前包含节点的数量（表头节点不计算在内）

位于zskiplist结构右方的是四个zskiplistNode结构

- 层（level）：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。
  - 每个层都带有两个属性：前进指针和跨度。
    - 前进指针用于访问位于表尾方向的其他节点，
    - 跨度则记录了前进指针所指向节点和当前节点的距离。
    - 在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。
    - 当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。
- 后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用
- 分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列
- 成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象

注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表
头节点的各个层。

### 5.1.1 跳跃表节点

redis.h/zskiplistNode

```c
typedef struct zskiplistNode {
    //层
    struct zskiplistLevel {
        //前进指针
        struct zskiplistNode *forward;
        //跨度
        unsigned int span;
    } level[];
    //后退指针
    struct zskiplistNode *backward;
    //分值
    double score;
    //成员对象
    robj *obj;
} zskiplistNode;
```

1. 层

- 一般来说，层的数量越多，访问其他节点的速度就越快
- 每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这
  个大小就是层的“高度”

图5-2 带有不同层高的节点

![](https://res.weread.qq.com/wrepub/epub_622000_46)

2. 前进指针

level[i].forward, 用于从表头向表尾方向访问节点

图5-3 遍历整个跳跃表

- 注意虚线标识的访问路径, 可以在不同层之间前进

![](https://res.weread.qq.com/wrepub/epub_622000_47)

3. 跨度

level[i].span用于记录两个节点之间的距离

- 两个节点之间的跨度越大，它们相距得就越远
- 指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点
- 跨度实际上是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。

图5-4 计算节点的排位

![](https://res.weread.qq.com/wrepub/epub_622000_48)

图5-5 另一个计算节点排位的例子

![](https://res.weread.qq.com/wrepub/epub_622000_49)

4. 后退指针

backward每次只能后退至前一个节点。

图5-6 从表尾向表头方向遍历跳跃表

![](https://res.weread.qq.com/wrepub/epub_622000_50)

5. 分值和成员

- score是double类型的浮点数, 跳跃表中的所有节点都按分值从小到大来排序
- obj指向一个字符串对象，而字符串对象则保存着一个SDS值
- 分值相同的节点将按照成员对象在字典序中的大小来进行排序

图5-7 三个带有相同分值的跳跃表节点

![](https://res.weread.qq.com/wrepub/epub_622000_51)

### 5.1.2 跳跃表

redis.h/zskiplist

```c
typedef struct zskiplist {
    //表头节点和表尾节点
    structz skiplistNode *header, *tail;
    //表中节点的数量
    unsigned long length;
    //表中层数最大的节点的层数
    int level;
} zskiplist;
```

图5-8 由多个跳跃节点组成的跳跃表

![](https://res.weread.qq.com/wrepub/epub_622000_52)

图5-9 带有zskiplist结构的跳跃表

![](https://res.weread.qq.com/wrepub/epub_622000_53)

- header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为O(1)。
- 通过使用length属性来记录节点的数量，程序可以在O(1)复杂度内返回跳跃表的长度。
- level属性则用于在O(1)复杂度内获取跳跃表中层高最大的那个节点的层数量，注意表头节点的层高并不计算在内。

## 5.2 跳跃表API

表5-1 跳跃表API

![](https://res.weread.qq.com/wrepub/epub_622000_54)

## 5.3 重点回顾

- 跳跃表是有序集合的底层实现之一。
- Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而
  zskiplistNode则用于表示跳跃表节点。
- 每个跳跃表节点的层高都是1至32之间的随机数。
- 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。
- 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。

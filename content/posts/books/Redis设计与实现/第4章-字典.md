---
title: "第4章 字典"
date: 2023-04-21T13:29:08+08:00
---

## 4.1 字典的实现

### 4.1.1 哈希表

dict.h/dictht

```c
typedef struct dictht {
    //哈希表数组
    dictEntry **table;
    //哈希表大小
    unsigned long size;
    //哈希表大小掩码，用于计算索引值
    //总是等于size-1
    unsigned long sizemask;
    //该哈希表已有节点的数量
    unsigned long used;
} dictht;
```

图4-1 一个空的哈希表

![](https://res.weread.qq.com/wrepub/epub_622000_27)

### 4.1.2 哈希表节点

dict.h/dictEntry

```c
typedef struct dictEntry {
    //键
    void *key;
    //值
    union{
        void *val;
        uint64_tu64;
        int64_ts64;
    } v;
    //指向下个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```

next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。

图4-2 连接在一起的键K1和键K0

![](https://res.weread.qq.com/wrepub/epub_622000_28)

### 4.1.3 字典

dict.h/dict

```c
typedef struct dict {
    //类型特定函数
    dictType *type;
    //私有数据
    void *privdata;
    //哈希表
    dictht ht[2];
    // rehash索引
    //当rehash不在进行时，值为-1
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */
} dict;
```

- type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。
- privdata属性则保存了需要传给那些类型特定函数的可选参数

```c
typedef struct dictType {
    //计算哈希值的函数
    unsigned int (*hashFunction)(const void *key);
    //复制键的函数
    void *(*keyDup)(void *privdata, const void *key);
    //复制值的函数
    void *(*valDup)(void *privdata, const void *obj);
    //对比键的函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    //销毁键的函数
    void (*keyDestructor)(void *privdata, void *key);
    //销毁值的函数
    void (*valDestructor)(void *privdata, void *obj);
} dictType;
```

- ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行
  rehash时使用。

图4-3 普通状态下的字典

![](https://res.weread.qq.com/wrepub/epub_622000_29)

## 4.2 哈希算法

Redis计算哈希值和索引值的方法

```c
#使用字典设置的哈希函数，计算键key的哈希值
hash = dict-＞type-＞hashFunction(key);
#使用哈希表的sizemask属性和哈希值，计算出索引值
#根据情况不同，ht[x]可以是ht[0]或者ht[1]
index = hash & dict-＞ht[x].sizemask;
```

图4-4 空字典

![](https://res.weread.qq.com/wrepub/epub_622000_30)

图4-5 添加键值对K0和v0之后的字典

![](https://res.weread.qq.com/wrepub/epub_622000_31)

当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。

- 这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。

## 4.3 解决键冲突

Redis的哈希表使用链地址法（separate chaining）来解决键冲突

图4-6 一个包含两个键值对的哈希表

![](https://res.weread.qq.com/wrepub/epub_622000_32)

因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将**新节点添加到链表的表头位置**（复杂度为O（1）），排在其他已有节
点的前面。

图4-7 使用链表解决k2和k1的冲突

![](https://res.weread.qq.com/wrepub/epub_622000_33)

## 4.4 rehash

Redis对字典的哈希表执行rehash的步骤

1. 为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）
   - 如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n；
   - 如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n。
2. 将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。
3. 当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次
   rehash做准备。

图4-8 执行rehash之前的字典

![](https://res.weread.qq.com/wrepub/epub_622000_34)

ht[0].used当前的值为4，4*2=8，而8（2^3）恰好是第一个大于等于4的2的n次方，所以程序会将ht[1]哈希表的大小设置为8。

图4-9 为字典的ht[1]哈希表分配空间

![](https://res.weread.qq.com/wrepub/epub_622000_35)

将ht[0]包含的四个键值对都rehash到ht[1]

图4-10 ht[0]的所有键值对都已经被迁移到ht[1]

![](https://res.weread.qq.com/wrepub/epub_622000_36)

释放ht[0]，并将ht[1]设置为ht[0]，然后为ht[1]分配一个空白哈希表

图4-11 完成rehash之后的字典

![](https://res.weread.qq.com/wrepub/epub_622000_37)

当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作

- 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1
- 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5

哈希表的负载因子

```c
#负载因子=哈希表已保存节点数量/哈希表大小
load_factor = ht[0].used / ht[0].size
```

根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，
Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，所以在子进程存在期间，服务器会
提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。

当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。

## 4.5 渐进式rehash

扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但是，这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。

1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。
2. 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。
3. 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键
   值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。
4. 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完
   成。

图4-12 准备开始rehash

![](https://res.weread.qq.com/wrepub/epub_622000_38)

图4-13 rehash索引0上的键值对

![](https://res.weread.qq.com/wrepub/epub_622000_39)

图4-14 rehash索引1上的键值对

![](https://res.weread.qq.com/wrepub/epub_622000_40)

图4-15 rehash索引2上的键值对

![](https://res.weread.qq.com/wrepub/epub_622000_41)

图4-16 rehash索引3上的键值对

![](https://res.weread.qq.com/wrepub/epub_622000_42)

图4-17 rehash执行完毕

![](https://res.weread.qq.com/wrepub/epub_622000_43)

因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、
更新（update）等操作会在两个哈希表上进行。例如，要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht[1]里面进
行查找，诸如此类。

在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减
不增，并随着rehash操作的执行而最终变成空表。

## 4.6 字典API

表4-1 字典的主要操作API

![](https://res.weread.qq.com/wrepub/epub_622000_44)

## 4.7 重点回顾

- 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。
- Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。
- 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。
- 哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。
- 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进
  式地完成的。

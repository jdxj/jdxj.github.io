---
title: "第8章 对象"
date: 2023-05-18T17:47:07+08:00
---

Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和
有序集合对象这五种类型的对象

## 8.1 对象的类型与编码

Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另
一个对象用作键值对的值（值对象）。

Redis中的每个对象都由一个redisObject结构表示

```c
typedef struct redisObject {
    //类型
    unsigned type:4;
    //编码
    unsigned encoding:4;
    //指向底层实现数据结构的指针
    void *ptr;
    // ...
} robj;
```

### 8.1.1 类型

对象的type属性记录了对象的类型

表8-1 对象的类型

![](https://res.weread.qq.com/wrepub/epub_622000_86)

对于Redis数据库保存的键值对来说，**键总是一个字符串对象**，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种

TYPE命令用于查看值对象的类型

```bash
#键为字符串对象，值为字符串对象
redis> SET msg "hello world"
OK
redis> TYPE msg
string
#键为字符串对象，值为列表对象
redis> RPUSH numbers 1 3 5
(integer) 6
redis> TYPE numbers
list
#键为字符串对象，值为哈希对象
redis> HMSET profile name Tom age 25 career Programmer
OK
redis> TYPE profile
hash
#键为字符串对象，值为集合对象
redis> SADD fruits apple banana cherry
(integer) 3
redis> TYPE fruits
set
#键为字符串对象，值为有序集合对象
redis> ZADD price 8.5 apple 5.0
    banana 6.0 cherry
(integer) 3
redis> TYPE price
zset
```

### 8.1.2 编码和底层实现

表8-3 对象的编码

![](https://res.weread.qq.com/wrepub/epub_622000_88)

表8-4 不同类型和编码的对象

![](https://res.weread.qq.com/wrepub/epub_622000_89)

## 8.2 字符串对象 {#string}

编码

- int
- raw
- embstr

如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成
long），并将字符串对象的编码设置为int。

图8-1 int编码的字符串对象

![](https://res.weread.qq.com/wrepub/epub_622000_91)

如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的
编码设置为raw。

图8-2 raw编码的字符串对象

![](https://res.weread.qq.com/wrepub/epub_622000_92)

如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值

图8-3 embstr编码创建的内存块结构

![](https://res.weread.qq.com/wrepub/epub_622000_93)

图8-4 embstr编码的字符串对象

![](https://res.weread.qq.com/wrepub/epub_622000_94)

**如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。**

### 8.2.1 编码的转换

对于int编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw。

```bash
redis> SET number 10086
OK
redis> OBJECT ENCODING number
"int"
redis> APPEND number " is a good number!"
(integer) 23
redis> GET number
"10086 is a good number!"
redis> OBJECT ENCODING number
"raw"
```

因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序, 所以embstr编码的字符串对象实际上是只读的。当我们对embstr编码的字符串对象执行任何
修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。

```bash
redis> SET msg "hello world"
OK
redis> OBJECT ENCODING msg
"embstr"
redis> APPEND msg " again!"
(integer) 18
redis> OBJECT ENCODING msg
"raw"
```

### 8.2.2 字符串命令的实现

表8-7 字符串命令的实现

![](https://res.weread.qq.com/wrepub/epub_622000_96)

## 8.3 列表对象

编码

- ziplist
- linkedlist

图8-5 ziplist编码的numbers列表对象

![](https://res.weread.qq.com/wrepub/epub_622000_97)

图8-6 linkedlist编码的numbers列表对象

![](https://res.weread.qq.com/wrepub/epub_622000_98)

### 8.3.1 编码转换

当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：

- 列表对象保存的所有字符串元素的长度都小于64字节；
- 列表对象保存的元素数量小于512个；

不能满足这两个条件的任意一个时, 列表对象需要使用linkedlist编码。

以上两个条件的上限值是可以修改的，具体请看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明。

```bash
#
所有元素的长度都小于64
字节
redis> RPUSH blah "hello" "world" "again"
(integer)3
redis> OBJECT ENCODING blah
"ziplist"
#将一个65字节长的元素推入列表对象中
redis> RPUSH blah "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww"
(integer) 4
#编码已改变
redis> OBJECT ENCODING blah
"linkedlist"
```

### 8.3.2 列表命令的实现

表8-8 列表命令的实现

![](https://res.weread.qq.com/wrepub/epub_622000_101)

## 8.4 哈希对象

编码

- ziplist
- hashtable

ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保
存了值的压缩列表节点推入到压缩列表表尾

图8-9 ziplist编码的profile哈希对象

![](https://res.weread.qq.com/wrepub/epub_622000_102)

图8-10 profile哈希对象的压缩列表底层实现

![](https://res.weread.qq.com/wrepub/epub_622000_103)

hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：

- 字典的每个键都是一个字符串对象，对象中保存了键值对的键；
- 字典的每个值都是一个字符串对象，对象中保存了键值对的值。

图8-11 hashtable编码的profile哈希对象

![](https://res.weread.qq.com/wrepub/epub_622000_104)

### 8.4.1 编码转换

当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：

- 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；
- 哈希对象保存的键值对数量小于512个；

不能满足这两个条件的任意一个时, 哈希对象需要使用hashtable编码。

这两个条件的上限值是可以修改的，具体请看配置文件中关于hash-max-ziplist-value选项和hash-max-ziplist-entries选项的说明。

```bash
#哈希对象只包含一个键和值都不超过64个字节的键值对
redis> HSET book name "Mastering C++ in 21 days"
(integer) 1
redis> OBJECT ENCODING book
"ziplist"
#向哈希对象添加一个新的键值对，键的长度为66字节
redis> HSET book long_long_long_long_long_long_long_long_long_long_long_description "content"
(integer) 1
#编码已改变
redis> OBJECT ENCODING book
"hashtable"
```

### 8.4.2 哈希命令的实现

表8-9 哈希命令的实现

![](https://res.weread.qq.com/wrepub/epub_622000_105)

## 8.5 集合对象

编码

- intset
- hashtable

intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。

图8-12 intset编码的numbers集合对象

![](https://res.weread.qq.com/wrepub/epub_622000_106)

hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。

图8-13 hashtable编码的fruits集合对象

![](https://res.weread.qq.com/wrepub/epub_622000_107)

### 8.5.1 编码的转换

当集合对象可以同时满足以下两个条件时，对象使用intset编码：

- 集合对象保存的所有元素都是整数值；
- 集合对象保存的元素数量不超过512个。

不能满足这两个条件的任意一个时, 集合对象需要使用hashtable编码。

第二个条件的上限值是可以修改的，具体请看配置文件中关于set-max-intset-entries选项的说明。

```bash
redis> SADD numbers 1 3 5
(integer) 3
redis> OBJECT ENCODING numbers
"intset"
redis> SADD numbers "seven"
(integer) 1
redis> OBJECT ENCODING numbers
"hashtable"
```

### 8.5.2 集合命令的实现

表8-10 集合命令的实现方法

![](https://res.weread.qq.com/wrepub/epub_622000_108)

## 8.6 有序集合对象

编码

- ziplist
- skiplist

ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第
二个元素则保存元素的分值（score）。

- 压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。

图8-14 ziplist编码的有序集合对象

![](https://res.weread.qq.com/wrepub/epub_622000_109)

图8-15 有序集合元素在压缩列表中按分值从小到大排列

![](https://res.weread.qq.com/wrepub/epub_622000_110)

skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：

```c
typedef struct zset {
    zskiplist *zsl;
    dict *dict;
} zset;
```

- zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：
  - 跳跃表节点的object属性保存了元素的成员
  - 跳跃表节点的score属性则保存了元素的分值。
  - 通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK、ZRANGE等命令就是基于跳跃表API来实现的。
- zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：
  - 字典的键保存了元素的成员
  - 字典的值则保存了元素的分值。
  - 通过这个字典，程序可以用**O(1)复杂度查找给定成员的分值**，ZSCORE命令就是根据这一特性实现的

有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。值得一提的是，虽然zset结构同时使用跳跃表和字典来保存有序集
合元素，但这两种数据结构都会**通过指针来共享相同元素的成员和分值**

**为什么有序集合需要同时使用跳跃表和字典来实现？**

- 有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现, 但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低
- 如果我们只使用字典来实现有序集合，那么虽然以O(1)复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行
  范围型操作——比如ZRANK、ZRANGE等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少O(NlogN)时间复杂度，以及额外的O(N)内存
  空间（因为要创建一个数组来保存排序后的元素）。
- 如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1)
  上升为O(logN)。

图8-16 skiplist编码的有序集合对象

![](https://res.weread.qq.com/wrepub/epub_622000_111)

图8-17 有序集合元素同时被保存在字典和跳跃表中

![](https://res.weread.qq.com/wrepub/epub_622000_112)

为了展示方便，图8-17在字典和跳跃表中重复展示了各个元素的成员和分值，但在实际中，字典和跳跃表会共享元素的成员和分值，所以并不会造成任何数据重复，也
不会因此而浪费任何内存。

### 8.6.1 编码的转换

当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：

- 有序集合保存的元素数量小于128个；
- 有序集合保存的所有元素成员的长度都小于64字节；

不能满足以上两个条件的任意一个时, 有序集合对象将使用skiplist编码。

以上两个条件的上限值是可以修改的，具体请看配置文件中关于zset-max-ziplist-entries选项和zset-max-ziplist-value选项的说明。

```bash
#对象包含了128个元素
redis> EVAL "for i=1, 128 do redis.call('ZADD', KEYS[1], i, i) end" 1 numbers
(nil)
redis> ZCARD numbers
(integer) 128
redis> OBJECT ENCODING numbers
"ziplist"
#再添加一个新元素
redis> ZADD numbers 3.14 pi
(integer) 1
#对象包含的元素数量变为129个
redis> ZCARD numbers
(integer) 129
#编码已改变
redis> OBJECT ENCODING numbers
"skiplist"
```

### 8.6.2 有序集合命令的实现

表8-11 有序集合命令的实现方法

![](https://res.weread.qq.com/wrepub/epub_622000_113)

## 8.7 类型检查与命令多态

### 8.7.1 类型检查的实现

类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的

### 8.7.2 多态命令的实现

Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。

## 8.8 内存回收

因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制，
程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。

每个对象的引用计数信息由redisObject结构的refcount属性记录：

```c
typedef struct redisObject {
    // ...
    //引用计数
    int refcount;
    // ...
} robj;
```

对象的引用计数信息会随着对象的使用状态而不断变化：

- 在创建一个新对象时，引用计数的值会被初始化为1；
- 当对象被一个新程序使用时，它的引用计数值会被增一；
- 当对象不再被一个程序使用时，它的引用计数值会被减一；
- 当对象的引用计数值变为0时，对象所占用的内存会被释放。

表8-12 修改对象引用计数的API

![](https://res.weread.qq.com/wrepub/epub_622000_116)

对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。

## 8.9 对象共享

在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：

1. 将数据库键的值指针指向一个现有的值对象；
2. 将被共享的值对象的引用计数增一。

图8-20 未被共享的字符串对象

![](https://res.weread.qq.com/wrepub/epub_622000_117)

图8-21 被共享的字符串对象

![](https://res.weread.qq.com/wrepub/epub_622000_118)

Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值

创建共享字符串对象的数量可以通过修改redis.h/REDIS_SHARED_INTEGERS常量来修改。

如果我们创建一个值为100的键A，并使用OBJECT REFCOUNT命令查看键A的值对象的引用计数，我们会发现值对象的引用计数为2：

```bash
redis> SET A 100
OK
redis> OBJECT REFCOUNT A
(integer) 2
```

引用这个值对象的两个程序分别是持有这个值对象的服务器程序

图8-22 引用数为2的共享对象

![](https://res.weread.qq.com/wrepub/epub_622000_119)

那些在数据结构中嵌套了字符串对象的对象（linkedlist编码的列表对象、hashtable编码的哈希对象、hashtable编码的集合对象，以及zset编码的有序集合
对象）都可以使用这些共享对象。

**为什么Redis不共享包含字符串的对象？**

只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂
度就会越高，消耗的CPU时间也会越多：

- 如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为O(1)；
- 如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)；
- 如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N^2)。

## 8.10 对象的空转时长

redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：

```c
typedef struct redisObject {
    // ...
    unsigned lru:22;
    // ...
} robj;
```

OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的：

```bash
redis> SET msg "hello world"
OK
#等待一小段时间
redis> OBJECT IDLETIME msg
(integer) 20
#等待一阵子
redis> OBJECT IDLETIME msg
(integer) 180
#访问msg键的值
redis> GET msg
"hello world"
#键处于活跃状态，空转时长为0
redis> OBJECT IDLETIME msg
(integer) 0
```

OBJECT IDLETIME命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性。

如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设
置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。

配置文件的maxmemory选项和maxmemory-policy选项的说明介绍了关于这方面的更多信息。

## 8.11 重点回顾

- Redis数据库中的每个键值对的键和值都是一个对象。
- Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象
  的使用效率。
- 服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。
- Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。
- Redis会共享值为0到9999的字符串对象。
- 对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。

---
title: "第9章 数据库"
date: 2023-05-19T13:45:40+08:00
---

## 9.1 服务器中的数据库

redis.h/redisServer

```c
struct redisServer {
    // ...
    //一个数组，保存着服务器中的所有数据库
    redisDb *db;
    // ...
    //服务器的数据库数量
    int dbnum;
    // ...
};
```

dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16

图9-1 服务器数据库示例

![](https://res.weread.qq.com/wrepub/epub_622000_121)

## 9.2 切换数据库

```bash
redis> SET msg "hello world"
OK
redis> GET msg
"hello world"
redis> SELECT 2
OK
redis[2]> GET msg
(nil)
redis[2]> SET msg"another world"
OK
redis[2]> GET msg
"another world"
```

在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库

```c
typedef struct redisClient {
// ...
//记录客户端当前正在使用的数据库
redisDb *db;
// ...
} redisClient;
```

redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。

图9-2 客户端的目标数据库为1号数据库

![](https://res.weread.qq.com/wrepub/epub_622000_122)

建议显式地切换到指定的数据库，然后才执行命令

## 9.3 数据库键空间

redis.h/redisDb

```c
typedef struct redisDb {
    // ...
    //
    数据库键空间，保存着数据库中的所有键值对
    dict *dict;
    // ...
} redisDb;
```

- 每个键都是一个字符串对象
- 每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象

图9-4 数据库键空间例子

![](https://res.weread.qq.com/wrepub/epub_622000_124)


### 9.3.6 读写键空间时的维护操作

- 在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个
  值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。
- 在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。
- 如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作
- 如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改
  过
- 如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知

## 9.4 设置键的生存时间或过期时间

通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置**生存时间**（Time To Live，TTL）

客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置**过期时间**（expire time）。

TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间

### 9.4.1 设置过期时间

**实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的**

1. EXPIRE命令可以转换成PEXPIRE命令
2. PEXPIRE命令又可以转换成PEXPIREAT命令
3. EXPIREAT命令也可以转换成PEXPIREAT命令

图9-11 设置生存时间和设置过期时间的命令之间的转换

![](https://res.weread.qq.com/wrepub/epub_622000_131)

### 9.4.2 保存过期时间

redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：

- 过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。
- 过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。

```c
typedef struct redisDb {
    // ...
    //过期字典，保存着键的过期时间
    dict *expires;
    // ...
} redisDb;
```

图9-12 带有过期字典的数据库例子

![](https://res.weread.qq.com/wrepub/epub_622000_132)

为了展示方便，图9-12的键空间和过期字典中重复出现了两次alphabet键对象和book键对象。在实际中，键空间的键和过期字典的键都指向同一个键对象，所以不
会出现任何重复对象，也不会浪费任何空间。

### 9.4.3 移除过期时间

PERSIST命令可以移除一个键的过期时间：

```bash
redis> PEXPIREAT message 1391234400000
(integer) 1
redis> TTL message
(integer) 13893281
redis> PERSIST message
(integer) 1
redis> TTL message
(integer) -1
```

### 9.4.4 计算并返回剩余生存时间

TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间：

```bash
redis> PEXPIREAT alphabet 1385877600000
(integer) 1
redis> TTL alphabet
(integer) 8549007
redis> PTTL alphabet
(integer) 8549001011
```

TTL和PTTL两个命令都是通过计算键的过期时间和当前时间之间的差来实现的

### 9.4.5 过期键的判定

通过过期字典，程序可以用以下步骤检查一个给定键是否过期：

1. 检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。
2. 检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。

## 9.5 过期键删除策略

- 定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。
- 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。
- 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

### 9.5.1 定时删除

使用定时器

优点

- 尽快删除过期键, 释放内存

缺点

- cpu不友好, 有大量过期键时可能影响响应时间和吞吐量
- 时间事件使用无序链表, 查找事件事件复杂度O(N), 效率不高

### 9.5.2 惰性删除

程序只会在取出键时才对键进行过期检查

优点

- cpu友好

缺点

- 内存不友好, 过期了只要不访问就不删除(视为内存泄漏)

### 9.5.3 定期删除

- 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。
- 除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。

定期删除策略的难点是确定删除操作执行的时长和频率：

## 9.6 Redis的过期键删除策略

Redis服务器实际使用的是惰性删除和定期删除两种策略

### 9.6.1 惰性删除策略的实现

过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查

图9-15 命令调用expireIfNeeded来删除过期键

![](https://res.weread.qq.com/wrepub/epub_622000_135)

### 9.6.2 定期删除策略的实现

过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle
函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。

## 9.7 AOF、RDB和复制功能对过期键的处理

在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。

### 9.7.2 载入RDB文件

在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：

- 如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略
- 如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的
  时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。

### 9.7.3 AOF文件写入

当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。

当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。

### 9.7.4 AOF重写

在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。

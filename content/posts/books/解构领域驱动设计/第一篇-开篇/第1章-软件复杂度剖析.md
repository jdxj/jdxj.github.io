---
title: "第1章 软件复杂度剖析"
date: 2023-06-19T19:33:05+08:00
---

## 1.1 什么是复杂系统

由大量相互作用的部分组成的系统。与整个系统比起来，这些组成部分相对简单，没有中央控制，组成部分之间也没有全局性的通信，并且组成部分的相互作用导致了
复杂行为。

Jurgen Appelo从理解能力与预测能力两个维度分析了复杂度的成因

- 理解能力维度——简单的(simple)和复杂的(complicated)；
- 预测能力维度——有序的(ordered)、复杂的(complex)和混沌的(chaotic)。

图1-1 复杂系统的特征

![](https://res.weread.qq.com/wrepub/CB_43208821_5.jpg)

软件系统的“复杂”同时覆盖了“复杂难解”(complicated)与“复杂难测”(complex)两个层面，对标图1-1给出的案例，就是一座城市的复杂特征。

## 1.2 理解能力

### 1.2.1 规模

系统的规模取决于

- 需求的数量
- 需求之间的关系

软件开发的拥堵现象或许更严重

- 函数存在副作用，调用时可能对函数的结果做了隐含的假设；
- 类的职责繁多，导致开发人员不敢轻易修改，因为不知会影响到哪些模块；
- 热点代码被频繁变更，职责被包裹了一层又一层，没有清晰的边界；
- 在系统某个角落，隐藏着伺机而动的bug，当诱发条件具备时，就会让整条调用链瘫痪；
- 不同的业务场景包含了不同的例外场景，每种例外场景的处理方式都各不相同；
- 同步处理代码与异步处理代码纠缠在一起，不可预知程序执行的顺序。

随着软件系统规模的扩张，软件复杂度以指数级增长.

软件之所以无法躲避熵的重击，源于我们在构建软件时无法避免技术债(technical debt). 对付技术债的唯一方案就是尽量让它可见，例如通过技术债列表或者技
术债雷达等可视化形式及时呈现给团队成员，并制订计划主动地消除或降低技术债。

在面向对象设计的软件项目里，除了代码行数，包、类、方法的数量，继承的层次以及方法的调用数，还有我们常常提及的圈复杂度，都会或多或少地影响整个软件系
统的规模。

### 1.2.2 结构

结构之所以变得复杂，多数情况下还是由系统的质量属性(quality attribute)决定

- 需要满足高性能、高并发的需求，就需要考虑在系统中引入缓存、并行处理、CDN、异步消息以及支持分区的可伸缩结构；
- 需要支持对海量数据的高效分析，就得考虑这些海量数据该如何分布存储，并如何有效地利用各个节点的内存与CPU资源执行运算。

分解的软件元素, 怎么协同，怎么通信，就成了系统分解后面临的主要问题。

软件系统的结构繁复还会增加软件组织的复杂度。系统架构的分解促成了软件构建工作的分工，这种分工虽然使得高效的并行开发成为可能，却也可能因为沟通成本的
增加为管理带来挑战。

康威定律(Conway’s law)就指出：“任何组织在设计一套系统（广义概念上的系统）时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。”

- 这里的"组织"是指开发系统的组织, 而不是使用系统的组织

无论设计是优雅还是拙劣，系统结构都可能因为某种设计权衡而变得复杂。唯一的区别在于前者是主动地控制结构的复杂度，而后者带来的复杂度是偶发的，是错误的
滋生，是一种技术债，它会随着系统规模的增大产生一种无序设计。

无序设计系统的几种警告信号

- 代码没有显而易见的进入系统中的路径；
- 不存在一致性，不存在风格，也没有能够将不同的部分组织在一起的统一概念；
- 系统中的控制流让人觉得不舒服，无法预测；
- 系统中有太多的“坏味道”；
- 数据很少放在它被使用的地方，经常引入额外的巴洛克式缓存层，试图让数据停留在更方便的地方。

分层架构的引入原本是为了维护系统的有序性，而如果团队却不注意维护逻辑分层确定的边界，不按照架构规定的层次分配各个类的职责，就会随着职责的乱入让逻辑
分层形成的边界变得越来越模糊。

## 1.3 预测能力

影响预测能力的关键要素在于**变化**。对变化的应对不妥，就会导致过度设计或设计不足。

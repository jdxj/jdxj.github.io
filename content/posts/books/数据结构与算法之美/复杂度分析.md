---
title: "复杂度分析"
date: 2023-04-19T10:59:41+08:00
---

# 大 O 复杂度表示法

```c
int cal(int n) {
  int sum = 0;
  int i = 1;
  for (; i <= n; ++i) {
    sum = sum + i;
  }
  return sum;
}
```

T(n) = (2n+2)*unit_time

```c
int cal(int n) {
  int sum = 0;
  int i = 1;
  int j = 1;
  for (; i <= n; ++i) {
    j = 1;
    for (; j <= n; ++j) {
      sum = sum +  i * j;
    }
  }
}
```

T(n) = (2n2+2n+3)*unit_time

![](https://static001.geekbang.org/resource/image/22/ef/22900968aa2b190072c985a08b0e92ef.png?wh=1133*109)

- T(n) 表示代码执行的时间；
- n 表示数据规模的大小；
- f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。
- 公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度
（asymptotic time complexity），简称时间复杂度。

- 当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。

# 时间复杂度分析

## 只关注循环执行次数最多的一段代码

- 第4, 5行
- O(n)

```c
int cal(int n) {
  int sum = 0;
  int i = 1;
  for (; i <= n; ++i) {
    sum = sum + i;
  }
  return sum;
}
```

## 加法法则：总复杂度等于量级最大的那段代码的复杂度

- sum_1: 100
- sum_2: O(n)
- sum_3: O(n^2)
- 整段代码的时间复杂度就为O(n^2)

```c
int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
}
```

## 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

- ret: O(n)
- sum: O(n)
- cal: O(n^2)

```c
int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
int f(int n) {
 int sum = 0;
 int i = 1;
 for (; i < n; ++i) {
   sum = sum + i;
 } 
 return sum;
}
```

# 几种常见时间复杂度实例分析

![](https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg?wh=1142*572)

## 非多项式量级

非多项式量级的算法问题叫作 NP, Non-Deterministic Polynomial

- O(2^n)
- O(n!)

## 多项式量级

### O(1)

```c
int i = 8;
int j = 6;
int sum = i + j;
```

### O(logn), O(nlogn)

O(log_2 n)

```c
i=1;
while (i <= n)  {
  i = i * 2;
}
```

O(log_3 n)

```c
i=1;
while (i <= n)  {
  i = i * 3;
}
```

如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。

### O(m+n), O(m*n)

```c

int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

# 空间复杂度分析

空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

只分配了`new int[n]`个空间, 复杂度为O(n)

```c
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。

# 内容小结

![](https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg?wh=1142*640)

# 其他时间复杂度

- 最好情况时间复杂度（best case time complexity）
- 最坏情况时间复杂度（worst case time complexity）
- 平均情况时间复杂度（average case time complexity）
- 均摊时间复杂度（amortized time complexity）

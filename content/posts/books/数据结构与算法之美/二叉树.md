---
title: "二叉树"
date: 2023-06-12T14:13:10+08:00
---

![](https://static001.geekbang.org/resource/image/50/b4/50f89510ad1f7570791dd12f4e9adeb4.jpg?wh=1142*570)

链式存储法

![](https://static001.geekbang.org/resource/image/12/8e/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg?wh=1142*734)

基于数组的顺序存储法

![](https://static001.geekbang.org/resource/image/14/30/14eaa820cb89a17a7303e8847a412330.jpg?wh=1142*604)

- 左子节点: 2*i
- 右子节点: 2*i+1

遍历

- 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
- 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
- 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

![](https://static001.geekbang.org/resource/image/ab/16/ab103822e75b5b15c615b68560cb2416.jpg?wh=1142*582)

```
前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

后序遍历的递推公式：
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
```

```java
void preOrder(Node* root) {
  if (root == null) return;
  print root // 此处为伪代码，表示打印root节点
  preOrder(root->left);
  preOrder(root->right);
}

void inOrder(Node* root) {
  if (root == null) return;
  inOrder(root->left);
  print root // 此处为伪代码，表示打印root节点
  inOrder(root->right);
}

void postOrder(Node* root) {
  if (root == null) return;
  postOrder(root->left);
  postOrder(root->right);
  print root // 此处为伪代码，表示打印root节点
}
```

# 二叉查找树（Binary Search Tree）

也叫二叉搜索树

二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。

![](https://static001.geekbang.org/resource/image/f3/ae/f3bb11b6d4a18f95aa19e11f22b99bae.jpg?wh=1142*515)
![](https://static001.geekbang.org/resource/image/96/2a/96b3d86ed9b7c4f399e8357ceed0db2a.jpg?wh=1142*616)
![](https://static001.geekbang.org/resource/image/da/c5/daa9fb557726ee6183c5b80222cfc5c5.jpg?wh=1142*602)
![](https://static001.geekbang.org/resource/image/29/2c/299c615bc2e00dc32225f4d9e3490e2c.jpg?wh=1142*620)

关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。

中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n), 因此，二叉查找树也叫作二叉排序树。

# 支持重复数据的二叉查找树

![](https://static001.geekbang.org/resource/image/3f/5f/3f59a40e3d927f567022918d89590a5f.jpg?wh=1142*555)
![](https://static001.geekbang.org/resource/image/fb/ff/fb7b320efd59a05469d6d6fcf0c98eff.jpg?wh=1142*577)
![](https://static001.geekbang.org/resource/image/25/17/254a4800703d31612c0af63870260517.jpg?wh=1142*608)

# 二叉查找树的时间复杂度分析

![](https://static001.geekbang.org/resource/image/e3/d9/e3d9b2977d350526d2156f01960383d9.jpg?wh=1142*765)

- 不平衡O(n)
- 平衡O(logN)

# 为什么还要用二叉查找树呢？

散列表是无序的, 扩容耗时, 冲突时性能不稳定, 设计比二叉查找树复杂, 装载因子不能太大浪费空间

# 平衡二叉查找树

二叉树中任意一个节点的左右子树的高度相差不能大于1。

完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。

- [AVL树](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)完全符合平衡二叉查找树的定义

# 红黑树

红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树

红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：

- 根节点是黑色的；
- 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；(为了简化红黑树的代码实现而设置的)
- 任何相邻(同一路径)的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

在画图和讲解的时候，将黑色的、空的叶子节点都省略掉了。

![](https://static001.geekbang.org/resource/image/90/9a/903ee0dcb62bce2f5b47819541f9069a.jpg?wh=1142*473)

红黑树的高度近似 2logN。

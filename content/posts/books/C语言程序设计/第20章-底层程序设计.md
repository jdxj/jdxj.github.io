---
title: "第20章 底层程序设计"
date: 2023-07-09T12:25:36+08:00
---

## 20.1 位运算符

### 20.1.1 移位运算符

表20-1 移位运算符

![](https://res.weread.qq.com/wrepub/epub_31359737_754)

运算符<<和运算符>>的操作数可以是任意整数类型（包括char型）。对两个操作数都会进行整数提升，返回值的类型是左操作数提升后的类型。

i << j的值是将i中的位左移j位后的结果。每次从i的最左端溢出一位，在i的最右端补一个0位。i >> j的值是将i中的位右移j位后的结果。如果i是无符号
数或非负值，则需要在i的左端补0。如果i是负值，其结果是由实现定义的：一些实现会在左端补0，其他一些实现会保留符号位而补1。

- 为了可移植性，最好仅对无符号数进行移位运算。

```c
unsigned short i, j;
i = 13;       /* i is now 13 (binary 0000000000001101) */
j = i << 2;   /* j is now 52 (binary 0000000000110100) */
j = i >> 2;   /* j is now  3 (binary 0000000000000011) */

i = 13;       /* i is now 13 (binary 0000000000001101) */
i <<= 2;      /* i is now 52 (binary 0000000000110100) */
i >>= 2;      /* i is now  3 (binary 0000000000000011)
```

### 20.1.2 按位求反运算符、按位与运算符、按位异或运算符和按位或运算符

表20-2 其他位运算符

![](https://res.weread.qq.com/wrepub/epub_31359737_756)

运算符~是一元运算符，对其操作数会进行整数提升。其他运算符都是二元运算符，对其操作数进行常用的算术转换。

```c
unsigned short i, j, k;
i = 21;       /* i is now     21 (binary 0000000000010101) */
j = 56;       /* j is now     56 (binary 0000000000111000) */
k = ~i;       /* k is now  65514 (binary 1111111111101010) */
k = i & j;    /* k is now     16 (binary 0000000000010000) */
k = i ^ j;    /* k is now     45 (binary 0000000000101101) */
k = i | j;    /* k is now     61 (binary 0000000000111101) */
```

优先级从高到低

- `~`
- `&`
- `^`
- `|`

```c
i = 21;      /* i is now 21  (binary 0000000000010101) */
j = 56;      /* j is now 56  (binary 0000000000111000) */
i &= j;      /* i is now 16  (binary 0000000000010000) */
i ^= j;      /* i is now 40  (binary 0000000000101000) */
i |= j;      /* i is now 56  (binary 0000000000111000) */
```

### 20.1.3 用位运算符访问位

位的设置

```c
i = 0x0000;          /* i is now 0000000000000000 */
i |= 0x0010;         /* i is now 0000000000010000 */

i |= 1 << j;         /* sets bit j */
```

位的清除

```c
i = 0x00ff;          /* i is now 0000000011111111 */
i &= ~0x0010;        /* i is now 0000000011101111 */

i &= ~(1 << j);      /* clears bit j */
```

位的测试

```c
if (i & 0x0010) ...              /* tests bit 4 */

if (i & 1 << j) ...              /* tests bit j */
```

为了使对于位的操作更容易，经常会给它们起名字。

```c
#define BLUE   1
#define GREEN  2
#define RED    4
```

设置、清除或测试BLUE位可以如下进行

```c
i |= BLUE;          /* sets BLUE bit   */
i &= ~BLUE;         /* clears BLUE bit */
if (i & BLUE)...    /* tests BLUE bit  */
```

同时设置、清除或测试几个位也一样简单

```c
i |= BLUE | GREEN;               /* sets BLUE and GREEN bits   */
i &= ~(BLUE | GREEN);            /* clears BLUE and GREEN bits */
if (i & (BLUE | GREEN))...       /* tests BLUE and GREEN bits  */
```

### 20.1.4 用位运算符访问位域

处理一组连续的位（位域）比处理单个位要复杂一点。下面是两种最常见的位域操作的例子。

修改位域

```c
i = i & ~0x0070 | 0x0050;       /* stores 101 in bits 4-6 */
i = i & ~0x0070 | j << 4;
```

获取位域

```c
j = i & 0x0007;          /* retrieves bits 0-2 */
j = (i >> 4) & 0x0007;   /* retrieves bits 4-6 */
```

## 20.2 结构中的位域

DOS只为日期分配了16位，其中5位用于日，4位用于月，7位用于年

![](https://res.weread.qq.com/wrepub/epub_31359737_763)

利用位域，我们可以定义相同形式的C结构

- 每个成员后面的数指定了它所占用位的长度。

```c
struct file_date {
  unsigned int day: 5;
  unsigned int month: 4;
  unsigned int year: 7;
};

struct file_date {
  unsigned int day: 5, month: 4, year: 7;
};
```

位域的类型必须是int、unsigned int或signed int。

- 使用int会引起二义性，因为一些编译器将位域的最高位作为符号位，而其他一些编译器则不会。
- 可移植性技巧: 将所有的位域声明为unsigned int或signed int。

在C99中，位域也可以具有类型_Bool。C99编译器还允许额外的位域类型

我们可以将位域像结构的其他成员一样使用

```c
struct file_date fd;
fd.day = 28;
fd.month = 12;
fd.year = 8;     /* represents 1988 */
```

C语言不允许将&运算符用于位域。

```c
scanf("%d", &fd.day);    /*** WRONG ***/
```

### 位域是如何存储的

与编译器有关

C语言允许省略位域的名字。未命名的位域经常用来作为字段间的“填充”，以保证其他位域存储在适当的位置。

```c
struct file_time {
  unsigned int : 5;                   /* not used */
  unsigned int minutes: 6;
  unsigned int hours: 5;
};
```

长度为0的位域是给编译器的一个信号，告诉编译器将下一个位域在一个存储单元的起始位置对齐。假设存储单元是8位长的，编译器会给成员a分配4位，接着跳
过余下的4位到下一个存储单元，然后给成员b分配8位。如果存储单元是16位，编译器会给a分配4位，接着跳过12位，然后给成员b分配8位。

```c
struct s {
  unsigned int a: 4;
  unsigned int : 0;              /* 0-length bit-field */
  unsigned int b: 8;
};
```

## 20.3 其他底层技术

### 20.3.1 定义依赖机器的类型

```c
typedef unsigned char BYTE;
typedef unsigned short WORD;
```

### 20.3.2 用联合提供数据的多个视角

```c
union int_date {
  unsigned short i;
  struct file_date fd;
};

void print_date(unsigned short n)
{
  union int_date u;
  u.i = n;
  printf("%d/%d/%d\n", u.fd.month, u.fd.day, u.fd.year + 1980);
}
```

寄存器

- 注意字节序

```c
union {
  struct {
    WORD ax, bx, cx,dx;
  } word;
  struct {
    BYTE al, ah, bl, bh, cl, ch, dl, dh;
  } byte;
} regs;

regs.byte.ah = 0x12;
regs.byte.al = 0x34;
printf("AX: %hx\n", regs.word.ax);
```

### 20.3.3 将指针作为地址使用

```c
BYTE *p;
p = (BYTE *) 0x1000;           /* p contains address 0x1000 */
```

```c
/* Allows the user to view regions of computer memory */
#include <ctype.h>
#include <stdio.h>
typedef unsigned char BYTE;
int main(void)
{
  unsigned int addr;
  int i, n;
  BYTE *ptr;
  printf("Address of main function: %x\n", (unsigned int) main);
  printf("Address of addr variable: %x\n", (unsigned int) &addr);
  printf("\nEnter a (hex) address: ");
  scanf("%x", &addr);
  printf("Enter number of bytes to view: ");
  scanf("%d", &n);
  printf("\n");
  printf(" Address              Bytes        Characters\n");
  printf(" -------  -----------------------  ----------\n");
  ptr = (BYTE *) addr;
  for (; n > 0; n -= 10) {
    printf("%8X  ", (unsigned int) ptr);
    for (i = 0; i < 10 && i < n; i++)
      printf("%.2X ", *(ptr + i));
    for (; i < 10; i++)
      printf("   ");
    printf("  ");
    for (i = 0; i < 10 && i < n; i++){
      BYTE ch = *(ptr + i);
      if (!isprint(ch))
        ch = '.';
      printf("%c", ch);
    }
    printf("\n");
    ptr += 10;
  }
  return 0;
}
```

### 20.3.4 volatile类型限定符

在一些计算机中，一部分内存空间是“易变”的，保存在这种内存空间的值可能会在程序运行期间发生改变，即使程序自身并未试图存放新值。例如，一些内存空
间可能被用于保存直接来自输入设备的数据。

volatile类型限定符使我们可以通知编译器，程序中的某些数据是“易变”的。volatile限定符通常使用在用于指向易变内存空间的指针的声明中：

```c
volatile BYTE *p;      /* p will point to a volatile byte */
```

我们可能使用下面的循环获取键盘输入的字符，并将它们存入一个缓冲区数组中：

```c
while (缓冲区未满) {
  等待输入;
  buffer[i] = *p;
  if (buffer[i++] == '\n')
    break;
}
```

比较好的编译器可能会注意到这个循环既没有改变p，也没有改变`*p`，因此编译器可能会对程序进行优化，使`*p`只被取一次

```c
在寄存器中存储*p;
while (缓冲区未满) {
  等待输入;
  buffer[i] = 存储在寄存器中的值;
  if (buffer[i++] == '\n')
    break;
}
```

优化后的程序会不断复制同一个字符来填满缓冲区，这并不是我们想要的程序。将p声明成指向易变的数据的指针可以避免这一问题的发生，因为volatile限定
符会通知编译器*p每一次都必须从内存中重新取。

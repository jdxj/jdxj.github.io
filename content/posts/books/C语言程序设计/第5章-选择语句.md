---
title: "第5章 选择语句"
date: 2023-07-01T12:01:33+08:00
---

## 5.1 逻辑表达式

在C语言中，诸如i < j这样的比较运算会产生整数：0（假）或1（真）。

### 5.1.1 关系运算符

关系运算符可以用于比较整数和浮点数，也允许比较混合类型的操作数。

表5-1 关系运算符

![](https://res.weread.qq.com/wrepub/epub_31359737_166)

表达式i < j < k在C语言中是合法的, 左结合

```c
// 表达式首先检测i是否小于j，然后用比较后产生的结果（1或0）来和k进行比较。
(i < j) < k
```

### 5.1.2 判等运算符

表5-2 判等运算符

![](https://res.weread.qq.com/wrepub/epub_31359737_168)

判等运算符也是左结合的，也是产生0（假）或1（真）作为结果。然而，判等运算符的优先级低于关系运算符。

### 5.1.3 逻辑运算符

表5-3 逻辑运算符

![](https://res.weread.qq.com/wrepub/epub_31359737_169)

逻辑运算符所产生的结果是0或1。操作数的值经常是0或1，但这不是必需的。逻辑运算符将任何非零值操作数作为真值来处理，同时将任何零值操作数作为假值
来处理。

运算符&&和运算符||都对操作数进行“短路”计算。

## 5.2 if语句

if (表达式) 语句

- 表达式两边的圆括号是必需的

```c
if (line_num == MAX_LINES)
  line_num = 0;
```

### 5.2.1 复合语句

在if语句模板中，语句是一条语句而不是多条语句：

```c
if (表达式) 语句
```

如果想用if语句处理两条或更多条语句，可以引入复合语句

- { 多条语句}
- 无分号

```c
{ line_num = 0; page_num++; }

{
  line_num = 0;
  page_num++;
}

if (line_num == MAX_LINES) {
  line_num = 0;
  page_num++;
}
```

### 5.2.2 else子句

if (表达式) 语句else语句

```c
if (i > j)
  max = i;
else
  max = j;
```

建议在任何时候都使用花括号

```c
if (i > j) {
  if (i > k){
    max = i;
  } else  {
    max = k;
  }
} else {
  if (j > k) {
    max = j;
  } else  {
    max = k;
  }
}
```

### 5.2.3 级联式if语句

```c
if (表达式)
  语句
else if (表达式)
  语句
...
else if (表达式)
  语句
else
  语句
```

级联式if语句不是新的语句类型，它仅仅是普通的if语句，只是碰巧有另外一条if语句作为else子句（而且这条if语句又有另外一条if语句作为它自己的else
子句，依次类推）。

### 5.2.4 “悬空else”的问题

```c
if (y != 0)
  if (x != 0)
    result = x / y;
else // 匹配最近的if
  printf("Error: y is equal to 0\n");
```

### 5.2.5 条件表达式

表达式1 ? 表达式2 : 表达式3

```c
int i, j, k;
i = 1;
j = 2;
k = i > j ? i : j;             /* k is now 2 */
k = (i >= 0 ? i : 0) + j;      /* k is now 3 */
```

### 5.2.6 C89中的布尔值

C89标准中没有定义布尔类型, C89的程序员通常使用TRUE和FALSE这样的名字定义宏：

```c
#define BOOL int
#define TRUE 1
#define FALSE 0

BOOL flag;
```

### 5.2.7 C99中的布尔值

C99提供了_Bool型

- _Bool是无符号整型
- 只能赋值0或1, 往_Bool变量中存储非零值会导致变量赋值为1
- 算术运算是合法的（不过不建议这样做）

```c
_Bool flag;
```

- C99还提供了一个新的头<stdbool.h>，这使得操作布尔值更加容易

```c
#include <stdbool.h>

bool flag;  /* same as _Bool flag; */

flag = false;
...
flag = true;
```

## 5.3 switch语句

```c
switch (表达式) {
      case 常量表达式 : 语句
      ...
      case 常量表达式 : 语句
      default : 语句
    }
```

- 控制表达式。switch后边必须跟着由圆括号括起来的整型表达式。C语言把字符当成整数来处理，因此在switch语句中可以对字符进行判定。
- 分支标号。每个分支的开头都有一个标号`case 常量表达式:`. 分支标号中的常量表达式的值必须是整数（字符也可以）
- 语句。每个分支标号的后边可以跟**任意数量**的语句。每组语句的最后一条通常是break语句
- C语言不允许有重复的分支标号，但对分支的顺序没有要求，特别是default分支不一定要放置在最后。
- case后边只可以跟随一个常量表达式。但是，多个分支标号可以放置在同一组语句的前面

```c
switch  (grade)  {
  case 4:
  case 3:
  case 2:
  case 1:   printf("Passing");
            break;
  case 0:   printf("Failing");
            break;
  default:  printf("Illegal grade");
            break;
}
```

switch语句不要求一定有default分支。如果default不存在，而且控制表达式的值和任何一个分支标号都不匹配的话，控制会直接传给switch语句后面的语
句。

### break语句的作用

需要break语句是由于switch语句实际上是一种“基于计算的跳转”。

- 对控制表达式求值时，控制会跳转到与switch表达式的值相匹配的分支标号处。
- 分支标号只是一个说明switch内部位置的标记。在执行完分支中的最后一条语句后，程序控制“向下跳转”到下一个分支的第一条语句上，而忽略下一个分支
  的分支标号。
- 如果没有break语句（或者其他某种跳转语句），控制将会从一个分支继续到下一个分支。

故意从一个分支跳转到下一个分支的情况是非常少见的，如果没有注释，将来某人可能会通过增加多余的break语句来修正“错误”。

**虽然switch语句中的最后一个分支不需要break语句，但通常还是会放一个break语句在那里**，以防止将来增加分支数目时出现“丢失break”的问题。

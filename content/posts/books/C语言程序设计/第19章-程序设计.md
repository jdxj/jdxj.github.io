---
title: "第19章 程序设计"
date: 2023-07-09T12:25:22+08:00
---

## 19.1 模块

模块的接口就是头文件，头文件中包含那些可以被程序中其他文件调用的函数的原型。模块的实现就是包含该模块中函数的定义的源文件。

将程序分割成模块有一系列好处

- 抽象
- 可复用性
- 可维护性

![](https://res.weread.qq.com/wrepub/epub_31359737_748)

### 19.1.1 内聚性与耦合性

在设计良好的程序中，模块应该具有下面两个性质

- 高内聚性
- 低耦合性

### 19.1.2 模块的类型

- 数据池。数据池是一些相关的变量或常量的集合。在C语言中，这类模块通常只是一个头文件。从程序设计的角度说，通常不建议将变量放在头文件中，但建
  议把相关常量放在头文件中。在C库中，<float.h>头和<limits.h>头都属于数据池。
- 库。库是一个相关函数的集合。例如<string.h>头就是字符串处理函数库的接口。
- 抽象对象。抽象对象是指对于隐藏的数据结构进行操作的函数的集合。
- 抽象数据类型（ADT）。将具体数据实现方式隐藏起来的数据类型称为抽象数据类型。客户模块可以使用该类型来声明变量，但不会知道这些变量的具体数据
  结构。如果客户模块需要对这种变量进行操作，则必须调用抽象数据类型模块所提供的函数。

## 19.2 信息隐藏

息隐藏有以下两大优点

- 安全性
- 灵活性

在C语言中，强制信息隐藏的主要工具是static存储类型

## 19.3 抽象数据类型

### 19.3.1 封装

C语言对于封装类型的支持很有限。

### 19.3.2 不完整类型

C语言提供的唯一封装工具为不完整类型

- 不完整类型将会在程序的其他地方将信息补充完整。

```c
struct t;      /* incomplete declaration of t */
```

不完整类型的使用是受限的。因为编译器不知道不完整类型的大小，所以不能用它来声明变量：

```c
struct t s;    /*** WRONG ***/
```

可以定义一个指针类型引用不完整类型

- 不能对这些变量使用->运算符，因为编译器对t结构的成员一无所知

```c
typedef struct t *T;
```

## 19.4 栈抽象数据类型

### 19.4.1 为栈抽象数据类型定义接口

stackADT.h (version 1)

```c
#ifndef STACKADT_H
#define STACKADT_H
#include <stdbool.h>     /* C99 only */
typedef struct stack_type *Stack;
Stack create(void);
void destroy(Stack s);
void make_empty(Stack s);
bool is_empty(Stack s);
bool is_full(Stack s);
void push(Stack s, int i);
int pop(Stack s);
#endif
```

stackclient.c

```c
#include <stdio.h>
#include "stackADT.h"
int main(void)
{
  Stack s1, s2;
  int n;
  s1 = create();
  s2 = create();
  push(s1, 1);
  push(s1, 2);
  n = pop(s1);
  printf("Popped %d from s1\n", n);
  push(s2, n);
  n = pop(s1);
  printf("Popped %d from s1\n",n);
  push(s2, n);
  destroy(s1);
  while (!is_empty(s2))
    printf("Popped %d from s2\n", pop(s2));
  push(s2,3);
  make_empty(s2);
  if (is_empty(s2))
    printf("s2 is empty\n");
  else
    printf("s2 is not empty\n");
  destroy(s2);
  return 0;
}
```

### 19.4.2 用定长数组实现栈抽象数据类型

stackADT.c

```c
#include <stdio.h>
#include <stdlib.h>
#include "stackADT.h"
#define STACK_SIZE 100
struct stack_type {
  int contents[STACK_SIZE];
  int top;
};
static void terminate (const char *message)
{
  printf("%s\n", message);
  exit(EXIT_FAILURE);
}
Stack create(void)
{
  Stack s = malloc(sizeof(struct stack_type));
  if (s == NULL)
    terminate("Error in create: stack could not be created.");
  s->top = 0;
  return s;
}
void destroy(Stack s)
{
  free(s);
}
void make_empty(Stack s)
{
  s->top = 0;
}
bool is_empty(Stack s)
{
  return s->top == 0;
}
bool is_full(Stack s)
{
  return s->top == STACK_SIZE;
}
void push(Stack s, int i)
{
  if (is_full(s))
    terminate("Error in push: stack is full.");
  s->contents[s->top++] = i;
}
int pop(Stack s)
{
  if (is_empty(s))
    terminate("Error in pop: stack is empty.");
  return s->contents[--s->top];
}
```

### 19.4.3 改变栈抽象数据类型中数据项的类型

stackADT.h(version 2)

```c
#ifndef STACKADT_H
#define STACKADT_H
#include     /* C99 only */
typedef int Item;
typedef struct stack_type *Stack;
Stack create(void);
void destroy(Stack s);
void make_empty(Stack s);
bool is_empty(Stack s);
bool is_full(Stack s);
void push(Stack s, Item i);
Item pop (Stack s);
#endif
```

stackADT.c

```c
struct stack_type {
  Item contents[STACK_SIZE];
  int top;
};
```

push和pop的函数体部分没有改变，相应的改变仅仅是把push的第二个参数和pop的返回值改成了Item类型。

可以通过修改stackADT.h中Item类型的定义来任意修改数据项类型了。

- 仍然需要对它进行重新编译

### 19.4.4 用动态数组实现栈抽象数据类型

```c
struct stack_type {
  Item *contents;
  int top;
  int size;
};

Stack create(int size);
```

stackADT2.c

```c
#include 
#include 
#include "stackADT2.h"
struct stack_type {
  Item *contents;
  int top;
  int size;
};
static void terminate (const char *message)
{
  printf("%s\n", message);
  exit(EXIT_FAILURE);
}
Stack create(int size)
{
  Stack s = malloc(sizeof(struct stack_type));
  if (s == NULL)
    terminate("Error in create: stack could not be created.");
  s->contents = malloc(size * sizeof(Item));
  if (s->contents == NULL) {
    free(s);
    terminate("Error in create: stack could not be created.");
  }
  s->top = 0;
  s->size = size; 
  return s;
}
void destroy(Stack s)
{
  free(s->contents);
  free(s);
}
void make_empty(Stack s)
{
  s->top = 0;
}
bool is_empty(Stack s)
{
  return s->top == 0;
}
bool is_full (Stack s)
{
  return s->top == s->size;
}
void push(Stack s, Item i)
{
  if (is_full(s))
    terminate("Error in push: stack is full.");
  s->contents[s->top++] = i;
}
Item pop(Stack s)
{
  if (is_empty(s))
    terminate("Error in pop: stack is empty.");
  return s->contents[--s->top];
}
```

### 19.4.5 用链表实现栈抽象数据类型

```c
struct node {
  Item data;
  struct node *next;
};

struct stack_type {
  struct node *top;
};
```

stackADT3.c

```c
#include <stdio.h>
#include <stdlib.h>
#include "stackADT.h"
struct node {
  Item data;
  struct node *next;
};
struct stack_type {
  struct node *top;
};
static void terminate(const char *message)
{
  printf("%s\n", message);
  exit(EXIT_FAILURE);
}
Stack create(void)
{
  Stack s = malloc(sizeof(struct stack_type));
  if (s == NULL)
    terminate("Error in create: stack could not be created.");
  s->top = NULL;
  return s;
}
void destroy(Stack s)
{
  make_empty(s);
  free(s);
}
void make_empty(Stack s)
{
  while (!is_empty(s))
    pop(s);
}
bool is_empty(Stack s)
{
  return s->top == NULL;
}
bool is_full(Stack s)
{
  return false;
}
void push(Stack s, Item i)
{
  struct node *new_node = malloc(sizeof(struct node));
  if (new_node == NULL)
    terminate("Error in push: stack is full.");
  new_node->data = i;
  new_node->next = s->top;
  s->top = new_node;
}
Item pop(Stack s)
{
  struct node *old_top;
  Item i;
  if (is_empty(s))
    terminate("Error in pop: stack is empty.");
  old_top = s->top;
  i = old_top->data;
  s->top = old_top->next;
  free(old_top);
  return i;
}
```

## 19.5 抽象数据类型的设计问题

这里的抽象数据类型存在一些问题，使其达不到工业级强度。

### 19.5.1 命名惯例

目前的栈抽象数据类型函数都采用简短、便于记忆的名字：create、destroy、make_empty、is_empty、is_full、push和pop。如果在一个程序中有多个
抽象数据类型，两个模块中很可能具有同名函数，这样就出现了名字冲突。

### 19.5.2 错误处理

程序员可以通过在每次调用pop之前调用is_empty，在每次调用push之前调用is_full，来避免从空栈中弹出数据项或者向满栈里压入数据项。所以从理论上
来讲，对pop和push的调用没有理由会出错。（但在链表实现中，调用is_full并没有效果，后续调用push仍然可能出错。）

一个可选的方案是让push和pop函数返回一个bool值说明函数调用是否成功。

- 让pop返回一个指向弹出的值的指针而不是返回该值本身，那就可以让pop返回NULL来表示此时栈为空

C标准库里包含带参数的assert宏，可以在指定的条件不满足时终止程序。

### 19.5.3 通用抽象数据类型

最常见的一种方法是使用void *作为数据项类型

```c
void push(Stack s, void *p);
void *pop(Stack s);
```

使用void *作为数据项类型有两个缺点。

- 第一，这种方法不适用于无法用指针形式表示的数据。数据项可以是字符串（用指向字符串第一个字符的指针表示）或动态分配的结构，但不能是int、
  double之类的基本类型。
- 第二，不能进行错误检测。存放void *数据项的栈允许各种类型的指针共存，所以无法检测出由压入错误的指针类型导致的错误。

> int, float不能用指针表示?

### 19.5.4 新语言中的抽象数据类型

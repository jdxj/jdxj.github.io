---
title: "第9章 函数"
date: 2023-07-04T14:14:09+08:00
---

## 9.1 函数的定义和调用

```c
double average(double a, double b)
{
  return (a + b) / 2;
}
```

void是一种没有值的类型

```c
void print_count(int n)
{
  printf("T minus %d and counting\n", n);
}
```

无参函数

```c
void print_pun(void)
{
  printf("To C, or not to C: that is the question.\n");
}
```

### 9.1.1 函数定义

```c
返回类型 函数名 (形式参数)
{
    声明
    语句
}
```

- **函数不能返回数组**，但关于返回类型没有其他限制。
- 指定返回类型是void类型说明函数没有返回值。
- 如果省略返回类型，C89会假定函数返回值的类型是int类型，但在C99中这是不合法的。
- C89中，变量声明必须出现在语句之前。在C99中，变量声明和语句可以混在一起，只要变量在第一次使用之前进行声明就行。

对于返回类型为void的函数，其函数体可以为空

```c
void print_pun(void)
{
}
```

### 9.1.2 函数调用

```c
avg = average(x, y);
if (average(x, y) > 0)
  printf("Average is positive\n");
printf("The average is %g\n", average(x, y));
```

为了清楚地表明函数返回值是被故意丢掉的，C语言允许在函数调用前加上(void)

```c
(void) printf ("Hi, Mom!\n");
```

## 9.2 函数声明

函数声明（function declaration）使得编译器可以先对函数进行概要浏览，而函数的完整定义以后再给出。

C99遵循这样的规则：在调用一个函数之前，必须先对其进行声明或定义。调用函数时，如果此前编译器未见到该函数的声明或定义，会导致出错。

```c
#include <stdio.h>
double average(double a, double b);     /* DECLARATION */
int main(void)
{
  double x,  y,  z;
  printf("Enter three numbers:  ");
  scanf("%lf%lf%lf",  &x,  &y,  &z);
  printf("Average of %g and %g: %g\n", x, y, average(x, y));
  printf("Average of %g and %g: %g\n", y, z, average(y, z));
  printf("Average of %g and %g: %g\n", x, z, average(x, z));
  return 0;
}

double average(double a, double b)   /* DEFINITION */
{
  return  (a + b)  / 2;
}
```

函数原型不需要说明函数形式参数的名字，只要显示它们的类型就可以了：

```c
double average(double, double);
```

## 9.3 实际参数 {#actual-param}

在C语言中，实际参数是通过值传递的

### 9.3.1 实际参数的转换

C语言允许在实际参数的类型与形式参数的类型不匹配的情况下进行函数调用。管理如何转换实际参数的规则与编译器是否在调用前遇到函数的原型（或者函数的
完整定义）有关。

- 编译器在调用前遇到原型。就像使用赋值一样，每个实际参数的值被隐式地转换成相应形式参数的类型。
- 编译器在调用前没有遇到原型。编译器执行默认的实际参数提升：
  - （1）把float类型的实际参数转换成double类型
  - （2）执行整值提升，即把char类型和short类型的实际参数转换成int类型

### 9.3.2 数组型实际参数

当形式参数是一维数组时，可以（而且是通常情况下）不说明数组的长度：

```c
int f(int a[])     /* no length specified */
{
  ...
}
```

C语言没有为函数提供任何简便的方法来确定传递给它的数组的长度；如果函数需要，我们必须把长度作为额外的参数提供出来。

虽然可以用运算符sizeof计算出数组变量的长度，但是它无法给出关于数组型形式参数的正确答案：

```c
int f(int a[])
{
  int len = sizeof(a) / sizeof(a[0]);
    /*** WRONG: not the number of elements in a ***/
  ...
}
```

函数可以改变数组型形式参数的元素，且改变会在相应的实际参数中体现出来。

如果形式参数是多维数组，声明参数时只能省略第一维的长度。

```c
#define LEN 10
int sum_two_dimensional_array(int a[][LEN], int n)
{
  int i, j, sum = 0;
  for (i = 0; i < n; i++)
    for (j = 0; j < LEN; j++)
      sum += a[i][j];
  return sum;
}
```

### 9.3.3 变长数组形式参数

C99增加了几个与数组型参数相关的特性。第一个是变长数组，这一特性允许我们用非常量表达式指定数组的长度。变长数组也可以作为参数。

```c
// 注意声明顺序
int sum_array(int n, int a[n])
{
  ...
}
```

函数原型有好几种写法

```c
int sum_array(int n, int a[n]);      /* Version 1 */
int sum_array(int n, int a[*]);      /* Version 2a */
int sum_array(int, int [*]);        /* Version 2b */
int sum_array(int n, int a[]);      /* Version 3a */
int sum_array(int, int []);         /* Version 3b */
```

变长数组形式参数的长度可以是任意表达式, 该表达式可以使用函数外部的变量，甚至可以调用其他函数

```c
int concatenate(int m, int n, int a[m], int b[n], int c[m+n])
{
   ...
}
```

使用变长数组形式参数，则可以推广到任意列数的情况：

```c
int sum_two_dimensional_array(int n, int m, int a[n][m])
{
  int i, j, sum = 0;
  for (i = 0; i < n; i++)
    for (j = 0; j < m; j++)
      sum += a[i][j];
  return sum;
}
```

这个函数的原型可以是以下几种：

```c
int sum_two_dimensional_array(int n, int m, int a[n][m]);
int sum_two_dimensional_array(int n, int m, int a[*][*]);
int sum_two_dimensional_array(int n, int m, int a[][m]);
int sum_two_dimensional_array(int n, int m, int a[][*]);
```

### 9.3.4 在数组参数声明中使用static

C99允许在数组参数声明中使用关键字static

将static放在数字3之前表明数组a的长度至少可以保证是3：

```c
int sum_array(int a[static 3], int n)
{
  ...
}
```

- 这样使用static不会对程序的行为有任何影响。static的存在只不过是一个“提示”，C编译器可以据此生成更快的指令来访问数组。
- 如果数组参数是多维的，static仅可用于第一维

### 9.3.5 复合字面量(c99)

复合字面量是通过指定其包含的元素而创建的没有名字的数组。

```c
// (int[4]){1, 9, 2, 1} 也可以
total = sum_array((int []){3, 0, 3, 4, 1},5);
// 可以使用指示符
(int[10]){8, 6}
// 函数内部创建的复合字面量可以包含任意的表达式，不限于常量
total = sum_array((int []){2 * i, i + j, j * k}, 3);
```

复合字面量为左值，所以其元素的值可以改变。如果要求其值为“只读”，可以在类型前加上const，如(const int []){5, 4}。

## 9.4 return语句

非void的函数必须使用return语句来指定将要返回的值。

return 表达式;

如果return语句中表达式的类型和函数的返回类型不匹配，那么系统将会把表达式的类型隐式转换成返回类型。

如果没有给出表达式，return语句可以出现在返回类型为void的函数中：

```c
return;  /* return in a void function */
```

如果非void函数到达了函数体的末尾（也就是说没有执行return语句），那么如果程序试图使用函数的返回值，其行为是未定义的。

## 9.5 程序终止

正常情况下，main函数的返回类型是int类型

```c
int main(void)
{
  ...
}
```

- 以往的C程序常常省略main的返回类型，这其实是利用了返回类型默认为int类型的传统
- 省略函数的返回类型在C99中是不合法的, 省略main函数参数列表中的void是合法的
- main函数返回的值是状态码，在某些操作系统中程序终止时可以检测到状态码。

### exit函数

此函数属于<stdlib.h>头。传递给exit函数的实际参数和main函数的返回值具有相同的含义

return语句和exit函数之间的差异是：不管哪个函数调用exit函数都会导致程序终止，return语句仅当由main函数调用时才会导致程序终止。一些程序员只
使用exit函数，以便更容易定位程序中的全部退出点。

## 9.6 递归

```c
int fact(int n)
{
  if (n <= 1)
    return 1;
  else
    return n * fact(n-1);
}
```

### 快速排序算法

```c
/* Sorts an array of integers using Quicksort algorithm */
#include <stdio.h>
#define N 10
void quicksort(int a[], int low, int high);
int split(int a[], int low, int high);
int main(void)
{
  int a[N], i;
  printf("Enter %d numbers to be sorted: ", N);
  for (i = 0; i < N; i++)
    scanf("%d", &a[i]);
  quicksort(a, 0, N - 1);
  printf("In sorted order: ");
  for (i = 0; i < N; i++)
    printf("%d ", a[i]);
  printf("\n");
  return 0;
}
void quicksort(int a[], int low, int high)
{
  int middle;
  if (low >= high) return;
  middle = split(a, low, high);
  quicksort(a, low, middle - 1);
  quicksort(a, middle + 1, high);
}
int split(int a[], int low, int high)
{
  int part_element = a[low];
  for (;;) {
    while (low < high && part_element <= a[high])
      high--;
    if (low >= high) break;
    a[low++] = a[high];
    while (low < high && a[low] <= part_element)
      low++;
    if (low >= high) break;
    a[high--] = a[low];
  }
  a[high] = part_element;
  return high;
}
```

---
title: "第14章 预处理器"
date: 2023-07-06T12:39:47+08:00
---

## 14.1 预处理器的工作原理

#define指令定义了一个宏——用来代表其他东西的一个名字. 当这个宏在后面的程序中使用到时，预处理器“扩展”宏，将宏替换为其定义值。

#include指令告诉预处理器打开一个特定的文件，将它的内容作为正在编译的文件的一部分“包含”进来。

预处理器的输入是一个C语言程序，程序可能包含指令。预处理器会执行这些指令，并在处理过程中删除这些指令。预处理器的输出是另一个C程序：原程序编辑
后的版本，不再包含指令。预处理器的输出被直接交给编译器，编译器检查程序是否有错误，并将程序翻译为目标代码（机器指令）。

预处理器不仅仅是执行了指令，还做了一些其他的事情。特别值得注意的是，它将每一处注释都替换为一个空格字符。有一些预处理器还会进一步删除不必要的
空白字符，包括每一行开始用于缩进的空格符和制表符。

预处理器仅知道少量C语言的规则。因此，它在执行指令时非常有可能产生非法的程序。经常是原始程序看起来没问题，使错误查找起来很难。对于较复杂的程序，
检查预处理器的输出可能是找到这类错误的有效途径。

## 14.2 预处理指令

- 宏定义。#define指令定义一个宏，#undef指令删除一个宏定义。
- 文件包含。#include指令导致一个指定文件的内容被包含到程序中。
- 条件编译。#if、#ifdef、#ifndef、#elif、#else和#endif指令可以根据预处理器可以测试的条件来确定是将一段文本块包含到程序中还是将其排除在
  程序之外。
- 剩下的#error、#line和#pragma指令是更特殊的指令，较少用到。


指令总是在第一个换行符处结束，除非明确地指明要延续。

```c
#define DISK_CAPACITY (SIDES *              \
                       TRACKS_PER_SIDE *    \
                       SECTORS_PER_TRACK *  \
                       BYTES_PER_SECTOR)
```

指令可以出现在程序中的任何地方。但我们通常将#define和#include指令放在文件的开始，其他指令则放在后面，甚至可以放在函数定义的中间。

## 14.3 宏定义

### 14.3.1 简单的宏

#define 标识符 替换列表

宏的替换列表可以包括标识符、关键字、数值常量、字符常量、字符串字面量、操作符和排列。

不要在宏定义中放置任何额外的符号，否则它们会被作为替换列表的一部分。

```c
#define N = 100   /*** WRONG ***/
...
int a[N];         /* becomes int a[= 100]; */
// 在宏定义的末尾使用分号结尾是另一个常见错误
#define N 100;    /*** WRONG ***/
...
int a[N];         /* becomes int a[100;]; */
```

编译器可以检测到宏定义中绝大多数由多余符号所导致的错误。但是，编译器只会将每一个使用这个宏的地方标为错误，而不会直接找到错误的根源——宏定义本
身，因为**宏定义已经被预处理器删除了**。

可以使用宏给数值、字符值和字符串值命名

```c
#define STE_LEN 80
#define TRUE    1
#define FALSE   0
#define PI      3.14159
#define CR      '\r'
#define EOS     '\0'
#define MEM_ERR "Error: not enough memory"
```

### 14.3.2 带参数的宏

#define 标识符(x1, x2,..., xn)替换列表

其中x...是标识符（宏的参数）。这些参数可以在替换列表中根据需要出现任意次。

- 在宏的名字和左括号之间必须没有空格。如果有空格，预处理器会认为是在定义一个简单的宏，其中x...是替换列表的一部分。

```c
#define MAX(x,y)    ((x)>(y)?(x):(y))
#define IS_EVEN(n)  ((n)%2==0)

i = MAX(j+k, m-n);
if (IS_EVEN(i)) i++;
```

带参数的宏可以包含空的参数列表

```c
#define getchar()  getc(stdin)
```

缺点

- 宏参数没有类型检查
- 无法用一个指针来指向一个宏
- 宏可能会不止一次地计算它的参数

```c
n = MAX(i++, j);
n = ((i++)>(j)?(i++):(j));
```

### 14.3.3 #运算符

#运算符将宏的一个参数转换为字符串字面量。它仅允许出现在带参数的宏的替换列表中。

```c
#define PRINT_INT(n) printf(#n " = %d\n", n)

PRINT_INT(i/j);
// 变为
printf("i/j" " = %d\n", i/j);
// 等价于
printf("i/j = %d\n", i/j);
```

### 14.3.4 ##运算符

##运算符可以将两个记号（如标识符）“粘合”在一起，成为一个记号。

```c
#define MK_ID(n) i##n

int MK_ID(1), MK_ID(2), MK_ID(3);
// 变为
int i1, i2, i3;
```

用C实现泛型

```c
#define GENERIC_MAX(type)         \
type type##_max(type x, type y)   \
{                                 \
  return x > y ? x : y;           \
}

GENERIC_MAX(float)
// 变为
float float_max(float x, float y) { return x > y ? x : y; }
```

### 14.3.5 宏的通用属性

- 宏的替换列表可以包含对其他宏的调用

```c
#define PI      3.14159
#define TWO_PI  (2*PI)
```

- 宏定义的作用范围通常到出现这个宏的文件末尾
- 宏不可以被定义两遍，除非新的定义与旧的定义是一样的
- 宏可以使用#undef指令“取消定义”. 如果N没有被定义成一个宏，#undef指令没有任何作用。

```c
#undef N
```

### 14.3.6 宏定义中的圆括号

如果我们少用几个圆括号，宏有时可能会得到意想不到的

- 如果宏的替换列表中有运算符，那么始终要将替换列表放在括号中

```c
#define TWO_PI (2*3.14159)
```

- 如果宏有参数，每个参数每次在替换列表中出现时都要放在圆括号中

```c
#define SCALE(x)  ((x)*10)
```

### 14.3.7 创建较长的宏

在创建较长的宏时，逗号运算符会十分有用

```c
// 先gets, 再puts
#define ECHO(s) (gets(s), puts(s))

ECHO(str);   /* 替换为 (gets(str), puts(str)); */
```

定义复合语句：

```c
#define ECHO(s)      \
        do {         \
          gets(s);   \
          puts(s);   \
        } while (0)

ECHO(str);
  /* becomes do { gets(str); puts(str); } while (0);  */
```

### 14.3.8 预定义宏

表14-1 预定义宏

![](https://res.weread.qq.com/wrepub/epub_31359737_596)

### 14.3.9 C99中新增的预定义宏

表14-2 C99中新增的预定义宏

![](https://res.weread.qq.com/wrepub/epub_31359737_597)

### 14.3.10 空的宏参数

C99允许宏调用中的任意或所有参数为空。当然这样的调用需要有和一般调用一样多的逗号

```c
#define ADD(x,y) (x+y)

i = ADD(j,k);
// 变为
i = (j+k);

i = ADD(,k);
// 变为
i = (+k);
```

当空参数是#或##运算符的操作数时，用法有特殊规定。如果空的实际参数被#运算符“字符串化”，则结果为""（空字符串）

```c
#define MK_STR(x) #x
...
char empty_string[] = MK_STR();
// 变为
char empty_string[] = "";
```

```c
#define JOIN(x,y,z) x##y##z
...
int JOIN(a,b,c), JOIN(a,b,), JOIN(a,,c), JOIN(,,c);
// 变为
int abc, ab, ac, c;
```

### 14.3.11 参数个数可变的宏

在C89中，如果宏有参数，那么参数的个数是固定的。在C99中，这个条件被适当放宽了，允许宏具有可变长度的参数列表

宏具有可变参数个数的主要原因是：它可以将参数传递给具有可变参数个数的函数，如printf和scanf。

```c
#define TEST(condition, ...) ((condition)? \
  printf("Passed test: %s\n", #condition): \
  printf(__VA_ARGS__))

TEST(voltage <= max_voltage,
     "Voltage %d exceeds %d\n", voltage, max_voltage);
// 变为
((voltage <= max_voltage)?
  printf("Passed test: %s\n", "voltage <= max_voltage"):
  printf("Voltage %d exceeds %d\n", voltage, max_voltage));
```

### 14.3.12 __func__标识符

C99的另一个新特性是__func__标识符。__func__与预处理器无关

每一个函数都可以访问__func__标识符，它的行为很像一个存储当前正在执行的函数的名字的字符串变量。

- 其作用相当于在函数体的一开始包含如下声明

```c
static const char __func__[] = "function-name";
```

这个标识符的存在使得我们可以写出如下的调试宏

```c
#define FUNCTION_CALLED() printf("%s called\n", __func__);
#define FUNCTION_RETURNS() printf("%s returns\n", __func__);
```

__func__的另一个用法：作为参数传递给函数，让函数知道调用它的函数的名字。

## 14.4 条件编译

### 14.4.1 #if指令和#endif指令

```c
#define DEBUG 1
#if DEBUG
printf("Value of i: %d\n", i);
printf("Value of j: %d\n", j);
#endif
```

#if指令会把没有定义过的标识符当作是值为0的宏对待

### 14.4.2 defined运算符

defined运算符通常与#if指令结合使用

```c
#if defined(DEBUG)
...
#endif

// 括号不是必须的
#if defined DEBUG

// 由于defined运算符仅检测DEBUG是否有定义，所以不需要给DEBUG赋值
#define DEBUG
```

### 14.4.3 #ifdef指令和#ifndef指令

#ifdef指令测试一个标识符是否已经定义为宏

```c
#ifdef 标识符
当标识符被定义为宏时需要包含的代码
#endif

// 等价于
#if defined(标识符)
```

#ifndef指令测试的是标识符是否没有被定义为宏：

```c
#ifndef 标识符
// 等价于
#if !defined(标识符)
```

### 14.4.4 #elif指令和#else指令

```c
#if 表达式1
当表达式1非0时需要包含的代码
#elif 表达式2
当表达式1为0但表达式2非0时需要包含的代码
#else
其他情况下需要包含的代码
#endif
```

在#if指令和#endif指令之间可以有任意多个#elif指令，但最多只能有一个#else指令。

### 14.4.5 使用条件编译

为宏提供默认定义

```c
#ifndef BUFFER_SIZE
#define BUFFER_SIZE 256
#endif
```

临时屏蔽包含注释的代码

```c
#if 0
包含注释的代码行
#endif
```

## 14.5 其他指令

### 14.5.1 #error指令

#error 消息

如果预处理器遇到#error指令，它会显示一条包含消息的出错消息。对于不同的编译器，出错消息的具体形式也可能会不一样。

```c
#if INT_MAX < 100000
#error int type is too small
#endif
```

### 14.5.2 #line指令

### 14.5.3 #pragma指令

### 14.5.4 _Pragma运算符(c99)

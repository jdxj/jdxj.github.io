---
title: "第10章 程序结构"
date: 2023-07-05T10:41:38+08:00
---

## 10.1 局部变量

把在函数体内声明的变量称为该函数的局部变量。

局部变量具有下列性质

- 自动存储期限
- 块作用域, 从变量声明的点开始一直到所在函数体的末尾

C99不要求在函数一开始就进行变量声明，所以局部变量的作用域可能非常小。

### 10.1.1 静态局部变量

在局部变量声明中放置单词static可以使变量具有静态存储期限而不再是自动存储期限。

```c
void f(void)
{
  static int i;    /* static local variable */
  ...
}
```

静态局部变量始终有块作用域，所以它对其他函数是不可见的。概括来说，静态变量是对其他函数隐藏数据的地方，但是它会为将来同一个函数的再调用保留这
些数据。

### 10.1.2 形式参数

形式参数拥有和局部变量一样的性质，即自动存储期限和块作用域。事实上，形式参数和局部变量唯一真正的区别是，在每次函数调用时对形式参数自动进行初
始化（调用中通过赋值获得相应实际参数的值）。

## 10.2 外部变量

外部变量（有时称为全局变量）的性质不同于局部变量的性质

- 静态存储期限
- 外部变量拥有文件作用域：从变量被声明的点开始一直到所在文件的末尾。

### 10.2.1 示例：用外部变量实现栈

```c
#include <stdbool.h>    /* C99 only */
#define STACK_SIZE 100
/* external variables */
int contents[STACK_SIZE];
int top = 0;
void make_empty(void)
{
  top = 0;
}
bool is_empty(void)
{
  return top == 0;
}
bool is_full(void)
{
  return top == STACK_SIZE;
}
void push(int i)
{
  if (is_full())
    stack_overflow();
  else
    contents[top++]  = i;
}
int pop(void)
{
  if (is_empty())
    stack_underflow();
  else
    return contents [--top];
}
```

### 10.2.2 外部变量的利与弊

弊

- 在程序维护期间，如果改变外部变量（比方说改变它的类型），那么将需要检查同一文件中的每个函数，以确认该变化如何对函数产生影响。
- 如果外部变量被赋了错误的值，可能很难确定出错的函数。
- 很难在其他程序中复用依赖于外部变量的函数。依赖外部变量的函数不是“独立的”。为了在另一个程序中使用该函数，必须带上此函数需要的外部变量。

使用外部变量时，要确保它们都拥有有意义的名字。

## 10.3 程序块

{ 多条声明 多条语句 }

```c
if (i > j) {
  /* swap values of i and j */
  int temp = i;
  i = j;
  j = temp;
}
```

默认情况下，声明在程序块中的变量的存储期限是自动的：进入程序块时为变量分配存储单元，退出程序块时收回分配的空间。变量具有块作用域，也就是说，
不能在程序块外引用。

C99允许在程序块的任何地方声明变量，就像允许在函数体内的任何地方声明变量一样。

## 10.4 作用域

当程序块内的声明命名一个标识符时，如果此标识符已经是可见的（因为此标识符拥有文件作用域，或者因为它已在某个程序块内声明），新的声明临时“隐藏”
了旧的声明，标识符获得了新的含义。在程序块的末尾，标识符重新获得旧的含义。

![](https://res.weread.qq.com/wrepub/epub_31359737_449)

## 10.5 构建C程序

下面是一种可能的编排顺序

1. #include指令；
2. #define指令；
3. 类型定义；
4. 外部变量的声明；
5. **除main函数之外的函数的原型；**
6. main函数的定义；
7. 其他函数的定义。

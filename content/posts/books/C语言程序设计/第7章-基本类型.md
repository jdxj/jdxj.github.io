---
title: "第7章 基本类型"
date: 2023-07-01T16:07:44+08:00
---

## 7.1 整数类型

实际上只有下列6种组合可以产生不同的类型

- 说明符的顺序没什么影响

```c
short int
unsigned short int
int
unsigned int
long int
unsigned long int
```

- C语言允许通过省略单词int来缩写整数类型的名字

6种整数类型的每一种所表示的取值范围都会根据机器的不同而不同，但是有两条所有编译器都必须遵守的原则

- C标准要求short int、int和long int中的每一种类型都要覆盖一个确定的最小取值范围
- 标准要求int类型不能比short int类型短，long int类型不能比int类型短。但是，short int类型的取值范围有可能和int类型的范围是一样的，int类
  型的取值范围也可以和long int的一样。

表7-1 16位机的整数类型

![](https://res.weread.qq.com/wrepub/epub_31359737_226)

表7-2 32位机的整数类型

![](https://res.weread.qq.com/wrepub/epub_31359737_227)

表7-3 64位机的整数类型

![](https://res.weread.qq.com/wrepub/epub_31359737_228)

表7-1、表7-2和表7-3中给出的取值范围不是C标准强制的，会随着编译器的不同而不同。对于特定的实现，确定整数类型范围的一种方法是检查<limits.h>
头。该头是标准库的一部分，其中定义了表示每种整数类型的最大值和最小值的宏。

### 7.1.1 C99中的整数类型

C99提供了两个额外的标准整数类型：long long int和unsigned long long int。

- 这两个long long类型要求至少64位宽

C99标准还允许在具体实现时定义扩展的整数类型（包括有符号的和无符号的）。例如，编译器可以提供有符号和无符号的128位整数类型。

### 7.1.2 整数常量

在程序中以文本形式出现的数，而不是读、写或计算出来的数。

为了强制编译器把常量作为长整数来处理，只需在后边加上一个字母L（或l）

```c
15L  0377L  0x7fffL
```

为了指明是无符号常量，可以在常量后边加上字母U（或u）

```c
15U  0377U  0x7fffU
```

L和U可以结合使用，以表明常量既是长整型又是无符号的：0xffffffffUL

- 字母L、U的顺序和大小写无所谓。

### 7.1.3 C99中的整数常量

在C99中，以LL或ll（两个字母大小写要一致）结尾的整数常量是long long int型的。如果在LL或ll的前面或后面增加字母U（或u），则该整数常量为
unsigned long long int型。

C99确定整数常量类型的规则与C89有些不同。对于没有后辍（U、u、L、l、LL、ll）的十进制常量，其类型是int、long int或long long int中能表示该
值的“最小”类型。对于八进制或者十六进制常量，可能的类型顺序为int、unsigned int、long int、unsigned long int、long long int和
unsigned long long int。常量后面的任何后辍都会改变可能类型的列表。例如，以U（或u）结尾的常量类型一定是unsigned int、
unsigned long int和unsigned long long int中的一种，以L（或l）结尾的十进制常量类型一定是long int或long long int中的一种。如果常量的
数值过大以至不能用标准的整数类型表示，则可以使用扩展的整数类型。

### 7.1.4 整数溢出

- 有符号整数运算中发生溢出时，程序的行为是未定义的。
- 无符号整数运算过程中发生溢出时，结果是有定义的

### 7.1.5 读/写整数

读写无符号整数

```c
unsigned int u;
scanf("%u", &u);     /* reads  u in base 10 */
printf("%u", u);     /* writes u in base 10 */
scanf("%o", &u);     /* reads  u in base  8 */
printf("%o", u);     /* writes u in base  8 */
scanf("%x", &u);     /* reads  u in base 16 */
printf("%x", u);     /* writes u in base 16 */
```

读写短整数

```c
short s;
scanf("%hd", &s);
printf("%hd", s);
```

读写长整数
```c
long l;
scanf("%ld",  &l);
printf("%ld",  l);
```

## 7.2 浮点类型

C语言提供了3种浮点类型

- float：单精度浮点数。
- double：双精度浮点数
- long double：扩展精度浮点数

C标准没有说明float、double和long double类型提供的精度到底是多少，因为不同的计算机可以用不同方法存储浮点数。大多数现代计算机都遵循IEEE 754标
准（即IEC 60559）的规范

表7-4 浮点类型的特征（IEEE标准）

![](https://res.weread.qq.com/wrepub/epub_31359737_240)

在一些机器上，float可以有和double相同的数值集合，或者double可以有和long double相同的数值集合。可以在头<float.h>中找到定义浮点类型特征的宏。

在C99中，浮点类型分为两种：一种是实浮点类型，包括float、double和long double类型；另一种是C99新增的复数类型（27.3节，包括float _Complex、
double _Complex和long double _Complex）。

### 7.2.1 浮点常量

```c
57.0  57.  57.0e0  57E0  5.7e1  5.7e+1  .57e2  570.e-1
```

浮点常量必须包含小数点或指数；其中，指数指明了对前面的数进行缩放所需的10的幂次。如果有指数，需要在指数数值前放置字母E（或e）。可选符号+或-可以出
现在字母E（或e）的后边。

默认情况下，浮点常量都以双精度数的形式存储。

为了表明只需要单精度，可以在常量的末尾处加上字母F或f（如57.0F）；而为了说明常量必须以long double格式存储，可以在常量的末尾处加上字母L或l（如
57.0L）。

C99提供了十六进制浮点常量的书写规范。

### 7.2.2 读/写浮点数

读取double类型

```c
double d;
scanf("%lf", &d);
```

注意：只能在scanf函数格式串中使用l，不能在printf函数格式串中使用。在printf函数格式串中，转换e、f和g可以用来写float类型或double类型的值。
（C99允许printf函数调用中使用%le、%lf和%lg，不过字母l不起作用。）

读写long double类型

```c
long double ld;
scanf("%Lf", &ld);
printf("%Lf", ld);
```

## 7.3 字符类型

```c
char ch;
ch = 'a';     /* lower-case a */
ch = 'A';     /* upper-case A */
ch = '0';     /* zero         */
ch = ' ';     /* space        */
```

### 7.3.1 字符操作

```c
char ch;
int i;
i = 'a';         /* i is now 97    */
ch = 65;         /* ch is now  'A' */
ch = ch + 1;     /* ch is now  'B' */
ch++;            /* ch is now  'C' */

if ('a' <= ch && ch <= 'z')
  ch = ch - 'a' + 'A';

for (ch = 'A'; ch <= 'Z'; ch++)...
```

### 7.3.2 有符号字符和无符号字符

C语言标准没有说明普通char类型数据是有符号型还是无符号型

标准C允许使用单词signed和unsigned来修饰char类型

```c
signed char sch;
unsigned char uch;
```

C89采用术语整值类型（integral type）来（统称）包含整数类型和字符类型。枚举类型也属于整值类型。

C99不使用术语“整值类型”，而是扩展了整数类型的含义使其包含字符类型和枚举类型。C99中的_Bool型是无符号整数类型。

### 7.3.3 算术类型

整数类型和浮点类型统称为算术类型。

C89中的算术类型

整值类型：

- 字符数型（char）；
- 有符号整型（signed char、short int、int、long int）；
- 无符号整型（unsigned char、unsigned short int、unsigned int、unsigned long int）；
- 枚举类型。

浮点类型（float、double、long double）。

C99的算术类型

整数类型：

- 字符类型（char）；
- 有符号整型, 包括标准的（signed char、short int、int、long int、long long int）和扩展的；
- 无符号整型，包括标准的（unsigned char、unsigned short int、unsigned int、unsigned long int、unsigned long long int、_Bool）和
  扩展的；
- 枚举类型。

浮点类型：

- 实数浮点类型（float、double、long double）；
- 复数类型（float_Complex、double_Complex、long double_Complex）。

### 7.3.4 转义序列

转义序列共有两种：字符转义序列（character escape）和数字转义序列（numeric escape）。

表7-5 字符转义序列

![](https://res.weread.qq.com/wrepub/epub_31359737_251)

转义序列列表没有包含所有无法打印的ASCII字符，只包含了最常用的字符。数字转义序列可以表示任何字符

- 八进制转义序列由字符\和跟随其后的一个最多含有三位数字的八进制数组成。转义序列中的八进制数不一定要用0开头。必须为无符号
- 十六进制转义序列由\x和跟随其后的一个十六进制数组成。必须为无符号, x必须小写

转义序列可能有点隐晦，所以采用#define的方式给它们命名通常是个不错的主意

```c
#define ESC '\33'    /* ASCII escape character */
```

### 7.3.5 字符处理函数

```c
#include <ctype.h>
ch = toupper(ch);  /* converts ch to upper case */
```

### 7.3.6 用scanf和printf读/写字符

```c
char ch;
scanf("%c", &ch);    /* reads a single character */
printf("%c", ch);    /* writes a single character */
```

在读入字符前，scanf函数不会跳过空白字符。

为了强制scanf函数在读入字符前跳过空白字符，需要在格式串中的转换说明%c前面加上一个空格

```c
scanf(" %c", &ch);   /* skips white space, then reads ch */

do {
  scanf("%c", &ch);
} while  (ch != '\n');
```

### 7.3.7 用getchar和putchar读/写字符

```c
putchar(ch);
ch = getchar();     /* reads a character and stores it in ch */
```

getchar函数也不会在读取时跳过空白字符。

执行程序时，使用getchar函数和putchar函数（胜于scanf函数和printf函数）可以节约时间。

- 这两个函数比scanf函数和printf函数简单得多，因为scanf函数和printf函数是设计用来按不同的格式读/写多种不同类型数据的。
- 为了额外的速度提升，通常getchar函数和putchar函数是作为宏（➤14.3节）来实现的。

把getchar函数调用移到控制表达式中可以精简循环

```c
while (getchar() != '\n')  /* skips rest of line */
  ;
```

## 7.4 类型转换

当发生下列情况时会进行隐式转换

- 当算术表达式或逻辑表达式中操作数的类型不相同时。（C语言执行所谓的常用算术转换。）
- 当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。
- 当函数调用中的实参类型与其对应的形参类型不匹配时。
- 当return语句中表达式的类型和函数返回值的类型不匹配时。

### 7.4.1 常用算术转换

常用算术转换的策略是把操作数转换成可以安全地适用于两个数值的“最狭小的”数据类型。

任一操作数的类型是浮点类型的情况

```c
long double
     ↑
   double
     ↑
    float
```

两个操作数的类型都不是浮点类型

```c
unsigned long int
        ↑
     long int
        ↑
   unsigned int
        ↑
       int
```

如果一个操作数的类型是long int，而另一个的类型是unsigned int，那么两个操作数都会转换成unsigned long int类型。

### 7.4.2 赋值过程中的转换

把赋值运算右边的表达式转换成左边变量的类型。如果变量的类型至少和表达式类型一样“宽”，那么这种转换将没有任何障碍。

```c
char c;
int i;
float f;
double d;
i = c;   /* c is converted to int    */
f = i;   /* i is converted to float  */
d = f;   /* f is converted to double */
```

把浮点数赋值给整型变量会丢掉该数的小数部分

```c
int i;
i = 842.97;   /* i is now 842  */
i = -842.97;  /* i is now -842 */
```

如果该值在变量类型范围之外，那么将会得到无意义的结果

```c
c = 10000;    /*** WRONG ***/
i = 1.0e20;   /*** WRONG ***/
f = 1.0e100;  /*** WRONG ***/
```

如果浮点常量被赋值给float型变量时，一个很好的方法是在浮点常量尾部加上后辍f

### 7.4.3 C99中的隐式转换

C99允许每个整数类型具有“整数转换等级”

- (1) long long int、unsigned long long int
- (2) long int、unsigned long int
- (3) int、unsigned int
- (4) short int、unsigned short int
- (5) char、signed char、unsigned char
- (6) _Bool

C99用整数提升（integer promotion）取代了C89中的整值提升（integral promotion），可以将任何等级低于int和unsigned int的类型转换为int
（只要该类型的所有值都可以用int类型表示）或unsigned int。

C99中执行常用算术转换的规则

- 任一操作数的类型是浮点类型的情况。只要两个操作数都不是复数型，规则与前面一样
- 两个操作数的类型都不是浮点类型的情况。首先对两个操作数进行整数提升。如果这时两个操作数的类型相同，过程结束。否则，依次尝试下面的规则，一旦
  遇到可应用的规则就不再考虑别的规则：
  - 如果两个操作数都是有符号型或者都是无符号型，将整数转换等级较低的操作数转换为等级较高的操作数的类型；
  - 如果无符号操作数的等级高于或等于有符号操作数的等级，将有符号操作数转换为无符号操作数的类型。
  - 如果有符号操作数类型可以表示无符号操作数类型的所有值，将无符号操作数转换为有符号操作数的类型。
  - 否则，将两个操作数都转换为与有符号操作数的类型相对应的无符号类型。

所有算术类型都可以转换为_Bool类型。如果原始值为0则转换结果为0，否则结果为1。

### 7.4.4 强制类型转换

(类型名) 表达式

```c
float f, frac_part;
frac_part = f - (int) f;
```

C语言把(类型名)视为一元运算符。一元运算符的优先级高于二元运算符

## 7.5 类型定义

```c
typedef int Bool;
Bool flag;    /* same as int flag; */
```

### 7.5.1 类型定义的优点

- 类型定义使程序更加易于理解
- 基础类型变更更容易

```c
typedef float Dollars;
typedef double Dollars;
```

### 7.5.2 类型定义和可移植性

为了更大的可移植性，可以考虑使用typedef定义新的整数类型名。

## 7.6 sizeof运算符

sizeof (类型名)

- 值为无符号整数, byte
- 编译器本身通常就能够确定sizeof表达式的值
- sizeof应用于表达式时不要求圆括号
- 编译器会把表达式sizeof i + j解释为(sizeof i) + j，这是因为sizeof作为一元运算符的优先级高于二元运算符+
- 因为sizeof表达式的类型是size_t, 在C89中, 最好在显示前把表达式的值转换成一种已知的类型
  - size_t一定是无符号整型，所以最安全的方法是把sizeof表达式强制转换成unsigned long类型
  - 然后使用转换说明符%lu显示

```c
printf("Size of int: %lu\n", (unsigned long) sizeof(int));
```

 - 在C99中，size_t类型可以比unsigned long更长。但C99中的printf可以直接显示出size_t类型值而不需要强制转换。

```c
printf("Size of int: %zu\n", sizeof(int));     /* C99 only */
```

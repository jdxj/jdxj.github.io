---
title: "第16章 结构, 联合和枚举"
date: 2023-07-07T11:26:30+08:00
---

## 16.1 结构变量

### 16.1.1 结构变量的声明

```c
struct {
  int number;
  char name[NAME_LEN+1];
  int on_hand;
} part1, part2;
```

### 16.1.2 结构变量的初始化

```c
struct  {
  int number;
  char name[NAME_LEN+1];
  int on_hand;
} part1 = {528, "Disk drive", 10},
  part2 = {914, "Printer cable", 5};
```

初始化式中的成员数可以少于它所初始化的结构，就像数组那样，任何“剩余的”成员都用0作为它的初始值。

### 16.1.3 指定初始化(c99)

```c
{.number = 528, .name = "Disk drive", .on_hand = 10}
```

值"Disk drive"的前面并没有指示符，所以编译器会认为它用于初始化结构中位于number之后的成员。初始化式中没有涉及的成员都设为0。

```c
{.number = 528, "Disk drive", .on_hand = 10}
```

### 16.1.4 对结构的操作

访问结构内的成员

```c
printf("Part number: %d\n", part1.number);
printf("Part name: %s\n", part1.name);
printf("Quantity on hand: %d\n", part1.on_hand);

Part1.number = 258;          /* changes part1's part number */
Part1.on_hand++;     /* increments part1's quantity on hand */

scanf("%d", &part1.on_hand);
// 复制每个字段
part2 = part1;
// 可以复制数组
struct { int a[10]; } a1, a2;
a1 = a2;   /* legal, since a1 and a2 are structures */
```

不能使用运算符==和!=来判定两个结构相等还是不等。

## 16.2 结构类型

C语言提供了两种命名结构的方法：可以声明“结构标记”，也可以使用typedef来定义类型名

### 16.2.1 结构标记的声明

```c
struct part {
  int number;
  char name[NAME_LEN+1];
  int on_hand;
};// 注意分号

struct part part1, part2;
// 不能通过漏掉单词struct来缩写这个声明
part part1, part2;     /*** WRONG ***/

// 同时声明变量
struct part {
  int number;
  char name[NAME_LEN+1];
  int on_hand;
} part1,  part2;
// 所有声明为struct part类型的结构彼此之间是兼容的
struct part part1 = {528, "Disk drive", 10};
struct part part2;
part2 = part1;    /* legal; both parts have the same type */
```

### 16.2.2 结构类型的定义

```c
typedef struct  {
  int number;
  char name[NAME_LEN+1];
  int on_hand;
} Part;
Part part1, part2;
```

### 16.2.3 结构作为参数和返回值

```c
void print_part(struct part p)
{
  printf("Part number: %d\n", p.number);
  printf("Part name: %s\n", p.name);
  printf("Quantity on hand: %d\n", p.on_hand);
}
print_part(part1);

struct part build_part(int number, const char * name, int on_hand)
{
  struct part p;
  p.number = number;
  strcpy (p.name, name);
  p.on_hand = on_hand;
  return p;
}
part1 = build_part(528, "Disk drive", 10);

void f(struct part part1)
{
  struct part part2 = part1;
  ...
}
```

### 16.2.4 复合字面量(c99)

```c
print_part((struct part) {528, "Disk drive", 10});
part1 = (struct part) {528, "Disk drive", 10};

// typedef也可以
print_part((struct part) {.on_hand = 10,
                          .name = "Disk drive",
                          .number = 528});
```

复合字面量不会提供完全的初始化，所以任何未初始化的成员默认值为0。

## 16.3 嵌套的数组和结构

### 16.3.1 嵌套的结构

```c
struct person_name {
  char first[FIRST_NAME_LEN+1];
  char middle_initial;
  char last[LAST_NAME_LEN+1];
};

struct student {
  struct person_name name;
  int_id, age;
  char sex;
} student1, student2;
strcpy(student1.name.first, "Fred");
```

### 16.3.2 结构数组

```c
struct part inventory[100];
print_part(inventory[i]);

inventory[i].number = 883;
inventory[i].name[0] = '\0';
```

### 16.3.3 结构数组的初始化

```c
const struct dialing_code country_codes[] =
  {{"Argentina",            54}, {"Bangladesh",          880},
   {"Brazi1",               55}, {"Burma (Myanmar)",      95},
   {"China",                86}, {"Colombia",             57},
   {"Congo, Dem. Rep. of", 243}, {"Egypt",                20},
   {"Ethiopia",            251}, {"France",               33},
   {"Germany",              49}, {"India ",               91},
   {"Indonesia"             62}, {"Iran",                 98},
   {"Italy",                39}, {"Japan",                81},
   {"Mexico",               52}, {"Nigeria",             234},
   {"Pakistan",             92}, {"Philippines",          63},
   {"Poland",               48}, {"Russia",                7},
   {"South Africa",         27}, {"Korea"                 82},
   {"Spain",                34}, {"Sudan"                249},
   {"Thailand",             66}, {"Turkey",               90},
   {"Ukraine",             380}, {"United Kingdom",       44},
   {"United States",         1}, {"Vietnam",             84}};
```

C99的指定初始化式允许每一项具有多个指示符。

- 指示符是指`[]`, `.`

```c
struct part inventory[100] =
  {[0].number = 528, [0].on_hand = 10, [0].name[0] = '\0'};
```

## 16.4 联合

编译器只为联合中最大的成员分配足够的内存空间。

```c
union {
  int i;
  double d;
} u;

struct {
  int i;
  double d;
} s;
```

![](https://res.weread.qq.com/wrepub/epub_31359737_649)

访问联合成员

- 如果把一个值存储到u.d中，那么先前存储在u.i中的值将会丢失。

```c
u.i = 82;
u.d = 74.8;
```

初始化

```c
union {
  int i;
  double d;
} u = {0};

union {
  int i;
  double d;
} u = {.d = 10.0};
```

### 16.4.1 用联合来节省空间

```c
struct catalog_item {
  int stock_number;
  double price;
  int item_type;
  union {
    struct {
      char title[TITLE_LEN+1];
      char author[AUTHOR_LEN+1];
      int num_pages;
    } book;
    struct {
      char design[DESIGN_LEN+1];
    } mug;
    struct {
      char design[DESIGN_LEN+1];
      int colors;
      int sizes;
    } shirt;
  } item;
};

printf("%s", c.item.book.title);
```

C标准提到了一种特殊情况：联合的两个或多个成员是结构，而这些结构最初的一个或多个成员是相匹配的。（这些成员的顺序应该相同，类型也要兼容，但名字
可以不一样。）如果当前某个结构有效，则其他结构中的匹配成员也有效。

```c
strcpy(c.item.mug.design, "Cats");
printf("%s", c.item.shirt.design);    /* prints "Cats" */
```

### 16.4.2 用联合来构造混合的数据结构

```c
typedef union {
  int i;
  double d;
} Number;
Number number_array[1000];
number_array[0].i = 5;
number_array[1].d = 8.395;
```

### 16.4.3 为联合添加“标记字段”

```c
#define INT_KIND 0
#define DOUBLE_KIND 1
typedef struct {
  int kind;   /* tag field */
  union{
    int i;
    double d;
  } u;
} Number;

n.kind = INT_KIND;
n.u.i = 82;

void print_number(Number n)
{
  if (n.kind == INT_KIND)
    printf("%d", n.u.i);
  else
    printf("%g", n.u.d);
}
```

## 16.5 枚举

```c
enum {CLUBS, DIAMONDS, HEARTS, SPADES} s1, s2;
```
枚举常量的名字必须不同于作用域范围内声明的其他标识符。

### 16.5.1 枚举标记和类型名

```c
enum suit {CLUBS, DIAMONDS, HEARTS, SPADES};
enum suit s1, s2;

typedef enum {CLUBS, DIAMONDS, HEARTS, SPADES} Suit;
Suit s1, s2;
```

### 16.5.2 枚举作为整数

在系统内部，C语言会把枚举变量和常量作为整数来处理。

在枚举suit的例子中，CLUBS、DIAMONDS、HEARTS和SPADES分别表示0、1、2和3。

可以为枚举常量自由选择不同的值。

```c
// 可以不用按照特定的顺序
enum suit {CLUBS = 1, DIAMONDS = 2, HEARTS = 3, SPADES = 4};
// 两个或多个枚举常量具有相同的值甚至也是合法的
```

当没有为枚举常量指定值时，它的值比前一个常量的值大1。（第一个枚举常量的值默认为0。）

```c
enum EGA_colors {BLACK, LT_GRAY = 7, DK_GRAY, WHITE = 15};
```

枚举的值只不过是一些稀疏分布的整数，所以C语言允许把它们与普通整数进行混合

```c
int i;
enum {CLUBS, DIAMONDS, HEARTS, SPADES} s;
i = DIAMONDS;   /* i is now 1             */
s = 0;          /* s is now 0  (CLUBS)    */
s++;            /* s is now 1  (DIAMONDS) */
i = s + 2;      /* i is now 3             */
```

### 16.5.3 用枚举声明“标记字段”

```c
typedef struct {
  enum {INT_KIND, DOUBLE_KIND} kind;
  union {
    int i;
    double d;
  } u;
} Number;
```

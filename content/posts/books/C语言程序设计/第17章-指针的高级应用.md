---
title: "第17章 指针的高级应用"
date: 2023-07-07T15:46:24+08:00
---

## 17.1 动态存储分配

即在程序执行期间分配内存单元的能力。

### 17.1.1 内存分配函数

这些函数都是声明在<stdlib.h>中

- malloc函数——分配内存块，但是不对内存块进行初始化。
- calloc函数——分配内存块，并且对内存块进行清零。
- realloc函数——调整先前分配的内存块大小。

由于函数无法知道计划存储在内存块中的数据是什么类型的，所以它不能返回int类型、char类型等普通类型的指针。取而代之的，函数会返回void *类型的值。
void *类型的值是“通用”指针，本质上它只是内存地址。

### 17.1.2 空指针

当调用内存分配函数时，总存在这样的可能性：找不到满足我们需要的足够大的内存块。如果真的发生了这类问题，函数会返回空指针（null pointer）。
在把函数的返回值存储到指针变量中以后，需要判断该指针变量是否为空指针。

```c
p = malloc(10000);
if (p == NULL) {
  /* allocation failed;  take appropriate action  */
}
```

名为NULL的宏在6个头<locale.h>、<stddef.h>、<stdio.h>、<stdlib.h>、<string.h>和<time.h>中都有定义。（C99的<wchar.h>也定义了NULL。）

## 17.2 动态分配字符串

### 17.2.1 使用malloc函数为字符串分配内存

```c
void *malloc(size_t size);

p = (char *) malloc(n + 1);
// 可以不用强制转换
p = malloc(n + 1);
```

### 17.2.2 在字符串函数中使用动态存储分配

```c
char *concat(const char *s1, const char *s2)
{
  char *result ;
  result = malloc(strlen(s1) + strlen(s2) + 1);
  if (result == NULL)  {
    printf("Error: malloc failed in concat\n");
    exit (EXIT_FAILURE);
  }
  strcpy(result, s1);
  strcat(result, s2);
  return result;
}
```

### 17.2.3 动态分配字符串的数组

## 17.3 动态分配数组

### 17.3.1 使用malloc函数为数组分配存储空间

```c
int *a;
a = malloc(n * sizeof(int));
for (i = 0; i < n; i++)
  a[i] = 0;
```

### 17.3.2 calloc函数

```c
// 元素个数, 元素大小
void *calloc(size_t nmemb, size_t size);
```

calloc函数会通过把所有位设置为0的方式进行初始化。

通过调用以1作为第一个实际参数的calloc函数，可以为任何类型的数据项分配空间：

```c
struct point { int x, y; } *p;
p = calloc(1, sizeof(struct point));
```

### 17.3.3 realloc函数

```c
void *realloc(void *ptr, size_t size);
```

当调用realloc函数时，ptr必须指向先前通过malloc、calloc或realloc的调用获得的内存块。size表示内存块的新尺寸，新尺寸可能会大于或小于原有尺
寸。虽然realloc函数不要求ptr指向正在用作数组的内存，但实际上通常是这样的。

C标准列出了几条关于realloc函数的规则。

- 当扩展内存块时，realloc函数不会对添加进内存块的字节进行初始化。
- 如果realloc函数不能按要求扩大内存块，那么它会返回空指针，并且在原有的内存块中的数据不会发生改变。
- 如果realloc函数被调用时以空指针作为第一个实际参数，那么它的行为就将像malloc函数一样。
- 如果realloc函数被调用时以0作为第二个实际参数，那么它会释放掉内存块。

**一旦realloc函数返回，请一定要对指向内存块的所有指针进行更新，因为realloc函数可能会使内存块移动到了其他地方。**

## 17.4 释放存储空间

### 17.4.1 free函数

```c
void free(void *ptr);

p = malloc(...);
q = malloc(...);
free(p);
p = q;
```

free函数的实际参数必须是先前由内存分配函数返回的指针。（参数也可以是空指针，此时free调用不起作用。）如果参数是指向其他对象（比如变量或数组
元素）的指针，可能会导致未定义的行为。

### 17.4.2 “悬空指针”问题

```c
char *p = malloc(4);
...
free(p);
...
strcpy(p, "abc");     /*** WRONG ***/
```

## 17.5 链表

### 17.5.1 声明结点类型

```c
struct node {
  int value;            /* data stored in the node   */
  struct node *next;    /* pointer to the next node  */
};
struct node *first = NULL;
```

在结构有一个指向相同结构类型的指针成员时（就像node中那样），要求使用结构标记。

### 17.5.2 创建结点

```c
struct node *new_node;
new_node = malloc(sizeof(struct node));
(*new_node).value = 10;
```

在`*new_node`两边的圆括号是强制要求的，因为运算符.的优先级高于运算符*

### 17.5.3 ->运算符

```c
new_node->value = 10;
scanf("%d", &new_node->value);
```

### 17.5.4 在链表的开始处插入结点

```c
struct node *add_to_list(struct node *list, int n)
{
  struct node *new_node;
  new_node = malloc(sizeof(struct node));
  if (new_node == NULL) {
    printf("Error: malloc failed in add_to list\n");
    exit(EXIT_FAILURE);
  }
  new_node->value = n;
  new_node->next = list;
  return new_node;
}

first = add_to_list(first, 10);
first = add_to_list(first, 20);
```

### 17.5.5 搜索链表

```c
for (p  =  first;  p  !=  NULL;  p  =  p->next)
...
```

### 17.5.6 从链表中删除结点

```c
struct node *delete_from_list(struct node *list, int n)
{
  struct node *cur, *prev;
  for (cur = list, prev = NULL;
       cur != NULL && cur->value != n;
       prev = cur,  cur = cur->next)
    ;
  if (cur == NULL)
    return list;                /* n was not found */
  if (prev == NULL)
    list = list->next;          /* n is in the first node */
  else
    prev->next = cur->next;     /* n is in some other node */
  free (cur);
  return list;
}
```

### 17.5.7 有序链表

往有序列表中插入结点会更困难一些，但是搜索会更快

## 17.6 指向指针的指针

```c
void_add_to_list(struct node **list, int n)
{
   struct node *new_node;
   new_node = malloc(sizeof(struct node));
   if (new_node == NULL) {
     printf("Error: malloc failed in add_to_list\n");
     exit(EXIT_FAILURE);
   }
   new_node->value = n;
   new_node->next = *list;
   *list = new_node;
}
add_to_list(&first, 10);
```

## 17.7 指向函数的指针

### 17.7.1 函数指针作为参数

```c
double integrate(double (*f)(double), double a, double b);
// 等价
double integrate(double f(double), double a, double b);

result = integrate(sin, 0.0, PI / 2);

// integrate内调用f
y = (*f)(x);
// 也可以
y = f(x);
```

### 17.7.2 qsort函数

此函数的原型可以在<stdlib.h>中找到

```c
void qsort(void *base, size_t nmemb, size_t size,
           int (*compar) (const void *, const void *));

qsort(inventory, num_parts, sizeof(struct part), compare_parts);
int compare_parts(const void *p, const void *q)
{
  const struct part *p1 = p;
  const struct part *q1 = q;
  if (p1->number < q1->number)
    return -1;
  else if  (p1->number == q1->number)
    return 0;
  else
    return 1;
}
// 使用强制类型转换
int compare_parts(const void *p, const void *q)
{
  if (((struct part *) p)->number <
      ((struct part *) q)->number)
    return -1;
  else if (((struct part *) p)->number ==
           ((struct part *) q)->number)
    return 0;
  else
    return 1;
}
// 移除if
int compare_parts(const void *p, const void *q)
{
  return ((struct part *) p)->number -
         ((struct part *) q)->number;
}
```

### 17.7.3 函数指针的其他用途

可以把函数指针存储在变量中，或者用作数组的元素，再或者用作结构或联合的成员，甚至可以编写返回函数指针的函数

指向函数的指针

```c
void (*pf)(int);

pf = f;
(*pf)(i);
// 或
pf(i);
```

函数指针数组

```c
void (*file_cmd[])(void) = {new_cmd,
                            open_cmd,
                            close_cmd,
                            close_all_cmd,
                            save_cmd,
                            save_as_cmd,
                            save_all_cmd,
                            print_cmd,
                            exit_cmd
                           };
(*file_cmd[n])();   /* or file_cmd[n](); */
```

## 17.8 受限指针(c99)

```c
int * restrict p;
```

这样做的目的是，如果指针p指向的对象在之后需要修改，那么该对象不会允许通过除指针p之外的任何方式访问（其他访问对象的方式包括让另一个指针指向同
一个对象，或者让指针p指向命名变量）。如果一个对象有多种访问方式，通常把这些方式互称为别名。

## 17.9 灵活数组成员(c99)

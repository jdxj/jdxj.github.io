---
title: "第21章 标准库"
date: 2023-07-09T15:38:41+08:00
---

## 21.1 标准库的使用

表21-1 标准库的头

![](https://res.weread.qq.com/wrepub/epub_31359737_774)

当一个文件包含多个标准头时，#include指令的顺序无关紧要。多次包含同一个标准头也是合法的。

### 21.1.1 对标准库中所用名字的限制

任何包含了标准头的文件都必须遵守两条规则

- 该文件不能将头中定义过的宏的名字用于其他目的。(不能重定义宏)
- 具有文件作用域的库名（尤其是typedef名）也不可以在文件层次重定义。
- 由一个下划线和一个大写字母开头或由两个下划线开头的标识符是为标准库保留的标识符。程序不允许为任何目的使用这种形式的标识符。
- 由一个下划线开头的标识符被保留用作具有文件作用域的标识符和标记。除非在函数内部声明，否则不应该使用这类标识符。
- 在标准库中所有具有外部链接的标识符被保留用作具有外部链接的标识符。特别是所有标准库函数的名字都被保留。

哪些名字是保留的, 可以在C标准的“future library directions”中找到。

### 21.1.2 使用宏隐藏的函数

C标准允许在头中定义与库函数同名的宏，为了起到保护作用，还要求有实际的函数存在。

<stdio.h>

```c
int getchar(void);
#define getchar() getc(stdin)
```

在默认情况下，对getchar的调用会被看作宏调用（因为宏名会在预处理时被替换）。

在大多数情况下，我们喜欢使用宏来替代实际的函数，因为这样可能会提高程序的运行速度。然而在某些情况下，我们可能需要的是一个真实的函数，可能是为
了尽量缩小可执行代码的大小。

如果确实存在这种需求，我们可以使用#undef指令来删除宏定义。

```c
#include <stdio.h>
#undef getchar
```

也可以通过给名字加圆括号来禁用个别宏调用

```c
ch = (getchar)();        /* instead of ch = getchar(); */
```

## 21.2 C89标准库概述

1. <assert.h>：诊断
2. <ctype.h>：字符处理
3. <errno.h>：错误
4. <float.h>：浮点类型的特性
5. <limits.h>：整数类型的大小
6. <locale.h>：本地化
7. <math.h>：数学计算
8. <setjmp.h>：非本地跳转
9. <signal.h>：信号处理
10. <stdarg.h>：可变参数
11. <stddef.h>：常用定义
12. <stdio.h>：输入/输出
13. <stdlib.h>：常用实用程序
14. <string.h>：字符串处理
15. <time.h>：日期和时间

## 21.3 C99标准库更新

1. <complex.h>：复数算术
2. <fenv.h>：浮点环境
3. <inttypes.h>：整数类型格式转换
4. <iso646.h>：拼写转换
5. <stdbool.h>：布尔类型和值
6. <stdint.h>：整数类型
7. <tgmath.h>：泛型数学
8. <wchar.h>：扩展的多字节和宽字符实用工具
9. <wctype.h>：宽字符分类和映射实用工具

## 21.4 <stddef.h>：常用定义

- ptrdiff_t。当进行指针相减运算时，其结果的类型。
- size_t。sizeof运算符返回的类型。
- wchar_t。一种足够大的、可以用于表示所有支持的地区的所有字符的类型。
- NULL
- offsetof

只有少数程序真的需要包含<stddef.h>。

## 21.5 <stdbool.h>：布尔类型和值(c99)

- bool（定义为_Bool）；
- true（定义为1）；
- false（定义为0）；
- __bool_true_false_are_defined（定义为1）。

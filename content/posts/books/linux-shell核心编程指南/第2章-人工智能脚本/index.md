---
title: "第2章 人工智能, 很人工, 很智能的脚本"
date: 2023-04-20T16:45:11+08:00
---

## 2.1 智能化脚本的基础之测试

条件判断的方式

- [[ expr ]]
- [ expr ]
- test expr

不管使用哪种方式进行条件判断，系统默认都不会有任何输出结果，可以通过echo $?命令，查看上一条命令的退出状态码，或者使用&&和||操作符结合其他命令进
行结果的输出操作。

- 表达式两边要有空格
- 操作符两边要有空格
- 使用[[]]和test进行排序比较时，使用的比较符号不同
- 在test或[]中不能直接使用<或>符号进行排序比较(因为是输入输出重定向符号)

在一行中执行多个命令

- ; 按顺序执行命令, 退出码以最后一个命令为准
- && 前一条命令成功后才会执行之后的命令, 都成功执行后退出码为0
- || 前一条命令失败后才会执行之后的命令, 存在成功执行退出码为0

## 2.2 字符串的判断与比较

```bash
$ test a == b; echo $?
$ [ a == b ]; echo $?
```

-z测试字符串是否为空

```bash
$ [ -z $TEST ]
```

-n测试字符串是否非空

```bash
$ [ -n $TEST ]
```

- 使用-n时最好使用""将变量扩起来, 否则会测试随后空格, 返回值永为真

```bash
$ [ -n ] && echo Y || echo N 
Y
$ [ -n $Jacob ] && echo Y || echo N
Y
$ [ -n "$Jacob" ] && echo Y || echo N
N
```

## 2.3 整数的判断与比较

表2-1 整数的比较运算符

![](https://res.weread.qq.com/wrepub/epub_27741237_36)

```bash
$ test 3 -eq 3 && echo Y || echo N
```

## 2.4 文件属性的判断与比较

更多文件属性操作符可以参考命令帮助手册（man test）

表2-2 文件属性操作符

![](https://res.weread.qq.com/wrepub/epub_27741237_37)

```bash
$ [ ! -e docs ] && echo 对 || echo 错
错
```

在测试权限时需要注意，超级管理员root在没有rw权限的情况下，也是可以读写文件的，rw权限对超级管理员是无效的。但是如果文件没有x权限，哪怕是root也不
可以执行该文件。

## 2.5 探究[[]]和[]的区别

多数情况下[]和[[]]是可以通用的，两者的主要差异是：test或[]是符合POSIX标准的测试语句，兼容性更强，几乎可以运行在所有Shell解释器中，相比较而言
[[]]仅可运行在特定的几个Shell解释器中（如Bash、Zsh等）。事实上，目前支持使用[[]]进行条件测试的解释器已经足够多了。使用[[]]进行测试判断时甚至
可以使用正则表达式。

在[[]]中使用<和>符号时，系统进行的是排序操作，而且支持在测试表达式内使用&&和||符号。在test或[]测试语句中不可以使用&&和||符号。

- [[]]中的表达式如果使用<或>进行排序比较，使用的是本地的locale语言顺序。可以使用LANG=C设置在排序时使用标准的ASCII码顺序。

```bash
$ LANG=C
$ [[ b > A ]] && echo Y || echo N
```

虽然[]也支持同时进行多个条件的逻辑测试，但是在[]中需要使用-a和-o进行逻辑与和逻辑或的比较操作，而[[]]中可以直接使用&&和||进行逻辑比较操作，更直
观，可读性更好。

```bash
$ [ yes == y -a no == no ] && echo Y || echo N
$ [[ yes == y && no == no ]] && echo Y || echo N
```

在[[]]中==是模式匹配，模式匹配允许使用通配符。例如，Bash常用的通配符有*、? 、[…]等。而==在test语句中仅代表字符串的精确比较，判断字符串是否一模
一样。

```bash
$ name=Jacob
$ [[ $name == J* ]] && echo Y || echo N
Y
$ [[ $name == J?cob ]] && echo Y || echo N
Y
```

在[[]]中还支持使用=～进行正则匹配，而在[]中则完全不支持正则匹配

```bash
$ name="welcome to beijing"                
$ [[ $name =~ w ]] && echo Y || echo N
Y
```

[[]]支持分组测试`()`(类似数学计算中的括号), 仅部分shell的[]支持`()`

```bash
$ [[ a == a && (b == b || c == d) ]] && echo Y || echo N
Y
```

表2-3 [[]]和[]的对比

![](https://res.weread.qq.com/wrepub/epub_27741237_39)

## 2.6 实战案例：系统性能监控脚本

## 2.7 实战案例：单分支if语句

```shell
if cond
then
  cmd
fi

if cond; then
  cmd
fi
```

任何有退出码的命令都可以写在if后面

```shell
if grep -q AMD /proc/cpuinfo; then
  echo "AMD CPU"
fi
```

## 2.8 实战案例：双分支if语句

```shell
if cond; then
  cmd
else
  cmd
fi
```

## 2.9 实战案例：如何监控HTTP服务状态

## 2.10 实战案例：多分支if语句

```shell
if cond; then
  cmd
elif cond; then
  cmd
else
  cmd
fi
```

## 2.11 实战案例：简单、高效的case语句

```shell
case word in
模式1）
命令序列1; ;
模式2）
命令序列2; ;
......
＊）
命令序列n; ;
esac
```

```shell
case word in
模式1|模式2|模式3）
    命令序列1; ;
模式4|模式5|模式6）
    命令序列2; ;
... ...
*）
    命令序列n; ;
esac
```

- word关键字展开支持使用~（根目录）、变量展开$、算术运算展开$[]、命令展开$()等。每个模式匹配中也都支持与word关键字一样的展开功能。
- 如果命令序列的最后使用了`;;`（双分号），则case命令不再对后续的模式进行匹配比较，即匹配停止。
- 如果使用`;&`替代`;;`会导致case继续执行下一个模式匹配中附加的命令序列。
- 如果使用`;;&`替代`;;`则会导致case继续对下一个模式进行匹配，如果匹配则执行对应命令序列中的命令。

## 2.12 实战案例：编写Nginx启动脚本

## 2.13 揭秘模式匹配与通配符、扩展通配符

表2-7 通配符

![](https://res.weread.qq.com/wrepub/epub_27741237_81)

使用shopt命令将Shell的extglob控制选项开启，则在Shell中可以支持如表2-8所示的扩展通配符。

```bash
# 开启选项
$ shopt -s extglob
# 关闭选项
$ shopt -u extglob
```

表2-8 扩展通配符

![](https://res.weread.qq.com/wrepub/epub_27741237_83)

## 2.14 Shell小游戏之石头剪刀布

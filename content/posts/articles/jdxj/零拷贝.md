---
title: "零拷贝"
date: 2023-06-20T23:32:32+08:00
tags:
  - zero-copy
---

// todo: 用go整一个

在内核态和用户态之间来回切换

![](https://static001.geekbang.org/resource/image/65/ee/6593f66902b337ec666551fe2c6f5bee.jpg?wh=3509*1970)

要想提升传输文件的性能，需要从降低上下文切换的频率和内存拷贝次数两个方向入手。

# 零拷贝如何提升文件传输性能？

- 如果想减少上下文切换次数，就一定要减少系统调用的次数。解决方案就是把 read、write 两次系统调用合并成一次，在内核中完成磁盘与网卡的数据交换。
- 如果内核在读取文件后，直接把 PageCache中的内容拷贝到Socket 缓冲区，待到网卡发送完毕后，再通知进程，这样就只有2次上下文切换，和 3次内存拷贝。

![](https://static001.geekbang.org/resource/image/bf/a1/bf80b6f858d5cb49f600a28f853e89a1.jpg?wh=3517*1995)

如果网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术，还可以再去除 Socket 缓冲区的拷贝，这样一共只有 2 次内存拷贝。

![](https://static001.geekbang.org/resource/image/0a/77/0afb2003d8aebaee763d22dda691ca77.jpg?wh=3514*1959)

用户缓冲区为什么不与 socket 缓冲区大小一致呢？这是因为，socket 缓冲区的可用空间是动态变化的，它既用于 TCP 滑动窗口，也用于应用缓冲区，还受到
整个系统内存的影响

零拷贝使我们不必关心 socket 缓冲区的大小。

零拷贝还使用了 PageCache 技术，通过它，零拷贝可以进一步提升性能

# PageCache，磁盘高速缓存

为什么要把磁盘文件读到内存中?

- 由于磁盘比内存的速度慢许多，所以我们应该想办法把读写磁盘替换成读写内存
- 读取磁盘数据时，需要先找到数据所在的位置，对于机械磁盘来说，就是旋转磁头到数据所在的扇区，再开始顺序读取数据。其中，旋转磁头耗时很长，为了降低它
  的影响，PageCache 使用了预读功能。

高并发场景下，为了防止 PageCache 被大文件占满后不再对小文件产生作用，大文件不应使用 PageCache，进而也不应使用零拷贝技术处理。

# 异步 IO + 直接 IO

高并发场景处理大文件时，应当使用异步 IO 和直接 IO 来替换零拷贝技术。

// todo: go中怎么实现?

当调用 read 方法读取文件时，实际上 read 方法会在磁盘寻址过程中阻塞等待，导致进程无法并发地处理其他任务

![](https://static001.geekbang.org/resource/image/9e/4e/9ef6fcb7da58a007f8f4e3e67442df4e.jpg?wh=3933*2550)

异步 IO（异步 IO 既可以处理网络 IO，也可以处理磁盘 IO，这里我们只关注磁盘 IO）可以解决阻塞问题。它把读操作分为两部分

- 前半部分向内核发起读请求，但不等待数据就位就立刻返回，此时进程可以并发地处理其他任务。
- 当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的通知，再去处理数据，这是异步 IO 的后半部分。

![](https://static001.geekbang.org/resource/image/15/f3/15d33cf599d11b3188253912b21e4ef3.jpg?wh=4040*2172)

异步 IO 并没有拷贝到 PageCache 中，这其实是异步 IO 实现上的缺陷。经过 PageCache 的 IO 我们称为缓存 IO，它与虚拟内存系统耦合太紧，导致异步
IO 从诞生起到现在都不支持缓存 IO。

绕过 PageCache 的 IO 是个新物种，我们把它称为直接 IO。对于磁盘，异步 IO 只支持直接 IO。

有了直接 IO 后，异步 IO 就可以无阻塞地读取文件了。现在，大文件由异步 IO 和直接 IO 处理，小文件则交由零拷贝处理，至于判断文件大小的阈值可以灵活
配置（参见 Nginx 的 directio 指令）。

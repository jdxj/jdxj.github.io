---
title: "锁"
date: 2023-06-21T11:20:01+08:00
tags:
  - lock
---

# 互斥锁

当你无法判断锁住的代码会执行多久时，应该首选互斥锁

对于 99% 的线程级互斥锁而言，阻塞都是由操作系统内核实现的

![](https://static001.geekbang.org/resource/image/74/8a/749fc674c55136bd455725b79c9e0c8a.jpg?wh=1198*1144)

线程获取锁失败时，增加了两次上下文切换的成本：从运行中切换为休眠，以及锁释放时从休眠状态切换为运行中。

# 自旋锁

如果你能确定被锁住的代码执行时间很短，就应该用自旋锁取代互斥锁。

自旋锁比互斥锁快得多，因为它通过 CPU 提供的 CAS 函数（全称 Compare And Swap），在用户态代码中完成加锁与解锁操作。

- 第 1 步查看锁的状态，如果锁是空闲的，第 2 步将锁设置为当前线程持有。
- 在没有 CAS 操作前，多个线程同时执行这 2 个步骤是会出错的。
- CAS 函数把这 2 个步骤合并为一条硬件级指令。

什么叫“忙等待”

- 它并不意味着一直执行 CAS 函数，生产级的自旋锁在“忙等待”时，会与 CPU 紧密配合 ，它通过 CPU 提供的 PAUSE 指令，减少循环等待时的耗电量；
- 对于单核 CPU，忙等待并没有意义，此时它会主动把线程休眠。

# 读写锁

可以由互斥锁或自旋锁实现.

如果你能够明确区分出读和写两种场景，可以选择读写锁。

读写锁的优势在于，当写锁未被持有时，多个线程能够并发地持有读锁，这提高了共享资源的使用率。多个读锁被同时持有时，读线程并不会修改共享资源，所以它们
的并发执行不会产生数据错误。

读写锁真正发挥优势的场景，必然是读多写少的场景，否则读锁将很难并发持有。

**读优先锁**更强调效率，它期待锁能被更多的线程持有。简单看下它的工作特点：当线程 A 先持有读锁后，即使线程 B 在等待写锁，后续前来获取读锁的线程 C
仍然可以立刻加锁成功，因为这样就有 A、C 这 2 个读线程在并发持有锁，效率更高。

**写优先**的读写锁。同样的情况下，线程 C 获取读锁会失败，它将被阻塞在获取锁的代码中，这样，只要线程 A 释放读锁后，线程 B 马上就可以获取到写锁。

![](https://static001.geekbang.org/resource/image/7b/c6/7b5f4e4bb3370b89b90c1bf83cb58fc6.jpg?wh=1202*1496)

能否兼顾二者，避免读、写线程饿死呢？

- 用队列把请求锁的线程排队，按照先来后到的顺序加锁即可，当然读线程仍然可以并发，只不过不能插队到写线程之前。

# 乐观锁

无论互斥锁、自旋锁还是读写锁，都属于悲观锁。

- 它认为同时修改资源的概率很高，很容易出现冲突，所以访问共享资源前，先加上锁，总体效率会更优。

所谓“乐观”，就是假定冲突的概率很低，所以它采用的“加锁”方式是，先修改完共享资源，再验证这段时间内有没有发生冲突。如果没有其他线程在修改资源，那么
操作完成。如果发现其他线程已经修改了这个资源，就放弃本次操作。

至于放弃后如何重试，则与业务场景相关，虽然重试的成本很高，但出现冲突的概率足够低的话，还是可以接受的。可见，乐观锁全程并没有加锁，所以它也叫无锁编
程。

无锁编程中如何验证发生了冲突?

以在线文档为例, 比较版本号来判断是否冲突

![](https://static001.geekbang.org/resource/image/1d/f0/1db3bb24d896fabeebf68359384214f0.jpg?wh=1578*1150)

乐观锁除了应用在 Web 分布式场景，在数据库等单机上也有广泛的应用。只是面向多线程时，最后的验证步骤是通过 CPU 提供的**CAS**操作完成的。

乐观锁虽然去除了锁操作，但是一旦发生冲突，重试的成本非常高。所以，只有在**冲突概率非常低，且加锁成本较高**时，才考虑使用乐观锁。

---
title: "事件驱动"
date: 2023-06-21T13:03:10+08:00
tags:
  - c10k
  - c10m
---

# 事件是怎么产生的？

- 读事件表示有到达的消息需要处理
- 写事件表示可以发送消息（TCP 连接的写缓冲区中有可用空间）。

tcp握手

![](https://static001.geekbang.org/resource/image/73/98/73b9d890c7087531b51180ada6e65f98.png?wh=909*628)

- 在建立好的 TCP 连接上收发消息时，读事件对应着接收到对方的消息
- 写事件则稍微复杂些
  - 假设要发送一个 2MB 的请求, 当调用 write 函数发送时，会先把内存中的数据拷贝到写缓冲区中后，再发送到网卡上
  - 因为在对方没有明确表示收到前，TCP 会通过定时器重发写缓冲区中的数据，保证消息能够到达对方。
  - 写缓冲区是有大小限制的。这里假设写缓冲区只有 1MB，所以调用 write 发送 2MB 数据时，write 函数的返回值只有 1MB，表示写缓冲区已用尽。
  - 当收到对方发来的 ACK 报文后，缓冲区中的数据才能释放，就会**产生写事件通知进程发送剩余的那 1MB 数据**。

![](https://static001.geekbang.org/resource/image/c5/7a/c524965bee6407bd716c7dc33bdd437a.png?wh=903*477)

如同建立连接需要双向建立一样，关闭连接也需要双方各自关闭每个方向的通道。主动关闭的一方发送 FIN 报文，到达被动方后，内核自动回复 ACK 报文，这表示
从主动方到被动方的通道已经关闭。但被动方到主动方的通道也需要关闭，所以此时**被动方会产生读事件，提醒被动方调用 close 函数关闭连接**。

![](https://static001.geekbang.org/resource/image/b7/96/b73164fd504cc2574066f526ebee7596.png?wh=893*627)

什么样的代码值得基于事件来做拆分呢？

对于服务器来说，对最慢的操作做异步化改造，才能值回开发效率的损失。而服务里对资源的操作速度由快到慢，依次是 CPU、内存、磁盘和网络。CPU 和内存的执
行速度都是纳秒级的，无须考虑事件驱动，而**磁盘**和**网络**都可以采用事件驱动的异步方式处理。

# 怎样处理网络事件？

epoll

理解多路复用

一个进程虽然任一时刻只能处理一个请求，但处理每个请求产生的事件时，若耗时控制在 1 毫秒以内，这样 1 秒钟就可以处理数千个请求，从更长的时间维度上看，
多个请求复用了一个进程，也叫做多路复用（或者叫做时分多路复用）。我们熟知的 epoll，就是内核提供给用户态的多路复用接口，进程可以通过它从内核中获取
事件。

epoll 是如何获取网络事件的呢？最简单的方法，就是在获取事件时，把所有并发连接传给内核，再由内核返回产生了事件的连接，再处理这些连接对应的请求即可。
epoll 前的 select 等多路复用函数就是这么干的。

epoll 为了降低性能消耗，把获取事件拆分成两步。

- 第一步把需要监控的 socket 传给内核（epoll_ctl 函数），它仅在连接建立等有限的时机调用；
- 第二步收集事件（epoll_wait 函数）便不用传递 socket 了，这样就把 socket 的重复传递改为了一次传递，降低了性能损耗。

进程获取到产生事件的 socket 后，又该如何处理它呢？这里的核心约束是，处理任何一个事件的耗时都应该是微秒级或者毫秒级，否则就会延误其他事件的处理，
不只降低了用户的体验，而且会形成恶性循环。

怎样保证处理一个事件的时间不会太长呢？

- 第一类是计算任务，虽然内存、CPU 的速度很快，然而循环执行也可能耗时达到秒级。所以，如果一定要引入需要密集计算才能完成的请求，为了不阻碍其他事件
  的处理，要么把这样的请求放在独立的线程中完成，要么把请求的处理过程拆分成多段，确保每段能够快速执行完，同时每段执行完都要均等地处理其他事件，这样
  通过放慢该请求的处理时间，就保障了其他请求的及时处理。
- 第二类会读写磁盘，由于磁盘的写入操作使用了 PageCache 的延迟写特性，当 write 函数返回时只是复制到了内存中，所以写入操作很快。磁盘的读取操作就
  比较慢了，这时，通常要把大文件的读取，拆分成许多份，每份仅有几十 KB，降低单次操作的耗时。
- 第三类是通过网络访问上游服务。与处理客户端请求相似，我们必须使用非阻塞 socket，用事件驱动方式处理请求。需要注意的是，许多网络服务提供的 SDK，
  都是基于阻塞 socket 实现的，使用前必须先做完非阻塞改造。

// todo: 怎么用go整个非阻塞的client

# 小结

网络报文到达后，内核就产生了读、写事件，而 epoll 函数使得进程可以高效地收集到这些事件。接下来，要确保在进程中处理每个事件的时间足够短，才能及时地
处理所有请求，这个过程中既要避免阻塞 socket 的使用，也要把耗时过长的操作拆成多份执行。最终，通过快速、及时、均等地执行所有事件，异步 Server 实
现了高并发。

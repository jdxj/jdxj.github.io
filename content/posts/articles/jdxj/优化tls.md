---
title: "优化TLS"
date: 2023-06-22T19:20:42+08:00
tags:
  - tls
---

# 提升对称加密算法的性能

AES 是我们的首选对称加密算法

AES 只支持 3 种不同的密钥长度，分别是 128 位、192 位和 256 位，它们的安全性依次升高，运算时间也更长。

在 TLS1.2 及更早的版本中，仍然允许通讯双方使用 DES 算法，这是非常不安全的行为

这种分组后变换密钥的算法就叫做分组密码工作模式（下文简称为分组模式），它是影响 AES 性能的另一个因素。

CBC 分组模式中，只有第 1 组明文加密完成后，才能对第 2 组加密，因为第 2 组加密时会用到第 1 组生成的密文。因此，CBC 必然无法并行计算。

通常我们应选择可以并行计算的 GCM 分组模式，这也是当下互联网中最常见的 AES 分组算法。

由于 AES 算法中的替换法、行移位等流程对 CPU 指令并不友好，所以 Intel 在 2008 年推出了支持AES-NI 指令集的 CPU，能够将 AES 算法的执行速度从
每字节消耗 28 个时钟周期（参见这里），降低至 3.5 个时钟周期（参见这里）。在 Linux 上你可以用下面这行命令查看 CPU 是否支持 AES-NI 指令集：

```bash
$ sort -u /proc/crypto | grep module |grep aes
module       : aesni_intel
```

如果CPU支持AES-NI特性，那么应选择 AES 算法，否则可以选择CHACHA20 对称加密算法，它主要使用 ARX 操作（add-rotate-xor），CPU 执行起来更快。

# 更快地协商出密钥

RSA 密钥协商算法的最大问题是不支持前向保密（Forward Secrecy），一旦服务器的私钥泄露，过去被攻击者截获的所有 TLS 通讯密文都会被破解。解决前向
保密的是DH（Diffie–Hellman）密钥协商算法。

DH 算法的工作流程

通讯双方各自独立生成随机的数字作为私钥，而后依据公开的算法计算出各自的公钥，并通过未加密的 TLS 握手发给对方。接着，根据对方的公钥和自己的私钥，双
方各自独立运算后能够获得相同的数字，这就可以作为后续对称加密时使用的密钥。即使攻击者截获到明文传递的公钥，查询到公开的 DH 计算公式后，在不知道私钥
的情况下，也是无法计算出密钥的。这样，DH 算法就可以在握手阶段生成随机的新密钥，实现前向保密。

DH 算法的计算速度很慢，如上图所示，计算公钥以及最终的密钥时，需要做大量的乘法运算，而且为了保障安全性，这些数字的位数都很长。为了提升 DH 密钥交换
算法的性能，诞生了当下广为使用的ECDH 密钥交换算法，ECDH 在 DH 算法的基础上利用ECC 椭圆曲线特性，可以用更少的计算量计算出公钥以及最终的密钥。

依据解析几何，椭圆曲线实际对应一个函数，而不同的曲线便有不同的函数表达式，目前不被任何已知专利覆盖的最快椭圆曲线是X25519 曲线，它的表达式是

```
y^2 = x^3 + 486662x^2 + x。
```

提升密钥协商速度的另一个思路，是减少密钥协商的次数，主要包括以下 3 种方式

- 最为简单有效的方式是在一个 TLS 会话中传输多组请求，对于 HTTP 协议而言就是使用长连接，在请求中加入 Connection: keep-alive 头部便可以做到。
- 客户端与服务器在首次会话结束后缓存下 session 密钥，并用唯一的 session ID 作为标识。这样，下一次握手时，客户端只要把 session ID 传给服务器，
  且服务器在缓存中找到密钥后（为了提升安全性，缓存会定期失效），双方就可以加密通讯了。这种方式的问题在于，当 N 台服务器通过负载均衡提供 TLS 服务
  时，客户端命中上次访问过的服务器的概率只有 1/N，所以大概率它们还得再次协商密钥。
- session ticket 方案可以解决上述问题，它把服务器缓存密钥，改为由服务器把密钥加密后作为 ticket 票据发给客户端，由客户端缓存密文。其中，集群中
  每台服务器对 session 加密的密钥必须相同，这样，客户端携带 ticket 密文访问任意一台服务器时，都能通过解密 ticket，获取到密钥。

使用 session 缓存或者 session ticket 既没有前向安全性，应对重放攻击也更加困难。提升 TLS 握手性能的更好方式，是把 TLS 协议升级到 1.3 版本。

# 升级到 TLS1.3

TLS1.3（参见RFC8446）对性能的最大提升，在于它把 TLS 握手时间从 2 个 RTT 降为 1 个 RTT。

在 TLS1.2 的握手中，先要通过 Client Hello 和 Server Hello 消息协商出后续使用的加密算法，再互相交换公钥并计算出最终密钥。TLS1.3 中把
Hello 消息和公钥交换合并为一步，这就减少了一半的握手时间

![](https://www.ssl2buy.com/wp-content/uploads/2018/08/ssl2buy-tls12-13.jpg)

那 TLS1.3 握手为什么只需要 1 个 RTT 就可以完成呢？因为 TLS1.3 支持的密钥协商算法大幅度减少了，这样，客户端尽可以把常用 DH 算法的公钥计算出来，
并与协商加密算法的 HELLO 消息一起发送给服务器，服务器也作同样处理，这样仅用 1 个 RTT 就可以协商出密钥。

而且，TLS1.3 仅支持目前最安全的几个算法，比如 openssl 中仅支持下面 5 种安全套件：

- TLS_AES_256_GCM_SHA384
- TLS_CHACHA20_POLY1305_SHA256
- TLS_AES_128_GCM_SHA256
- TLS_AES_128_CCM_8_SHA256
- TLS_AES_128_CCM_SHA256

相较起来，TLS1.2 支持各种古老的算法，中间人可以利用降级攻击，在握手阶段把加密算法替换为不安全的算法，从而轻松地破解密文。如前文提到过的 DES 算法，
由于密钥位数只有 56 位，很容易破解。

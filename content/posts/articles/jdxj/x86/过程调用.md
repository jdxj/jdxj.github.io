---
title: "过程调用"
date: 2023-08-28T10:05:21+08:00
tags:
  - x86
  - asm
---

处理器可以用过程调用指令转移到这段代码执行，在遇到过程返回指令时重新返回到调用处的下一条指令接着执行。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_40.jpg)

要调用过程，需要该过程的地址。一般来说，过程的第一条指令需要一个标号，以方便引用该过程。

参数传递最简单的办法是通过寄存器。

在调用过程前，主程序会用到一些寄存器，在过程返回之后，可能还要继续使用。但是，在每个过程内部，也可能会用到一些寄存器。由于可用的寄存器很少，
所以有可能用到和主程序相同的寄存器。为了让主程序的执行不失连续性，在过程的开头，应当将本过程要用到（内容肯定会被破坏）的寄存器临时压栈，并在
返回到调用点之前出栈恢复。

# 8086处理器支持四种调用方式

## 16位相对近调用

近调用的意思是被调用的目标过程位于当前代码段内，而非另一个不同的代码段，所以只需要得到偏移地址即可。

16位相对近调用是三字节指令，操作码为0xE8，后跟16位的操作数，因为是相对调用，故该操作数是当前call指令相对于目标过程的偏移量。

- 用目标过程的汇编地址减去当前call指令的下一条指令的汇编地址，保留16位的结果。

```nasm
call near proc_1
```

近调用的特征是在指令中使用关键字“near”。“proc_1”是程序中的一个标号。在编译阶段，编译器用标号proc_1处的汇编地址减去本指令的下一条指令的汇编
地址（可以用本指令的汇编地址加上本指令的长度3得到），保留16位结果，作为机器指令的操作数部分。

关键字“near”不是必需的，如果call指令中没有提供任何关键字，则编译器认为该指令是近调用。

被调用过程可在call之前或之后, 所以call后的16位操作数是有符号数, **被调用过程的首地址必须位于距离当前call指令-32768～32767字节的地方**

在指令执行阶段，处理器看到操作码0xE8，就知道它应当调用一个过程。于是，它

1. 用指令指针寄存器IP的当前内容（它已经指向下一条指令）加上指令中的操作数，得到一个新的偏移地址。
2. 将指令指针寄存器IP的原有内容压入栈
3. 用刚才计算出的偏移地址取代指令指针寄存器IP原有的内容。这直接导致处理器的执行流转移到目标位置处。

注意以下形式, 在call指令后跟一个标号和跟一个数值没有什么不同。标号是数值的等价形式，是代表标号处的汇编地址。在指令编译阶段，它首先会被转化成
数值。所以，你在call指令后跟一个数值，只是帮了编译器的忙，帮它省了一个转化步骤，它依然会用这个数值减去当前指令的下一条指令的汇编地址，来得到
一个偏移量。

```nasm
call 0x0500
```

## 16位间接绝对近调用

这种调用也是近调用，只能调用当前代码段内的过程，指令中的操作数不是偏移量，而是被调用过程的真实偏移地址，故称为**绝对地址**。不过，这个偏移地
址不是直接出现在指令中的，而是由16位的通用寄存器或者16位的内存单元**间接**给出的。

默认ds

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_44.jpg)

由于间接绝对近调用的机器指令操作数是16位的绝对地址，因此，它**可以调用当前代码段任何位置处的过程**。

## 16位直接绝对远调用

这种调用属于段间调用(far call), 远调用既需要被调用过程所在的段地址，也需要该过程在段内的偏移地址。

```nasm
call 0x2000:0x0030
```

处理器在执行时

1. 首先将代码段寄存器CS的当前内容压栈
2. 再把指令指针寄存器IP的当前内容压栈。
3. 用指令中给出的段地址代替CS原有的内容，用指令中给出的偏移地址代替指令指针寄存器IP原有的内容。这直接导致处理器从新的位置开始执行。

## 16位间接绝对远调用

这也属于段间调用, 被调用过程所在的段地址和偏移地址是间接给出的. 

- 间接远调用必须使用关键字“far”

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_46.jpg)

段地址和偏移地址在内存中的其他位置，**指令中仅仅给出的是该位置的偏移地址**，需要处理器在执行指令的时候自行按图索骥，找到它们。

前两条指令是等效的，不同之处仅仅在于，第一条指令直接给出的是数值，而第二条指令用的是标号。

实际情况类似于

```nasm
; 0x0102是偏移地址, 0x2000是段地址
proc_1 dw 0x0102, 0x2000
; 为了调用该过程，可以在代码段内使用这条指令
call far [proc_1]
```

当这条指令执行时

1. 处理器访问由段寄存器DS指向的数据段，从指令中指定的偏移地址（由标号proc_1提供）处取得两个字（分别是段地址0x2000和偏移地址0x0102）；
2. 接着，将代码段寄存器CS和指令指针寄存器IP的当前内容分别压栈；
3. 最后，用刚才取得的段地址和偏移地址分别取代CS和IP的原值。

# 过程返回

- ret是近返回指令，从栈中弹出一个字到指令指针寄存器IP中。
- retf是远返回指令(return far), 处理器分别从栈中弹出两个字到指令指针寄存器IP和代码段寄存器CS中

尽管call指令通常需要ret/retf和它配对，遥相呼应，但ret/retf指令却并不依赖于call指令


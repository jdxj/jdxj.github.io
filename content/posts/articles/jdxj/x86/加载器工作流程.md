---
title: "加载器工作流程"
date: 2023-08-27T11:13:52+08:00
tags:
  - x86
  - asm
---

# 加载器需要了解如何加载用户程序

加载器与用户程序之间的协议部分

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_9.jpg)

```nasm
SECTION header vstart=0
```

因为它是“头部”，所以，该段当然必须是第一个被定义的段，且总是位于整个源程序的开头。

用户程序头部起码要包含以下信息

- 用户程序的尺寸，即以字节为单位的大小。这对加载器来说是很重要的，加载器需要根据这一信息来决定读取多少个逻辑扇区
- 应用程序的入口点，包括段地址和偏移地址。加载器并不清楚用户程序的分段情况，更不知道第一条要执行的指令在用户程序中的位置。因此，必须在头部给
  出第一条指令的段地址和偏移地址，这就是所谓的应用程序入口点(Entry Point)。
- 段重定位表。用户程序可能包含不止一个段, 程序加载到内存后，每个段的地址必须重新确定一下。段的重定位是加载器的工作，它需要知道每个段在用户程
  序内的位置

# 加载流程

## 1. 初始化和决定加载位置

可用于加载用户程序的空间范围

- 物理地址0x0FFFF以下，是加载器及其栈的势力范围；物理地址A0000以上，是BIOS和外围设备的势力范围
- 可用的空间就位于0x10000～9FFFF，差不多500多KB。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_19.jpg)

## 2. 从硬盘读取用户程序

### I/O接口

和处理器打交道的硬件很多，不单是硬盘，还有显示器、网络设备、扬声器（喇叭）和话筒（麦克风）、键盘、鼠标等。

总线技术

- 解决多种I/O接口与处理器相连的问题
- 总线可以认为是一排电线，所有的外围设备，包括处理器，都连接到这排电线上。但是，每个连接到这排电线上的器件都必须拥有电子开关，以使它们随时能
  够同这排电线连接，或者从这排电线上断开（脱离）。

输入输出控制设备集中器(I/O Controller Hub,ICH)芯片

- 避免各个I/O设备与处理器通信的冲突问题
- 该芯片的作用是连接不同的总线，并协调各个I/O接口对处理器的访问。在个人计算机上，这块芯片就是所谓的南桥。

计算机内部总线系统

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_23.jpg)

处理器是通过端口(Port)来和外围设备打交道的。本质上，端口就是一些寄存器，类似于处理器内部的寄存器。不同之处仅仅在于，这些叫作端口的寄存器位于
I/O接口电路中。

端口在不同的计算机系统中有着不同的实现方式。在一些计算机系统中，端口号是映射到内存地址空间的。而在另一些计算机系统中，端口是独立编址的，不和
内存发生关系。

- INTEL处理器，早期是独立编址的，现在既有内存映射的，也有独立编址的。

在INTEL的系统中，只允许65536（十进制数）个端口存在，端口号从0到65535(0x0000～0xffff)。因为是独立编址，所以，端口的访问不能使用类似于mov
这样的指令，取而代之的是in和out指令。

```nasm
in al, dx
; 或
in ax, dx
```

### 通过硬盘控制器端口读扇区数据

采用LBA28来访问硬盘. 个人计算机上的主硬盘控制器被分配了8位端口，端口号从0x1f0到0x1f7。

1. 设置要读取的扇区数量

```nasm
mov dx, 0x1f2; 目标端口0x1f2
mov al, 0x01 ; 1个扇区
out dx, al
```

如果写入的值为0，则表示要读取256个扇区。每读一个扇区，这个数值就减1。因此，如果在读写过程中发生错误，该端口包含着尚未读取的扇区数。

2. 设置起始LBA扇区号

28位的扇区号太长，需要将其分成4段，其中，0x1f3号端口存放的是0～7位；0x1f4号端口存放的是8～15位；0x1f5号端口存放的是16～23位，最后4位在
0x1f6号端口。

假定我们要读写的起始逻辑扇区号为0x02

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_33.jpg)

在现行的体系下，每个PATA/SATA接口允许挂接两块硬盘，分别是主盘(Master)和从盘(Slave)。0x1f6端口的低4位用于存放逻辑扇区号的24～27位，第4位
用于指示硬盘号，0表示主盘，1表示从盘。高3位是“111”，表示LBA模式(0xe0)。

端口1f6各位的含义

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_36.jpg)

3. 向端口0x1f7写入0x20，请求硬盘读

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_34.jpg)

4. 等待读写操作完成

端口0x1f7既是命令端口，又是状态端口。硬盘内部操作期间，它将0x1f7端口的第7位置“1”，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明
自己已经忙完了，同时将第3位置“1”，意思是准备好了，请求主机发送或者接收数据。

端口0x1f7部分状态位的含义

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_37.jpg)

接收数据

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_35.jpg)

`and al, 0x88`这条指令保留住寄存器AL中的第7位和第3位，其他无关的位都清零。

5. 连续取出数据

0x1f0是硬盘接口的数据端口，而且还是一个16位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。

```nasm
    mov cx, 256        ; 总共要读取的字数
    mov dx, 0x1f0
.readw:
    in ax, dx
    mov [bx], ax
    add bx, 2
    loop .readw
```

0x1f1端口是错误寄存器，包含硬盘驱动器最后一次执行命令后的状态


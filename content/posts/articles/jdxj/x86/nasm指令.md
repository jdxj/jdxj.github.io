---
title: "nasm指令"
date: 2023-08-23T16:14:51+08:00
tags:
  - x86
  - asm
---

# div 无符号除法指令

可以做两种类型的除法

- 16位被除数(必须放在ax中), 8位除数(通用寄存器/内存), 执行后商在al中, 余数在ah中

```nasm
div cl
div byte [0x0023]

; 使用标号
dividnd dw 0x3f0
divisor db 0x3f
...
mov ax, [dividnd] ; 相当于 mov ax, [0xf000], 相对于ds
div byte [divisor]; 相当于 div byte [0xf002]
```

- 32位被除数, 16位除数

因为16位的处理器无法直接提供32位的被除数，故要求被除数的高16位在寄存器DX中，低16位在寄存器AX中。
指令执行后，商在寄存器AX中，余数在寄存器DX中

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt008_36.jpg)

```nasm
div cx
div word [0x0230]
```

# idiv 有符号除法

用法和div相同

```nasm
mov ax, 0x0400
mov bl, 0xf0
idiv bl
```

# mul

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_81.jpg)

mul指令可以用8位的通用寄存器或者内存单元中的数和寄存器AL中的内容相乘，结果是16位，在AX寄存器中；也可以用16位的通用寄存器或者内存单元中的数
和寄存器AX中的内容相乘，结果是32位，高16位和低16位分别在DX和AX中。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_82.jpg)

# xor 异或

目的操作数可以是通用寄存器和内存单元，源操作数可以是通用寄存器、内存单元和立即数（不允许两个操作数同时为内存单元）

```nasm
; 清零
xor dx, dx
```

`mov dx，0`的机器码是BA 00 00；而`xor dx，dx`的机器码则是31 D2，不但较短，而且，因为`xor dx，dx`的两个操作数都是通用寄存器，所以执行速
度最快。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt008_42.jpg)

# add

- 目的操作数可以是8位或者16位的通用寄存器，或者指向8位或者16位实际操作数的内存地址；
- 源操作数可以是相同数据宽度的8位或者16位通用寄存器、指向8位或者16位实际操作数的内存地址，或者立即数，但不允许两个操作数同时为内存单元。
- 相加后，结果保存在目的操作数中。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt008_44.jpg)

# sub

目的操作数可以是8位或者16位通用寄存器，也可以是8位或者16位的内存单元；源操作数可以是通用寄存器，也可以是内存单元或者立即数（不允许两个操作数
同时为内存单元）。

```nasm
sub ah, al
sub dx, ax
sub [label_a], ch
```

# 无条件转移指令

## 相对短转移

相对短转移的操作码为0xEB，操作数是相对于目标位置的偏移量，仅1字节，是个有符号数。由于这个原因，该指令属于段内转移指令，而且只允许转移到距离
当前指令-128～127字节的地方。相对短转移指令必须使用关键字“short”。

```nasm
jmp short infinite
```

在源程序编译阶段，编译器会检查标号infinite所代表的值，如果数值超过了1字节所能允许的数值范围，则无法通过编译。否则，编译器用目标位置的汇编地
址减去当前指令的下一条指令的汇编地址，保留1字节的结果，作为机器指令的操作数。

相对短转移指令的汇编语言操作数只能是标号和数值。

```nasm
jmp short 0x2000
```

在指令执行时，处理器把指令中的操作数加到指令指针寄存器IP上，这会导致指令的执行流程转向目标地址处。

## 16位相对近转移

机器指令操作码为0xE9，而且，该指令的长度为3字节，操作码0xE9后面还有一个16位（2字节）的操作数。

因为是近转移，故其属于段内转移。“相对”的意思同样是指它的操作数是一个相对量，是相对于目标位置处的偏移量。在源程序编译阶段，编译器用目标位置的
汇编地址减去当前指令的下一条指令的汇编地址，保留16位的结果，作为机器指令的操作数。由于这是一个16位的有符号数，故可以转移到距离当前指令
-32768～32767字节的地方。

16位相对近转移指令应当使用关键字“near”

```nasm
jmp near infinite
jmp near 0x3000
```

如果没有指定关键字short或者near，那么，如果目标位置距离当前指令-128～127字节，则自动采用short；否则，采用near。

## 16位间接绝对近转移

这种转移方式也是近转移，即只在段内转移。但是，转移到的目标偏移地址不是在指令中直接给出的，而是用一个16位的通用寄存器或者内存地址来间接给出的。

- 指令中的关键字“near”可以省略

```nasm
jmp near bx
jmp near cx
jmp [jump_dest]; ds
```

## 16位直接绝对远转移

```nasm
jmp 0x0000:0x7c00
```

执行这条指令后，处理器用指令中给出的段地址代替段寄存器CS的原有内容，用给出的偏移地址代替IP寄存器的原有内容，从而跳转到另一个不同的代码段中，
即执行一个段间转移。

## 16位间接绝对远转移

远转移的目标地址可以通过访问内存来间接得到，这叫间接远转移，但是要使用关键字“far”。假如在某程序的数据段内声明了标号jump_far，并在其后初始化
了两个字：

```nasm
; 偏移地址, 段地址
jump_far dw 0x33c0, 0xf000
```

转移指令

```nasm
jmp far [jump_far]
```

处理器执行这条指令后，访问段寄存器DS所指向的数据段，从指令中给出的偏移地址处取出两个字，分别用来替代段寄存器CS和指令指针寄存器IP的内容。

```nasm
jmp far [0x04]
jmp far [bx]
jmp far [bx + si]
```

“16位”的意思是，要转移到的目标位置的偏移地址是16位的。

# 条件转移指令

## jns

```nasm
; 如果未设置符号位，则转移到标号“show”所在的位置处执行。
jns show
```

它和jmp指令很相似，它也是相对转移指令，编译后的机器指令操作数也是一个相对偏移量，是用标号处的汇编地址减去当前指令的下一条指令的汇编地址得到的。

相反的指令js

## jz

结果为零（ZF标志为1）则转移；jnz的意思是结果不为零（ZF标志为0）则转移。

## jo

结果溢出（OF标志为1）则转移，jno的意思是结果未溢出（OF标志为0）则转移。

## jc

有进位（CF标志为1）则转移，jnc的意思是没有进位（CF标志为0）则转移。

## jp

如果PF标志为1则转移，jnp的意思是如果PF标志不为1（为0）则转移。

## 与cmp配合的条件转移指令

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt009_52.jpg)
![](https://res.weread.qq.com/wrepub/CB_3300050845_txt009_53.jpg)

## jcxz(jump if CX is zero)

当寄存器CX的内容为零时则转移。

如果寄存器CX的内容为零，则转移到标号show；否则不转移，继续往下执行。

```nasm
jcxz show
```

# cmp

目的操作数可以是8位或者16位通用寄存器，也可以是8位或者16位内存单元；源操作数可以是与目的操作数宽度一致的通用寄存器、内存单元或者立即数，但两
个操作数同时为内存单元的情况除外。

```nasm
cmp al, 0x08
cmp dx, bx
cmp [label_a], cx
```

cmp指令在功能上和sub指令相同，唯一不同之处在于，cmp指令仅仅根据计算的结果设置相应的标志位，而不保留计算结果，因此也就不会改变两个操作数的原
有内容。cmp指令将会影响到CF、OF、SF、ZF、AF和PF标志位。

# times 重复后面的指令

```nasm
times 20 mov ax, bx
```

# 批量数据传送

- movsb
- movsw

movsb和movsw指令执行时，原始数据串的段地址由DS指定，偏移地址由SI指定，简写为DS:SI；要传送到的目的地址由ES:DI指定；传送的字节数(movsb)或
者字数(movsw)由CX指定。

除此之外，还要指定是正向传送还是反向传送，正向传送是指传送操作的方向是从内存区域的低地址端到高地址端；反向传送则正好相反。正向传送时，每传送
一字节(movsb)或者一个字(movsw)，SI和DI加1或者加2；反向传送时，每传送一字节(movsb)或者一个字(movsw)时，SI和DI减去1或者减去2。不管是正向
传送还是反向传送，也不管每次传送的是字节还是字，每传送一次，CX的内容自动减1

# 方向控制

- cld, 传送方向从低到高
- std, 传送方向从高到低

# rep 重复执行指令

cx不为零则重复

```nasm
rep movsw
```

# loop 循环

```nasm
digit: 
         xor dx,dx
         div si
         mov [bx],dl ;保存数位
         inc bx 
         loop digit
```

在执行loop时

- 将cx减1
- 如果cx不为零, 则转移到指定位置, 否则执行后面的指令

# inc 加1

```nasm
inc al
inc byte [bx]; ds
inc word [label_a]; ds
```

# dec 减1

# neg 求相反数

```nasm
neg al
neg dx
neg word [label_a]
```

# 扩展有符号数

- cbw(convert byte to word)
- cwd(convert word to double-world)

cbw操作al, 扩展到ax

- 如果寄存器AL中的内容为01001111，那么执行该指令后，寄存器AX中的内容为0000000001001111；
- 如果寄存器AL中的内容为10001101，执行该指令后，寄存器AX中的内容为1111111110001101。

cwd操作ax, 扩展到dx:ax

- 如果寄存器AX中的内容为0100111101111001，那么执行该指令后，寄存器DX中的内容为0000000000000000，寄存器AX中的内容不变；
- 如果寄存器AX中的内容为1000110110001011，那么执行该指令后，寄存器DX中的内容为1111111111111111，寄存器AX中的内容同样不变。

**事实上，符号位是数的一部分，和其他比特一起共同表示数的大小，同时又用来判断数的正负。**

# or

目的操作数可以是8位或者16位的通用寄存器，或者包含8/16位实际操作数的内存单元，源操作数可以是与目的操作数数据宽度相同的通用寄存器、内存单元或
者立即数。不允许目的操作数和源操作数都是内存单元的情况出现。结果位于目的操作数中。

```nasm
mov al, 0x55
or al, 0xaa
```

# and

and指令的两个操作数都应当是字节或者字。其中，目的操作数可以是通用寄存器和内存单元；源操作数可以是通用寄存器、内存单元或者立即数，但不允许两个
操作数同时为内存单元，而且它们在数据宽度上应当一致。结果保存在目的操作数中。

```nasm
and al, 0x55
```

# push

在16位的处理器上，push指令的操作数可以是16位的寄存器或者内存单元。

```nasm
push ax
push word [label_a]
```

处理器在执行push指令时，首先将栈指针寄存器SP的内容减去操作数的字长（以字节为单位的长度，在16位处理器上是2），然后，把要压入栈的数据存放到逻
辑地址SS:SP所指向的内存位置

**8086处理器不能在栈中压入立即数**

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt010_13.jpg)

# pop

将逻辑地址SS:SP处的一个字弹出到16位寄存器/内存, 然后将SP的内容加上操作数的字长(2)。

```nasm
pop ax
pop word [label_a]
```



# 其他

在8086处理器上，如果要用寄存器来提供偏移地址，只能使用寄存器BX、SI、DI、BP，不能使用其他寄存器。

INTEL8086处理器只允许以下几种基址寄存器和变址寄存器的组合

```nasm
[bx + si]
[bx + di]
[bp + si]
[bp + di]
```

# in, out

in指令的目的操作数必须是寄存器AL或者AX，当访问8位的端口时，使用寄存器AL；访问16位的端口时，使用AX。in指令的源操作数应当是寄存器DX，用来指
定端口号。

in al，dx的机器指令码是0xEC，in ax，dx的机器指令码是0xED，都是一字节的。之所以如此简短，是因为in指令不允许使用别的通用寄存器，也不允许使
用内存地址作为操作数。

in指令还有2字节的形式。此时，前一字节是操作码0xE4或者0xE5，分别用于指示8位或者16位端口访问；后一字节是立即数，指示端口号。

- 这种指令形式的源操作数部分只允许一字节，故只能访问0～255(0x00～0xff)号端口

out指令正好和in指令相反，目的操作数可以是8位立即数或者寄存器DX，源操作数必须是寄存器AL或者AX。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_30.jpg)

# shr 逻辑右移

“挤”出来的比特被移到标志寄存器的CF位, 左边空出来的位置用比特“0”填充。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_53.jpg)

格式

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_54.jpg)

例子

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_55.jpg)
![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_56.jpg)

注意，源操作数为1的逻辑右移指令是特殊设计的优化指令，比如以上的shr ah，1，它的机器码是D1 E8；而类似的指令shr ah，5则拥有完全不同的机器码
C1 E8 05。

如果shr指令的源操作数是寄存器，则只能使用CL. 寄存器CL只用来提供移动次数，而不用于限定和暗示目的操作数的字长。因此，对于目的操作数是内存地址
的情况，必须用关键字byte或者word等来加以限定。

```nasm
shr al, cl
shr byte [bx], cl
```

shr的配对指令是逻辑左移指令shl(SHift logical Left)，它的指令格式和shr相同，只不过它是向左移动的。

# ror 循环右移

每右移一次，移出的比特既送到标志寄存器的CF位，也送进左边空出的位。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt011_59.jpg)

ror的配对指令是循环左移指令rol(ROtate Left)。ror、rol、shl、shr的指令格式都是相同的。

# 伪指令

## 声明空间

- db(declare byte) 声明字节

```nasm
; 声明5个初始值为0的字节
db 0,0,0,0,0
```

- dw(declare word) 声明字
- dd(declare double) 声明双字
- dq(declare quad word) 声明四字

## resb

REServe Byte, 保留空间, 但不初始化

```nasm
; 保留256B空间
resb 256
;类似指令
resw 100 ; 声明100个未初始化的字
resd 50  ; 声明50个未初始化的双字
```

# iret

中断返回指令

没有操作数，执行这条指令时，处理器依次从栈中弹出数值到IP、CS和标志寄存器。

# cli

清中断

# sti

开放中断

# hlt


使处理器停止执行指令，并处于停机状态，这将降低处理器的功耗。处于停机状态的处理器可以被外部中断唤醒并恢复执行，而且会继续执行hlt后面的指令。

# test

test指令在功能上和and指令是一样的，都是将两个操作数按位进行逻辑“与”，并根据结果设置相应的标志位。但是，test指令执行后，运算结果被丢弃

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt013_17.jpg)



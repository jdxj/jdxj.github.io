---
title: "保护模式"
date: 2023-09-01T12:33:21+08:00
tags:
  - x86
  - asm
  - GDT
---

# 全局描述符表

在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，在每个段能够访问之前，必须先进行登记。

- 当你访问的偏移地址超出段的界限时，处理器就会阻止这种访问，并产生一个叫作内部异常的中断。

和一个段有关的信息需要8字节来描述，所以称为段描述符(Segment Descriptor)，每个段都需要一个描述符。为了存放这些描述符，需要在内存中开辟出一
段空间。在这段空间里，所有的描述符都是挨在一起集中存放的，这就构成了一个描述符表。

- 最主要的描述符表是**全局描述符表**(Global Descriptor Table, GDT)，所谓全局，意味着该表是为整个软硬件系统服务的。
- 在进入保护模式前，必须要定义全局描述符表。

**全局描述符表寄存器**GDTR

- GDTR的32位线性基地址部分保存的是全局描述符表在内存中的起始线性地址
- 16位边界部分保存的是全局描述符表的边界(表内最后1字节的偏移量)

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt015_2.jpg)

因为GDT的界限是16位的，所以，该表最大是2^16字节，也就是65536字节(64KB)。又因为一个描述符占8字节，故最多可以定义8192个描述符。

由于在进入保护模式之后，处理器要立即按新的内存访问模式工作，所以，必须在进入保护模式之前定义GDT。但是，由于在实模式下只能访问1MB的内存，故
**GDT通常都定义在1MB以下的内存范围中**。当然，允许在进入保护模式之后换个位置重新定义GDT。

GDT和GDTR的关系

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt015_3.jpg)

# 存储器的段描述符

进入保护模式前的内存映象

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt015_4.jpg)

描述符不是由用户程序自己建立的，而是在加载时，由操作系统根据你的程序结构而建立的，而用户程序通常是无法建立和修改GDT的, 超出这个范围，或者未
按预定的方法访问这些段，都将被处理器阻止。

存储器的段描述符格式

- 下面是低32位（低双字）
- 上面是高32位（高双字）

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt015_5.jpg)

- 描述符中指定了32位的段起始地址，以及20位的段边界。
- 在实模式下，段地址并非真实的物理地址，在计算物理地址时，还要左移4位（乘以16）
- 在32位保护模式下，段地址是32位的线性地址，如果未开启分页功能，该线性地址就是物理地址。
- 描述符中的段基地址和段界限不是连续的, 32位处理器为了保持同80286的兼容，只能在旧描述符的格式上进行扩充，这是不得已的做法

段基地址可以是0～4GB范围内的任意地址，不过，还是建议应当选取那些16字节对齐的地址。尽管对于INTEL处理器来说，允许不对齐的地址，但是，对齐能够
使程序在访问代码和数据时的性能最大化。

有两种决定段大小的方法

- 规定偏移量从0开始，那么**偏移量的最大值就是段边界**。这种方法适用于任何类型的段，包括代码段、数据段和栈段
- 段内偏移量是从最大值开始往下递减的，而且这种方法是为栈段设计的。对于这种段，描述符中的**段界限就是段内不可使用的最小偏移量**
  - 访问栈段时，取决于段描述符中的B位, 可能使用SP，也可能使用ESP
  - 如果是使用SP，段内偏移量的最大值是0xFFFF
  - 如果是使用ESP，段内偏移量的最大值是0xFFFFFFFF

G位是粒度(Granularity)位，用于解释段界限的含义。

- 当G位是“0”时，段界限以字节为单位。此时，段的扩展范围是从1字节到1兆字节(1B～1MB)，因为描述符中的界限值是20位的。
- 如果该位是“1”，那么，段界限是以4KB为单位的。这样，段的扩展范围（段的大小）是从4KB到4GB。

S位用于指定描述符的类型(Descriptor Type)。

- 当该位是“0”时，表示是一个系统段
- 为“1”时，表示是一个代码段或者数据段（栈段也是特殊的数据段）。

DPL表示描述符的特权级(Descriptor Privilege Level, DPL)。共有4种处理器支持的特权级别，分别是0、1、2、3，其中0是最高特权级别，3是最低特
权级别。

- 特权级是一个数字，可以赋给一个程序，用来决定该程序能够执行哪些指令，或者能够访问哪些系统资源；也可以赋给系统资源，用来决定哪些程序可以访问
  它们。
- 刚进入保护模式时执行的代码具有最高特权级0（可以看成从实模式那里继承来的），这些代码通常都是操作系统代码，因此它的特权级别最高。每当操作系统
  加载一个用户程序时，它通常都会指定一个稍低的特权级，比如3特权级。
- 不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令（特权指令）只能由0特权级的程序来执行，为的就是安全。
- 描述符的特权级用于指定要访问该段所必须具有的最低特权级。如果这里的数值是2，那么，只有特权级别为0、1和2的程序才能访问该段，而特权级为3的程
  序访问该段时，处理器会予以阻止。

P是段存在位(Segment Present)。P位用于指示描述符所对应的段是否存在。

- 一般来说，描述符所指示的段都位于内存中。但是，当内存空间紧张时，有可能只是建立了描述符，对应的内存空间并不存在，这时，就应当把描述符的P位
  清零，表示段并不存在。另外，同样是在内存空间紧张的情况下，会把很少用到的段换出到硬盘中，腾出空间给当前急需内存的程序使用（当前正在执行的），
  这时，同样要把段描述符的P位清零。当再次轮到它执行时，再装入内存，然后将P位置1。
- P位是由处理器负责检查的。每当通过描述符访问内存中的段时，如果P位是“0”，处理器就会产生一个异常中断。通常，该中断处理过程是由操作系统提供的，
  该处理过程的任务是负责将该段从硬盘换回内存，并将P位置1。

D/B位是“默认操作尺寸”(Default Operation Size)或者“默认的栈指针尺寸”(Default Stack Pointer Size)，又或者“上部边界”(Upper Bound)标
志。

- 设立该标志位，主要是为了能够在32位处理器上兼容运行16位保护模式的程序。尽管这种程序现在已经非常罕见了
- 该标志位对不同的段有不同的效果。
  - 对于代码段，此位称作“D”位，用于指示指令中默认的有效地址和操作数尺寸。D=0表示指令中的有效地址或者操作数是16位的；D=1，指示32位的有效地
    址或者操作数。
  - 对于栈段和向下扩展的数据段来说，该位被叫作“B”位，用于指定在进行隐式的栈操作时，是使用寄存器SP还是寄存器ESP，隐式的栈操作指令包括push、
    pop和call等。如果该位是“0”，在访问那个段时，使用寄存器SP，否则就是使用寄存器ESP。

L位是64位代码段标志(64-bit Code Segment)，保留此位给64位处理器使用。

TYPE字段共4位，用于指示描述符的子类型，或者说是类别

- 对于数据段来说，这4位分别是X、E、W、A位；而对于代码段来说，这4位则分别是X、C、R、A位。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt015_6.jpg)

- X表示是否可以执行(eXecutable)。数据段总是不可执行的，X=0；代码段总是可以执行的，X=1。
- 对于数据段来说，E位指示段的扩展方向。E=0是向上扩展的，也就是向高地址方向扩展的，是普通的数据段；E=1是向下扩展的，也就是向低地址方向扩展的，
  通常是栈段。
- W位指示段的读写属性，或者说段是否可写，W=0的段是不允许写入的，否则会引发处理器异常中断；W=1的段是可以正常写入的。
- 对于代码段来说，C位指示段是否为特权级依从的(Conforming)。C=0表示非依从的代码段，这样的代码段可以从与它特权级相同的代码段调用，或者通过门
  调用；C=1表示允许从低特权级的程序转移到该段执行。
- R位指示代码段是否允许读出。代码段总是可以执行的，但是，为了防止程序被破坏，它是不能写入的。至于是否有读出的可能，由R位指定。R=0表示不能读
  出，如果企图去读一个R=0的代码段，会引发处理器异常中断；如果R=1，则代码段是可以读出的，即可以把这个段的内容当成ROM一样使用。
- 数据段和代码段的A位是已访问(Accessed)位，用于指示它所指向的段最近是否被访问过。在描述符创建的时候，应该清零。之后，每当该段被访问时，处理
  器自动将该位置“1”。对该位的清零是由软件（操作系统）负责的，通过定期监视该位的状态，就可以统计出该段的使用频率。当内存空间紧张时，可以把不
  经常使用的段退避到硬盘上，从而实现虚拟内存管理。

AVL是软件可以使用的位(Available)，通常由操作系统来用，处理器并不使用它。

# 安装存储器的段描述符并加载GDTR

处理器规定，GDT中的第一个描述符必须是空描述符，或者叫“哑描述符”、NULL描述符

- 一个未初始化的选择子往往也是0，使用这样的描述符将默认选择GDT中的0号描述符，但未必是我们的本意。因此处理器要求将第一个描述符定义成空描述符。

加载描述符表的线性基地址和界限到寄存器GDTR，这要使用lgdt指令，该指令的格式为

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt015_8.jpg)

lgdt指令从指定的内存地址处加载6字节的数据到寄存器GDTR，其中包括32位的GDT线性地址及16位的界限值。

- 该指令在实模式和保护模式下都可以执行，但是在实模式下使用16位的有效地址m访问内存；在32位保护模式下使用32位的有效地址m访问内存。
- 在这6字节的内存区域中，要求前（低）16位是GDT的界限值，后（高）32位是GDT的基地址。
- 在初始状态下（计算机启动之后），寄存器GDTR的基地址被初始化为0x00000000；界限值为0xFFFF。
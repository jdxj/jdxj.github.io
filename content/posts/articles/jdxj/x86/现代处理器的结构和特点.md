---
title: "现代处理器的结构和特点"
date: 2023-08-31T15:59:40+08:00
tags:
  - x86
---

# 流水线

为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解成若干个细小的步骤，并分配给相应的单元来完成。各个单元的执行是独立的、并行的。如
此一来，**各个步骤的执行在时间上就会重叠起来**，这种执行指令的方法就是流水线(Pipe-Line)技术。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt014_9.jpg)

2000年之后推出的Pentium 4处理器采用了NetBurst微结构，它进一步分解指令的执行过程，采用了31级超深流水线。

# 高速缓存

- 寄存器的速度是最快的，原因在于它使用了触发器，这是一种利用反馈原理制作的存储电路. 触发器的工作速度是纳秒(ns)级别的
- 制作内存芯片的材料一般是电容和单个的晶体管，由于电容需要定时刷新，使得它的访问速度变得很慢，通常是几十纳秒
- 硬盘是机电设备，是机械和电子的混合体，它的速度最慢，通常在毫秒级(ms)。

在这种情况下，因为需要等待内存和硬盘这样的慢速设备，处理器便无法全速运行。为了缓解这一矛盾，高速缓存(Cache)技术应运而生。高速缓存是处理器与
内存(DRAM)之间的一个静态存储器，容量较小，但速度可以与处理器匹配。

高速缓存的用处源于程序在运行时所具有的**局部性规律**。

高速缓存的装载是以块为单位的，包括那个所需数据的邻近内容。为此，需要额外的时间来等待块从内存载入高速缓存，在该过程中所损失的时间称为不中惩罚
(miss penalty)。

高速缓存的复杂性在于，每一款处理器可能都有不同的实现。在一些复杂的处理器内部，会存在多级Cache，分别应用于各个独立的执行部件。

# 乱序执行

为了实现流水线技术，需要将指令拆分成更小的可独立执行部分，即拆分成微操作(micro-operations)，简写为μops。

一旦将指令拆分成微操作，处理器就可以在必要的时候乱序执行(Out-Of-Order Execution)程序。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt014_13.jpg)

这里，指令add eax，［mem2］可以拆分为两个微操作。如此一来，在执行逻辑左移指令的同时，处理器可以提前从内存中读取mem2的内容。典型的，如果数
据不在高速缓存中（不中），那么处理器在获取mem1的内容之后，会立即开始获取mem2的内容，与此同时，shl指令的执行早就开始了。

将指令拆分成微操作，也可以使得栈的操作更有效率

```nasm
push eax
call func
```

push eax指令可以拆分成两个微操作，即可以表述为以下的等价形式

```nasm
sub esp, 4
mov [esp], eax
```

即使寄存器EAX的内容还没有准备好，微操作sub esp，4也可以执行。call指令执行时需要在当前栈中保存返回地址，在以前，该操作只能等待push eax指令
执行结束，因为它需要ESP的新值。感谢微操作，现在，call指令在微操作sub esp，4执行结束时就可以无延迟地立即开始执行。

# 寄存器重命名

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt014_16.jpg)

以上代码片段做了两件事，但互不相干：将mem1里的内容左移3次（乘以8），并将mem3里的内容加2。如果我们为最后三条指令使用不同的寄存器，那么将更明
显地看出这两件事的无关性。并且，处理器实际上也是这样做的。处理器为最后三条指令使用了另一个不同的临时寄存器，因此，左移（乘法）和加法可以并行
地处理。

IA-32架构的处理器只有8个32位通用寄存器，但通常都会被我们全部派上用场（甚至还觉得不够）。因此，我们不能奢望在每个计算当中都使用新的寄存器。
不过，在处理器内部，却有大量的临时寄存器可用，处理器可以重命名这些寄存器以代表一个逻辑寄存器，比如EAX。

寄存器重命名以一种完全自动和非常简单的方式工作。每当指令写逻辑寄存器时，处理器就为那个逻辑寄存器分配一个新的临时寄存器。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt014_17.jpg)

假定现在mem1的内容在高速缓存里，可以立即取得，但mem2的内容不在高速缓存中。这意味着，左移操作可以在加法之前开始（使用临时寄存器代替EAX）。为
左移的结果使用一个新的临时寄存器，其好处是寄存器EAX中仍然是以前的内容，它将一直保持这个值，直到寄存器EBX中的内容就绪，然后同它一起做加法运算。
如果没有寄存器重命名机制，左移操作将不得不等待从内存中读取mem2的内容到寄存器EBX及加法操作完成。

在所有的操作都完成之后，那个代表寄存器EAX最终结果的临时寄存器的内容被写入真实的寄存器EAX中，该处理过程称为**引退**(Retirement)。

所有通用寄存器、栈指针、标志、浮点寄存器，甚至段寄存器都有可能被重命名。

# 分支目标预测

流水线并不是百分之百完美的解决方案。实际上，有很多潜在的因素会使得流水线不能达到最佳的效率。一个典型的情况是，如果遇到一条转移指令，则后面那
些已经进入流水线的指令就都无效了。换句话说，我们必须清空(Flush)流水线，从要转移到的目标位置处重新取指令放入流水线。

在现代处理器中，流水线操作分为很多步骤，包括取指令、译码、寄存器分配和重命名、微操作排序、执行和引退。

流水线的最大问题是代码中经常存在分支。举个例子，一个条件转移允许指令流前往任意两个方向。如果这里只有一个流水线，那么，直到那个分支开始执行，
在此之前，处理器将不知道应该用哪个分支填充流水线。流水线越长，处理器在用错误的分支填充流水线时，浪费的时间越多。

分支预测的核心问题是，转移会发生还是不会发生。换句话说，条件转移指令的条件会不会成立。

```nasm
jne branch5
```

- 在这条指令还没有执行的时候，处理器就必须提前预测相等的条件在这条指令执行的时候是否成立。这当然是很困难的，几乎不可能。想想看，如果能够提前
  知道结果，还执行这些指令干嘛。
- 但是，从统计学的角度来看，有些事情一旦出现，下一次还会出现的概率较大。一个典型的例子就是循环

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt014_19.jpg)

当jnz指令第一次执行时，转移一定会发生。那么，处理器就可以预测，下一次它还会转移到标号lops处，而不是顺序往下执行。事实上，
**这个预测通常是很准的**。

在处理器内部，有一个小容量的高速缓存器，叫分支目标缓存器(Branch Target Buffer, BTB)。当处理器执行了一条分支语句后，它会在BTB中记录当前
指令的地址、分支目标的地址，以及本次分支预测的结果。下一次，在那条转移指令实际执行前，处理器会查找BTB，看有没有最近的转移记录。如果能找到对
应的条目，则推测执行和上一次相同的分支，把该分支的指令送入流水线。

当该指令实际执行时，如果预测是失败的，那么，清空流水线，同时刷新BTB中的记录。这个代价较大。

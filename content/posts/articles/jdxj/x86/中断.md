---
title: "中断"
date: 2023-08-29T15:30:42+08:00
tags:
  - x86
---

# 外部硬件中断

从处理器外面来的中断信号

外部硬件中断是通过两个信号线引入处理器内部的。从很早的时候起，也就是8086处理器的时代，这两根线的名字就叫NMI和INTR。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt013_1.jpg)

- 可屏蔽中断. 对于那些不紧急，不用着急处理的中断信号，应该从INTR引脚输入。
- 非屏蔽中断(Non Maskable Interrupt, NMI). 所有严重事件都必须无条件地加以处理，由这类事件引发的中断信号应当通过NMI引脚送入处理器
  - 电池即将耗尽、内存校验错误、I/O检验错误

## 非屏蔽中断

尽管非屏蔽中断在处理器内部是不可屏蔽的, 但是，在处理器外部却有一个开关来控制非屏蔽中断信号能否进入处理器

INTEL处理器规定，NMI中断信号由0跳变到1后，至少要维持4个以上的时钟周期才算是有效的，才能被识别。

当一个中断发生时，处理器将会通过中断引脚NMI和INTR得到通知。除此之外，它还应当知道发生了什么事，以便采取适当的处理措施。每种类型的中断都被统
一编号，这称为**中断类型号**、**中断向量**或者**中断号**。

由于不可屏蔽中断的特殊性——几乎所有触发NMI的事件对处理器来说都是致命的，甚至是不可纠正的。在这种情况下，努力去搞清楚发生了什么，通常没有太大
的意义，这样的事最好留到关机之后，让专业维修人员来做。也正是这个原因，**在实模式下，NMI被赋予了统一的中断号2，不再进行细分**。一旦发生2号中
断，处理器和软件系统通常会放弃继续正常工作的“念头”，也不会试图纠正已经发生的问题和错误，很可能只是由软件系统给出一个提示信息。

## 可屏蔽中断

- 需要区分中断的类型和来源
- 需要一个代理，来接受外部设备发出的中断信号
- 该代理的任务还包括对它们进行仲裁，以决定让它们中的哪一个优先向处理器提出服务请求

单处理器系统的中断机制

- 8259中断代理芯片(中断控制器)

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt013_2.jpg)

INTEL处理器允许256个中断，中断号的范围是0～255，8259负责提供其中的15个，但中断号并不固定。之所以不固定，是因为当初设计的时候，允许软件根
据自己的需要灵活设置中断号，以防止发生冲突。该中断控制器芯片有自己的端口号，可以像访问其他外部设备一样用in和out指令来改变它的状态，包括各引
脚的中断号。正是因为这样，它又叫可编程中断控制器(Programmable Interrupt Controller, PIC)。

8259主片的引脚0(IR0)接的是系统定时器/计数器芯片；从片的引脚0(IR0)接的是实时时钟芯片RTC. 这两块芯片的固定连接即使是在硬件更新换代非常频繁
的今天，也依然没有改变。

在8259芯片内部，有中断屏蔽寄存器(Interrupt Mask Register, IMR)，这是个8位寄存器，对应着该芯片的8个中断输入引脚，对应的位是0还是1，决定
了从该引脚来的中断信号是否能够通过8259送往处理器（0表示允许，1表示阻断，这可能出乎你的意料）

- 主片的端口号是0x20和0x21，从片的端口号是0xa0和0xa1
- 可以通过这些端口访问8259芯片，设置它的工作方式，包括IMR的内容。

当一个中断正在处理时，其他中断也会陆续到来，甚至会有多个中断同时发生的情况, 8259芯片会记住它们，并按一定的策略决定先为谁服务

中断的优先级和引脚是相关的，主片的IR0引脚优先级最高，IR7引脚优先级最低，从片也是如此。当然，还要考虑到从片是级联在主片的IR2引脚上的。

当一个中断事件正在处理时，如果来了一个优先级更高的中断事件时，允许暂时中止当前的中断处理，先为优先级较高的中断事件服务，这称为中断嵌套。

## 实模式下的中断向量表

在实模式下，处理器要求将中断处理程序的入口点集中存放到内存中从物理地址0x00000开始到0x003ff结束，共1KB的空间内，这就是所谓的中断向量表
(Interrupt Vector Table, IVT)。

每个中断在中断向量表中占2个字，分别是中断处理程序的偏移地址和逻辑段地址。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt013_3.jpg)

1. 当中断发生时，如果从外部硬件到处理器之间的道路都是畅通的，那么，处理器在执行完当前的指令后，会立即着手为硬件服务。它首先会响应中断，告诉
   8259芯片准备着手处理该中断。接着，它还会要求8259芯片把中断号送过来。
2. 处理器拿着这个中断号，要按顺序做以下几件事
   - 保护断点的现场。首先要将标志寄存器FLAGS压栈，然后清除它的IF位和TF位。再将当前的代码段寄存器CS和指令指针寄存器IP压栈。
   - 执行中断处理程序。由于处理器已经拿到了中断号，它将该号码乘以4, 就得到了该中断入口点在中断向量表中的偏移地址。接着，从表中依次取出中断程
     序的偏移地址和段地址，并分别传送到IP和CS，处理器就开始执行中断处理程序了。
   - 返回到断点接着执行。所有中断处理程序的最后一条指令必须是中断返回指令iret。这将导致处理器依次从栈中弹出（恢复）IP、CS和FLAGS的原始内容，
     于是转到主程序接着执行。

中断随时可能发生，**中断向量表的建立和初始化工作是由BIOS在计算机启动时负责完成的**。BIOS为每个中断号填写入口地址，因为它不知道多数中断处理
程序的位置，所以，一律将它们指向一个相同的入口地址，在那里，只有一条指令：iret。也就是说，当这些中断发生时，只做一件事，那就是立即返回。当计
算机启动后，操作系统和用户程序再根据自己的需要，来修改某些中断的入口地址，使它指向自己的代码。

## 实时时钟、CMOS RAM和BCD编码

实时时钟电路(Real Time Clock, RTC)和两小块由互补金属氧化物(CMOS)材料组成的静态存储器(CMOS RAM)。实时时钟电路负责计时，而日期和时间的数
值则存储在这块存储器中。

CMOS RAM中保存的日期和时间通常是以二进制编码的十进制数(Binary Coded Decimal, BCD)，这是默认状态，如果需要，也可以设置成按正常的二进制数
来表示。

CMOS RAM中的时间信息

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt013_4.jpg)

CMOS RAM的访问，需要通过两个端口来进行

- 0x70或者0x74是索引端口，用来指定CMOS RAM内的单元
- 0x71或者0x75是数据端口，用来读写相应单元里的内容

端口0x70的最高位(bit 7)是控制NMI中断的开关。当它为0时，允许NMI中断到达处理器，为1时，则阻断所有的NMI信号，其他7个比特，即0～6位，则实际上
用于指定CMOS RAM单元的索引号

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt013_6.jpg)

寄存器A各位功能说明

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt013_7.jpg)

- 续表

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt013_8.jpg)

寄存器B各位功能说明

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt013_9.jpg)

- 续表

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt013_10.jpg)

寄存器C各位功能说明

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt013_11.jpg)

寄存器D各位功能说明

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt013_12.jpg)

## 实时时钟RTC的中断信号

实时时钟RTC电路可以产生三种中断信号，分别是：

- 周期性中断(Periodic Interrupt, PF), 每隔一段时间重复发生一次
- 更新周期结束中断(Update-ended Interrupt, UI), 每隔一秒，实时时钟电路将更新CMOS RAM里面的时间和日期。在每个更新周期结束时，如果允许的
  话，实时时钟电路可以发出一个中断信号，表示本次更新周期已经结束
- 闹钟中断(Alarm Interrupt, AI), 类似于我们日常用的闹钟，当实时时钟到达指定的闹点时，如果允许的话，将产生闹钟中断信号。

# 内部中断

内部中断发生在处理器内部，是在执行指令的过程中出现了问题或者故障引起的。

内部中断不受标志寄存器IF位的影响，也不需要中断识别总线周期，它们的中断类型是固定的，可以立即转入相应的处理过程。

- 当处理器检测到div或者idiv指令的除数为0时，或者除法的结果溢出时，将产生中断0（0号中断），这就是除法错中断。
- 当处理器遇到非法指令时，将产生中断6。

# 软中断

在编写程序的时候，我们可以随时用指令来产生中断，这种类型的中断叫作软中断。软中断也不需要中断识别总线周期，中断号在指令中给出。

产生软中断的指令

```nasm
int3
int imm8
into
```

- int3是断点中断指令，机器指令码为0xCC。
- int指令的机器码为2字节，第一字节是操作码0xCD，第2字节给出了中断号。

![](https://res.weread.qq.com/wrepub/CB_3300050845_txt013_23.jpg)

- into是溢出中断指令，机器码为0xCE，也是单字节指令。当处理器执行这条指令时，如果标志寄存器的OF位是1，那么，将产生4号中断。否则，这条指令什
  么也不做。

## BIOS中断

之所以称为BIOS中断，是因为这些中断功能是在计算机加电之后，BIOS程序执行期间建立起来的。换句话说，这些中断功能在加载和执行主引导扇区之前，就已
经可以使用了。

BIOS中断，又称BIOS功能调用，主要是为了方便地使用最基本的硬件访问功能。不同的硬件使用不同的中断号，比如，使用键盘服务时，中断号是0x16

```nasm
int 0x16
```

为了区分针对同一硬件的不同功能，使用寄存器AH来指定具体的功能编号。

```nasm
; 从键盘读取一个按键
mov ah, 0x00; 从键盘读字符
int 0x16; 键盘服务, 返回时, 字符代码在寄存器al中
```

BIOS是怎么建立起这套功能调用中断的？它又是怎么知道如何访问硬件的？

- BIOS可能会为一些简单的外围设备提供初始化代码和功能调用代码，并填写中断向量表，但也有一些BIOS中断是由外部设备接口自己建立的。
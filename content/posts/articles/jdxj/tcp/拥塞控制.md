---
title: "拥塞控制"
date: 2023-04-10T21:01:57+08:00
cover:
  image: https://www.researchgate.net/profile/Maya-Diwakar-2/publication/332436793/figure/fig1/AS:1128789102870528@1646135702126/TCP-Slow-Start-and-Congestion-Avoidance-phase.ppm
summary: "todo: 找一个完整的拥塞控制图"
tags:
  - tcp
---

![](https://upload.wikimedia.org/wikipedia/commons/2/24/TCP_Slow-Start_and_Congestion_Avoidance.svg)

# 拥塞窗口 Congestion Window，cwnd

拥塞窗口指的是在收到对端 ACK 之前自己还能传输的最大 MSS 段数。

- TCP 头部的 window 字段其实讲的接收窗口（rwnd）大小。
- 拥塞窗口初始值等于操作系统的一个变量 initcwnd，最新的 linux 系统 initcwnd 默认值等于 10。
- 真正的发送窗口大小 = 「接收端接收窗口大小」 与 「发送端自己拥塞窗口大小」 两者的最小值

# 拥塞处理

## 算法1: 慢启动 Slow Start

算法过程

1. 三次握手以后，双方通过 ACK 告诉了对方自己的接收窗口（rwnd）的大小，之后就可以互相发数据了
2. 通信双方各自初始化自己的「拥塞窗口」（Congestion Window，cwnd）大小
3. cwnd 初始值较小时，每收到一个 ACK，cwnd + 1，所以每经过一个 RTT，cwnd 变为之前的两倍

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/10/16a04a09647a07ea~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

拥塞窗口达到 N 所花费的时间公式为

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/10/16a04a095a9789a3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

假设 RTT 为 50ms，客户端和服务端的接收窗口为65535字节（64KB），初始拥塞窗口为：10段，那么要达到 64KB 的吞吐量，拥塞窗口的段数 =
65535 / 1460 = 45 段，需要的 RTT 次数 = log2（45 / 10）= 2.12 次，需要的时间 = 50 * 2.12 = 106ms。也就是客户端和服务器之间的 64KB
的吞吐量，需要 2.12 次 RTT，100ms 左右的延迟。

### 慢启动阈值 Slow Start Threshold，ssthresh

ssthresh 就是一道刹车，让拥塞窗口别涨那么快。

- 当 cwnd < ssthresh 时，拥塞窗口按指数级增长（慢启动）
- 当 cwnd > ssthresh 时，拥塞窗口按线性增长（拥塞避免）

> todo: ssthresh 的初始值哪里来的?

## 算法2: 拥塞避免 Congestion Avoidance

在这个阶段，每一个往返 RTT，拥塞窗口**大约增加1个 MSS** 大小，直到检测到拥塞为止。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/12/16a1126f794fdf38~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

实际的算法是

- 每收到一个 ACK，将拥塞窗口增加一点点（1 / cwnd）: cwnd += 1 / cwnd

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/12/16a1126f8a9442d0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

## 算法3: 快速重传 Fast Retransmit

快速重传的含义是：当接收端收到一个不按序到达的数据段时，TCP 立刻发送 1 个重复 ACK，而不用等有数据捎带确认，当发送端收到 3 个或以上重复 ACK，就
意识到之前发的包可能丢了，于是马上进行重传，**不用傻傻的等到重传定时器超时再重传**。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/12/16a1126f8b4307c8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

### 选择确认 Selective Acknowledgment，SACK

ack中携带已收到的包序号, 只重传丢失的包

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/12/16a1126f8b380ed9~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

## 算法4: 快速恢复 Fast Recovery

当收到三次重复 ACK 时，进入快速恢复阶段。

- 拥塞阈值 ssthresh 降低为 cwnd 的一半：ssthresh = cwnd / 2
- 拥塞窗口 cwnd 设置为 ssthresh
- 拥塞窗口线性增加

> - 超时不会启动快速重传
> - 快速重传下不会进入慢启动(因为收到了ack, 网络问题不大)
> - 快速恢复是在快速重传下适当降低发送速度
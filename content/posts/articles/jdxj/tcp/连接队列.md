---
title: "连接队列"
date: 2023-04-05T10:21:38+08:00
tags:
  - tcp
---

- 半连接队列（Incomplete connection queue），又称 SYN 队列
- 全连接队列（Completed connection queue），又称 Accept 队列

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/28/16b9dae5efc47de8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

# 半连接队列（SYN Queue）

1. 当客户端发起 SYN 到服务端，服务端收到以后会回 ACK 和自己的 SYN。这时服务端这边的 TCP 从 listen 状态变为 SYN_RCVD (SYN Received)，此
   时会将这个连接信息放入「半连接队列」，半连接队列也被称为 SYN Queue，存储的是 "inbound SYN packets"。
2. 服务端回复 SYN+ACK 包以后等待客户端回复 ACK，同时开启一个定时器，如果超时还未收到 ACK 会进行 SYN+ACK 的重传，重传的次数由
   tcp_synack_retries 值确定。在 CentOS 上这个值等于 5。
3. 一旦收到客户端的 ACK，服务端就开始尝试把它加入另外一个全连接队列（Accept Queue）。

半连接队列的大小与三个值有关

- 用户层 listen 传入的backlog
- 系统变量 net.ipv4.tcp_max_syn_backlog，默认值为 128
- 系统变量 net.core.somaxconn，默认值为 128

# 全连接队列（Accept Queue）

包含了服务端所有完成了三次握手，但是还未被应用调用 accept 取走的连接队列。此时的 socket 处于 ESTABLISHED 状态。每次应用调用 accept()
函数会移除队列头的连接。如果队列为空，accept() 通常会阻塞。全连接队列也被称为 Accept 队列。

如果全连接队列满，内核会舍弃掉 client 发过来的 ack（应用层会认为此时连接还未完全建立）

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/29/16ba09ba6e24b1c3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

SYN+ACK重传的次数是由操作系统的一个文件决定

```
cat /proc/sys/net/ipv4/tcp_synack_retries
```

全连接队列的大小是 listen 传入的 backlog 和 somaxconn 中的较小值

ss命令

```
ss -lnt | grep :9090
State      Recv-Q Send-Q Local Address:Port               Peer Address:Port
LISTEN     51     50           *:9090                     *:*
```

- 对于 LISTEN 状态的套接字，Recv-Q 表示 accept 队列排队的连接个数，Send-Q 表示全连接队列（也就是 accept 队列）的总大小。

# 多大的 backlog 是合适的

- 你如果的接口处理连接的速度要求非常高，或者在做压力测试，很有必要调高这个值
- 如果业务接口本身性能不好，accept 取走已建连的速度较慢，那么把 backlog 调的再大也没有用，只会增加连接失败的可能性

# tcp_abort_on_overflow 参数

默认情况下，全连接队列满以后，服务端会忽略客户端的 ACK，随后会重传SYN+ACK，也可以修改这种行为，这个值由
/proc/sys/net/ipv4/tcp_abort_on_overflow决定。

- 0表示三次握手最后一步全连接队列满以后 server 会丢掉 client 发过来的 ACK，服务端随后会进行重传 SYN+ACK。
- 1表示全连接队列满以后服务端直接发送 RST 给客户端。
  - 回给客户端 RST 包会带来另外一个问题，客户端不知道服务端响应的 RST 包到底是因为「该端口没有进程监听」，还是「该端口有进程监听，只是它的队列
    满了」。

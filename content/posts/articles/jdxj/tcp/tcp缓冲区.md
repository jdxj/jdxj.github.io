---
title: "TCP缓冲区"
date: 2023-06-21T23:10:17+08:00
tags:
  - tcp
---

# 滑动窗口是怎样影响传输速度的？

TCP 报文发出去后，并不能立刻从内存中删除，因为重发时还需要用到它。由于 TCP 是由内核实现的，所以报文存放在内核缓冲区中，这也是高并发下
buff/cache 内存增加很多的原因。

确认报文被收到的机制非常复杂，它受制于很多因素

- 网速
- 接收方的处理能力

![](https://static001.geekbang.org/resource/image/9a/f1/9a9385d4e5343285201e0242809c16f1.jpg?wh=2024*590)

RFC1323 定义了扩充窗口的方法，但 Linux 中打开这一功能，需要把 tcp_window_scaling 配置设为 1，此时窗口的最大值可以达到 1GB（2^30）

```
net.ipv4.tcp_window_scaling = 1
```

因为网络的传输能力是有限的，当发送方依据发送窗口，发送超过网络处理能力的报文时，路由器会直接丢弃这些报文。因此，缓冲区的内存并不是越大越好。

# 带宽时延积如何确定最大传输速度？

当最大带宽是 100MB/s、网络时延是 10ms 时，这意味着客户端到服务器间的网络一共可以存放 100MB/s * 0.01s = 1MB 的字节。这个 1MB 是带宽与时延
的乘积，所以它就叫做带宽时延积（缩写为 BDP，Bandwidth Delay Product）。这 1MB 字节存在于飞行中的 TCP 报文，它们就在网络线路、路由器等网络
设备上。如果飞行报文超过了 1MB，就一定会让网络过载，最终导致丢包。

- 由于发送缓冲区决定了发送窗口的上限，而发送窗口又决定了已发送但未确认的飞行报文的上限，因此，发送缓冲区不能超过带宽时延积，因为超出的部分没有办法
  用于有效的网络传输，且飞行字节大于带宽时延积还会导致丢包；
- 缓冲区也不能小于带宽时延积，否则无法发挥出高速网络的价值。

# 怎样调整缓冲区去适配滑动窗口？

可以使用 Linux 的缓冲区动态调节功能

发送缓冲区，它的范围通过 tcp_wmem 配置

- 第 1 个数值是动态范围的下限，第 3 个数值是动态范围的上限。而中间第 2 个数值，则是初始默认值。
- 发送缓冲区完全根据需求自行调整。比如，一旦发送出的数据被确认，而且没有新的数据要发送，就可以把发送缓冲区的内存释放掉。

```
net.ipv4.tcp_wmem = 4096        16384   4194304
```

设置接收缓冲区范围的 tcp_rmem：

- 第 1、3 个值是范围的下限和上限，第 2 个值是初始默认值
- 如果系统的空闲内存很多，就可以把缓冲区增大一些，这样传给对方的接收窗口也会变大，因而对方的发送速度就会通过增加飞行报文来提升。
- 反之，内存紧张时就会缩小缓冲区，这虽然会减慢速度，但可以保证更多的并发连接正常工作。

```
net.ipv4.tcp_rmem = 4096        87380   6291456
```

发送缓冲区的调节功能是自动开启的，而接收缓冲区则需要配置 tcp_moderate_rcvbuf 为 1 来开启调节功能：

```
net.ipv4.tcp_moderate_rcvbuf = 1
```

接收缓冲区调节时，怎么判断空闲内存的多少呢？这是通过 tcp_mem 配置完成的：

- 当 TCP 内存小于第 1 个值时，不需要进行自动调节；
- 在第 1 和第 2 个值之间时，内核开始调节接收缓冲区的大小；
- 大于第 3 个值时，内核不再为 TCP 分配新内存，此时新连接是无法建立的。

```
net.ipv4.tcp_mem = 88560        118080  177120
```

在高并发服务器中，为了兼顾网速与大量的并发连接，我们应当保证缓冲区的动态调整上限达到带宽时延积，而下限保持默认的 4K 不变即可。而对于内存紧张的服务
而言，调低默认值是提高并发的有效手段。

如果这是网络 IO 型服务器，那么，调大 tcp_mem 的上限可以让 TCP 连接使用更多的系统内存，这有利于提升并发能力。需要注意的是，tcp_wmem 和
tcp_rmem 的单位是字节，而 tcp_mem 的单位是页面大小。而且，千万不要在 socket 上直接设置 SO_SNDBUF 或者 SO_RCVBUF，这样会关闭缓冲区的动态
调整功能。

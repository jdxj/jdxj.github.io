<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>x86 on jdxj</title><link>https://jdxj.github.io/tags/x86/</link><description>Recent content in x86 on jdxj</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 28 Aug 2023 10:05:21 +0800</lastBuildDate><atom:link href="https://jdxj.github.io/tags/x86/index.xml" rel="self" type="application/rss+xml"/><item><title>过程调用</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 28 Aug 2023 10:05:21 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/</guid><description>处理器可以用过程调用指令转移到这段代码执行，在遇到过程返回指令时重新返回到调用处的下一条指令接着执行。 要调用过程，需要该过程的地址。一般来说</description></item><item><title>加载器工作流程</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</link><pubDate>Sun, 27 Aug 2023 11:13:52 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</guid><description>加载器需要了解如何加载用户程序 加载器与用户程序之间的协议部分 1 SECTION header vstart=0 因为它是“头部”，所以，该段当然必须是第一个被定义的段，且总是位于整个源</description></item><item><title>段</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/%E6%AE%B5/</link><pubDate>Sun, 27 Aug 2023 10:07:20 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/%E6%AE%B5/</guid><description>定义段 1 2 3 SECTION 段名称 ; 或 SEGMENT 段名称 未定义段的内容自成一个段 在编写源程序时定义的段也必须至少按16字节对齐。 要在编写程序时指定段的对齐方式，应该</description></item><item><title>8086处理器的寻址方式</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/8086%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</link><pubDate>Fri, 25 Aug 2023 16:01:13 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/8086%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</guid><description>处理器的一生，是忙碌的一生，只要它工作着，就必定是在取指令和执行指令。它就像勤劳的牛，吃的是电，挤出来的还是电，不过是另一种形式的电。</description></item><item><title>标志寄存器</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/</link><pubDate>Thu, 24 Aug 2023 11:03:38 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/</guid><description>ZF, 当处理器执行一条算术或者逻辑运算指令后, 如果计算结果为0，这一位被置成1，表示计算结果为0是“真”的；否则清除此位(0)。 DF, 通过将这一位清</description></item><item><title>通用寄存器的扩展</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%89%A9%E5%B1%95/</link><pubDate>Thu, 24 Aug 2023 00:01:58 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%89%A9%E5%B1%95/</guid><description>在64位处理器上，这些寄存器再次被扩展，达到了64位，即RAX、RBX、RCX、RDX、RSI、RDI、RBP、RSP和RIP。同时，它们的</description></item><item><title>nasm指令</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/nasm%E6%8C%87%E4%BB%A4/</link><pubDate>Wed, 23 Aug 2023 16:14:51 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/nasm%E6%8C%87%E4%BB%A4/</guid><description>声明空间 db(declare byte) 声明字节 1 2 ; 声明5个初始值为0的字节 db 0,0,0,0,0 dw(declare word) 声明字 dd(declare double) 声明双字 dq(declare quad word) 声明四字 div 无符号除法指令 可以做两种类型的除法 16位被除数(</description></item><item><title>nasm标号</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/nasm%E6%A0%87%E5%8F%B7/</link><pubDate>Wed, 23 Aug 2023 15:59:43 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/nasm%E6%A0%87%E5%8F%B7/</guid><description>1 infi: jmp near infi 标号可以由字母、数字、_、$、#、@、~、.、?组成，但必须以字母、. _和?中的任意一个打头。 $标记 1 2 jmp near $; 等同于 infi: jmp near infi $$标</description></item><item><title>字符模式</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/%E5%AD%97%E7%AC%A6%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 23 Aug 2023 13:16:38 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/%E5%AD%97%E7%AC%A6%E6%A8%A1%E5%BC%8F/</guid><description>K是闪烁位，为0时不闪烁，为1时闪烁；I是亮度位，为0时正常亮度，为1时呈高亮。</description></item><item><title>8086引导过程</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/8086%E5%BC%95%E5%AF%BC%E8%BF%87%E7%A8%8B/</link><pubDate>Tue, 22 Aug 2023 16:22:39 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/8086%E5%BC%95%E5%AF%BC%E8%BF%87%E7%A8%8B/</guid><description>8086地址空间为1MB, ROM占内存空间顶端64KB(0xF0000~0xFFFFF), DRAM占内存空间低640KB(0x00000~0</description></item><item><title>8086的内存分段机制</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/8086%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 21 Aug 2023 12:54:01 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/8086%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/</guid><description>分段机制能解决程序重定位问题. 在进行数据传送或者算术逻辑运算的时候，使用算术逻辑部件(ALU)。比如，将AX的内容和CX的内容相加，结果仍在</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>asm on jdxj</title><link>https://jdxj.github.io/tags/asm/</link><description>Recent content in asm on jdxj</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 28 Aug 2023 10:05:21 +0800</lastBuildDate><atom:link href="https://jdxj.github.io/tags/asm/index.xml" rel="self" type="application/rss+xml"/><item><title>过程调用</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 28 Aug 2023 10:05:21 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/</guid><description>处理器可以用过程调用指令转移到这段代码执行，在遇到过程返回指令时重新返回到调用处的下一条指令接着执行。 要调用过程，需要该过程的地址。一般来说</description></item><item><title>加载器工作流程</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</link><pubDate>Sun, 27 Aug 2023 11:13:52 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</guid><description>加载器需要了解如何加载用户程序 加载器与用户程序之间的协议部分 1 SECTION header vstart=0 因为它是“头部”，所以，该段当然必须是第一个被定义的段，且总是位于整个源</description></item><item><title>段</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/%E6%AE%B5/</link><pubDate>Sun, 27 Aug 2023 10:07:20 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/%E6%AE%B5/</guid><description>定义段 1 2 3 SECTION 段名称 ; 或 SEGMENT 段名称 未定义段的内容自成一个段 在编写源程序时定义的段也必须至少按16字节对齐。 要在编写程序时指定段的对齐方式，应该</description></item><item><title>8086处理器的寻址方式</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/8086%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</link><pubDate>Fri, 25 Aug 2023 16:01:13 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/8086%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</guid><description>处理器的一生，是忙碌的一生，只要它工作着，就必定是在取指令和执行指令。它就像勤劳的牛，吃的是电，挤出来的还是电，不过是另一种形式的电。</description></item><item><title>nasm指令</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/nasm%E6%8C%87%E4%BB%A4/</link><pubDate>Wed, 23 Aug 2023 16:14:51 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/nasm%E6%8C%87%E4%BB%A4/</guid><description>声明空间 db(declare byte) 声明字节 1 2 ; 声明5个初始值为0的字节 db 0,0,0,0,0 dw(declare word) 声明字 dd(declare double) 声明双字 dq(declare quad word) 声明四字 div 无符号除法指令 可以做两种类型的除法 16位被除数(</description></item><item><title>nasm标号</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/nasm%E6%A0%87%E5%8F%B7/</link><pubDate>Wed, 23 Aug 2023 15:59:43 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/nasm%E6%A0%87%E5%8F%B7/</guid><description>1 infi: jmp near infi 标号可以由字母、数字、_、$、#、@、~、.、?组成，但必须以字母、. _和?中的任意一个打头。 $标记 1 2 jmp near $; 等同于 infi: jmp near infi $$标</description></item><item><title>8086引导过程</title><link>https://jdxj.github.io/posts/articles/jdxj/x86/8086%E5%BC%95%E5%AF%BC%E8%BF%87%E7%A8%8B/</link><pubDate>Tue, 22 Aug 2023 16:22:39 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/x86/8086%E5%BC%95%E5%AF%BC%E8%BF%87%E7%A8%8B/</guid><description>8086地址空间为1MB, ROM占内存空间顶端64KB(0xF0000~0xFFFFF), DRAM占内存空间低640KB(0x00000~0</description></item></channel></rss>
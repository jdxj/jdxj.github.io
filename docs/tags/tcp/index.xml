<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>tcp on jdxj</title><link>https://jdxj.github.io/tags/tcp/</link><description>Recent content in tcp on jdxj</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 11 Apr 2023 20:34:56 +0800</lastBuildDate><atom:link href="https://jdxj.github.io/tags/tcp/index.xml" rel="self" type="application/rss+xml"/><item><title>延迟确认</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4/</link><pubDate>Tue, 11 Apr 2023 20:34:56 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4/</guid><description>延迟确认在很多 linux 机器上是没有办法关闭的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible) { struct tcp_sock *tp = tcp_sk(sk); /* More than one full frame received... */ if (((tp-&amp;gt;rcv_nxt - tp-&amp;gt;rcv_wup) &amp;gt; tp-&amp;gt;ack.rcv_mss /* ...</description></item><item><title>Nagle</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/nagle/</link><pubDate>Tue, 11 Apr 2023 20:07:52 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/nagle/</guid><description>减少发送端频繁的发送小包给对方。 算法思路 if there is new data to send if the window size &amp;gt;= MSS and available data is &amp;gt;= MSS send complete MSS segment now else if there is unconfirmed data still in the pipe enqueue data in the buffer until an acknowledge is received else send data immediately end if</description></item><item><title>拥塞控制</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 10 Apr 2023 21:01:57 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</guid><description>拥塞窗口 Congestion Window，cwnd 拥塞窗口指的是在收到对端 ACK 之前自己还能传输的最大 MSS 段数。 TCP 头部的 window 字段其实讲的接收窗口（rwnd）大小。 拥塞</description></item><item><title>滑动窗口</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link><pubDate>Sun, 09 Apr 2023 11:43:02 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</guid><description>TCP 包状态分类 粉色部分#1 (Bytes Sent and Acknowledged)：表示已发送且已收到 ACK 确认的数据包。 蓝色部分#2 (Bytes Sent but Not Yet Acknowledged)</description></item><item><title>超时重传</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0/</link><pubDate>Sun, 09 Apr 2023 11:08:12 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0/</guid><description>Retransmission TimeOut，RTO 计算RTO 经典方法 适用 RTT 波动较小的情况 取平均值 Smoothed round trip time，SRTT α 是平滑因子，建议值是0.8 ~ 0.9 SRTT = ( α * SRTT )</description></item><item><title>快速重传与SACK</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0/</link><pubDate>Sun, 09 Apr 2023 10:51:53 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0/</guid><description>当发送端收到 3 个或以上重复 ACK，就意识到之前发的包可能丢了，于是马上进行重传，不用傻傻的等到超时再重传。</description></item><item><title>Socket Options</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/socket-options/</link><pubDate>Sun, 09 Apr 2023 10:05:58 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/socket-options/</guid><description>SO_LINGER SO_LINGER 参数是一个 linger 结构体 1 2 3 4 struct linger { int l_onoff; /* linger active */ int l_linger; /* how many seconds to linger for */ }; l_onoff 用来表示是否启用 linger 特性，非 0 为启用，0 为禁用 ，linux 内核默认为禁</description></item><item><title>发生RST的情景</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/%E5%B8%B8%E8%A7%81rst/</link><pubDate>Sun, 09 Apr 2023 09:58:47 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/%E5%B8%B8%E8%A7%81rst/</guid><description>端口未监听 断电丢失连接 设置SO_LINGER为true 如果设置 SO_LINGER 为 true，linger 设置为 0，当调用 socket.close() 时， close 函数会立即返回，同时丢弃缓冲</description></item><item><title>MSL</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/msl/</link><pubDate>Sat, 08 Apr 2023 11:06:58 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/msl/</guid><description>Max Segment Lifetime MSL（报文最大生存时间）是 TCP 报文在网络中的最大生存时间。这个值与 IP 报文头的 TTL 字段有密切的关系。 TTL: IP 报文最大可经过的路由数 Linux 的套接字实</description></item><item><title>Linux内核参数优化及原理</title><link>https://jdxj.github.io/posts/articles/code2life/tcp%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/</link><pubDate>Sat, 08 Apr 2023 10:06:49 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/code2life/tcp%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/</guid><description>原文 修改内核参数的方法 编辑/etc/sysctl.conf添加配置 执行sysctl -p立即生效</description></item><item><title>TCP拥塞控制及BBR原理分析</title><link>https://jdxj.github.io/posts/articles/weixin/bbr%E5%88%86%E6%9E%90/</link><pubDate>Sat, 08 Apr 2023 09:56:37 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/weixin/bbr%E5%88%86%E6%9E%90/</guid><description>原文 可以搜一下该文章的标题, 有很多与bbr相关的.</description></item><item><title>Debian11开启BBR</title><link>https://jdxj.github.io/posts/articles/ahlxjg/bbr/</link><pubDate>Sat, 08 Apr 2023 09:11:45 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/ahlxjg/bbr/</guid><description>Debian11应该默认开启了, 验证 lsmod | grep bbr #或成功则会出现类似的内容 tcp_bbr 20480 1 参考 Debian11开启bbr</description></item><item><title>TFO</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/tfo/</link><pubDate>Wed, 05 Apr 2023 11:27:57 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/tfo/</guid><description>TFO 是在原来 TCP 协议上的扩展协议，它的主要原理就在发送第一个 SYN 包的时候就开始传数据了，不过它要求当前客户端之前已经完成过「正常」的三次握手。 快速</description></item><item><title>SYN Cookie</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/syn-cookie/</link><pubDate>Wed, 05 Apr 2023 11:12:14 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/syn-cookie/</guid><description>用来解决 SYN Flood 攻击的，现在服务器上的 tcp_syncookies 都是默认等于 1，表示连接队列满时启用，等于 0 表示禁用，等于 2 表示始终启用。由 /proc/sys/net/</description></item><item><title>SYN Flood 攻击</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/syn-flood/</link><pubDate>Wed, 05 Apr 2023 11:06:54 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/syn-flood/</guid><description>客户端大量伪造 IP 发送 SYN 包，服务端回复的 ACK+SYN 去到了一个「未知」的 IP 地址，势必会造成服务端大量的连接处于 SYN_RCVD 状态，而服务器的 半连接队列大小也是有限的</description></item><item><title>连接队列</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/</link><pubDate>Wed, 05 Apr 2023 10:21:38 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/</guid><description>半连接队列（Incomplete connection queue），又称 SYN 队列 全连接队列（Completed connection queue），又称 Accept 队列 半连接队列（SYN Queu</description></item><item><title>连接状态转换</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/</link><pubDate>Sun, 02 Apr 2023 17:44:43 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/</guid><description>完整的状态转换 三次握手的状态变化 同时打开的状态变化 自连接的状态变化 其实就是同时打开, 步骤5, 6在原文当中是window update包, 所以s</description></item><item><title>MSS</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/mss/</link><pubDate>Sun, 02 Apr 2023 12:09:48 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/mss/</guid><description>MSS TCP 为了避免被发送方分片，会主动把数据分割成小段再交给网络层，最大的分段大小称之为 MSS（Max Segment Size）。 MSS = MTU - IP header头大小 -</description></item><item><title>MTU</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/mtu/</link><pubDate>Sun, 02 Apr 2023 11:38:53 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/mtu/</guid><description>MTU 数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层，这个限制被称为「最大传输单元（Maximum Transmission Unit, MTU）」 MTU是指整</description></item><item><title>TCP Options</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-options/</link><pubDate>Sat, 01 Apr 2023 21:16:50 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-options/</guid><description>可选项格式 时间戳选项 TCP Timestamps Option，TSopt 由4部分组成 类别（kind） 长度（Length） 发送方时间戳（TS value） 回显时间戳（T</description></item><item><title>TCP窗口大小</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-window-size/</link><pubDate>Sat, 01 Apr 2023 21:10:57 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-window-size/</guid><description>window size只有16位, 起初表示最大窗口为65535B 后来不够用就引入了TCP窗口缩放选项, 范围为0~14 0: 不缩放 !=0: 窗口大小为 windowSize * 2^n 窗口缩放在</description></item><item><title>TCP Flags</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-flags/</link><pubDate>Sat, 01 Apr 2023 21:07:11 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-flags/</guid><description>这些标记可以组合使用，比如 SYN+ACK，FIN+ACK 等 SYN（Synchronize）：用于发起连接数据包同步双方的初始序列号 ACK（A</description></item><item><title>TCP序列号/确认号</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/tcp%E5%BA%8F%E5%88%97%E5%8F%B7/tcp%E5%BA%8F%E5%88%97%E5%8F%B7/</link><pubDate>Sat, 01 Apr 2023 18:23:15 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/tcp%E5%BA%8F%E5%88%97%E5%8F%B7/tcp%E5%BA%8F%E5%88%97%E5%8F%B7/</guid><description>序列号 Sequence Number 序列号指的是本报文段第一个字节的序列号 32位无符号整数 初始序列号 在建立连接之初，通信双方都会各自选择一个序列号，称之为初始序列号。</description></item><item><title>TCP头部格式</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/tcp%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F/</link><pubDate>Sat, 01 Apr 2023 18:21:56 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/tcp%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F/</guid><description>不变部分为20B</description></item><item><title>TCP的特点</title><link>https://jdxj.github.io/posts/articles/jdxj/tcp/tcp%E7%89%B9%E7%82%B9/</link><pubDate>Sat, 01 Apr 2023 17:39:06 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/jdxj/tcp/tcp%E7%89%B9%E7%82%B9/</guid><description>面向连接 可靠 校验和 序列号解决乱序, 重复 超时重传 流量控制, 拥塞控制 基于字节流 全双工</description></item><item><title>Socket是并发安全的吗</title><link>https://jdxj.github.io/posts/articles/weixin/socket%E6%98%AF%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97/</link><pubDate>Fri, 17 Feb 2023 14:51:20 +0800</pubDate><guid>https://jdxj.github.io/posts/articles/weixin/socket%E6%98%AF%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97/</guid><description>多线程并发读/写同一个TCP socket是线程安全的，因为TCP socket的读/写操作都上锁了。虽然线程安全，但依然不建议你这么做，因为T</description></item></channel></rss>
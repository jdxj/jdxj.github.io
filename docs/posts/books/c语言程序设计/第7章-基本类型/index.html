<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>第7章 基本类型 | jdxj</title><meta name=keywords content><meta name=description content="7.1 整数类型 实际上只有下列6种组合可以产生不同的类型 说明符的顺序没什么影响 1 2 3 4 5 6 short int unsigned short int int unsigned int long int unsigned long int C语言允许通过省略单词int来"><meta name=author content><link rel=canonical href=https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC7%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jdxj.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jdxj.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jdxj.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jdxj.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jdxj.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-FBE4H074FW"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FBE4H074FW",{anonymize_ip:!1})}</script><meta property="og:title" content="第7章 基本类型"><meta property="og:description" content="7.1 整数类型 实际上只有下列6种组合可以产生不同的类型 说明符的顺序没什么影响 1 2 3 4 5 6 short int unsigned short int int unsigned int long int unsigned long int C语言允许通过省略单词int来"><meta property="og:type" content="article"><meta property="og:url" content="https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC7%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-01T16:07:44+08:00"><meta property="article:modified_time" content="2023-07-04T11:29:13+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="第7章 基本类型"><meta name=twitter:description content="7.1 整数类型 实际上只有下列6种组合可以产生不同的类型 说明符的顺序没什么影响 1 2 3 4 5 6 short int unsigned short int int unsigned int long int unsigned long int C语言允许通过省略单词int来"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://jdxj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Books","item":"https://jdxj.github.io/posts/books/"},{"@type":"ListItem","position":5,"name":"第7章 基本类型","item":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC7%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"第7章 基本类型","name":"第7章 基本类型","description":"7.1 整数类型 实际上只有下列6种组合可以产生不同的类型 说明符的顺序没什么影响 1 2 3 4 5 6 short int unsigned short int int unsigned int long int unsigned long int C语言允许通过省略单词int来","keywords":[],"articleBody":"7.1 整数类型 实际上只有下列6种组合可以产生不同的类型\n说明符的顺序没什么影响 1 2 3 4 5 6 short int unsigned short int int unsigned int long int unsigned long int C语言允许通过省略单词int来缩写整数类型的名字 6种整数类型的每一种所表示的取值范围都会根据机器的不同而不同，但是有两条所有编译器都必须遵守的原则\nC标准要求short int、int和long int中的每一种类型都要覆盖一个确定的最小取值范围 标准要求int类型不能比short int类型短，long int类型不能比int类型短。但是，short int类型的取值范围有可能和int类型的范围是一样的，int类 型的取值范围也可以和long int的一样。 表7-1 16位机的整数类型\n表7-2 32位机的整数类型\n表7-3 64位机的整数类型\n表7-1、表7-2和表7-3中给出的取值范围不是C标准强制的，会随着编译器的不同而不同。对于特定的实现，确定整数类型范围的一种方法是检查 头。该头是标准库的一部分，其中定义了表示每种整数类型的最大值和最小值的宏。\n7.1.1 C99中的整数类型 C99提供了两个额外的标准整数类型：long long int和unsigned long long int。\n这两个long long类型要求至少64位宽 C99标准还允许在具体实现时定义扩展的整数类型（包括有符号的和无符号的）。例如，编译器可以提供有符号和无符号的128位整数类型。\n7.1.2 整数常量 在程序中以文本形式出现的数，而不是读、写或计算出来的数。\n为了强制编译器把常量作为长整数来处理，只需在后边加上一个字母L（或l）\n1 15L 0377L 0x7fffL 为了指明是无符号常量，可以在常量后边加上字母U（或u）\n1 15U 0377U 0x7fffU L和U可以结合使用，以表明常量既是长整型又是无符号的：0xffffffffUL\n字母L、U的顺序和大小写无所谓。 7.1.3 C99中的整数常量 在C99中，以LL或ll（两个字母大小写要一致）结尾的整数常量是long long int型的。如果在LL或ll的前面或后面增加字母U（或u），则该整数常量为 unsigned long long int型。\nC99确定整数常量类型的规则与C89有些不同。对于没有后辍（U、u、L、l、LL、ll）的十进制常量，其类型是int、long int或long long int中能表示该 值的“最小”类型。对于八进制或者十六进制常量，可能的类型顺序为int、unsigned int、long int、unsigned long int、long long int和 unsigned long long int。常量后面的任何后辍都会改变可能类型的列表。例如，以U（或u）结尾的常量类型一定是unsigned int、 unsigned long int和unsigned long long int中的一种，以L（或l）结尾的十进制常量类型一定是long int或long long int中的一种。如果常量的 数值过大以至不能用标准的整数类型表示，则可以使用扩展的整数类型。\n7.1.4 整数溢出 有符号整数运算中发生溢出时，程序的行为是未定义的。 无符号整数运算过程中发生溢出时，结果是有定义的 7.1.5 读/写整数 读写无符号整数\n1 2 3 4 5 6 7 unsigned int u; scanf(\"%u\", \u0026u); /* reads u in base 10 */ printf(\"%u\", u); /* writes u in base 10 */ scanf(\"%o\", \u0026u); /* reads u in base 8 */ printf(\"%o\", u); /* writes u in base 8 */ scanf(\"%x\", \u0026u); /* reads u in base 16 */ printf(\"%x\", u); /* writes u in base 16 */ 读写短整数\n1 2 3 short s; scanf(\"%hd\", \u0026s); printf(\"%hd\", s); 读写长整数\n1 2 3 long l; scanf(\"%ld\", \u0026l); printf(\"%ld\", l); 7.2 浮点类型 C语言提供了3种浮点类型\nfloat：单精度浮点数。 double：双精度浮点数 long double：扩展精度浮点数 C标准没有说明float、double和long double类型提供的精度到底是多少，因为不同的计算机可以用不同方法存储浮点数。大多数现代计算机都遵循IEEE 754标 准（即IEC 60559）的规范\n表7-4 浮点类型的特征（IEEE标准）\n在一些机器上，float可以有和double相同的数值集合，或者double可以有和long double相同的数值集合。可以在头中找到定义浮点类型特征的宏。\n在C99中，浮点类型分为两种：一种是实浮点类型，包括float、double和long double类型；另一种是C99新增的复数类型（27.3节，包括float _Complex、 double _Complex和long double _Complex）。\n7.2.1 浮点常量 1 57.0 57. 57.0e0 57E0 5.7e1 5.7e+1 .57e2 570.e-1 浮点常量必须包含小数点或指数；其中，指数指明了对前面的数进行缩放所需的10的幂次。如果有指数，需要在指数数值前放置字母E（或e）。可选符号+或-可以出 现在字母E（或e）的后边。\n默认情况下，浮点常量都以双精度数的形式存储。\n为了表明只需要单精度，可以在常量的末尾处加上字母F或f（如57.0F）；而为了说明常量必须以long double格式存储，可以在常量的末尾处加上字母L或l（如 57.0L）。\nC99提供了十六进制浮点常量的书写规范。\n7.2.2 读/写浮点数 读取double类型\n1 2 double d; scanf(\"%lf\", \u0026d); 注意：只能在scanf函数格式串中使用l，不能在printf函数格式串中使用。在printf函数格式串中，转换e、f和g可以用来写float类型或double类型的值。 （C99允许printf函数调用中使用%le、%lf和%lg，不过字母l不起作用。）\n读写long double类型\n1 2 3 long double ld; scanf(\"%Lf\", \u0026ld); printf(\"%Lf\", ld); 7.3 字符类型 1 2 3 4 5 char ch; ch = 'a'; /* lower-case a */ ch = 'A'; /* upper-case A */ ch = '0'; /* zero */ ch = ' '; /* space */ 7.3.1 字符操作 1 2 3 4 5 6 7 8 9 10 11 char ch; int i; i = 'a'; /* i is now 97 */ ch = 65; /* ch is now 'A' */ ch = ch + 1; /* ch is now 'B' */ ch++; /* ch is now 'C' */ if ('a' \u003c= ch \u0026\u0026 ch \u003c= 'z') ch = ch - 'a' + 'A'; for (ch = 'A'; ch \u003c= 'Z'; ch++)... 7.3.2 有符号字符和无符号字符 C语言标准没有说明普通char类型数据是有符号型还是无符号型\n标准C允许使用单词signed和unsigned来修饰char类型\n1 2 signed char sch; unsigned char uch; C89采用术语整值类型（integral type）来（统称）包含整数类型和字符类型。枚举类型也属于整值类型。\nC99不使用术语“整值类型”，而是扩展了整数类型的含义使其包含字符类型和枚举类型。C99中的_Bool型是无符号整数类型。\n7.3.3 算术类型 整数类型和浮点类型统称为算术类型。\nC89中的算术类型\n整值类型：\n字符数型（char）； 有符号整型（signed char、short int、int、long int）； 无符号整型（unsigned char、unsigned short int、unsigned int、unsigned long int）； 枚举类型。 浮点类型（float、double、long double）。\nC99的算术类型\n整数类型：\n字符类型（char）； 有符号整型, 包括标准的（signed char、short int、int、long int、long long int）和扩展的； 无符号整型，包括标准的（unsigned char、unsigned short int、unsigned int、unsigned long int、unsigned long long int、_Bool）和 扩展的； 枚举类型。 浮点类型：\n实数浮点类型（float、double、long double）； 复数类型（float_Complex、double_Complex、long double_Complex）。 7.3.4 转义序列 转义序列共有两种：字符转义序列（character escape）和数字转义序列（numeric escape）。\n表7-5 字符转义序列\n转义序列列表没有包含所有无法打印的ASCII字符，只包含了最常用的字符。数字转义序列可以表示任何字符\n八进制转义序列由字符\\和跟随其后的一个最多含有三位数字的八进制数组成。转义序列中的八进制数不一定要用0开头。必须为无符号 十六进制转义序列由\\x和跟随其后的一个十六进制数组成。必须为无符号, x必须小写 转义序列可能有点隐晦，所以采用#define的方式给它们命名通常是个不错的主意\n1 #define ESC '\\33' /* ASCII escape character */ 7.3.5 字符处理函数 1 2 #include ch = toupper(ch); /* converts ch to upper case */ 7.3.6 用scanf和printf读/写字符 1 2 3 char ch; scanf(\"%c\", \u0026ch); /* reads a single character */ printf(\"%c\", ch); /* writes a single character */ 在读入字符前，scanf函数不会跳过空白字符。\n为了强制scanf函数在读入字符前跳过空白字符，需要在格式串中的转换说明%c前面加上一个空格\n1 2 3 4 5 scanf(\" %c\", \u0026ch); /* skips white space, then reads ch */ do { scanf(\"%c\", \u0026ch); } while (ch != '\\n'); 7.3.7 用getchar和putchar读/写字符 1 2 putchar(ch); ch = getchar(); /* reads a character and stores it in ch */ getchar函数也不会在读取时跳过空白字符。\n执行程序时，使用getchar函数和putchar函数（胜于scanf函数和printf函数）可以节约时间。\n这两个函数比scanf函数和printf函数简单得多，因为scanf函数和printf函数是设计用来按不同的格式读/写多种不同类型数据的。 为了额外的速度提升，通常getchar函数和putchar函数是作为宏（➤14.3节）来实现的。 把getchar函数调用移到控制表达式中可以精简循环\n1 2 while (getchar() != '\\n') /* skips rest of line */ ; 7.4 类型转换 当发生下列情况时会进行隐式转换\n当算术表达式或逻辑表达式中操作数的类型不相同时。（C语言执行所谓的常用算术转换。） 当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。 当函数调用中的实参类型与其对应的形参类型不匹配时。 当return语句中表达式的类型和函数返回值的类型不匹配时。 7.4.1 常用算术转换 常用算术转换的策略是把操作数转换成可以安全地适用于两个数值的“最狭小的”数据类型。\n任一操作数的类型是浮点类型的情况\n1 2 3 4 5 long double ↑ double ↑ float 两个操作数的类型都不是浮点类型\n1 2 3 4 5 6 7 unsigned long int ↑ long int ↑ unsigned int ↑ int 如果一个操作数的类型是long int，而另一个的类型是unsigned int，那么两个操作数都会转换成unsigned long int类型。\n7.4.2 赋值过程中的转换 把赋值运算右边的表达式转换成左边变量的类型。如果变量的类型至少和表达式类型一样“宽”，那么这种转换将没有任何障碍。\n1 2 3 4 5 6 7 char c; int i; float f; double d; i = c; /* c is converted to int */ f = i; /* i is converted to float */ d = f; /* f is converted to double */ 把浮点数赋值给整型变量会丢掉该数的小数部分\n1 2 3 int i; i = 842.97; /* i is now 842 */ i = -842.97; /* i is now -842 */ 如果该值在变量类型范围之外，那么将会得到无意义的结果\n1 2 3 c = 10000; /*** WRONG ***/ i = 1.0e20; /*** WRONG ***/ f = 1.0e100; /*** WRONG ***/ 如果浮点常量被赋值给float型变量时，一个很好的方法是在浮点常量尾部加上后辍f\n7.4.3 C99中的隐式转换 C99允许每个整数类型具有“整数转换等级”\n(1) long long int、unsigned long long int (2) long int、unsigned long int (3) int、unsigned int (4) short int、unsigned short int (5) char、signed char、unsigned char (6) _Bool C99用整数提升（integer promotion）取代了C89中的整值提升（integral promotion），可以将任何等级低于int和unsigned int的类型转换为int （只要该类型的所有值都可以用int类型表示）或unsigned int。\nC99中执行常用算术转换的规则\n任一操作数的类型是浮点类型的情况。只要两个操作数都不是复数型，规则与前面一样 两个操作数的类型都不是浮点类型的情况。首先对两个操作数进行整数提升。如果这时两个操作数的类型相同，过程结束。否则，依次尝试下面的规则，一旦 遇到可应用的规则就不再考虑别的规则： 如果两个操作数都是有符号型或者都是无符号型，将整数转换等级较低的操作数转换为等级较高的操作数的类型； 如果无符号操作数的等级高于或等于有符号操作数的等级，将有符号操作数转换为无符号操作数的类型。 如果有符号操作数类型可以表示无符号操作数类型的所有值，将无符号操作数转换为有符号操作数的类型。 否则，将两个操作数都转换为与有符号操作数的类型相对应的无符号类型。 所有算术类型都可以转换为_Bool类型。如果原始值为0则转换结果为0，否则结果为1。\n7.4.4 强制类型转换 (类型名) 表达式\n1 2 float f, frac_part; frac_part = f - (int) f; C语言把(类型名)视为一元运算符。一元运算符的优先级高于二元运算符\n7.5 类型定义 1 2 typedef int Bool; Bool flag; /* same as int flag; */ 7.5.1 类型定义的优点 类型定义使程序更加易于理解 基础类型变更更容易 1 2 typedef float Dollars; typedef double Dollars; 7.5.2 类型定义和可移植性 为了更大的可移植性，可以考虑使用typedef定义新的整数类型名。\n7.6 sizeof运算符 sizeof (类型名)\n值为无符号整数, byte 编译器本身通常就能够确定sizeof表达式的值 sizeof应用于表达式时不要求圆括号 编译器会把表达式sizeof i + j解释为(sizeof i) + j，这是因为sizeof作为一元运算符的优先级高于二元运算符+ 因为sizeof表达式的类型是size_t, 在C89中, 最好在显示前把表达式的值转换成一种已知的类型 size_t一定是无符号整型，所以最安全的方法是把sizeof表达式强制转换成unsigned long类型 然后使用转换说明符%lu显示 1 printf(\"Size of int: %lu\\n\", (unsigned long) sizeof(int)); 在C99中，size_t类型可以比unsigned long更长。但C99中的printf可以直接显示出size_t类型值而不需要强制转换。 1 printf(\"Size of int: %zu\\n\", sizeof(int)); /* C99 only */ ","wordCount":"5193","inLanguage":"en","datePublished":"2023-07-01T16:07:44+08:00","dateModified":"2023-07-04T11:29:13+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC7%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"},"publisher":{"@type":"Organization","name":"jdxj","logo":{"@type":"ImageObject","url":"https://jdxj.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jdxj.github.io accesskey=h title="jdxj (Alt + H)">jdxj</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jdxj.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://jdxj.github.io/posts title=Collections><span>Collections</span></a></li><li><a href=https://jdxj.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jdxj.github.io/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jdxj.github.io>Home</a>&nbsp;»&nbsp;<a href=https://jdxj.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://jdxj.github.io/posts/books/>Books</a>&nbsp;»&nbsp;<a href=https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/>C语言程序设计: 现代方法</a></div><h1 class=post-title>第7章 基本类型</h1><div class=post-meta><span title='2023-07-01 16:07:44 +0800 CST'>July 1, 2023</span>&nbsp;·&nbsp;5193 words</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#71-%e6%95%b4%e6%95%b0%e7%b1%bb%e5%9e%8b aria-label="7.1 整数类型">7.1 整数类型</a><ul><li><a href=#711-c99%e4%b8%ad%e7%9a%84%e6%95%b4%e6%95%b0%e7%b1%bb%e5%9e%8b aria-label="7.1.1 C99中的整数类型">7.1.1 C99中的整数类型</a></li><li><a href=#712-%e6%95%b4%e6%95%b0%e5%b8%b8%e9%87%8f aria-label="7.1.2 整数常量">7.1.2 整数常量</a></li><li><a href=#713-c99%e4%b8%ad%e7%9a%84%e6%95%b4%e6%95%b0%e5%b8%b8%e9%87%8f aria-label="7.1.3 C99中的整数常量">7.1.3 C99中的整数常量</a></li><li><a href=#714-%e6%95%b4%e6%95%b0%e6%ba%a2%e5%87%ba aria-label="7.1.4 整数溢出">7.1.4 整数溢出</a></li><li><a href=#715-%e8%af%bb%e5%86%99%e6%95%b4%e6%95%b0 aria-label="7.1.5 读/写整数">7.1.5 读/写整数</a></li></ul></li><li><a href=#72-%e6%b5%ae%e7%82%b9%e7%b1%bb%e5%9e%8b aria-label="7.2 浮点类型">7.2 浮点类型</a><ul><li><a href=#721-%e6%b5%ae%e7%82%b9%e5%b8%b8%e9%87%8f aria-label="7.2.1 浮点常量">7.2.1 浮点常量</a></li><li><a href=#722-%e8%af%bb%e5%86%99%e6%b5%ae%e7%82%b9%e6%95%b0 aria-label="7.2.2 读/写浮点数">7.2.2 读/写浮点数</a></li></ul></li><li><a href=#73-%e5%ad%97%e7%ac%a6%e7%b1%bb%e5%9e%8b aria-label="7.3 字符类型">7.3 字符类型</a><ul><li><a href=#731-%e5%ad%97%e7%ac%a6%e6%93%8d%e4%bd%9c aria-label="7.3.1 字符操作">7.3.1 字符操作</a></li><li><a href=#732-%e6%9c%89%e7%ac%a6%e5%8f%b7%e5%ad%97%e7%ac%a6%e5%92%8c%e6%97%a0%e7%ac%a6%e5%8f%b7%e5%ad%97%e7%ac%a6 aria-label="7.3.2 有符号字符和无符号字符">7.3.2 有符号字符和无符号字符</a></li><li><a href=#733-%e7%ae%97%e6%9c%af%e7%b1%bb%e5%9e%8b aria-label="7.3.3 算术类型">7.3.3 算术类型</a></li><li><a href=#734-%e8%bd%ac%e4%b9%89%e5%ba%8f%e5%88%97 aria-label="7.3.4 转义序列">7.3.4 转义序列</a></li><li><a href=#735-%e5%ad%97%e7%ac%a6%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0 aria-label="7.3.5 字符处理函数">7.3.5 字符处理函数</a></li><li><a href=#736-%e7%94%a8scanf%e5%92%8cprintf%e8%af%bb%e5%86%99%e5%ad%97%e7%ac%a6 aria-label="7.3.6 用scanf和printf读/写字符">7.3.6 用scanf和printf读/写字符</a></li><li><a href=#737-%e7%94%a8getchar%e5%92%8cputchar%e8%af%bb%e5%86%99%e5%ad%97%e7%ac%a6 aria-label="7.3.7 用getchar和putchar读/写字符">7.3.7 用getchar和putchar读/写字符</a></li></ul></li><li><a href=#74-%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2 aria-label="7.4 类型转换">7.4 类型转换</a><ul><li><a href=#741-%e5%b8%b8%e7%94%a8%e7%ae%97%e6%9c%af%e8%bd%ac%e6%8d%a2 aria-label="7.4.1 常用算术转换">7.4.1 常用算术转换</a></li><li><a href=#742-%e8%b5%8b%e5%80%bc%e8%bf%87%e7%a8%8b%e4%b8%ad%e7%9a%84%e8%bd%ac%e6%8d%a2 aria-label="7.4.2 赋值过程中的转换">7.4.2 赋值过程中的转换</a></li><li><a href=#743-c99%e4%b8%ad%e7%9a%84%e9%9a%90%e5%bc%8f%e8%bd%ac%e6%8d%a2 aria-label="7.4.3 C99中的隐式转换">7.4.3 C99中的隐式转换</a></li><li><a href=#744-%e5%bc%ba%e5%88%b6%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2 aria-label="7.4.4 强制类型转换">7.4.4 强制类型转换</a></li></ul></li><li><a href=#75-%e7%b1%bb%e5%9e%8b%e5%ae%9a%e4%b9%89 aria-label="7.5 类型定义">7.5 类型定义</a><ul><li><a href=#751-%e7%b1%bb%e5%9e%8b%e5%ae%9a%e4%b9%89%e7%9a%84%e4%bc%98%e7%82%b9 aria-label="7.5.1 类型定义的优点">7.5.1 类型定义的优点</a></li><li><a href=#752-%e7%b1%bb%e5%9e%8b%e5%ae%9a%e4%b9%89%e5%92%8c%e5%8f%af%e7%a7%bb%e6%a4%8d%e6%80%a7 aria-label="7.5.2 类型定义和可移植性">7.5.2 类型定义和可移植性</a></li></ul></li><li><a href=#76-sizeof%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label="7.6 sizeof运算符">7.6 sizeof运算符</a></li></ul></div></details></div><div class=post-content><h2 id=71-整数类型>7.1 整数类型<a hidden class=anchor aria-hidden=true href=#71-整数类型>#</a></h2><p>实际上只有下列6种组合可以产生不同的类型</p><ul><li>说明符的顺序没什么影响</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>short</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>C语言允许通过省略单词int来缩写整数类型的名字</li></ul><p>6种整数类型的每一种所表示的取值范围都会根据机器的不同而不同，但是有两条所有编译器都必须遵守的原则</p><ul><li>C标准要求short int、int和long int中的每一种类型都要覆盖一个确定的最小取值范围</li><li>标准要求int类型不能比short int类型短，long int类型不能比int类型短。但是，short int类型的取值范围有可能和int类型的范围是一样的，int类
型的取值范围也可以和long int的一样。</li></ul><p>表7-1 16位机的整数类型</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/epub_31359737_226 alt></p><p>表7-2 32位机的整数类型</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/epub_31359737_227 alt></p><p>表7-3 64位机的整数类型</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/epub_31359737_228 alt></p><p>表7-1、表7-2和表7-3中给出的取值范围不是C标准强制的，会随着编译器的不同而不同。对于特定的实现，确定整数类型范围的一种方法是检查&lt;limits.h>
头。该头是标准库的一部分，其中定义了表示每种整数类型的最大值和最小值的宏。</p><h3 id=711-c99中的整数类型>7.1.1 C99中的整数类型<a hidden class=anchor aria-hidden=true href=#711-c99中的整数类型>#</a></h3><p>C99提供了两个额外的标准整数类型：long long int和unsigned long long int。</p><ul><li>这两个long long类型要求至少64位宽</li></ul><p>C99标准还允许在具体实现时定义扩展的整数类型（包括有符号的和无符号的）。例如，编译器可以提供有符号和无符号的128位整数类型。</p><h3 id=712-整数常量>7.1.2 整数常量<a hidden class=anchor aria-hidden=true href=#712-整数常量>#</a></h3><p>在程序中以文本形式出现的数，而不是读、写或计算出来的数。</p><p>为了强制编译器把常量作为长整数来处理，只需在后边加上一个字母L（或l）</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ae81ff>15L</span>  <span style=color:#ae81ff>0377L</span>  <span style=color:#ae81ff>0x7fffL</span>
</span></span></code></pre></td></tr></table></div></div><p>为了指明是无符号常量，可以在常量后边加上字母U（或u）</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ae81ff>15U</span>  <span style=color:#ae81ff>0377U</span>  <span style=color:#ae81ff>0x7fffU</span>
</span></span></code></pre></td></tr></table></div></div><p>L和U可以结合使用，以表明常量既是长整型又是无符号的：0xffffffffUL</p><ul><li>字母L、U的顺序和大小写无所谓。</li></ul><h3 id=713-c99中的整数常量>7.1.3 C99中的整数常量<a hidden class=anchor aria-hidden=true href=#713-c99中的整数常量>#</a></h3><p>在C99中，以LL或ll（两个字母大小写要一致）结尾的整数常量是long long int型的。如果在LL或ll的前面或后面增加字母U（或u），则该整数常量为
unsigned long long int型。</p><p>C99确定整数常量类型的规则与C89有些不同。对于没有后辍（U、u、L、l、LL、ll）的十进制常量，其类型是int、long int或long long int中能表示该
值的“最小”类型。对于八进制或者十六进制常量，可能的类型顺序为int、unsigned int、long int、unsigned long int、long long int和
unsigned long long int。常量后面的任何后辍都会改变可能类型的列表。例如，以U（或u）结尾的常量类型一定是unsigned int、
unsigned long int和unsigned long long int中的一种，以L（或l）结尾的十进制常量类型一定是long int或long long int中的一种。如果常量的
数值过大以至不能用标准的整数类型表示，则可以使用扩展的整数类型。</p><h3 id=714-整数溢出>7.1.4 整数溢出<a hidden class=anchor aria-hidden=true href=#714-整数溢出>#</a></h3><ul><li>有符号整数运算中发生溢出时，程序的行为是未定义的。</li><li>无符号整数运算过程中发生溢出时，结果是有定义的</li></ul><h3 id=715-读写整数>7.1.5 读/写整数<a hidden class=anchor aria-hidden=true href=#715-读写整数>#</a></h3><p>读写无符号整数</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> u;
</span></span><span style=display:flex><span><span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%u&#34;</span>, <span style=color:#f92672>&amp;</span>u);     <span style=color:#75715e>/* reads  u in base 10 */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%u&#34;</span>, u);     <span style=color:#75715e>/* writes u in base 10 */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%o&#34;</span>, <span style=color:#f92672>&amp;</span>u);     <span style=color:#75715e>/* reads  u in base  8 */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%o&#34;</span>, u);     <span style=color:#75715e>/* writes u in base  8 */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%x&#34;</span>, <span style=color:#f92672>&amp;</span>u);     <span style=color:#75715e>/* reads  u in base 16 */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%x&#34;</span>, u);     <span style=color:#75715e>/* writes u in base 16 */</span>
</span></span></code></pre></td></tr></table></div></div><p>读写短整数</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>short</span> s;
</span></span><span style=display:flex><span><span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%hd&#34;</span>, <span style=color:#f92672>&amp;</span>s);
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%hd&#34;</span>, s);
</span></span></code></pre></td></tr></table></div></div><p>读写长整数</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>long</span> l;
</span></span><span style=display:flex><span><span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%ld&#34;</span>,  <span style=color:#f92672>&amp;</span>l);
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%ld&#34;</span>,  l);
</span></span></code></pre></td></tr></table></div></div><h2 id=72-浮点类型>7.2 浮点类型<a hidden class=anchor aria-hidden=true href=#72-浮点类型>#</a></h2><p>C语言提供了3种浮点类型</p><ul><li>float：单精度浮点数。</li><li>double：双精度浮点数</li><li>long double：扩展精度浮点数</li></ul><p>C标准没有说明float、double和long double类型提供的精度到底是多少，因为不同的计算机可以用不同方法存储浮点数。大多数现代计算机都遵循IEEE 754标
准（即IEC 60559）的规范</p><p>表7-4 浮点类型的特征（IEEE标准）</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/epub_31359737_240 alt></p><p>在一些机器上，float可以有和double相同的数值集合，或者double可以有和long double相同的数值集合。可以在头&lt;float.h>中找到定义浮点类型特征的宏。</p><p>在C99中，浮点类型分为两种：一种是实浮点类型，包括float、double和long double类型；另一种是C99新增的复数类型（27.3节，包括float _Complex、
double _Complex和long double _Complex）。</p><h3 id=721-浮点常量>7.2.1 浮点常量<a hidden class=anchor aria-hidden=true href=#721-浮点常量>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ae81ff>57.0</span>  <span style=color:#ae81ff>57.</span>  <span style=color:#ae81ff>57.0e0</span>  <span style=color:#ae81ff>57E0</span>  <span style=color:#ae81ff>5.7e1</span>  <span style=color:#ae81ff>5.7e+1</span>  <span style=color:#ae81ff>.57e2</span>  <span style=color:#ae81ff>570.e-1</span>
</span></span></code></pre></td></tr></table></div></div><p>浮点常量必须包含小数点或指数；其中，指数指明了对前面的数进行缩放所需的10的幂次。如果有指数，需要在指数数值前放置字母E（或e）。可选符号+或-可以出
现在字母E（或e）的后边。</p><p>默认情况下，浮点常量都以双精度数的形式存储。</p><p>为了表明只需要单精度，可以在常量的末尾处加上字母F或f（如57.0F）；而为了说明常量必须以long double格式存储，可以在常量的末尾处加上字母L或l（如
57.0L）。</p><p>C99提供了十六进制浮点常量的书写规范。</p><h3 id=722-读写浮点数>7.2.2 读/写浮点数<a hidden class=anchor aria-hidden=true href=#722-读写浮点数>#</a></h3><p>读取double类型</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>double</span> d;
</span></span><span style=display:flex><span><span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%lf&#34;</span>, <span style=color:#f92672>&amp;</span>d);
</span></span></code></pre></td></tr></table></div></div><p>注意：只能在scanf函数格式串中使用l，不能在printf函数格式串中使用。在printf函数格式串中，转换e、f和g可以用来写float类型或double类型的值。
（C99允许printf函数调用中使用%le、%lf和%lg，不过字母l不起作用。）</p><p>读写long double类型</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>double</span> ld;
</span></span><span style=display:flex><span><span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%Lf&#34;</span>, <span style=color:#f92672>&amp;</span>ld);
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%Lf&#34;</span>, ld);
</span></span></code></pre></td></tr></table></div></div><h2 id=73-字符类型>7.3 字符类型<a hidden class=anchor aria-hidden=true href=#73-字符类型>#</a></h2><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> ch;
</span></span><span style=display:flex><span>ch <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;a&#39;</span>;     <span style=color:#75715e>/* lower-case a */</span>
</span></span><span style=display:flex><span>ch <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;A&#39;</span>;     <span style=color:#75715e>/* upper-case A */</span>
</span></span><span style=display:flex><span>ch <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;0&#39;</span>;     <span style=color:#75715e>/* zero         */</span>
</span></span><span style=display:flex><span>ch <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39; &#39;</span>;     <span style=color:#75715e>/* space        */</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=731-字符操作>7.3.1 字符操作<a hidden class=anchor aria-hidden=true href=#731-字符操作>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> ch;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>i <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;a&#39;</span>;         <span style=color:#75715e>/* i is now 97    */</span>
</span></span><span style=display:flex><span>ch <span style=color:#f92672>=</span> <span style=color:#ae81ff>65</span>;         <span style=color:#75715e>/* ch is now  &#39;A&#39; */</span>
</span></span><span style=display:flex><span>ch <span style=color:#f92672>=</span> ch <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;     <span style=color:#75715e>/* ch is now  &#39;B&#39; */</span>
</span></span><span style=display:flex><span>ch<span style=color:#f92672>++</span>;            <span style=color:#75715e>/* ch is now  &#39;C&#39; */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>&lt;=</span> ch <span style=color:#f92672>&amp;&amp;</span> ch <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;z&#39;</span>)
</span></span><span style=display:flex><span>  ch <span style=color:#f92672>=</span> ch <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;A&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (ch <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;A&#39;</span>; ch <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;Z&#39;</span>; ch<span style=color:#f92672>++</span>)...
</span></span></code></pre></td></tr></table></div></div><h3 id=732-有符号字符和无符号字符>7.3.2 有符号字符和无符号字符<a hidden class=anchor aria-hidden=true href=#732-有符号字符和无符号字符>#</a></h3><p>C语言标准没有说明普通char类型数据是有符号型还是无符号型</p><p>标准C允许使用单词signed和unsigned来修饰char类型</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>signed</span> <span style=color:#66d9ef>char</span> sch;
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> uch;
</span></span></code></pre></td></tr></table></div></div><p>C89采用术语整值类型（integral type）来（统称）包含整数类型和字符类型。枚举类型也属于整值类型。</p><p>C99不使用术语“整值类型”，而是扩展了整数类型的含义使其包含字符类型和枚举类型。C99中的_Bool型是无符号整数类型。</p><h3 id=733-算术类型>7.3.3 算术类型<a hidden class=anchor aria-hidden=true href=#733-算术类型>#</a></h3><p>整数类型和浮点类型统称为算术类型。</p><p>C89中的算术类型</p><p>整值类型：</p><ul><li>字符数型（char）；</li><li>有符号整型（signed char、short int、int、long int）；</li><li>无符号整型（unsigned char、unsigned short int、unsigned int、unsigned long int）；</li><li>枚举类型。</li></ul><p>浮点类型（float、double、long double）。</p><p>C99的算术类型</p><p>整数类型：</p><ul><li>字符类型（char）；</li><li>有符号整型, 包括标准的（signed char、short int、int、long int、long long int）和扩展的；</li><li>无符号整型，包括标准的（unsigned char、unsigned short int、unsigned int、unsigned long int、unsigned long long int、_Bool）和
扩展的；</li><li>枚举类型。</li></ul><p>浮点类型：</p><ul><li>实数浮点类型（float、double、long double）；</li><li>复数类型（float_Complex、double_Complex、long double_Complex）。</li></ul><h3 id=734-转义序列>7.3.4 转义序列<a hidden class=anchor aria-hidden=true href=#734-转义序列>#</a></h3><p>转义序列共有两种：字符转义序列（character escape）和数字转义序列（numeric escape）。</p><p>表7-5 字符转义序列</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/epub_31359737_251 alt></p><p>转义序列列表没有包含所有无法打印的ASCII字符，只包含了最常用的字符。数字转义序列可以表示任何字符</p><ul><li>八进制转义序列由字符\和跟随其后的一个最多含有三位数字的八进制数组成。转义序列中的八进制数不一定要用0开头。必须为无符号</li><li>十六进制转义序列由\x和跟随其后的一个十六进制数组成。必须为无符号, x必须小写</li></ul><p>转义序列可能有点隐晦，所以采用#define的方式给它们命名通常是个不错的主意</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define ESC &#39;\33&#39;    </span><span style=color:#75715e>/* ASCII escape character */</span><span style=color:#75715e>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=735-字符处理函数>7.3.5 字符处理函数<a hidden class=anchor aria-hidden=true href=#735-字符处理函数>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;ctype.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ch <span style=color:#f92672>=</span> <span style=color:#a6e22e>toupper</span>(ch);  <span style=color:#75715e>/* converts ch to upper case */</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=736-用scanf和printf读写字符>7.3.6 用scanf和printf读/写字符<a hidden class=anchor aria-hidden=true href=#736-用scanf和printf读写字符>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> ch;
</span></span><span style=display:flex><span><span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%c&#34;</span>, <span style=color:#f92672>&amp;</span>ch);    <span style=color:#75715e>/* reads a single character */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%c&#34;</span>, ch);    <span style=color:#75715e>/* writes a single character */</span>
</span></span></code></pre></td></tr></table></div></div><p>在读入字符前，scanf函数不会跳过空白字符。</p><p>为了强制scanf函数在读入字符前跳过空白字符，需要在格式串中的转换说明%c前面加上一个空格</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34; %c&#34;</span>, <span style=color:#f92672>&amp;</span>ch);   <span style=color:#75715e>/* skips white space, then reads ch */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%c&#34;</span>, <span style=color:#f92672>&amp;</span>ch);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>while</span>  (ch <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;\n&#39;</span>);
</span></span></code></pre></td></tr></table></div></div><h3 id=737-用getchar和putchar读写字符>7.3.7 用getchar和putchar读/写字符<a hidden class=anchor aria-hidden=true href=#737-用getchar和putchar读写字符>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>putchar</span>(ch);
</span></span><span style=display:flex><span>ch <span style=color:#f92672>=</span> <span style=color:#a6e22e>getchar</span>();     <span style=color:#75715e>/* reads a character and stores it in ch */</span>
</span></span></code></pre></td></tr></table></div></div><p>getchar函数也不会在读取时跳过空白字符。</p><p>执行程序时，使用getchar函数和putchar函数（胜于scanf函数和printf函数）可以节约时间。</p><ul><li>这两个函数比scanf函数和printf函数简单得多，因为scanf函数和printf函数是设计用来按不同的格式读/写多种不同类型数据的。</li><li>为了额外的速度提升，通常getchar函数和putchar函数是作为宏（➤14.3节）来实现的。</li></ul><p>把getchar函数调用移到控制表达式中可以精简循环</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>getchar</span>() <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;\n&#39;</span>)  <span style=color:#75715e>/* skips rest of line */</span>
</span></span><span style=display:flex><span>  ;
</span></span></code></pre></td></tr></table></div></div><h2 id=74-类型转换>7.4 类型转换<a hidden class=anchor aria-hidden=true href=#74-类型转换>#</a></h2><p>当发生下列情况时会进行隐式转换</p><ul><li>当算术表达式或逻辑表达式中操作数的类型不相同时。（C语言执行所谓的常用算术转换。）</li><li>当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。</li><li>当函数调用中的实参类型与其对应的形参类型不匹配时。</li><li>当return语句中表达式的类型和函数返回值的类型不匹配时。</li></ul><h3 id=741-常用算术转换>7.4.1 常用算术转换<a hidden class=anchor aria-hidden=true href=#741-常用算术转换>#</a></h3><p>常用算术转换的策略是把操作数转换成可以安全地适用于两个数值的“最狭小的”数据类型。</p><p>任一操作数的类型是浮点类型的情况</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>double</span>
</span></span><span style=display:flex><span>     <span style=color:#960050;background-color:#1e0010>↑</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>double</span>
</span></span><span style=display:flex><span>     <span style=color:#960050;background-color:#1e0010>↑</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span>
</span></span></code></pre></td></tr></table></div></div><p>两个操作数的类型都不是浮点类型</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>        <span style=color:#960050;background-color:#1e0010>↑</span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>        <span style=color:#960050;background-color:#1e0010>↑</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>        <span style=color:#960050;background-color:#1e0010>↑</span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>int</span>
</span></span></code></pre></td></tr></table></div></div><p>如果一个操作数的类型是long int，而另一个的类型是unsigned int，那么两个操作数都会转换成unsigned long int类型。</p><h3 id=742-赋值过程中的转换>7.4.2 赋值过程中的转换<a hidden class=anchor aria-hidden=true href=#742-赋值过程中的转换>#</a></h3><p>把赋值运算右边的表达式转换成左边变量的类型。如果变量的类型至少和表达式类型一样“宽”，那么这种转换将没有任何障碍。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> c;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> f;
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> d;
</span></span><span style=display:flex><span>i <span style=color:#f92672>=</span> c;   <span style=color:#75715e>/* c is converted to int    */</span>
</span></span><span style=display:flex><span>f <span style=color:#f92672>=</span> i;   <span style=color:#75715e>/* i is converted to float  */</span>
</span></span><span style=display:flex><span>d <span style=color:#f92672>=</span> f;   <span style=color:#75715e>/* f is converted to double */</span>
</span></span></code></pre></td></tr></table></div></div><p>把浮点数赋值给整型变量会丢掉该数的小数部分</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>i <span style=color:#f92672>=</span> <span style=color:#ae81ff>842.97</span>;   <span style=color:#75715e>/* i is now 842  */</span>
</span></span><span style=display:flex><span>i <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>842.97</span>;  <span style=color:#75715e>/* i is now -842 */</span>
</span></span></code></pre></td></tr></table></div></div><p>如果该值在变量类型范围之外，那么将会得到无意义的结果</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>c <span style=color:#f92672>=</span> <span style=color:#ae81ff>10000</span>;    <span style=color:#75715e>/*** WRONG ***/</span>
</span></span><span style=display:flex><span>i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0e20</span>;   <span style=color:#75715e>/*** WRONG ***/</span>
</span></span><span style=display:flex><span>f <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0e100</span>;  <span style=color:#75715e>/*** WRONG ***/</span>
</span></span></code></pre></td></tr></table></div></div><p>如果浮点常量被赋值给float型变量时，一个很好的方法是在浮点常量尾部加上后辍f</p><h3 id=743-c99中的隐式转换>7.4.3 C99中的隐式转换<a hidden class=anchor aria-hidden=true href=#743-c99中的隐式转换>#</a></h3><p>C99允许每个整数类型具有“整数转换等级”</p><ul><li>(1) long long int、unsigned long long int</li><li>(2) long int、unsigned long int</li><li>(3) int、unsigned int</li><li>(4) short int、unsigned short int</li><li>(5) char、signed char、unsigned char</li><li>(6) _Bool</li></ul><p>C99用整数提升（integer promotion）取代了C89中的整值提升（integral promotion），可以将任何等级低于int和unsigned int的类型转换为int
（只要该类型的所有值都可以用int类型表示）或unsigned int。</p><p>C99中执行常用算术转换的规则</p><ul><li>任一操作数的类型是浮点类型的情况。只要两个操作数都不是复数型，规则与前面一样</li><li>两个操作数的类型都不是浮点类型的情况。首先对两个操作数进行整数提升。如果这时两个操作数的类型相同，过程结束。否则，依次尝试下面的规则，一旦
遇到可应用的规则就不再考虑别的规则：<ul><li>如果两个操作数都是有符号型或者都是无符号型，将整数转换等级较低的操作数转换为等级较高的操作数的类型；</li><li>如果无符号操作数的等级高于或等于有符号操作数的等级，将有符号操作数转换为无符号操作数的类型。</li><li>如果有符号操作数类型可以表示无符号操作数类型的所有值，将无符号操作数转换为有符号操作数的类型。</li><li>否则，将两个操作数都转换为与有符号操作数的类型相对应的无符号类型。</li></ul></li></ul><p>所有算术类型都可以转换为_Bool类型。如果原始值为0则转换结果为0，否则结果为1。</p><h3 id=744-强制类型转换>7.4.4 强制类型转换<a hidden class=anchor aria-hidden=true href=#744-强制类型转换>#</a></h3><p>(类型名) 表达式</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>float</span> f, frac_part;
</span></span><span style=display:flex><span>frac_part <span style=color:#f92672>=</span> f <span style=color:#f92672>-</span> (<span style=color:#66d9ef>int</span>) f;
</span></span></code></pre></td></tr></table></div></div><p>C语言把(类型名)视为一元运算符。一元运算符的优先级高于二元运算符</p><h2 id=75-类型定义>7.5 类型定义<a hidden class=anchor aria-hidden=true href=#75-类型定义>#</a></h2><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>int</span> Bool;
</span></span><span style=display:flex><span>Bool flag;    <span style=color:#75715e>/* same as int flag; */</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=751-类型定义的优点>7.5.1 类型定义的优点<a hidden class=anchor aria-hidden=true href=#751-类型定义的优点>#</a></h3><ul><li>类型定义使程序更加易于理解</li><li>基础类型变更更容易</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>float</span> Dollars;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>double</span> Dollars;
</span></span></code></pre></td></tr></table></div></div><h3 id=752-类型定义和可移植性>7.5.2 类型定义和可移植性<a hidden class=anchor aria-hidden=true href=#752-类型定义和可移植性>#</a></h3><p>为了更大的可移植性，可以考虑使用typedef定义新的整数类型名。</p><h2 id=76-sizeof运算符>7.6 sizeof运算符<a hidden class=anchor aria-hidden=true href=#76-sizeof运算符>#</a></h2><p>sizeof (类型名)</p><ul><li>值为无符号整数, byte</li><li>编译器本身通常就能够确定sizeof表达式的值</li><li>sizeof应用于表达式时不要求圆括号</li><li>编译器会把表达式sizeof i + j解释为(sizeof i) + j，这是因为sizeof作为一元运算符的优先级高于二元运算符+</li><li>因为sizeof表达式的类型是size_t, 在C89中, 最好在显示前把表达式的值转换成一种已知的类型<ul><li>size_t一定是无符号整型，所以最安全的方法是把sizeof表达式强制转换成unsigned long类型</li><li>然后使用转换说明符%lu显示</li></ul></li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Size of int: %lu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>) <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span></code></pre></td></tr></table></div></div><ul><li>在C99中，size_t类型可以比unsigned long更长。但C99中的printf可以直接显示出size_t类型值而不需要强制转换。</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Size of int: %zu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));     <span style=color:#75715e>/* C99 only */</span>
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://jdxj.github.io/posts/articles/jdxj/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/><span class=title>« Prev</span><br><span>理解整数溢出</span></a>
<a class=next href=https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC6%E7%AB%A0-%E5%BE%AA%E7%8E%AF/><span class=title>Next »</span><br><span>第6章 循环</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 第7章 基本类型 on twitter" href="https://twitter.com/intent/tweet/?text=%e7%ac%ac7%e7%ab%a0%20%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b&amp;url=https%3a%2f%2fjdxj.github.io%2fposts%2fbooks%2fc%25E8%25AF%25AD%25E8%25A8%2580%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%2f%25E7%25AC%25AC7%25E7%25AB%25A0-%25E5%259F%25BA%25E6%259C%25AC%25E7%25B1%25BB%25E5%259E%258B%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第7章 基本类型 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjdxj.github.io%2fposts%2fbooks%2fc%25E8%25AF%25AD%25E8%25A8%2580%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%2f%25E7%25AC%25AC7%25E7%25AB%25A0-%25E5%259F%25BA%25E6%259C%25AC%25E7%25B1%25BB%25E5%259E%258B%2f&amp;title=%e7%ac%ac7%e7%ab%a0%20%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b&amp;summary=%e7%ac%ac7%e7%ab%a0%20%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b&amp;source=https%3a%2f%2fjdxj.github.io%2fposts%2fbooks%2fc%25E8%25AF%25AD%25E8%25A8%2580%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%2f%25E7%25AC%25AC7%25E7%25AB%25A0-%25E5%259F%25BA%25E6%259C%25AC%25E7%25B1%25BB%25E5%259E%258B%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第7章 基本类型 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjdxj.github.io%2fposts%2fbooks%2fc%25E8%25AF%25AD%25E8%25A8%2580%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%2f%25E7%25AC%25AC7%25E7%25AB%25A0-%25E5%259F%25BA%25E6%259C%25AC%25E7%25B1%25BB%25E5%259E%258B%2f&title=%e7%ac%ac7%e7%ab%a0%20%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第7章 基本类型 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjdxj.github.io%2fposts%2fbooks%2fc%25E8%25AF%25AD%25E8%25A8%2580%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%2f%25E7%25AC%25AC7%25E7%25AB%25A0-%25E5%259F%25BA%25E6%259C%25AC%25E7%25B1%25BB%25E5%259E%258B%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第7章 基本类型 on whatsapp" href="https://api.whatsapp.com/send?text=%e7%ac%ac7%e7%ab%a0%20%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%20-%20https%3a%2f%2fjdxj.github.io%2fposts%2fbooks%2fc%25E8%25AF%25AD%25E8%25A8%2580%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%2f%25E7%25AC%25AC7%25E7%25AB%25A0-%25E5%259F%25BA%25E6%259C%25AC%25E7%25B1%25BB%25E5%259E%258B%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第7章 基本类型 on telegram" href="https://telegram.me/share/url?text=%e7%ac%ac7%e7%ab%a0%20%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b&amp;url=https%3a%2f%2fjdxj.github.io%2fposts%2fbooks%2fc%25E8%25AF%25AD%25E8%25A8%2580%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%2f%25E7%25AC%25AC7%25E7%25AB%25A0-%25E5%259F%25BA%25E6%259C%25AC%25E7%25B1%25BB%25E5%259E%258B%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jdxj.github.io>jdxj</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>第3章 函数 | jdxj</title>
<meta name=keywords content><meta name=description content="本章建议最多读到3.4, 到这里已经看不太懂了"><meta name=author content><link rel=canonical href=https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC3%E7%AB%A0-%E5%87%BD%E6%95%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://jdxj.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jdxj.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jdxj.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jdxj.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jdxj.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-FBE4H074FW"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FBE4H074FW",{anonymize_ip:!1})}</script><meta property="og:title" content="第3章 函数"><meta property="og:description" content="本章建议最多读到3.4, 到这里已经看不太懂了"><meta property="og:type" content="article"><meta property="og:url" content="https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC3%E7%AB%A0-%E5%87%BD%E6%95%B0/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-06T21:40:56+08:00"><meta property="article:modified_time" content="2023-03-20T22:12:19+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="第3章 函数"><meta name=twitter:description content="本章建议最多读到3.4, 到这里已经看不太懂了"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://jdxj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Books","item":"https://jdxj.github.io/posts/books/"},{"@type":"ListItem","position":5,"name":"第3章 函数","item":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC3%E7%AB%A0-%E5%87%BD%E6%95%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"第3章 函数","name":"第3章 函数","description":"本章建议最多读到3.4, 到这里已经看不太懂了","keywords":[],"articleBody":"图3-1 函数调用发生前\nCALL指令会先把下一条指令的地址(返回地址)压入栈中, IP寄存器存储f1的地址 图3-2 CALL指令执行后\n执行f1() f1()最后有条RET指令, 弹出栈顶的返回地址(应该弹到IP中), 跳到返回地址处继续执行 图3-3 RET指令执行后\n3.1 栈帧 3.1.1 栈帧布局 函数栈帧是由编译器管理的。\n图3-4 Go语言函数栈帧布局示意图\n猜测代码逻辑在其他地方, 这里只保存函数状态.\nreturn address：函数返回地址，占用一个指针大小的空间。实际上是在函数被调用时由CALL指令自动压栈的，并非由被调用函数分配。 caller’s BP：调用者的栈帧基址，占用一个指针大小的空间。用来将调用路径上所有的栈帧连成一个链表，方便栈回溯之类的操作， 只在部分平台架构上存在。函数通过将栈指针SP直接向下移动指定大小，一次性分配caller’s BP、locals和args to callee所占用的空间， 在x86架构上就是使用SUB指令将SP减去指定大小的。 locals：局部变量区间，占用若干机器字。用来存放函数的局部变量，根据函数的局部变量占用空间大小来分配，没有局部变量的函数不分配。 args to callee：调用传参区域，占用若干机器字。这一区域所占空间大小，会按照当前函数调用的所有函数中返回值加上参数所占用的最大空 间来分配。当没有调用任何函数时，不需要分配该区间。callee视角的args from caller区间包含在caller视角的args to callee区间内，占用空间 大小是小于或等于的关系。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 第3章 code_3_1.go package main func main() { var v1, v2 int v3, v4 := f1(v1, v2) println(\u0026v1, \u0026v2, \u0026v3, \u0026v4) f2(v3) } //go:noinline func f1(a1, a2 int) (r1, r2 int) { var l1, l2 int println(\u0026r2, \u0026r1, \u0026a2, \u0026a1, \u0026l1, \u0026l2) return } //go:noinline func f2(a1 int) { println(\u0026a1) } 实际上，代码中的println()函数会被编译器转换为多次调用runtime包中的printlock()、printunlock()、printpointer()、printsp()、 printnl()等函数。前两个函数用来进行并发同步，后3个函数用来打印指针、空格和换行。这5个函数均无返回值， 只有printpointer()函数有一个参数，会在调用者的args to callee区间占用一个机器字。\n输出结果\n表3-1 3个函数栈帧上各区间的大小\n(1+4+4)*8 = 72B = 0x48B 依次类推 图3-5 main调用f1()函数和f2()函数的栈帧布局图\n调用f2()函数时的栈，在a1和v4之间空了3个机器字。这是因为Go语言的函数是固定栈帧大小的，args to callee是按照所需的最大空间来分配的。\n3.1.2 寻址方式 图3-6 SUB指令分配整个栈帧\n如果把图3-6中整个函数栈帧视为一个struct，SP存储着这个struct的起始地址，然后就可以通过基址＋位移的方式来寻址struct的各个字段，也就是栈帧上 的局部变量、参数和返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 第3章 code_3_3.go package main func main() { fa(0) } //go:noinline func fa(n int) (r int) { r = fb(n) return } //go:noinline func fb(n int) int { return n } 图3-7 函数fa的栈帧布局\n4～7行和最后两行汇编代码主要用来检测和执行动态栈增长 倒数第4行的RET指令用于在函数执行完成后跳转回返回地址。 第8行的SUBQ指令向下移动栈指针SP，完成当前函数栈帧的分配。倒数第5行的ADDQ指令在函数返回前向上移动栈指针SP，释放当前函数的栈帧。释放与分 配时的大小一致，均为0x18，即24字节，其中BP of main占用了8字节，args to fb占用了16字节。 第9行代码把BP寄存器的值存到栈帧上的BP of main中，第10行把当前栈帧上BP of main的地址存入BP寄存器中。倒数第6行指令在当前栈帧释放前用 BP of main的值还原BP寄存器。 第12行和第13行代码，通过AX寄存器中转，把参数n的值从args to fa区间复制到args to fb区间，也就是在fa中把main()函数传递过来的参数n，复 制到调用fb()函数的参数区间。 第14行代码通过CALL指令调用fb()函数。 Go语言中函数的返回值可以是匿名的，也可以是命名的。对于匿名返回值而言，只能通过return语句为返回值赋值。对于命名返回值，可以在代码中通过其名称 直接操作，与参数和局部变量类似。无论返回值命名与否，都不会影响函数的栈帧布局。\n3.1.3 又见内存对齐 Go语言函数栈帧中返回值和参数的对齐方式与struct类似，对于有返回值和参数的函数，可以把所有返回值和所有参数等价成两个struct，一个返回值 struct和一个参数struct。因为内存对齐方式更加紧凑，所以在支持大量参数和返回值时能够做到较高的栈空间利用率。\n验证函数参数和返回值的对齐方式与struct成员的对齐方式是一致的\n栈帧上的参数和返回值到底是分开后作为两个struct，还是按照一个struct来对齐的？\n1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_5.go package main //go:noinline func f1(a int8) (b int8) { println(\u0026b, \u0026a) return } func main() { f1(0) } f1()函数有一个返回值和一个参数，而且都是int8类型，如果返回值和参数作为同一个struct进行内存对齐，则a和b应该是紧邻的，中间不会插入padding。 可以看到参数a和返回值b并没有紧邻，而是分别按照8字节的边界进行对齐的，也就说明返回值和参数是分别对齐的，不是合并在一起作为单个struct。 局部变量的对齐\n1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_6.go package main //go:inline func fn() { var a int8 var b int64 var c int32 var d int16 var e int8 println(\u0026a, \u0026b, \u0026c, \u0026d, \u0026e) } 1 2 3 4 5 6 7 struct { e int8 a int8 d int16 c int32 b int64 } 局部变量的顺序被重排的, 布局更紧凑\n为什么编译器会对栈帧上局部变量的顺序进行调整以优化内存利用率，但是并不会调整参数和返回值呢？\n因为函数本身就是对代码单元的封装，参数和返回值属于对外暴露的接口，编译器必须按照函数原型来呈现 局部变量属于封装在内部的数据，不会对外暴露，所以编译器按需调整局部变量布局不会对函数以外造成影响。 3.1.4 调用约定 对Go语言普通函数的调用约定进行如下总结：\n返回值和参数都通过栈传递，对应的栈空间由调用者负责分配和释放。 返回值和参数在栈上的布局等价于两个struct，struct的起始地址按照平台机器字长对齐。 验证编译器能够参照函数声明来生成传参相关指令\n1 2 3 4 5 6 7 8 9 10 11 // 第3章 code_3_7.go package main import _ \"unsafe\" func main() { Add(1, 2) } // 只有声明 func Add(a, b int) 编译\n反编译\n与Add()函数调用相关的几行汇编代码\n可以看到两条MOVQ指令分别复制了参数1和2，证明编译阶段参照函数声明生成了正确的传参指令，也就是调用约定在发挥作用。 CALL指令处，十六进制编码e800000000预留了32位的偏移量空间，在链接阶段会被链接器填写为实际的偏移值。 3.1.5 Go 1.17的变化 1.16版及以前的版本中都是通过栈来传递参数的，这样实现简单且能支持海量的参数传递，缺点就是与寄存器传参相比性能方面会差一些。 在1.17版本中就实现了基于寄存器的参数传递，当然只是在部分硬件架构上实现了。 结合Go自带的反编译工具，在汇编代码层面看一下1.17版本的函数调用是如何通过寄存器传递参数的。\n1. 函数入参的传递方式\n第1～9个参数是依次用AX、BX、CX、DI、SI、R8、R9、R10和R11这9个通用寄存器来传递的 从第10个参数开始使用栈来传递 (注意MOVW $0xb0a, 0(SP)直接复制了两个数字10, 11) 图3-8 Go 1.17中in12()函数入参的传递方式\n2. 函数返回值的传递方式\n反编译out12()函数\n3.2 逃逸分析 3.2.1 什么是逃逸分析 1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_10.go package main func main() { println(*newInt()) } //go:noinline func newInt() *int { var a int return \u0026a } 如果局部变量a仍分配在栈中, 那么返回的地址会变成一个悬挂指针\n反编译newInt()函数\n重点关注上述汇编代码中runtime.newobject()函数调用，该函数是Go语言内置函数new()的具体实现，用来在运行阶段分配单个对象。 CALL指令之后的两条MOVQ指令通过AX寄存器中转，把runtime.newobject()函数的返回值复制给了newInt()函数的返回值，这个返回值就是动态分配的 int型变量的地址。 3.2.2 不逃逸分析 验证new()函数与堆分配是否有必然关系\n1 2 3 4 5 6 // 第3章 code_3_11.go //go:noinline func New() int { p := new(int) return *p } 反编译New()函数\nMOVQ指令直接把返回值赋值为0，其他的逻辑全都被优化掉了，所以即便是代码中使用了new()函数，只要变量的生命周期没有超过当前函数栈帧的生命周期， 编译器就不会进行堆分配。\n3.2.3 不逃逸判断 如果把局部变量的地址赋值给包级别的指针变量，应该也会造成变量逃逸\n1 2 3 4 5 6 7 8 // 第3章 code_3_12.go var pt *int //go:noinline func setNew() { var a int pt = \u0026a } 反编译setNew()函数\n验证逃逸分析的依赖传递性\n1 2 3 4 5 6 7 8 9 var pp **int //go:noinline func dep() { var a int var p *int p = \u0026a pp = \u0026p } 反编译dep()函数\n跨包测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 第3章 code_3_14.go package inner //go:noinline func RetAry(p *int) *int { return p } // 第3章 code_3_15.go package main //go:noinline func arg() int { var a int return *inner.RetAry(\u0026a) } 反编译\n阻止编译器参考函数实现的测试\n反编译arg()函数\n变量a依旧是栈分配，变量b已经逃逸了。 在上述代码中的retArg()函数只是个函数声明，没有给出具体实现，通过linkname机制让链接器在链接阶段链接到inner.RetArg()函数。 retArg()函数只有声明没有实现，而且编译器不会跟踪linkname，所以无法根据代码逻辑判定变量b到底有没有逃逸。 3.3 Function Value 3.3.1 函数指针 函数指针存储的也是地址, 该地址指向代码段中某个函数的第一条指令\n3.3.2 Function Value分析 1 2 3 4 5 6 7 8 9 10 11 // 第3章 code_3_18.go package main func main() { println(helper(nil, 0, 0)) } //go:noinline func helper(fn func(int, int) int, a, b int) int { return fn(a, b) } 反编译\n4～7行和最后两行用于栈增长，暂不需要关心。 第8～10行分配栈帧并赋值caller’s BP，RET之前的两行还原BP寄存器并释放栈帧。 CALL后面的两行用来复制返回值。 CALL连同之前的6条MOVQ指令，实现了Function Value的传参和过程调用。 MOVQ 0x30(SP)，AX和MOVQ AX，0(SP)用于把helper()函数的第2个参数a的值复制给fn()函数的第1个参数。 MOVQ 0x38(SP)，AX和MOVQ AX，0x8(SP)同理，把helper()函数第3个参数b的值复制给fn()函数的第2个参数。 MOVQ 0x28(SP)，DX把helper()函数第1个参数fn的值复制到DX寄存器，MOVQ 0(DX)，AX把DX用作基址，加上位移0，也就是从DX存储的地址处读 取出一个64位的值，存入了AX寄存器中。 CALL AX说明，上一步中AX寄存器最终存储的是实际函数的地址。 栈分析\n40(SP) return value -| 38(SP) b | stack of main 30(SP) a | 28(SP) fn -| 20(SP) return addr 18(SP) bp -| 10(SP) return value | stack of helper 8(SP) b | 0(SP) a -| 3.3.3 闭包 1 2 3 4 5 6 // 第3章 code_3_19.go func mc(n int) func() int { return func() int { return n } } 闭包的状态保存在哪里呢？\n闭包对象 反编译\n栈分析\n... | 28(SP) main arg (mc-func()int) | stack of main 20(SP) main arg (mc-n) -| 18(SP) return address of mc 10(SP) bp -| 8(SP) newobject ret | stack of mc 0(SP) newobject arg -| 推测newobject所创建的对象的结构\n1 2 3 4 5 6 7 // 闭包对象 struct { // 闭包函数 F uintptr // 捕获列表 n int } 看到闭包 newobject的原型\n1 func newobject(typ *_type) unsafe.Pointer 使用自定义的newobject实现来查看_type的布局\n运行结果\n因为start++导致start变量逃逸, 所以调用了两次newobject\nint struct { F uintptr; start *int } 图3-12 Function Value和闭包对象\n调用闭包 闭包函数在被调用的时候，必须得到当前闭包对象的地址才能访问其中的捕获列表，这个地址是如何传递的呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 第3章 code_3_22.go package main func main() { a := mc(2) a() } func mc(n int) func() int { return func() int { return n } } 反编译\n将DX寄存器用作基址，再加上位移8，把该地址处的值复制到AX寄存器中。 把AX寄存器的值复制给闭包函数的返回值。 闭包函数返回。 书中说把AX的值给闭包函数的返回值, 不太理解为啥0x8(SP)是返回值地址.\n闭包与变量逃逸 1 2 3 4 5 6 7 // 第3章 code_3_23.go func sc(n int) int { f := func() int { return n } return f() } 禁用内联优化\n1 $ go build -gcflags='-l' 反编译\nreturn f()之前的6行汇编代码\nXORPS和MOVUPS这两行利用128位的寄存器X0，把栈帧上从位移8字节开始的16字节清零，这段区间就是sc()函数的局部变量区，正好符合捕获了一个int变 量的闭包对象大小。 LEAQ和MOVQ把闭包函数的地址复制到栈帧上位移8字节处，正是闭包对象中的函数指针。 接下来的两个MOVQ把sc()函数的参数n的值复制到栈帧上位移16字节处，也就是闭包捕获列表中的int变量。 图3-13 sc()函数中构造的闭包对象f\nreturn之后的5行汇编代码\nMOVQ把闭包函数的地址复制到AX寄存器中，LEAQ把闭包对象的地址存储到DX寄存器中。 CALL指令调用闭包函数，接下来的两条MOVQ把闭包函数的返回值复制到sc()函数的返回值。 图3-14 调用闭包函数f()\n闭包对象的捕获列表，捕获的是变量的值还是地址？\n只有在变量的值不会再改变的前提下，才可以复制变量的值，否则就会出现不一致错误。 示例, 需要禁用内联优化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 第3章 code_3_24.go // 捕获地址 func sc(n int) int { f := func() int { n++ return n } return f() } // 第3章 code_3_25.go // 捕获值 func sc(n int) int { n++ f := func() int { return n } return f() } // 第3章 code_3_26.go // 捕获地址 func sc(n int) int { f := func() int { return n } n++ return f() } 3.4 defer 3.4.1 最初的链表 使用go1.12\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 第3章 code_3_28.go package main func main() { println(df(10)) } func df(n int) int { defer func(i *int) { *i *= 2 }(\u0026n) return n } 反编译df()\ndeferproc Go语言中，每个goroutine都有自己的一个defer链表，而runtime.deferproc()函数做的事情就是把defer函数及其参数添加到链表中。 编译器还会在当前函数结尾处插入调用runtime.deferreturn()函数的代码，该函数会按照FILO的顺序调用当前函数注册的所有defer函数。 如果当前goroutine发生了panic（宕机），或者调用了runtime.Goexit()函数，runtime的panic处理逻辑会按照FILO的顺序遍历当前goroutine的整 个defer链表，并逐一调用defer函数，直到某个defer函数执行了recover，或者所有defer函数执行完毕后程序结束运行。 runtime.deferproc()函数原型\n1 func deferproc(size int32, fun *funcval) Go语言用两级指针结构统一了函数指针和闭包，这个funcval结构就是用来支持两级指针的。 funcval结构中只定义了uintptr 图3-15 funcval对Function Value两级指针的支持\n参数siz表示defer函数的参数占用空间的大小，这部分参数也是通过栈传递的，虽然没有出现在deferproc()函数的参数列表里，但实际上会被编译器追加 到fn的后面 注意defer函数的参数在栈上的fn后面，而不是在funcval结构的后面。这点不符合正常的Go语言函数调用约定，属于编译器的特殊处理。 图3-16 df()函数调用deferproc时的栈帧\n基于第3章/code_3_28.go反编译得到的汇编代码，整理出等价的伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func df(n int) (v int) { r := runtime.deferproc(8, df.func1, \u0026n) if r \u003e 0 { goto ret } v = n runtime.deferreturn() return ret: runtime.deferreturn() return } func df.func1(i *int) { *i *= 2 } deferproc()函数的返回值为0或非0时代表不同的含义\n0代表正常流程，也就是已经把需要延迟执行的函数注册到了链表中，这种情况下程序可正常执行后续逻辑。 返回值为1则表示发生了panic，并且当前defer函数执行了recover，这种情况会跳过当前函数后续的代码，直接执行返回逻辑。 deferproc()函数的具体实现, 摘抄自runtime包的panic.go\n通过getcallersp()函数获取调用者的SP，也就是调用deferproc()函数之前SP寄存器的值。这个值有两个用途\n一是在deferreturn()函数执行defer函数时用来判断该defer是不是被当前函数注册的 二是在执行recover的时候用来还原栈指针。 基于unsafe指针运算得到编译器追加在fn之后的参数列表的起始地址，存储在argp中。\n通过getcallerpc()函数获取调用者指令指针的位置，在amd64上实际就是deferproc()函数的返回地址，从调用者df()函数的视角来看就是CALL runtime.deferproc后面的那条指令的地址。这个地址主要用来在执行recover的时候还原指令指针。\n调用newdefer()函数分配一个runtime._defer结构，newdefer()函数内部使用了两级缓冲池来避免频繁的堆分配，并且会自动把新分配的_defer结构添加 到链表的头部。\nruntime._defer的定义\nsiz表示defer参数占用的空间大小，与deferproc()函数的第1个参数一样。 started表示有个panic或者runtime.Goexit()函数已经开始执行该defer函数。 _panic的值是在当前goroutine发生panic后，runtime在执行defer函数时，将该指针指向当前的_panic结构。 link指针用来指向下一个_defer结构，从而形成链表。 _defer中没有发现用来存储defer函数参数的空间，参数应该被存储到哪里？\n实际上runtime.newdefer()函数用了和编译器一样的手段，在分配_defer结构的时候，后面额外追加了siz大小的空间，如图3-17所示，所以deferproc() 函数接下来会将fn、callerpc、sp都复制到_defer结构中相应的字段，然后根据siz大小来复制参数，最后通过return0()函数来把返回值0写入AX寄存器中。\n图3-17 deferproc执行中为_defer赋值\n通过deferproc()函数注册完一个defer函数后，deferproc()函数的返回值是0。后面如果发生了panic，又通过该defer函数成功recover，那么指令指针 和栈指针就会恢复到这里设置的pc、sp处，看起来就像刚从runtime.deferproc()函数返回，只不过返回值为1，编译器插入的if语句继而会跳过函数体，仅 执行末尾的deferreturn()函数。\ndeferreturn 在正常情况下，注册过的defer函数是由runtime.deferreturn()函数负责执行的，正常情况指的就是没有panic或runtime.Goexit()函数，即当前函数完 成执行并正常返回时。\ndeferreturn()函数的代码如下：\n值得注意的是参数arg0的值没有任何含义，实际上编译器并不会传递这个参数，deferreturn()函数内部通过它获取调用者栈帧上args to callee区间的起 始地址，从而可以将defer函数所需参数复制到该区间。defer函数的参数个数要比编译器传给deferproc()函数的参数还少两个，所以调用者的 args to callee区间大小肯定足够，不必担心复制参数会覆盖掉栈帧上的其他数据。\ndeferreturn()函数的主要逻辑如下：\n若defer链表为空，则直接返回，否则获得第1个_defer的指针d，但并不从链表中移除。 判断d.sp是否等于调用者的SP，即判断d是否由当前函数注册，如果不是，则直接返回。 如果defer函数有参数，d.siz会大于0，就将参数复制到栈上\u0026arg0处。 将d从defer链表移除，链表头指向d.link，通过runtime.freedefer()函数释放d。和runtime.newdefer()函数对应，runtime.freedefer()函数 会把d放回缓冲池中，缓冲池内部按照defer函数参数占用空间的多少分成了5个列表，对于参数太多且占用空间太大的d，超出了缓冲池的处理范围则不会被 缓存，后续会被GC回收。 通过runtime.jmpdefer()函数跳转到defer函数去执行。 runtime.jmpdefer()函数是用汇编语言实现的，amd64平台下的实现代码如下：\n第2行把fn赋值给DX寄存器，3.3节中已经讲过Function Value调用时用DX寄存器传递闭包对象地址。接下来的3行代码通过设置SP和BP来还原 deferreturn()函数的栈帧，结合最后一条指令是跳转到defer函数而不是通过CALL指令来调用，这样从调用栈来看就像是deferreturn()函数的调用者直接 调用了defer函数。\njmpdefer()函数会调整返回地址，在amd64平台下会将返回地址减5，即一条CALL指令的大小，然后才会跳转到defer函数去执行。这样一来，等到defer函数 执行完毕返回的时候，刚好会返回编译器插入的runtime.deferreturn()函数调用之前，从而实现无循环、无递归地重复调用deferreturn()函数。直到当 前函数的所有defer都执行完毕，deferreturn()函数会在第1、第2步判断时返回，不经过jmpdefer()函数调整栈帧和返回地址，从而结束重复调用。\n使用deferproc()函数实现defer的好处是通用性比较强，能够适应各种不同的代码逻辑。\n因为defer函数的注册是运行阶段才进行的，可以跟代码逻辑很好地整合在一起，所以像if这种条件分支不用完成额外工作就能支持。由于每个 runtime._defer结构都是基于缓冲池和堆动态分配的，所以即使不定次数的循环也不用额外处理，多次注册互不干扰。\n但是链表与堆分配组合的最大缺点就是慢，即使用了两级缓冲池来优化runtime._defer结构的分配，性能方面依然不太乐观，所以在后续的版本中就开始了对 defer的优化之旅。\n3.4.2 栈上分配 在1.13版本中对defer做了一点小的优化，即把runtime._defer结构分配到当前函数的栈帧上。很明显这不适用于循环中的defer，循环中的defer仍然需要 通过deferproc()函数实现，这种优化只适用于只会执行一次的defer。\n编译器通过runtime.deferprocStack()函数来执行这类defer的注册，相比于runtime.deferproc()函数，少了通过缓冲池或堆分配_defer结构的步骤， 性能方面还是稍有提升的。\nruntime._defer结构中新增了一个bool型的字段heap来表示是否为堆上分配，对于这种栈上分配的_defer结构，deferreturn()函数就不会用 freedefer()函数进行释放了。因为编译器在栈帧上已经把_defer结构的某些字段包括后面追加的fn的参数都准备好了，所以deferprocStack()函数这里只 需为剩余的几个字段赋值，与deferproc()函数的逻辑基本一致。最后几行中通过unsafe.Pointer做类型转换再赋值，源码注释中解释为避免写屏障，暂时理 解成为提升性能就行了\n同样使用第3章/code_3_28.go，经过Go 1.13编译器转换后的伪代码如下：\n图3-18 df()函数调用deferprocStack()时的栈帧\n栈上分配_defer这种优化只是节省了_defer结构的分配、释放时间，仍然需要将defer函数添加到链表中，在调用的时候也还要复制栈上的参数，整体提升比 较有限。\n3.4.3 高效的open coded defer 在Go 1.14版本中又进行了一次优化，这次优化也是针对那些只会执行一次的defer。编译器不再基于链表实现这类defer，而是将这类defer直接展开为代码中 的函数调用，按照倒序放在函数返回前去执行，这就是所谓的open coded defer。\n使用第3章/code_3_28.go，在1.14版本中经编译器转换后的伪代码如下：\n1 2 3 4 5 6 7 func df(n int) (v int) { v = n func(i *int) { *i *= 2 }(\u0026n) return } 两个问题：\n如何支持嵌套在if语句块中的defer？ 当发生panic时，如何保证这些defer得以执行呢？ 第1个问题其实并不难解决，可以在栈帧上分配一个变量，用每个二进制位来记录一个对应的defer函数是否需要被调用。Go语言实际上用了一字节作为标 志，可以最多支持8个defer，为什么不支持更多呢？笔者是这样理解的，open coded defer本来就是为了提高性能而设计的，一个函数中写太多defer，应该 是不太在意这种层面上的性能了。\n还需要考虑的一个问题是，deferproc()函数在注册的时候会存储defer函数的参数副本，defer函数的参数经常是当前函数的局部变量，即使它们后来被修改 了，deferproc()函数存储的副本也是不会变的，副本是注册那一时刻的状态，所以在open coded defer中编译器需要在当前函数栈帧上分配额外的空间来存 储defer函数的参数。\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_30.go package main func fn(n int) (r int) { if n \u003e 0 { defer func(i int) { r \u003c\u003c= i }(n) } n++ return n } 经编译器转换后的等价代码如下：\n其中局部变量f就是专门用来支持if这类条件逻辑的标志位，局部变量i用作n在defer注册那一刻的副本，函数返回前根据标志位判断是否调用defer函数。\n图3-19 fn()函数通过open coded defer的方式调用defer函数\n3.5 panic 3.5.1 gopanic()函数 1.12版本的gopanic()函数的源码\n从函数原型来看，与内置函数panic()完全一致，有一个interface{}类型的参数，这使gopanic()函数可以接受任意类型的参数。函数首先通过getg()函数 得到当前goroutine的g对象指针gp，然后会进行一些校验工作，主要目的是确保处在系统栈、内存分配过程中、禁止抢占或持有锁的情况下不允许发生panic。 接下来gopanic()函数在栈上分配了一个_panic类型的对象p，把参数e赋值给p的arg字段，并把p安放到当前goroutine的_panic链表的头部，特意使用 noescape()函数来避免p逃逸，因为panic本身就是与栈的状态强相关的。\nruntime._panic结构的定义代码如下：\nargp字段用来在defer函数执行阶段指向其args from caller区间的起始地址。 arg字段保存的就是传递给gopanic()函数的参数。 link字段用来指向链表中的下一个_panic结构。 recovered字段表示当前panic已经被某个defer函数通过recover恢复。 aborted字段表示发生了嵌套的panic，旧的panic被新的panic流程标记为aborted。 gopanic()中的for循环\n每次循环开始都会从gp的_defer链表头部取一项赋值给d，直到链表为空时结束循环。 接下来判断若d.started为真则表明当前是一个嵌套的panic，也就是在原有panic或Goexit()函数执行defer函数的时候又触发了panic，因为触发 panic的defer函数还没有执行完，所以还没有从链表中移除。这里会把d关联的旧的_panic设置为aborted，然后把d从链表中移除，并通过freedefer() 函数释放。 后续的3大块逻辑就是：调用defer函数、释放_defer结构和检测recover。 调用defer函数 调用defer函数的代码如下：\n首先将d.started设置为true，这样如果defer函数又触发了panic，新的panic遍历defer链表时，就能通过started的值确定该defer函数已经被调用 过了，避免重复调用。 然后为d._panic赋值，将d关联到当前panic对象p，并使用noescape()函数避免p逃逸，这一步是为了后续嵌套的panic能够通过d._panic找到上一个 panic。 接下来，p.argp被设置为当前gopanic()函数栈帧上args to callee区间的起始地址，recover()函数通过这个值来判断自身是否直接被defer函数调用 reflectcall()函数\n1 func reflectcall(argtype *_type, fn, arg unsafe.Pointer, argsize uint32, retoffset uint32) reflectcall()函数的主要逻辑是根据argsize的大小在栈上分配足够的空间，然后把arg处的参数复制到栈上，复制的大小为argsize字节，然后调用fn() 函数，再把返回值复制回arg＋retoffset处，复制的大小为argsize-retoffset字节，如果argtype不为nil，则根据argtype来应用写屏障。\n在编译阶段，编译器无法知道gopanic()函数在运行阶段会调用哪些defer函数，所以也无法预分配足够大的args to callee区间，只能通过 reflectcall()函数在运行阶段进行栈增长。defer函数的返回值虽然也会被复制回调用者的栈帧上，但是Go语言会将其忽略，所以这里不必应用写屏障。\n释放_defer结构 调用完d.fn()函数后，不应该出现gp._defer不等于d这种情况。假如在d.fn()函数执行的过程中没有造成新的panic，那么所有新注册的defer都应该在 d.fn()函数返回的时候被deferreturn()函数移出链表。假如d.fn()函数执行过程中造成了新的panic，若没有recover，则不会再回到这里，若经 recover之后再回到这里，则所有在d.fn()函数执行过程中注册的defer也都应该在d.fn()函数返回之前被移出链表。\n检测recover 检测recover的代码如下：\n如果d.fn()函数成功地执行了recover，则当前_panic对象p的recovered字段就会被设置为true，此处通过检测后就会执行recover逻辑。\n首先把p从gp的_panic链表中移除，然后循环移除链表头部所有已经标为aborted的_panic对象。如果没有发生嵌套的panic，则此时gp._panic应该是nil， 不为nil就表明发生了嵌套的panic，而且只是内层的panic被recover。代码的最后把局部变量sp和pc赋值给gp的sigcode0和sigcode1字段，然后通过 mcall()函数执行recovery()函数。mcall()函数会切换到系统栈，然后把gp作为参数来调用recovery()函数。\nrecovery()函数负责用存储在sigcode0和sigcode1中的sp和pc恢复gp的执行状态。recovery()函数的主要逻辑代码如下：\n首先确保栈指针sp的值不能为0，并且还要在gp栈空间的上界与下界之间，然后把sp和pc赋值给gp.sched中对应的字段，并且把返回值设置为1。\n调用gogo()函数之后，gp的栈指针和指令指针就会被恢复到sp和pc的位置，而这个位置是deferproc()函数通过getcallersp()函数和getcallerpc()函 数获得的，即deferproc()函数正常返回后的位置，所以经过某个defer函数执行recover()函数后，当前goroutine的栈指针和指令指针会被恢复到deferproc()函数刚刚注册完该defer函数后返回的位置，只不过返回值是1而不是0。\n3.5.2 gorecover()函数 defer函数中调用了内置函数recover()，实际上只会设置_panic的一种状态。内置函数recover()对应runtime中的gorecover()函数，代码如下：\n编译器会把调用者的args from caller区间的起始地址作为参数传递给gorecover()函数。\n1 2 3 4 5 6 7 // 第3章 code_3_31.go func fn() { defer func(a int) { recover() println }(0) } 经编译器转换后的等价代码如下：\n1 2 3 4 5 func fn() { defer func(a int) { gorecover(uintptr(unsafe.Pointer(\u0026a))) }(0) } 图3-20 p.argp和gorecover()函数参数argp的关系\n3.5.3 嵌套的panic Go语言的panic是支持嵌套的，第1个panic在执行defer函数的时候可能会注册新的defer函数，也可能会触发新的panic。如果新的panic被新注册的defer 函数中的recover恢复，则旧的panic就会继续执行，否则新的panic就会把旧的panic置为aborted。\n1 2 3 4 5 6 7 // 第3章 code_3_32.go func fn() { defer func() { panic(\"2\") }() panic(\"1\") } fn()函数首先将一个defer函数注册到当前goroutine的defer链表头部，记为defer1，然后当panic(＂1＂)执行时，会在当前goroutine的_panic链表中 新增一个_panic结构，记为panic1，panic1触发defer执行，defer1中started字段会被标记为true，_panic字段会指向panic1\n图3-21 panic2执行前的_defer链表和_panic链表\n然后执行到panic(＂2＂)这里，也会在当前goroutine的_panic链表中新增一项，记为panic2。panic2同样会去执行defer链表，通过defer1记录的 _panic字段找到panic1，并将其标记为aborted，然后移除defer1，处理defer链表中的后续节点。\n图3-22 panic2执行后的_defer链表和_panic链表\n在defer函数中嵌套一个带有recover的defer函数\n1 2 3 4 5 6 7 8 9 10 // 第3章 code_3_35.go func fu() { defer func() { defer func() { recover() }() panic(\"2\") }() panic(\"1\") } 依然把fn()函数首先注册的defer函数记为defer1，把接下来执行的panic记为panic1，此时goroutine的_defer链表和_panic链表与图3-21中的链表并 无不同。只不过当panic1触发defer1执行时，会再次注册一个defer函数，记为defer2，然后才会执行到panic(＂2＂)，这里触发第二次panic，在_panic 链表中新增一项，记为panic2。\n图3-23 defer2执行前的_defer链表和_panic链表\n然后panic2去执行_defer链表，首先执行defer2，将其started字段置为true，_panic字段指向panic2。待到defer2执行recover()函数时，只会把 panic2的recovered字段置为true，defer2结束后，从_defer链表中移除\n图3-24 defer2结束后的_defer链表和_panic链表\n接下来，panic处理逻辑检测到panic2已经被刚刚执行的defer2恢复了，所以会把panic2从_panic链表中移除，如图3-25所示，然后进入recovery()函数 的逻辑中。\n图3-25 panic2恢复后的_defer链表和_panic链表\n结合3.5.1节中的recovery()函数的介绍，panic2被recover后，当前协程会恢复到defer1中注册完defer2刚刚返回时的状态，只不过返回值被置为1，直 接跳转到最后的deferreturn()函数处，而此时defer链表中已经没有defer1注册的defer函数了，所以defer1结束返回，返回panic1执行defer链表的逻 辑中继续执行。\n3.5.4 支持open coded defer 1.14版本中runtime._defer结构的定义\n3.6 本章小结 ","wordCount":"14038","inLanguage":"en","datePublished":"2023-02-06T21:40:56+08:00","dateModified":"2023-03-20T22:12:19+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC3%E7%AB%A0-%E5%87%BD%E6%95%B0/"},"publisher":{"@type":"Organization","name":"jdxj","logo":{"@type":"ImageObject","url":"https://jdxj.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jdxj.github.io accesskey=h title="jdxj (Alt + H)">jdxj</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jdxj.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://jdxj.github.io/posts title=Collections><span>Collections</span></a></li><li><a href=https://jdxj.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jdxj.github.io/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jdxj.github.io>Home</a>&nbsp;»&nbsp;<a href=https://jdxj.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://jdxj.github.io/posts/books/>Books</a>&nbsp;»&nbsp;<a href=https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/>深度探索Go语言--对象模型与runtime的原理特性及应用</a></div><h1 class=post-title>第3章 函数</h1><div class=post-meta>&lt;span title='2023-02-06 21:40:56 +0800 CST'>February 6, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;14038 words</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#31-%e6%a0%88%e5%b8%a7 aria-label="3.1 栈帧">3.1 栈帧</a><ul><li><a href=#311-%e6%a0%88%e5%b8%a7%e5%b8%83%e5%b1%80 aria-label="3.1.1 栈帧布局">3.1.1 栈帧布局</a></li><li><a href=#312-%e5%af%bb%e5%9d%80%e6%96%b9%e5%bc%8f aria-label="3.1.2 寻址方式">3.1.2 寻址方式</a></li><li><a href=#313-%e5%8f%88%e8%a7%81%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90 aria-label="3.1.3 又见内存对齐">3.1.3 又见内存对齐</a></li><li><a href=#314-%e8%b0%83%e7%94%a8%e7%ba%a6%e5%ae%9a aria-label="3.1.4 调用约定">3.1.4 调用约定</a></li><li><a href=#315-go-117%e7%9a%84%e5%8f%98%e5%8c%96 aria-label="3.1.5 Go 1.17的变化">3.1.5 Go 1.17的变化</a></li></ul></li><li><a href=#32-%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90 aria-label="3.2 逃逸分析">3.2 逃逸分析</a><ul><li><a href=#321-%e4%bb%80%e4%b9%88%e6%98%af%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90 aria-label="3.2.1 什么是逃逸分析">3.2.1 什么是逃逸分析</a></li><li><a href=#322-%e4%b8%8d%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90 aria-label="3.2.2 不逃逸分析">3.2.2 不逃逸分析</a></li><li><a href=#323-%e4%b8%8d%e9%80%83%e9%80%b8%e5%88%a4%e6%96%ad aria-label="3.2.3 不逃逸判断">3.2.3 不逃逸判断</a></li></ul></li><li><a href=#33-function-value aria-label="3.3 Function Value">3.3 Function Value</a><ul><li><a href=#331-%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88 aria-label="3.3.1 函数指针">3.3.1 函数指针</a></li><li><a href=#332-function-value%e5%88%86%e6%9e%90 aria-label="3.3.2 Function Value分析">3.3.2 Function Value分析</a></li><li><a href=#333-%e9%97%ad%e5%8c%85 aria-label="3.3.3 闭包">3.3.3 闭包</a></li></ul></li><li><a href=#34-defer aria-label="3.4 defer">3.4 defer</a><ul><li><a href=#341-%e6%9c%80%e5%88%9d%e7%9a%84%e9%93%be%e8%a1%a8 aria-label="3.4.1 最初的链表">3.4.1 最初的链表</a><ul><li><a href=#deferproc aria-label=deferproc>deferproc</a></li><li><a href=#deferreturn aria-label=deferreturn>deferreturn</a></li></ul></li><li><a href=#342-%e6%a0%88%e4%b8%8a%e5%88%86%e9%85%8d aria-label="3.4.2 栈上分配">3.4.2 栈上分配</a></li><li><a href=#343-%e9%ab%98%e6%95%88%e7%9a%84open-coded-defer aria-label="3.4.3 高效的open coded defer">3.4.3 高效的open coded defer</a></li></ul></li><li><a href=#35-panic aria-label="3.5 panic">3.5 panic</a><ul><li><a href=#351-gopanic%e5%87%bd%e6%95%b0 aria-label="3.5.1 gopanic()函数">3.5.1 gopanic()函数</a></li><li><a href=#352-gorecover%e5%87%bd%e6%95%b0 aria-label="3.5.2 gorecover()函数">3.5.2 gorecover()函数</a></li><li><a href=#353-%e5%b5%8c%e5%a5%97%e7%9a%84panic aria-label="3.5.3 嵌套的panic">3.5.3 嵌套的panic</a></li><li><a href=#354-%e6%94%af%e6%8c%81open-coded-defer aria-label="3.5.4 支持open coded defer">3.5.4 支持open coded defer</a></li></ul></li><li><a href=#36-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93 aria-label="3.6 本章小结">3.6 本章小结</a></li></ul></div></details></div><div class=post-content><p><strong>图3-1 函数调用发生前</strong></p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P45_5231.jpg alt></p><ol><li>CALL指令会先把下一条指令的地址(返回地址)压入栈中, IP寄存器存储f1的地址</li></ol><p><strong>图3-2 CALL指令执行后</strong></p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P46_5242.jpg alt></p><ol start=2><li>执行f1()</li><li>f1()最后有条RET指令, 弹出栈顶的返回地址(应该弹到IP中), 跳到返回地址处继续执行</li></ol><p><strong>图3-3 RET指令执行后</strong></p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P46_5245.jpg alt></p><h2 id=31-栈帧>3.1 栈帧<a hidden class=anchor aria-hidden=true href=#31-栈帧>#</a></h2><h3 id=311-栈帧布局>3.1.1 栈帧布局<a hidden class=anchor aria-hidden=true href=#311-栈帧布局>#</a></h3><p>函数栈帧是由编译器管理的。</p><p>图3-4 Go语言函数栈帧布局示意图</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P47_5259.jpg alt></p><blockquote><p>猜测代码逻辑在其他地方, 这里只保存函数状态.</p></blockquote><ul><li>return address：函数返回地址，占用一个指针大小的空间。实际上是在函数被调用时由CALL指令自动压栈的，并非由被调用函数分配。</li><li>caller’s BP：调用者的栈帧基址，占用一个指针大小的空间。用来将调用路径上所有的栈帧连成一个链表，方便栈回溯之类的操作，
<strong>只在部分平台架构上存在</strong>。<strong>函数通过将栈指针SP直接向下移动指定大小，一次性分配caller’s BP、locals和args to callee所占用的空间</strong>，
在x86架构上就是使用SUB指令将SP减去指定大小的。</li><li>locals：局部变量区间，占用若干机器字。用来存放函数的局部变量，根据函数的局部变量占用空间大小来分配，没有局部变量的函数不分配。</li><li>args to callee：调用传参区域，占用若干机器字。这一区域所占空间大小，会按照当前函数调用的所有函数中<strong>返回值</strong>加上<strong>参数</strong>所占用的最大空
间来分配。当没有调用任何函数时，不需要分配该区间。callee视角的args from caller区间包含在caller视角的args to callee区间内，占用空间
大小是小于或等于的关系。</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_1.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>v1</span>, <span style=color:#a6e22e>v2</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>v3</span>, <span style=color:#a6e22e>v4</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>f1</span>(<span style=color:#a6e22e>v1</span>, <span style=color:#a6e22e>v2</span>)
</span></span><span style=display:flex><span>	println(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>v1</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>v2</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>v3</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>v4</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>f2</span>(<span style=color:#a6e22e>v3</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f1</span>(<span style=color:#a6e22e>a1</span>, <span style=color:#a6e22e>a2</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r2</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>l1</span>, <span style=color:#a6e22e>l2</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	println(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>r2</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>r1</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a2</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a1</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>l1</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>l2</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f2</span>(<span style=color:#a6e22e>a1</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	println(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>实际上，代码中的println()函数会被编译器转换为多次调用runtime包中的printlock()、printunlock()、printpointer()、printsp()、
printnl()等函数。前两个函数用来进行并发同步，后3个函数用来打印指针、空格和换行。这5个函数均无返回值，
<strong>只有printpointer()函数有一个参数，会在调用者的args to callee区间占用一个机器字</strong>。</p><p>输出结果</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P48_5308.jpg alt></p><p>表3-1 3个函数栈帧上各区间的大小</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-T49_16079.jpg alt></p><ul><li>(1+4+4)*8 = 72B = 0x48B</li><li>依次类推</li></ul><p><strong>图3-5 main调用f1()函数和f2()函数的栈帧布局图</strong></p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P49_5366.jpg alt></p><p>调用f2()函数时的栈，在a1和v4之间空了3个机器字。这是因为Go语言的函数是固定栈帧大小的，args to callee是按照所需的最大空间来分配的。</p><h3 id=312-寻址方式>3.1.2 寻址方式<a hidden class=anchor aria-hidden=true href=#312-寻址方式>#</a></h3><p><strong>图3-6 SUB指令分配整个栈帧</strong></p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P50_5372.jpg alt></p><p>如果把图3-6中整个函数栈帧视为一个struct，SP存储着这个struct的起始地址，然后就可以通过基址＋位移的方式来寻址struct的各个字段，也就是栈帧上
的局部变量、参数和返回值。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_3.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fa</span>(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fa</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>r</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r</span> = <span style=color:#a6e22e>fb</span>(<span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fb</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P51_5394.jpg alt></p><p><strong>图3-7 函数fa的栈帧布局</strong></p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P51_5397.jpg alt></p><ol><li>4～7行和最后两行汇编代码主要用来检测和执行动态栈增长</li><li>倒数第4行的RET指令用于在函数执行完成后跳转回返回地址。</li><li>第8行的SUBQ指令向下移动栈指针SP，完成当前函数栈帧的分配。倒数第5行的ADDQ指令在函数返回前向上移动栈指针SP，释放当前函数的栈帧。释放与分
配时的大小一致，均为0x18，即24字节，其中BP of main占用了8字节，args to fb占用了16字节。</li><li>第9行代码把BP寄存器的值存到栈帧上的BP of main中，第10行把当前栈帧上BP of main的地址存入BP寄存器中。倒数第6行指令在当前栈帧释放前用
BP of main的值还原BP寄存器。</li><li>第12行和第13行代码，通过AX寄存器中转，把参数n的值从args to fa区间复制到args to fb区间，也就是在fa中把main()函数传递过来的参数n，复
制到调用fb()函数的参数区间。</li><li>第14行代码通过CALL指令调用fb()函数。</li></ol><p>Go语言中函数的返回值可以是匿名的，也可以是命名的。对于匿名返回值而言，只能通过return语句为返回值赋值。对于命名返回值，可以在代码中通过其名称
直接操作，与参数和局部变量类似。<strong>无论返回值命名与否，都不会影响函数的栈帧布局</strong>。</p><h3 id=313-又见内存对齐>3.1.3 又见内存对齐<a hidden class=anchor aria-hidden=true href=#313-又见内存对齐>#</a></h3><p>Go语言函数栈帧中返回值和参数的对齐方式与struct类似，对于有返回值和参数的函数，可以把所有返回值和所有参数等价成两个struct，一个返回值
struct和一个参数struct。因为内存对齐方式更加紧凑，所以在支持大量参数和返回值时能够做到较高的栈空间利用率。</p><p>验证函数参数和返回值的对齐方式与struct成员的对齐方式是一致的</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P52_5410.jpg alt>
<img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P53_5431.jpg alt></p><p>栈帧上的参数和返回值到底是分开后作为两个struct，还是按照一个struct来对齐的？</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_5.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f1</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int8</span>) (<span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int8</span>) {
</span></span><span style=display:flex><span>	println(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>f1</span>(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P53_5449.jpg alt></p><ul><li>f1()函数有一个返回值和一个参数，而且都是int8类型，如果返回值和参数作为同一个struct进行内存对齐，则a和b应该是紧邻的，中间不会插入padding。</li><li>可以看到参数a和返回值b并没有紧邻，而是分别按照8字节的边界进行对齐的，也就说明返回值和参数是分别对齐的，不是合并在一起作为单个struct。</li></ul><p>局部变量的对齐</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_6.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:inline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fn</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int8</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>d</span> <span style=color:#66d9ef>int16</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>e</span> <span style=color:#66d9ef>int8</span>
</span></span><span style=display:flex><span>	println(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>d</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P54_5467.jpg alt></p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>e</span> <span style=color:#66d9ef>int8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>d</span> <span style=color:#66d9ef>int16</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><strong>局部变量的顺序被重排的, 布局更紧凑</strong></p><p>为什么编译器会对栈帧上局部变量的顺序进行调整以优化内存利用率，但是并不会调整参数和返回值呢？</p><ul><li>因为函数本身就是对代码单元的封装，参数和返回值属于对外暴露的接口，编译器必须按照函数原型来呈现</li><li>局部变量属于封装在内部的数据，不会对外暴露，所以编译器按需调整局部变量布局不会对函数以外造成影响。</li></ul><h3 id=314-调用约定>3.1.4 调用约定<a hidden class=anchor aria-hidden=true href=#314-调用约定>#</a></h3><p>对Go语言普通函数的调用约定进行如下总结：</p><ul><li>返回值和参数都通过栈传递，对应的栈空间由调用者负责分配和释放。</li><li>返回值和参数在栈上的布局等价于两个struct，struct的起始地址按照平台机器字长对齐。</li></ul><p>验证编译器能够参照函数声明来生成传参相关指令</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_7.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#a6e22e>_</span> <span style=color:#e6db74>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 只有声明
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>)
</span></span></code></pre></td></tr></table></div></div><p>编译</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P55_5503.jpg alt></p><p>反编译</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P55_5514.jpg alt></p><p>与Add()函数调用相关的几行汇编代码</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P56_5524.jpg alt></p><ul><li>可以看到两条MOVQ指令分别复制了参数1和2，证明编译阶段参照函数声明生成了正确的传参指令，也就是调用约定在发挥作用。</li><li>CALL指令处，十六进制编码e800000000预留了32位的偏移量空间，在链接阶段会被链接器填写为实际的偏移值。</li></ul><h3 id=315-go-117的变化>3.1.5 Go 1.17的变化<a hidden class=anchor aria-hidden=true href=#315-go-117的变化>#</a></h3><ul><li>1.16版及以前的版本中都是通过栈来传递参数的，这样实现简单且能支持海量的参数传递，缺点就是与寄存器传参相比性能方面会差一些。</li><li>在1.17版本中就实现了基于寄存器的参数传递，当然只是在部分硬件架构上实现了。</li></ul><p>结合Go自带的反编译工具，在汇编代码层面看一下1.17版本的函数调用是如何通过寄存器传递参数的。</p><p><strong>1. 函数入参的传递方式</strong></p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P56_5534.jpg alt>
<img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P56_5544.jpg alt></p><ul><li>第1～9个参数是依次用AX、BX、CX、DI、SI、R8、R9、R10和R11这9个通用寄存器来传递的</li><li>从第10个参数开始使用栈来传递 (注意<code>MOVW $0xb0a, 0(SP)</code>直接复制了两个数字10, 11)</li></ul><p>图3-8 Go 1.17中in12()函数入参的传递方式</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P58_5574.jpg alt></p><p><strong>2. 函数返回值的传递方式</strong></p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P57_5561.jpg alt></p><p>反编译out12()函数</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P58_5582.jpg alt>
<img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P59_5588.jpg alt></p><h2 id=32-逃逸分析>3.2 逃逸分析<a hidden class=anchor aria-hidden=true href=#32-逃逸分析>#</a></h2><h3 id=321-什么是逃逸分析>3.2.1 什么是逃逸分析<a hidden class=anchor aria-hidden=true href=#321-什么是逃逸分析>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_10.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	println(<span style=color:#f92672>*</span><span style=color:#a6e22e>newInt</span>())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newInt</span>() <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>如果局部变量a仍分配在栈中, 那么返回的地址会变成一个<a href=https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC2%E7%AB%A0-%E6%8C%87%E9%92%88/#dereference>悬挂指针</a></p><p>反编译newInt()函数</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P60_5622.jpg alt></p><ul><li>重点关注上述汇编代码中runtime.newobject()函数调用，该函数是Go语言内置函数new()的具体实现，用来在运行阶段分配单个对象。</li><li>CALL指令之后的两条MOVQ指令通过AX寄存器中转，把runtime.newobject()函数的返回值复制给了newInt()函数的返回值，这个返回值就是动态分配的
int型变量的地址。</li></ul><h3 id=322-不逃逸分析>3.2.2 不逃逸分析<a hidden class=anchor aria-hidden=true href=#322-不逃逸分析>#</a></h3><p>验证new()函数与堆分配是否有必然关系</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_11.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>New</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> new(<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>反编译New()函数</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P61_5650.jpg alt></p><p>MOVQ指令直接把返回值赋值为0，其他的逻辑全都被优化掉了，所以即便是代码中使用了new()函数，只要变量的生命周期没有超过当前函数栈帧的生命周期，
编译器就不会进行堆分配。</p><h3 id=323-不逃逸判断>3.2.3 不逃逸判断<a hidden class=anchor aria-hidden=true href=#323-不逃逸判断>#</a></h3><p>如果把局部变量的地址赋值给包级别的指针变量，应该也会造成变量逃逸</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_12.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>pt</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>setNew</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pt</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>反编译setNew()函数</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P62_5672.jpg alt></p><p>验证逃逸分析的依赖传递性</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>pp</span> <span style=color:#f92672>**</span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>dep</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pp</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>反编译dep()函数</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P62_5689.jpg alt></p><p>跨包测试</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_14.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>inner</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>RetAry</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_15.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>arg</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>inner</span>.<span style=color:#a6e22e>RetAry</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>反编译</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P63_5724.jpg alt></p><p>阻止编译器参考函数实现的测试</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P64_5741.jpg alt></p><p>反编译arg()函数</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P64_5749.jpg alt></p><ul><li>变量a依旧是栈分配，变量b已经逃逸了。</li><li>在上述代码中的retArg()函数只是个函数声明，没有给出具体实现，通过linkname机制让链接器在链接阶段链接到inner.RetArg()函数。</li><li>retArg()函数只有声明没有实现，而且编译器不会跟踪linkname，所以无法根据代码逻辑判定变量b到底有没有逃逸。</li></ul><h2 id=33-function-value>3.3 Function Value<a hidden class=anchor aria-hidden=true href=#33-function-value>#</a></h2><h3 id=331-函数指针>3.3.1 函数指针<a hidden class=anchor aria-hidden=true href=#331-函数指针>#</a></h3><p>函数指针存储的也是地址, 该地址指向代码段中某个函数的第一条指令</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P65_5768.jpg alt></p><h3 id=332-function-value分析>3.3.2 Function Value分析<a hidden class=anchor aria-hidden=true href=#332-function-value分析>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_18.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	println(<span style=color:#a6e22e>helper</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:noinline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>helper</span>(<span style=color:#a6e22e>fn</span> <span style=color:#66d9ef>func</span>(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fn</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>反编译</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P67_5870.jpg alt></p><ol><li>4～7行和最后两行用于栈增长，暂不需要关心。</li><li>第8～10行分配栈帧并赋值caller’s BP，RET之前的两行还原BP寄存器并释放栈帧。</li><li>CALL后面的两行用来复制返回值。</li><li>CALL连同之前的6条MOVQ指令，实现了Function Value的传参和过程调用。<ol><li>MOVQ 0x30(SP)，AX和MOVQ AX，0(SP)用于把helper()函数的第2个参数a的值复制给fn()函数的第1个参数。</li><li>MOVQ 0x38(SP)，AX和MOVQ AX，0x8(SP)同理，把helper()函数第3个参数b的值复制给fn()函数的第2个参数。</li><li>MOVQ 0x28(SP)，DX把helper()函数第1个参数fn的值复制到DX寄存器，MOVQ 0(DX)，AX把DX用作基址，加上位移0，也就是从DX存储的地址处读
取出一个64位的值，存入了AX寄存器中。</li><li>CALL AX说明，上一步中AX寄存器最终存储的是实际函数的地址。</li></ol></li></ol><p>栈分析</p><pre tabindex=0><code>40(SP) return value -|
38(SP) b             | stack of main
30(SP) a             |
28(SP) fn           -|
20(SP) return addr
18(SP) bp           -|
10(SP) return value  | stack of helper
 8(SP) b             |
 0(SP) a            -|
</code></pre><h3 id=333-闭包>3.3.3 闭包<a hidden class=anchor aria-hidden=true href=#333-闭包>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_19.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mc</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>闭包的状态保存在哪里呢？</p><ol><li>闭包对象</li></ol><p>反编译</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P69_5896.jpg alt></p><p>栈分析</p><pre tabindex=0><code>...                             |
28(SP) main arg (mc-func()int)  | stack of main
20(SP) main arg (mc-n)         -|
18(SP) return address of mc
10(SP) bp                      -|
 8(SP) newobject ret            | stack of mc
 0(SP) newobject arg           -|
</code></pre><p>推测newobject所创建的对象的结构</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 闭包对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 闭包函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>F</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 捕获列表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><ol start=2><li>看到闭包</li></ol><p>newobject的原型</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newobject</span>(<span style=color:#a6e22e>typ</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span></code></pre></td></tr></table></div></div><p>使用自定义的newobject实现来查看_type的布局</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P71_5941.jpg alt></p><p>运行结果</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P72_5963.jpg alt></p><p>因为<code>start++</code>导致start变量逃逸, 所以调用了两次newobject</p><ul><li><code>int</code></li><li><code>struct { F uintptr; start *int }</code></li></ul><p>图3-12 Function Value和闭包对象</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P73_5970.jpg alt></p><ol start=3><li>调用闭包</li></ol><p>闭包函数在被调用的时候，必须得到当前闭包对象的地址才能访问其中的捕获列表，这个地址是如何传递的呢？</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_22.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mc</span>(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>a</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mc</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>反编译</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P74_5996.jpg alt></p><ul><li>将DX寄存器用作基址，再加上位移8，把该地址处的值复制到AX寄存器中。</li><li>把AX寄存器的值复制给闭包函数的返回值。</li><li>闭包函数返回。</li></ul><blockquote><p>书中说把AX的值给闭包函数的返回值, 不太理解为啥0x8(SP)是返回值地址.</p></blockquote><ol start=4><li>闭包与变量逃逸</li></ol><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_23.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sc</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>f</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>禁用内联优化</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ go build -gcflags<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;-l&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>反编译</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P75_6022.jpg alt></p><p>return f()之前的6行汇编代码</p><ul><li>XORPS和MOVUPS这两行利用128位的寄存器X0，把栈帧上从位移8字节开始的16字节清零，这段区间就是sc()函数的局部变量区，正好符合捕获了一个int变
量的闭包对象大小。</li><li>LEAQ和MOVQ把闭包函数的地址复制到栈帧上位移8字节处，正是闭包对象中的函数指针。</li><li>接下来的两个MOVQ把sc()函数的参数n的值复制到栈帧上位移16字节处，也就是闭包捕获列表中的int变量。</li></ul><p>图3-13 sc()函数中构造的闭包对象f</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P76_6028.jpg alt></p><p>return之后的5行汇编代码</p><ul><li>MOVQ把闭包函数的地址复制到AX寄存器中，LEAQ把闭包对象的地址存储到DX寄存器中。</li><li>CALL指令调用闭包函数，接下来的两条MOVQ把闭包函数的返回值复制到sc()函数的返回值。</li></ul><p>图3-14 调用闭包函数f()</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P76_6032.jpg alt></p><p>闭包对象的捕获列表，捕获的是变量的值还是地址？</p><ul><li>只有在变量的值不会再改变的前提下，才可以复制变量的值，否则就会出现不一致错误。</li></ul><p>示例, 需要禁用内联优化</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_24.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 捕获地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sc</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>n</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>f</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_25.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 捕获值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sc</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>f</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_26.go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 捕获地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sc</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>f</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h2 id=34-defer>3.4 defer<a hidden class=anchor aria-hidden=true href=#34-defer>#</a></h2><h3 id=341-最初的链表>3.4.1 最初的链表<a hidden class=anchor aria-hidden=true href=#341-最初的链表>#</a></h3><p>使用go1.12</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_28.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	println(<span style=color:#a6e22e>df</span>(<span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>df</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>		<span style=color:#f92672>*</span><span style=color:#a6e22e>i</span> <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>	}(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>反编译df()</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P79_6112.jpg alt></p><h4 id=deferproc>deferproc<a hidden class=anchor aria-hidden=true href=#deferproc>#</a></h4><ul><li>Go语言中，每个goroutine都有自己的一个defer链表，而runtime.deferproc()函数做的事情就是把defer函数及其参数添加到链表中。</li><li>编译器还会在当前函数结尾处插入调用runtime.deferreturn()函数的代码，该函数会按照FILO的顺序调用当前函数注册的所有defer函数。</li><li>如果当前goroutine发生了panic（宕机），或者调用了runtime.Goexit()函数，runtime的panic处理逻辑会按照FILO的顺序遍历当前goroutine的整
个defer链表，并逐一调用defer函数，直到某个defer函数执行了recover，或者所有defer函数执行完毕后程序结束运行。</li></ul><p>runtime.deferproc()函数原型</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deferproc</span>(<span style=color:#a6e22e>size</span> <span style=color:#66d9ef>int32</span>, <span style=color:#a6e22e>fun</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>funcval</span>)
</span></span></code></pre></td></tr></table></div></div><ul><li>Go语言用两级指针结构统一了函数指针和闭包，这个funcval结构就是用来支持两级指针的。</li><li>funcval结构中只定义了uintptr</li></ul><p>图3-15 funcval对Function Value两级指针的支持</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P81_6139.jpg alt></p><ul><li>参数siz表示defer函数的参数占用空间的大小，这部分参数也是通过栈传递的，虽然没有出现在deferproc()函数的参数列表里，但实际上会被编译器追加
到fn的后面</li><li>注意defer函数的参数在栈上的fn后面，而不是在funcval结构的后面。这点不符合正常的Go语言函数调用约定，属于编译器的特殊处理。</li></ul><p>图3-16 df()函数调用deferproc时的栈帧</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P81_6142.jpg alt></p><p>基于第3章/code_3_28.go反编译得到的汇编代码，整理出等价的伪代码如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>df</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>v</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>deferproc</span>(<span style=color:#ae81ff>8</span>, <span style=color:#a6e22e>df</span>.<span style=color:#a6e22e>func1</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>ret</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>deferreturn</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ret</span>:
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>deferreturn</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>df</span>.<span style=color:#a6e22e>func1</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span><span style=color:#a6e22e>i</span> <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>deferproc()函数的返回值为0或非0时代表不同的含义</p><ul><li>0代表正常流程，也就是已经把需要延迟执行的函数注册到了链表中，这种情况下程序可正常执行后续逻辑。</li><li>返回值为1则表示发生了panic，并且当前defer函数执行了recover，这种情况会跳过当前函数后续的代码，直接执行返回逻辑。</li></ul><p>deferproc()函数的具体实现, 摘抄自runtime包的panic.go</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P82_6165.jpg alt></p><p>通过getcallersp()函数获取调用者的SP，也就是调用deferproc()函数之前SP寄存器的值。这个值有两个用途</p><ul><li>一是在deferreturn()函数执行defer函数时用来判断该defer是不是被当前函数注册的</li><li>二是在执行recover的时候用来还原栈指针。</li></ul><p>基于unsafe指针运算得到编译器追加在fn之后的参数列表的起始地址，存储在argp中。</p><p>通过getcallerpc()函数获取调用者指令指针的位置，在amd64上实际就是deferproc()函数的返回地址，从调用者df()函数的视角来看就是CALL
runtime.deferproc后面的那条指令的地址。这个地址主要用来在执行recover的时候还原指令指针。</p><p>调用newdefer()函数分配一个runtime._defer结构，newdefer()函数内部使用了两级缓冲池来避免频繁的堆分配，并且会自动把新分配的_defer结构添加
到链表的头部。</p><p>runtime._defer的定义</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P83_6179.jpg alt></p><ul><li>siz表示defer参数占用的空间大小，与deferproc()函数的第1个参数一样。</li><li>started表示有个panic或者runtime.Goexit()函数已经开始执行该defer函数。</li><li>_panic的值是在当前goroutine发生panic后，runtime在执行defer函数时，将该指针指向当前的_panic结构。</li><li>link指针用来指向下一个_defer结构，从而形成链表。</li></ul><p>_defer中没有发现用来存储defer函数参数的空间，参数应该被存储到哪里？</p><p>实际上runtime.newdefer()函数用了和编译器一样的手段，在分配_defer结构的时候，后面额外追加了siz大小的空间，如图3-17所示，所以deferproc()
函数接下来会将fn、callerpc、sp都复制到_defer结构中相应的字段，然后根据siz大小来复制参数，最后通过return0()函数来把返回值0写入AX寄存器中。</p><p>图3-17 deferproc执行中为_defer赋值</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P84_6185.jpg alt></p><p>通过deferproc()函数注册完一个defer函数后，deferproc()函数的返回值是0。后面如果发生了panic，又通过该defer函数成功recover，那么指令指针
和栈指针就会恢复到这里设置的pc、sp处，看起来就像刚从runtime.deferproc()函数返回，只不过返回值为1，编译器插入的if语句继而会跳过函数体，仅
执行末尾的deferreturn()函数。</p><h4 id=deferreturn>deferreturn<a hidden class=anchor aria-hidden=true href=#deferreturn>#</a></h4><p>在正常情况下，注册过的defer函数是由runtime.deferreturn()函数负责执行的，正常情况指的就是没有panic或runtime.Goexit()函数，即当前函数完
成执行并正常返回时。</p><p>deferreturn()函数的代码如下：</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P84_6192.jpg alt></p><p>值得注意的是参数arg0的值没有任何含义，实际上编译器并不会传递这个参数，deferreturn()函数内部通过它获取调用者栈帧上args to callee区间的起
始地址，从而可以将defer函数所需参数复制到该区间。defer函数的参数个数要比编译器传给deferproc()函数的参数还少两个，所以调用者的
args to callee区间大小肯定足够，不必担心复制参数会覆盖掉栈帧上的其他数据。</p><p>deferreturn()函数的主要逻辑如下：</p><ol><li>若defer链表为空，则直接返回，否则获得第1个_defer的指针d，但并不从链表中移除。</li><li>判断d.sp是否等于调用者的SP，即判断d是否由当前函数注册，如果不是，则直接返回。</li><li>如果defer函数有参数，d.siz会大于0，就将参数复制到栈上&amp;arg0处。</li><li>将d从defer链表移除，链表头指向d.link，通过runtime.freedefer()函数释放d。和runtime.newdefer()函数对应，runtime.freedefer()函数
会把d放回缓冲池中，缓冲池内部按照defer函数参数占用空间的多少分成了5个列表，对于参数太多且占用空间太大的d，超出了缓冲池的处理范围则不会被
缓存，后续会被GC回收。</li><li>通过runtime.jmpdefer()函数跳转到defer函数去执行。</li></ol><p>runtime.jmpdefer()函数是用汇编语言实现的，amd64平台下的实现代码如下：</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P85_6210.jpg alt></p><p>第2行把fn赋值给DX寄存器，3.3节中已经讲过Function Value调用时用DX寄存器传递闭包对象地址。接下来的3行代码通过设置SP和BP来还原
deferreturn()函数的栈帧，结合最后一条指令是跳转到defer函数而不是通过CALL指令来调用，这样从调用栈来看就像是deferreturn()函数的调用者直接
调用了defer函数。</p><p>jmpdefer()函数会调整返回地址，在amd64平台下会将返回地址减5，即一条CALL指令的大小，然后才会跳转到defer函数去执行。这样一来，等到defer函数
执行完毕返回的时候，刚好会返回编译器插入的runtime.deferreturn()函数调用之前，从而实现无循环、无递归地重复调用deferreturn()函数。直到当
前函数的所有defer都执行完毕，deferreturn()函数会在第1、第2步判断时返回，不经过jmpdefer()函数调整栈帧和返回地址，从而结束重复调用。</p><p>使用deferproc()函数实现defer的好处是通用性比较强，能够适应各种不同的代码逻辑。</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P86_6220.jpg alt></p><p>因为defer函数的注册是运行阶段才进行的，可以跟代码逻辑很好地整合在一起，所以像if这种条件分支不用完成额外工作就能支持。由于每个
runtime._defer结构都是基于缓冲池和堆动态分配的，所以即使不定次数的循环也不用额外处理，多次注册互不干扰。</p><p>但是链表与堆分配组合的最大缺点就是慢，即使用了两级缓冲池来优化runtime._defer结构的分配，性能方面依然不太乐观，所以在后续的版本中就开始了对
defer的优化之旅。</p><h3 id=342-栈上分配>3.4.2 栈上分配<a hidden class=anchor aria-hidden=true href=#342-栈上分配>#</a></h3><p>在1.13版本中对defer做了一点小的优化，即把runtime._defer结构分配到当前函数的栈帧上。很明显这不适用于循环中的defer，循环中的defer仍然需要
通过deferproc()函数实现，这种优化只适用于只会执行一次的defer。</p><p>编译器通过runtime.deferprocStack()函数来执行这类defer的注册，相比于runtime.deferproc()函数，少了通过缓冲池或堆分配_defer结构的步骤，
性能方面还是稍有提升的。</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P87_16307.jpg alt></p><p>runtime._defer结构中新增了一个bool型的字段heap来表示是否为堆上分配，对于这种栈上分配的_defer结构，deferreturn()函数就不会用
freedefer()函数进行释放了。因为编译器在栈帧上已经把_defer结构的某些字段包括后面追加的fn的参数都准备好了，所以deferprocStack()函数这里只
需为剩余的几个字段赋值，与deferproc()函数的逻辑基本一致。最后几行中通过unsafe.Pointer做类型转换再赋值，源码注释中解释为避免写屏障，暂时理
解成为提升性能就行了</p><p>同样使用第3章/code_3_28.go，经过Go 1.13编译器转换后的伪代码如下：</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P87_6255.jpg alt></p><p>图3-18 df()函数调用deferprocStack()时的栈帧</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P88_6273.jpg alt></p><p>栈上分配_defer这种优化只是节省了_defer结构的分配、释放时间，仍然需要将defer函数添加到链表中，在调用的时候也还要复制栈上的参数，整体提升比
较有限。</p><h3 id=343-高效的open-coded-defer>3.4.3 高效的open coded defer<a hidden class=anchor aria-hidden=true href=#343-高效的open-coded-defer>#</a></h3><p>在Go 1.14版本中又进行了一次优化，这次优化也是针对那些只会执行一次的defer。编译器不再基于链表实现这类defer，而是将这类defer直接展开为代码中
的函数调用，按照倒序放在函数返回前去执行，这就是所谓的open coded defer。</p><p>使用第3章/code_3_28.go，在1.14版本中经编译器转换后的伪代码如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>df</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>v</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>		<span style=color:#f92672>*</span><span style=color:#a6e22e>i</span> <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    }(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>两个问题：</p><ul><li>如何支持嵌套在if语句块中的defer？</li><li>当发生panic时，如何保证这些defer得以执行呢？</li></ul><p>第1个问题其实并不难解决，可以<strong>在栈帧上分配一个变量</strong>，用每个二进制位来记录一个对应的defer函数是否需要被调用。Go语言实际上用了一字节作为标
志，可以最多支持8个defer，为什么不支持更多呢？笔者是这样理解的，open coded defer本来就是为了提高性能而设计的，一个函数中写太多defer，应该
是不太在意这种层面上的性能了。</p><p>还需要考虑的一个问题是，deferproc()函数在注册的时候会存储defer函数的参数副本，defer函数的参数经常是当前函数的局部变量，即使它们后来被修改
了，deferproc()函数存储的副本也是不会变的，副本是注册那一时刻的状态，所以在open coded defer中编译器需要在当前函数栈帧上分配额外的空间来存
储defer函数的参数。</p><p>示例</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_30.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fn</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>r</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>r</span> <span style=color:#f92672>&lt;&lt;=</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>		}(<span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>经编译器转换后的等价代码如下：</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P90_6312.jpg alt></p><p>其中局部变量f就是专门用来支持if这类条件逻辑的标志位，局部变量i用作n在defer注册那一刻的副本，函数返回前根据标志位判断是否调用defer函数。</p><p>图3-19 fn()函数通过open coded defer的方式调用defer函数</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P90_6329.jpg alt></p><h2 id=35-panic>3.5 panic<a hidden class=anchor aria-hidden=true href=#35-panic>#</a></h2><h3 id=351-gopanic函数>3.5.1 gopanic()函数<a hidden class=anchor aria-hidden=true href=#351-gopanic函数>#</a></h3><p>1.12版本的gopanic()函数的源码</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P91_6343.jpg alt></p><p>从函数原型来看，与内置函数panic()完全一致，有一个interface{}类型的参数，这使gopanic()函数可以接受任意类型的参数。函数首先通过getg()函数
得到当前goroutine的g对象指针gp，然后会进行一些校验工作，主要目的是确保处在系统栈、内存分配过程中、禁止抢占或持有锁的情况下不允许发生panic。
接下来gopanic()函数在栈上分配了一个_panic类型的对象p，把参数e赋值给p的arg字段，并把p安放到当前goroutine的_panic链表的头部，特意使用
noescape()函数来避免p逃逸，因为panic本身就是与栈的状态强相关的。</p><p>runtime._panic结构的定义代码如下：</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P92_6364.jpg alt></p><ul><li>argp字段用来在defer函数执行阶段指向其args from caller区间的起始地址。</li><li>arg字段保存的就是传递给gopanic()函数的参数。</li><li>link字段用来指向链表中的下一个_panic结构。</li><li>recovered字段表示当前panic已经被某个defer函数通过recover恢复。</li><li>aborted字段表示发生了嵌套的panic，旧的panic被新的panic流程标记为aborted。</li></ul><p>gopanic()中的for循环</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P92_6372.jpg alt></p><ul><li>每次循环开始都会从gp的_defer链表头部取一项赋值给d，直到链表为空时结束循环。</li><li>接下来判断若d.started为真则表明当前是一个嵌套的panic，也就是在原有panic或Goexit()函数执行defer函数的时候又触发了panic，因为触发
panic的defer函数还没有执行完，所以还没有从链表中移除。这里会把d关联的旧的_panic设置为aborted，然后把d从链表中移除，并通过freedefer()
函数释放。</li><li>后续的3大块逻辑就是：调用defer函数、释放_defer结构和检测recover。</li></ul><ol><li>调用defer函数</li></ol><p>调用defer函数的代码如下：</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P93_6390.jpg alt></p><ul><li>首先将d.started设置为true，这样如果defer函数又触发了panic，新的panic遍历defer链表时，就能通过started的值确定该defer函数已经被调用
过了，避免重复调用。</li><li>然后为d._panic赋值，将d关联到当前panic对象p，并使用noescape()函数避免p逃逸，这一步是为了后续嵌套的panic能够通过d._panic找到上一个
panic。</li><li>接下来，p.argp被设置为当前gopanic()函数栈帧上args to callee区间的起始地址，recover()函数通过这个值来判断自身是否直接被defer函数调用</li></ul><p>reflectcall()函数</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>reflectcall</span>(<span style=color:#a6e22e>argtype</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>arg</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>argsize</span> <span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>retoffset</span> <span style=color:#66d9ef>uint32</span>)
</span></span></code></pre></td></tr></table></div></div><p>reflectcall()函数的主要逻辑是根据argsize的大小在栈上分配足够的空间，然后把arg处的参数复制到栈上，复制的大小为argsize字节，然后调用fn()
函数，再把返回值复制回arg＋retoffset处，复制的大小为argsize-retoffset字节，如果argtype不为nil，则根据argtype来应用写屏障。</p><p>在编译阶段，编译器无法知道gopanic()函数在运行阶段会调用哪些defer函数，所以也无法预分配足够大的args to callee区间，只能通过
reflectcall()函数在运行阶段进行栈增长。defer函数的返回值虽然也会被复制回调用者的栈帧上，但是Go语言会将其忽略，所以这里不必应用写屏障。</p><ol start=2><li>释放_defer结构</li></ol><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P94_6409.jpg alt></p><p>调用完d.fn()函数后，不应该出现gp._defer不等于d这种情况。假如在d.fn()函数执行的过程中没有造成新的panic，那么所有新注册的defer都应该在
d.fn()函数返回的时候被deferreturn()函数移出链表。假如d.fn()函数执行过程中造成了新的panic，若没有recover，则不会再回到这里，若经
recover之后再回到这里，则所有在d.fn()函数执行过程中注册的defer也都应该在d.fn()函数返回之前被移出链表。</p><ol start=3><li>检测recover</li></ol><p>检测recover的代码如下：</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P94_6418.jpg alt></p><p>如果d.fn()函数成功地执行了recover，则当前_panic对象p的recovered字段就会被设置为true，此处通过检测后就会执行recover逻辑。</p><p>首先把p从gp的_panic链表中移除，然后循环移除链表头部所有已经标为aborted的_panic对象。如果没有发生嵌套的panic，则此时gp._panic应该是nil，
不为nil就表明发生了嵌套的panic，而且只是内层的panic被recover。代码的最后把局部变量sp和pc赋值给gp的sigcode0和sigcode1字段，然后通过
mcall()函数执行recovery()函数。mcall()函数会切换到系统栈，然后把gp作为参数来调用recovery()函数。</p><p>recovery()函数负责用存储在sigcode0和sigcode1中的sp和pc恢复gp的执行状态。recovery()函数的主要逻辑代码如下：</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P95_6436.jpg alt></p><p>首先确保栈指针sp的值不能为0，并且还要在gp栈空间的上界与下界之间，然后把sp和pc赋值给gp.sched中对应的字段，并且把返回值设置为1。</p><p>调用gogo()函数之后，gp的栈指针和指令指针就会被恢复到sp和pc的位置，而这个位置是deferproc()函数通过getcallersp()函数和getcallerpc()函
数获得的，即deferproc()函数正常返回后的位置，所以经过某个defer函数执行recover()函数后，当前goroutine的栈指针和指令指针会被恢复到deferproc()函数刚刚注册完该defer函数后返回的位置，只不过返回值是1而不是0。</p><h3 id=352-gorecover函数>3.5.2 gorecover()函数<a hidden class=anchor aria-hidden=true href=#352-gorecover函数>#</a></h3><p>defer函数中调用了内置函数recover()，实际上只会设置_panic的一种状态。内置函数recover()对应runtime中的gorecover()函数，代码如下：</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P96_6458.jpg alt></p><p>编译器会把调用者的args from caller区间的起始地址作为参数传递给gorecover()函数。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_31.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fn</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>		recover()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>println</span>
</span></span><span style=display:flex><span>	}(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>经编译器转换后的等价代码如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fn</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gorecover</span>(uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>)))
</span></span><span style=display:flex><span>	}(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>图3-20 p.argp和gorecover()函数参数argp的关系</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P97_6480.jpg alt></p><h3 id=353-嵌套的panic>3.5.3 嵌套的panic<a hidden class=anchor aria-hidden=true href=#353-嵌套的panic>#</a></h3><p>Go语言的panic是支持嵌套的，第1个panic在执行defer函数的时候可能会注册新的defer函数，也可能会触发新的panic。如果新的panic被新注册的defer
函数中的recover恢复，则旧的panic就会继续执行，否则新的panic就会把旧的panic置为aborted。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_32.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fn</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;2&#34;</span>)
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;1&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>fn()函数首先将一个defer函数注册到当前goroutine的defer链表头部，记为defer1，然后当panic(＂1＂)执行时，会在当前goroutine的_panic链表中
新增一个_panic结构，记为panic1，panic1触发defer执行，defer1中started字段会被标记为true，_panic字段会指向panic1</p><p>图3-21 panic2执行前的_defer链表和_panic链表</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P101_6563.jpg alt></p><p>然后执行到panic(＂2＂)这里，也会在当前goroutine的_panic链表中新增一项，记为panic2。panic2同样会去执行defer链表，通过defer1记录的
_panic字段找到panic1，并将其标记为aborted，然后移除defer1，处理defer链表中的后续节点。</p><p>图3-22 panic2执行后的_defer链表和_panic链表</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P101_6567.jpg alt></p><p>在defer函数中嵌套一个带有recover的defer函数</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 第3章 code_3_35.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fu</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>			recover()
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;2&#34;</span>)
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;1&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>依然把fn()函数首先注册的defer函数记为defer1，把接下来执行的panic记为panic1，此时goroutine的_defer链表和_panic链表与图3-21中的链表并
无不同。只不过当panic1触发defer1执行时，会再次注册一个defer函数，记为defer2，然后才会执行到panic(＂2＂)，这里触发第二次panic，在_panic
链表中新增一项，记为panic2。</p><p>图3-23 defer2执行前的_defer链表和_panic链表</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P102_6589.jpg alt></p><p>然后panic2去执行_defer链表，首先执行defer2，将其started字段置为true，_panic字段指向panic2。待到defer2执行recover()函数时，只会把
panic2的recovered字段置为true，defer2结束后，从_defer链表中移除</p><p>图3-24 defer2结束后的_defer链表和_panic链表</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P103_6596.jpg alt></p><p>接下来，panic处理逻辑检测到panic2已经被刚刚执行的defer2恢复了，所以会把panic2从_panic链表中移除，如图3-25所示，然后进入recovery()函数
的逻辑中。</p><p>图3-25 panic2恢复后的_defer链表和_panic链表</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P103_6599.jpg alt></p><p>结合3.5.1节中的recovery()函数的介绍，panic2被recover后，当前协程会恢复到defer1中注册完defer2刚刚返回时的状态，只不过返回值被置为1，直
接跳转到最后的deferreturn()函数处，而此时defer链表中已经没有defer1注册的defer函数了，所以defer1结束返回，返回panic1执行defer链表的逻
辑中继续执行。</p><h3 id=354-支持open-coded-defer>3.5.4 支持open coded defer<a hidden class=anchor aria-hidden=true href=#354-支持open-coded-defer>#</a></h3><p>1.14版本中runtime._defer结构的定义</p><p><img loading=lazy src=https://res.weread.qq.com/wrepub/CB_3300047233_Figure-P104_6611.jpg alt></p><h2 id=36-本章小结>3.6 本章小结<a hidden class=anchor aria-hidden=true href=#36-本章小结>#</a></h2></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://jdxj.github.io/posts/articles/zhangdetalk/%E8%B6%85%E5%85%A8%E9%9D%A2-mysql%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/><span class=title>« Prev</span><br><span>超全面 MySQL语句加锁分析</span>
</a><a class=next href=https://jdxj.github.io/posts/articles/cnblogs/rjzheng/%E6%83%8A-%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E7%9A%84select%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90-mysql/><span class=title>Next »</span><br><span>惊! 史上最全的select加锁分析(Mysql)</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 第3章 函数 on twitter" href="https://twitter.com/intent/tweet/?text=%e7%ac%ac3%e7%ab%a0%20%e5%87%bd%e6%95%b0&amp;url=https%3a%2f%2fjdxj.github.io%2fposts%2fbooks%2f%25E6%25B7%25B1%25E5%25BA%25A6%25E6%258E%25A2%25E7%25B4%25A2go%25E8%25AF%25AD%25E8%25A8%2580--%25E5%25AF%25B9%25E8%25B1%25A1%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%258Eruntime%25E7%259A%2584%25E5%258E%259F%25E7%2590%2586%25E7%2589%25B9%25E6%2580%25A7%25E5%258F%258A%25E5%25BA%2594%25E7%2594%25A8%2f%25E7%25AC%25AC3%25E7%25AB%25A0-%25E5%2587%25BD%25E6%2595%25B0%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第3章 函数 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjdxj.github.io%2fposts%2fbooks%2f%25E6%25B7%25B1%25E5%25BA%25A6%25E6%258E%25A2%25E7%25B4%25A2go%25E8%25AF%25AD%25E8%25A8%2580--%25E5%25AF%25B9%25E8%25B1%25A1%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%258Eruntime%25E7%259A%2584%25E5%258E%259F%25E7%2590%2586%25E7%2589%25B9%25E6%2580%25A7%25E5%258F%258A%25E5%25BA%2594%25E7%2594%25A8%2f%25E7%25AC%25AC3%25E7%25AB%25A0-%25E5%2587%25BD%25E6%2595%25B0%2f&amp;title=%e7%ac%ac3%e7%ab%a0%20%e5%87%bd%e6%95%b0&amp;summary=%e7%ac%ac3%e7%ab%a0%20%e5%87%bd%e6%95%b0&amp;source=https%3a%2f%2fjdxj.github.io%2fposts%2fbooks%2f%25E6%25B7%25B1%25E5%25BA%25A6%25E6%258E%25A2%25E7%25B4%25A2go%25E8%25AF%25AD%25E8%25A8%2580--%25E5%25AF%25B9%25E8%25B1%25A1%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%258Eruntime%25E7%259A%2584%25E5%258E%259F%25E7%2590%2586%25E7%2589%25B9%25E6%2580%25A7%25E5%258F%258A%25E5%25BA%2594%25E7%2594%25A8%2f%25E7%25AC%25AC3%25E7%25AB%25A0-%25E5%2587%25BD%25E6%2595%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第3章 函数 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjdxj.github.io%2fposts%2fbooks%2f%25E6%25B7%25B1%25E5%25BA%25A6%25E6%258E%25A2%25E7%25B4%25A2go%25E8%25AF%25AD%25E8%25A8%2580--%25E5%25AF%25B9%25E8%25B1%25A1%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%258Eruntime%25E7%259A%2584%25E5%258E%259F%25E7%2590%2586%25E7%2589%25B9%25E6%2580%25A7%25E5%258F%258A%25E5%25BA%2594%25E7%2594%25A8%2f%25E7%25AC%25AC3%25E7%25AB%25A0-%25E5%2587%25BD%25E6%2595%25B0%2f&title=%e7%ac%ac3%e7%ab%a0%20%e5%87%bd%e6%95%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第3章 函数 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjdxj.github.io%2fposts%2fbooks%2f%25E6%25B7%25B1%25E5%25BA%25A6%25E6%258E%25A2%25E7%25B4%25A2go%25E8%25AF%25AD%25E8%25A8%2580--%25E5%25AF%25B9%25E8%25B1%25A1%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%258Eruntime%25E7%259A%2584%25E5%258E%259F%25E7%2590%2586%25E7%2589%25B9%25E6%2580%25A7%25E5%258F%258A%25E5%25BA%2594%25E7%2594%25A8%2f%25E7%25AC%25AC3%25E7%25AB%25A0-%25E5%2587%25BD%25E6%2595%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第3章 函数 on whatsapp" href="https://api.whatsapp.com/send?text=%e7%ac%ac3%e7%ab%a0%20%e5%87%bd%e6%95%b0%20-%20https%3a%2f%2fjdxj.github.io%2fposts%2fbooks%2f%25E6%25B7%25B1%25E5%25BA%25A6%25E6%258E%25A2%25E7%25B4%25A2go%25E8%25AF%25AD%25E8%25A8%2580--%25E5%25AF%25B9%25E8%25B1%25A1%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%258Eruntime%25E7%259A%2584%25E5%258E%259F%25E7%2590%2586%25E7%2589%25B9%25E6%2580%25A7%25E5%258F%258A%25E5%25BA%2594%25E7%2594%25A8%2f%25E7%25AC%25AC3%25E7%25AB%25A0-%25E5%2587%25BD%25E6%2595%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第3章 函数 on telegram" href="https://telegram.me/share/url?text=%e7%ac%ac3%e7%ab%a0%20%e5%87%bd%e6%95%b0&amp;url=https%3a%2f%2fjdxj.github.io%2fposts%2fbooks%2f%25E6%25B7%25B1%25E5%25BA%25A6%25E6%258E%25A2%25E7%25B4%25A2go%25E8%25AF%25AD%25E8%25A8%2580--%25E5%25AF%25B9%25E8%25B1%25A1%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%258Eruntime%25E7%259A%2584%25E5%258E%259F%25E7%2590%2586%25E7%2589%25B9%25E6%2580%25A7%25E5%258F%258A%25E5%25BA%2594%25E7%2594%25A8%2f%25E7%25AC%25AC3%25E7%25AB%25A0-%25E5%2587%25BD%25E6%2595%25B0%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jdxj.github.io>jdxj</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
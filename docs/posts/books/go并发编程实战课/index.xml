<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Go并发编程实战课 on jdxj</title><link>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/</link><description>Recent content in Go并发编程实战课 on jdxj</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 21 Apr 2023 10:33:59 +0800</lastBuildDate><atom:link href="https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/index.xml" rel="self" type="application/rss+xml"/><item><title>Pool</title><link>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/pool/</link><pubDate>Tue, 06 Jun 2023 00:16:57 +0800</pubDate><guid>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/pool/</guid><description>sync.Pool 数据类型用来保存一组可独立访问的临时对象。 sync.Pool 本身就是线程安全的 sync.Pool 不可在使用之后再复制使用 Get 方法的返回值还可能会是一个 nil（Pool.Ne</description></item><item><title>map</title><link>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/map/</link><pubDate>Sun, 04 Jun 2023 15:16:56 +0800</pubDate><guid>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/map/</guid><description>key必须是可比较的 不可比较的类型 如果 struct 的某个字段值修改了，查询 map 时无法获取它 add 进去的值 有序的map orderedmap 不能并发读写 实现线程安全map 加读写锁</description></item><item><title>Once</title><link>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/once/</link><pubDate>Tue, 30 May 2023 15:12:18 +0800</pubDate><guid>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/once/</guid><description>Once 的使用场景 1 func (o *Once) Do(f func()) Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源。 如何实现一个 On</description></item><item><title>Cond 条件变量</title><link>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/cond/</link><pubDate>Tue, 30 May 2023 12:49:56 +0800</pubDate><guid>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/cond/</guid><description>Go 标准库提供 Cond 原语的目的是，为等待/通知场景下的并发问题提供支持。 Cond 的基本用法 1 2 3 4 5 type Cond func NeWCond(l Locker) *Cond func (c *Cond) Broadcast() func (c *Cond) Signal() func (c *Cond) Wait() Cond 关联的 Locker 实例可</description></item><item><title>WaitGroup</title><link>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/waitgroup/</link><pubDate>Fri, 26 May 2023 17:23:30 +0800</pubDate><guid>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/waitgroup/</guid><description>WaitGroup 的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type WaitGroup struct { // 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则 noCopy noCopy // 64bit(8</description></item><item><title>rwMutex</title><link>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/rwmutex/</link><pubDate>Mon, 24 Apr 2023 11:16:15 +0800</pubDate><guid>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/rwmutex/</guid><description>RWMutex 一般都是基于互斥锁、条件变量（condition variables）或者信号量（semaphores）等并发原语来实现。Go 标准库中的 RWMutex 是</description></item><item><title>死锁</title><link>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/%E6%AD%BB%E9%94%81/</link><pubDate>Fri, 21 Apr 2023 12:41:24 +0800</pubDate><guid>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/%E6%AD%BB%E9%94%81/</guid><description>两个或两个以上的进程（或线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下</description></item><item><title>mutex</title><link>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/mutex/</link><pubDate>Fri, 21 Apr 2023 10:38:19 +0800</pubDate><guid>https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/mutex/</guid><description>演化过程 初版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // CAS操作，当时还没有抽象出atomic包 func cas(val *int32, old, new int32) bool</description></item></channel></rss>
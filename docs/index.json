[{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/xiaolincoding/%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E5%87%BB%E7%A9%BF-%E7%A9%BF%E9%80%8F/","summary":"原文","title":"避免缓存雪崩 击穿 穿透"},{"content":"原文\nmap本身也占用内存, 即使用 delete 删除元素后也不释放, 且在 value \u0026lt;= 128B 时, map使用原地存储会占用大量内存不释放, 造成内存泄漏.\n","permalink":"https://jdxj.github.io/posts/articles/cnblogs/go-map%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/","summary":"原文 map本身也占用内存, 即使用 delete 删除元素后也不释放, 且在 value \u0026lt;= 128B 时, map使用原地存储会占用大量内存不释放, 造成内存泄漏.","title":"Go map 竟然也会发生内存泄漏？"},{"content":" 定义IT战略，比如，定义系统（无论是打算自己构建还是从外部购买）的必要IT特性，或者识别为了支撑业务战略还需要补充到现有IT配置组合中的组件。战略也包括 “退休”系统（电影《银翼杀手》中的特色词语）以免你被僵尸系统包围。 落实对IT蓝图的管控，以实现协调一致，降低复杂度，以及确保所有系统集成为一个有效整体。架构评审委员会需要自始至终担起管控的责任。 脚踏实地地关注项目的实际情况，从实际项目实施中获得有关决策的反馈。否则，控制依然是假象。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/architect/%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E5%B7%A5%E4%BD%9C/","summary":"定义IT战略，比如，定义系统（无论是打算自己构建还是从外部购买）的必要IT特性，或者识别为了支撑业务战略还需要补充到现有IT配置组合中的组件","title":"架构师的工作"},{"content":"消防员 很多管理人员都期望，架构师能随时分析并解决任何突发的危机，因为他们对当前系统有足够全面的了解。然而，架构师不应该无视产品的问题，因为这些问题很可能反映 出架构上的设计缺陷。但是时刻都在忙着“救火”的架构师根本就没有时间去做真正的架构。架构设计需要思考，只给30分钟肯定无法完成。\n资深开发人员 开发人员常常觉得他们需要把架构师这个角色作为其职业生涯（和薪资水平）的下一个目标。但是，成为架构师和成为明星工程师完全是两条不同的路线，两者没有高低之 分。架构师需要有更广的知识面，包括组织和战略方面的能力，工程师则需要专攻可运行软件的交付。理想情况下，大型组织的首席IT架构师和资深开发人员的关系都很好。\n项目经理 架构师必须能够并行处理多个不同但相关的主题，他们在做决策时也需要考虑项目时间表、人员配备以及所需技能。因此，上层管理者经常会通过架构师获取有关项目的信 息和决策，尤其是在项目经理忙于准备项目状态报告模板的时候。这会让架构师陷于更糟糕的境地，因为虽然为管理层提供项目信息和决策也是有价值的工作，但它毕竟不 是架构师的主要职责。\n科学家 架构师要才思敏捷，要能够从系统和模型的角度进行思考，还需要为具体项目和业务计划制定决策。这常常将首席架构师的角色与首席科学家的角色区分开来，尽管这两个 角色的界限很模糊——我知道一些首席科学家就是喜欢亲力亲为。我个人更喜欢首席工程师这个头衔，它强调了架构师除了撰写文档外还需要做其他事情。最后，科学家常常 把事物理论化和复杂化，而架构师的工作则是化繁为简。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/architect/%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88/","summary":"消防员 很多管理人员都期望，架构师能随时分析并解决任何突发的危机，因为他们对当前系统有足够全面的了解。然而，架构师不应该无视产品的问题，因为这","title":"架构师不是什么"},{"content":"原文\ngo 1.21及之前\n1 2 3 4 5 有两个重要的事实存在： 被遍历的容器值是aContainer的一个副本。 注意，只有aContainer的直接部分被复制了。 此副本是一个匿名的值，所以它是不可被修改的。 如果aContainer是一个数组，那么在遍历过程中对此数组元素的修改不会体现到循环变量中。 原因是此数组的副本（被真正遍历的容器）和此数组不共享任何元素。 如果aContainer是一个切片（或者映射），那么在遍历过程中对此切片（或者映射）元素的修改将体现到循环变量中。 原因是此切片（或者映射）的副本和此切片（或者映射）共享元素（或条目）。 在遍历中的每个循环步，aContainer副本中的一个键值元素对将被赋值（复制）给循环变量。 所以对循环变量的直接部分的修改将不会体现在aContainer中的对应元素中。 （因为这个原因，并且for-range循环是遍历映射条目的唯一途径，所以最好不要使用大尺寸的映射键值和元素类型，以避免较大的复制负担。） go 1.22\n1 从Go 1.22版本开始，每组键值元素对将被赋值给一对与众不同的循环变量实例（既循环变量在每个循环步都会生成一份新的实例）。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/go/go-range%E5%88%B0%E5%BA%95%E5%A4%8D%E5%88%B6%E4%BA%86%E4%BB%80%E4%B9%88/","summary":"原文 go 1.21及之前 1 2 3 4 5 有两个重要的事实存在： 被遍历的容器值是aContainer的一个副本。 注意，只有aContainer的直接部分","title":"Go Range到底复制了什么?"},{"content":"原文\n既不执行 ioutil.ReadAll(resp.Body) 也不执行resp.Body.Close()，并且不设置http.Client内timeout的时候，就会导致协程泄露。 SetDeadline是指 tcp 连接存活时长 ","permalink":"https://jdxj.github.io/posts/articles/weixin/go-http/","summary":"原文 既不执行 ioutil.ReadAll(resp.Body) 也不执行resp.Body.Close()，并且不设置http.Client内timeout的时候，就会导致协程泄露。 SetD","title":"用Go 请求接口不执行body.Close()会内存溢出吗？这次告诉你真相！"},{"content":"原文\n消息队列 + 线程池\n","permalink":"https://jdxj.github.io/posts/articles/weixin/%E5%BC%82%E6%AD%A5%E9%87%8D%E8%AF%95/","summary":"原文 消息队列 + 线程池","title":"如何实现异步通知的重试机制"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALTER SYSTEM SET max_connections = \u0026#39;20\u0026#39;; ALTER SYSTEM SET shared_buffers = \u0026#39;64MB\u0026#39;; ALTER SYSTEM SET effective_cache_size = \u0026#39;768MB\u0026#39;; ALTER SYSTEM SET maintenance_work_mem = \u0026#39;32MB\u0026#39;; ALTER SYSTEM SET random_page_cost = \u0026#39;1.1\u0026#39;; ALTER SYSTEM SET work_mem = \u0026#39;6553kB\u0026#39;; ALTER SYSTEM SET huge_pages = \u0026#39;off\u0026#39;; 参考 必看！PostgreSQL参数优化 PGTune ","permalink":"https://jdxj.github.io/posts/articles/jdxj/postgresql%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALTER SYSTEM SET max_connections = \u0026#39;20\u0026#39;; ALTER SYSTEM SET shared_buffers = \u0026#39;64MB\u0026#39;; ALTER SYSTEM SET effective_cache_size = \u0026#39;768MB\u0026#39;; ALTER SYSTEM SET maintenance_work_mem = \u0026#39;32MB\u0026#39;; ALTER SYSTEM SET random_page_cost = \u0026#39;1.1\u0026#39;; ALTER SYSTEM SET work_mem = \u0026#39;6553kB\u0026#39;; ALTER SYSTEM SET huge_pages = \u0026#39;off\u0026#39;; 参考 必看！PostgreSQ","title":"PostgreSQL内存配置"},{"content":"设置时区\n1 $ timedatectl set-timezone Asia/Shanghai 时区列表\n1 timedatectl list-timezones ","permalink":"https://jdxj.github.io/posts/cmd/timedatectl/","summary":"设置时区 1 $ timedatectl set-timezone Asia/Shanghai 时区列表 1 timedatectl list-timezones","title":"timedatectl"},{"content":"原文\n# /etc/my.cnf: innodb_buffer_pool_size=5M innodb_log_buffer_size=256K max_connections=50 key_buffer_size=8 thread_cache_size=1 host_cache_size=0 innodb_ft_cache_size=1600000 innodb_ft_total_cache_size=32000000 # per thread or per operation settings thread_stack=131072 sort_buffer_size=32K read_buffer_size=8200 read_rnd_buffer_size=8200 max_heap_table_size=16K tmp_table_size=1K bulk_insert_buffer_size=0 join_buffer_size=128 net_buffer_length=1K innodb_sort_buffer_size=64K #settings that relate to the binary log (if enabled) binlog_cache_size=4K binlog_stmt_cache_size=4K innodb_buffer_pool_size innodb_log_buffer_size max_connections key_buffer_size thread_cache_size host_cache_size innodb_ft_cache_size innodb_ft_total_cache_size thread_stack sort_buffer_size read_buffer_size read_rnd_buffer_size max_heap_table_size tmp_table_size bulk_insert_buffer_size join_buffer_size net_buffer_length innodb_sort_buffer_size binlog_cache_size binlog_stmt_cache_size ","permalink":"https://jdxj.github.io/posts/articles/tocker/mysql%E5%B0%8F%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE/","summary":"原文 # /etc/my.cnf: innodb_buffer_pool_size=5M innodb_log_buffer_size=256K max_connections=50 key_buffer_size=8 thread_cache_size=1 host_cache_size=0 innodb_ft_cache_size=1600000 innodb_ft_total_cache_size=32000000 # per thread or per operation settings thread_stack=131072 sort_buffer_size=32K read_buffer_size=8200 read_rnd_buffer_size=8200 max_heap_table_size=16K tmp_table_size=1K bulk_insert_buffer_size=0 join_buffer_size=128 net_buffer_length=1K innodb_sort_buffer_size=64K #settings that relate to the binary log (if enabled) binlog_cache_size=4K binlog_stmt_cache_size=4K innodb_buffer_pool_size innodb_log_buffer_size max_connections key_buffer_size thread_cache_size host_cache_size innodb_ft_cache_size innodb_ft_total_cache_size thread_stack sort_buffer_size read_buffer_size read_rnd_buffer_size max_heap_table_size tmp_table_size bulk_insert_buffer_size join_buffer_size net_buffer_length innodb_sort_buffer_size binlog_cache_size binlog_stmt_cache_size","title":"Configuring MySQL to use minimal memory"},{"content":"原文\n1 2 $ go test -c pkgName $ ./pkgName.test -test.run \u0026#34;TestXxx$\u0026#34; -test.v ","permalink":"https://jdxj.github.io/posts/articles/jdxj/go/go%E6%B5%8B%E8%AF%95%E7%BC%96%E8%AF%91%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%A7%E8%A1%8C/","summary":"原文 1 2 $ go test -c pkgName $ ./pkgName.test -test.run \u0026#34;TestXxx$\u0026#34; -test.v","title":"Go测试编译为二进制执行"},{"content":"原文\nGET /zoos：列出所有动物园 POST /zoos：新建一个动物园 GET /zoos/ID：获取某个指定动物园的信息 PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/ID：删除某个动物园 GET /zoos/ID/animals：列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 ","permalink":"https://jdxj.github.io/posts/articles/ruanyifeng/restful/","summary":"原文 GET /zoos：列出所有动物园 POST /zoos：新建一个动物园 GET /zoos/ID：获取某个指定动物园的信息 PUT /zoos/ID：更新某个指定动物","title":"RESTful API 设计指南"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/xiaofang520/mysql-charset/","summary":"原文","title":"MySQL字符集和排序规则详解"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/cnblogs/clear-binlog/","summary":"原文","title":"mysql正确清理binlog日志的方法"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/cmd/du/","summary":"原文","title":"du"},{"content":"可以先从编程语言中的锁思考, 比如Go. 在Go中访问并发资源可能会使用互斥Mutex, 如果想进一步提升性能, 那么可以使用RWMutex. 如果极致一点可以利用无锁编程技术CAS.\n在MySQL中也有类似的想法. 首先对于更新操作并发访问肯定是不允许的, 所以要用锁.\n对于读的情况\n如果有多个线程对相同数据行只读, 那么无需使用锁, 只需利用事务隔离级别(MVCC/快照读)来保证读取前后一致性 如果存在先读数据行, 之后再更新数据行的逻辑不能用快照读, 应当使用当前读(for update) 相关阅读 事务篇 锁篇 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/%E5%AF%B9mysql%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/","summary":"可以先从编程语言中的锁思考, 比如Go. 在Go中访问并发资源可能会使用互斥Mutex, 如果想进一步提升性能, 那么可以使用RWMutex. 如果极","title":"对MySQL并发控制的理解"},{"content":"原文\n并发读写 string 会出错.\n","permalink":"https://jdxj.github.io/posts/articles/weixin/go-string-panic/","summary":"原文 并发读写 string 会出错.","title":"踩坑记：Go服务灵异panic"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/xiaorui/go-http-shutdown/","summary":"原文","title":"源码分析golang http shutdown优雅退出的原理"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/cnblogs/docker-net/","summary":"原文","title":"Docker网络详解——原理篇"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/tonybai/go_timer/","summary":"原文","title":"论golang Timer Reset方法使用的正确姿势"},{"content":" nohup /dev/null 2\u0026gt;\u0026amp;1 含义详解 ","permalink":"https://jdxj.github.io/posts/cmd/nohup/","summary":"nohup /dev/null 2\u0026gt;\u0026amp;1 含义详解","title":"nohup"},{"content":"指令 自定义指令 computed 计算属性 watch 侦听器 生命周期 组件 组件通信 组件分类 页面组件, src/views 复用组件, src/components 插槽 vueRouter 路由 router-link 查询参数传参 动态路由传参 重定向 404页面 路由模式 编程式导航 查询参数传参 动态路由传参 vuex 状态管理 mutations ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vue/vue%E7%9F%A5%E8%AF%86%E7%82%B9/","summary":"指令 自定义指令 computed 计算属性 watch 侦听器 生命周期 组件 组件通信 组件分类 页面组件, src/views 复用组件, src/components 插槽 vueRouter 路由 router-link 查询参数传参 动态路由传参 重定向 404页面 路由","title":"vue知识点"},{"content":"是一个语法糖\n1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input v-model=\u0026#34;msg\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;input :value=\u0026#34;msg\u0026#34; @input=\u0026#34;msg = $event.target.value\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 不同的标签有不同的事件\n1 \u0026lt;select :value=\u0026#34;value\u0026#34; @change=\u0026#34;selectCity\u0026#34;\u0026gt; ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vue/v-model%E5%8E%9F%E7%90%86/","summary":"是一个语法糖 1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input v-model=\u0026#34;msg\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;input :value=\u0026#34;msg\u0026#34; @input=\u0026#34;msg = $event.target.value\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 不同的标签有不同的事件 1 \u0026lt;select :value=\u0026#34;value\u0026#34; @change=\u0026#34;selectCity\u0026#34;\u0026gt;","title":"v-model原理"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/zhihu/sudo/","summary":"原文","title":"sudo命令实现原理简析"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/zhihu/go_timer/","summary":"原文","title":"Go Timer 详解以及 Reset 和 Stop 的正确用法"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/go_trace/","summary":"原文","title":"Go_trace"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/eddycjy/trace/","summary":"原文","title":"Go 大杀器之跟踪剖析 trace"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/ruanyifeng/cors/","summary":"原文","title":"跨域资源共享 CORS 详解"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/meituan/innodb-lock/","summary":"原文","title":"Innodb中的事务隔离级别和锁的关系"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;time\u0026#34; \u0026#34;github.com/sasha-s/go-deadlock\u0026#34; ) func main() { dl() } func dl() { m1 := \u0026amp;deadlock.Mutex{} m2 := \u0026amp;deadlock.Mutex{} go func() { lock(m2, m1) }() lock(m1, m2) } func lock(m1, m2 *deadlock.Mutex) { m1.Lock() time.Sleep(time.Second) m2.Lock() time.Sleep(time.Second) m2.Unlock() m1.Unlock() } ","permalink":"https://jdxj.github.io/posts/articles/jdxj/go/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;time\u0026#34; \u0026#34;github.com/sasha-s/go-deadlock\u0026#34; ) func main() { dl() } func dl() { m1 := \u0026amp;deadlock.Mutex{} m2 := \u0026amp;deadlock.Mutex{} go func() { lock(m2, m1) }() lock(m1, m2) } func lock(m1, m2 *deadlock.Mutex) { m1.Lock() time.Sleep(time.Second)","title":"死锁检测"},{"content":" 介绍 排查内存泄漏的示例 goroutine泄漏的示例 CPU占用情况的示例 Profiling Go Programs pprof go pprof 性能分析 golang pprof 实战 实战Go内存泄露 golang 死锁检测 一些命令\n1 2 3 4 5 $ go tool pprof http://localhost:6060/debug/pprof/profile # pprof 内部命令 (pprof) top (pprof) list funcName (pprof) web # 生成svg ","permalink":"https://jdxj.github.io/posts/articles/jdxj/go/pprof/","summary":"介绍 排查内存泄漏的示例 goroutine泄漏的示例 CPU占用情况的示例 Profiling Go Programs pprof go pprof 性能分析 golang pprof 实战 实战Go内存泄露 golang 死锁检测 一些命令 1 2 3 4","title":"pprof"},{"content":" Vue2: defineProperty API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let getDouble = n=\u0026gt;n*2 let obj = {} let count = 1 let double = getDouble(count) Object.defineProperty(obj,\u0026#39;count\u0026#39;,{ get(){ return count }, set(val){ count = val double = getDouble(val) } }) console.log(double) // 打印2 obj.count = 2 console.log(double) // 打印4 有种自动变化的感觉 缺陷\n删除 obj.count 属性，set 函数就不会执行，double 还是之前的数值。 Vue3: Proxy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 let proxy = new Proxy(obj,{ get : function (target,prop) { return target[prop] }, set : function (target,prop,value) { target[prop] = value; if(prop===\u0026#39;count\u0026#39;){ double = getDouble(value) } }, deleteProperty(target,prop){ delete target[prop] if(prop===\u0026#39;count\u0026#39;){ double = NaN } } }) console.log(obj.count,double) proxy.count = 2 console.log(obj.count,double) delete proxy.count // 删除属性后，我们打印log时，输出的结果就会是 undefined NaN console.log(obj.count,double) 对象的 get 和 set 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let getDouble = n =\u0026gt; n * 2 let _value = 1 double = getDouble(_value) let count = { get value() { return _value }, set value(val) { _value = val double = getDouble(_value) } } console.log(count.value,double) count.value = 2 console.log(count.value,double) ","permalink":"https://jdxj.github.io/posts/articles/jdxj/js/vue%E4%B8%89%E7%A7%8D%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","summary":"Vue2: defineProperty API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let getDouble = n=\u0026gt;n*2 let obj = {} let count = 1 let double = getDouble(count) Object.defineProperty(obj,\u0026#39;count\u0026#39;,{ get(){ return count }, set(val){ count = val double = getDouble(val) } }) console.log(double) // 打印2 obj.count = 2 console.log(double) // 打印4 有种自动变化的","title":"Vue三种响应式原理"},{"content":"指标 网络接口层和网络层\n它们主要负责网络包的封装、寻址、路由，以及发送和接收。每秒可处理的网络包数 PPS，就是它们最重要的性能指标（特别是在小包的情况下）。 传输层的 TCP 和 UDP\n主要负责网络传输。对它们而言，吞吐量（BPS）、连接数以及延迟，就是最重要的性能指标。 应用层\n最需要关注的是吞吐量（BPS）、每秒请求数以及延迟等指标。 网络性能工具 网络性能优化 应用程序 epoll 异步 I/O 应用层的网络协议优化 长连接取代短连接 缓存 Protocol Buffer DNS 缓存、预取、HTTPDNS 套接字 调整缓冲区的大小\n传输层 网络层 负责网络包的封装、寻址和路由，包括 IP、ICMP 等常见协议。在网络层，最主要的优化，其实就是对路由、 IP 分片以及 ICMP 等进行调优。\n在需要转发的服务器中，比如用作 NAT 网关的服务器或者使用 Docker 容器时，开启 IP 转发，即设置 net.ipv4.ip_forward = 1。\n调整数据包的生存周期 TTL，比如设置 net.ipv4.ip_default_ttl = 64。注意，增大该值会降低系统性能。\n开启数据包的反向地址校验，比如设置 net.ipv4.conf.eth0.rp_filter = 1。这样可以防止 IP 欺骗，并减少伪造 IP 带来的 DDoS 问题。\n在使用 VXLAN、GRE 等叠加网络技术时，要注意，网络叠加会使原来的网络包变大，导致 MTU 也需要调整。\n从 ICMP 的角度出发，为了避免 ICMP 主机探测、ICMP Flood 等各种网络问题，你可以通过内核选项，来限制 ICMP 的行为。\n禁止 ICMP 协议，即设置 net.ipv4.icmp_echo_ignore_all = 1。这样，外部主机就无法通过 ICMP 来探测主机。 禁止广播 ICMP，即设置 net.ipv4.icmp_echo_ignore_broadcasts = 1。 链路层 负责网络包在物理网络中的传输，比如 MAC 寻址、错误侦测以及通过网卡传输网络帧等。\n由于网卡收包后调用的中断处理程序（特别是软中断），需要消耗大量的 CPU。所以，将这些中断处理程序调度到不同的 CPU 上执行，就可以显著提高网络吞 吐量。\n为网卡硬中断配置 CPU 亲和性（smp_affinity），或者开启 irqbalance 服务。 开启 RPS（Receive Packet Steering）和 RFS（Receive Flow Steering），将应用程序和软中断的处理，调度到相同 CPU 上，这样就可以增加 CPU 缓存命中率，减少网络延迟。 现在的网卡都有很丰富的功能，原来在内核中通过软件处理的功能，可以卸载到网卡中，通过硬件来执行。\nTSO（TCP Segmentation Offload）和 UFO（UDP Fragmentation Offload）：在 TCP/UDP 协议中直接发送大包；而 TCP 包的分段（按照 MSS 分段）和 UDP 的分片（按照 MTU 分片）功能，由网卡来完成 。 GSO（Generic Segmentation Offload）：在网卡不支持 TSO/UFO 时，将 TCP/UDP 包的分段，延迟到进入网卡前再执行。这样，不仅可以减少 CPU 的消耗，还可以在发生丢包时只重传分段后的包。 LRO（Large Receive Offload）：在接收 TCP 分段包时，由网卡将其组装合并后，再交给上层网络处理。不过要注意，在需要 IP 转发的情况下，不能 开启 LRO，因为如果多个包的头部信息不一致，LRO 合并会导致网络包的校验错误。 GRO（Generic Receive Offload）：GRO 修复了 LRO 的缺陷，并且更为通用，同时支持 TCP 和 UDP。RSS（Receive Side Scaling）：也称为多 队列接收，它基于硬件的多个接收队列，来分配网络接收进程，这样可以让多个 CPU 来处理接收到的网络包。 VXLAN 卸载：也就是让网卡来完成 VXLAN 的组包功能。 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/network/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","summary":"指标 网络接口层和网络层 它们主要负责网络包的封装、寻址、路由，以及发送和接收。每秒可处理的网络包数 PPS，就是它们最重要的性能指标（特别是在小","title":"网络性能优化"},{"content":"https://github.com/wg/wrk\n1 2 3 4 5 6 7 8 9 10 11 # -c表示并发连接数1000，-t表示线程数为2 $ wrk -c 1000 -t 2 http://192.168.0.30/ Running 10s test @ http://192.168.0.30/ 2 threads and 1000 connections Thread Stats Avg Stdev Max +/- Stdev Latency 65.83ms 174.06ms 1.99s 95.85% Req/Sec 4.87k 628.73 6.78k 69.00% 96954 requests in 10.06s, 78.59MB read Socket errors: connect 0, read 0, write 0, timeout 179 Requests/sec: 9641.31 Transfer/sec: 7.82MB 参考 wrk——轻量级异步性能测试工具 ","permalink":"https://jdxj.github.io/posts/cmd/wrk/","summary":"HTTP 性能测试工具","title":"wrk"},{"content":"目标机器上启动 iperf 服务端\n1 2 # -s表示启动服务端，-i表示汇报间隔，-p表示监听端口 $ iperf3 -s -i 1 -p 10000 运行 iperf 客户端\n1 2 3 4 5 # -c表示启动客户端，192.168.0.30为目标服务器的IP # -b表示目标带宽(单位是bits/s) # -t表示测试时间 # -P表示并发数，-p表示目标服务器监听端口 $ iperf3 -c 192.168.0.30 -b 1G -t 15 -P 2 -p 10000 iperf 的报告\n1 2 3 4 [ ID] Interval Transfer Bandwidth ... [SUM] 0.00-15.04 sec 0.00 Bytes 0.00 bits/sec sender [SUM] 0.00-15.04 sec 1.51 GBytes 860 Mbits/sec receiver ","permalink":"https://jdxj.github.io/posts/cmd/iperf/","summary":"网络性能测试工具","title":"iperf"},{"content":"各协议层的性能测试 转发性能 网络接口层和网络层，它们主要负责网络包的封装、寻址、路由以及发送和接收。在这两个网络协议层中，每秒可处理的网络包数 PPS，就是最重要的性能指标。 特别是 64B 小包的处理能力，值得我们特别关注。\n相关测试工具\npktgen pgctrl TCP/UDP 性能 iperf3 HTTP 性能 ab 应用负载性能 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/network/%E8%AF%84%E4%BC%B0%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/","summary":"各协议层的性能测试 转发性能 网络接口层和网络层，它们主要负责网络包的封装、寻址、路由以及发送和接收。在这两个网络协议层中，每秒可处理的网络包数","title":"评估网络性能"},{"content":" 1 2 $ ethtool eth0 | grep Speed Speed: 1000Mb/s ","permalink":"https://jdxj.github.io/posts/cmd/ethtool/","summary":" 1 2 $ ethtool eth0 | grep Speed Speed: 1000Mb/s ","title":"ethtool"},{"content":" 1 2 3 4 5 6 7 8 # -l 表示只显示监听套接字 # -t 表示只显示 TCP 套接字 # -n 表示显示数字地址和端口(而不是名字) # -p 表示显示进程信息 $ ss -ltnp | head -n 3 State Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 127.0.0.53%lo:53 0.0.0.0:* users:((\u0026#34;systemd-resolve\u0026#34;,pid=840,fd=13)) LISTEN 0 128 0.0.0.0:22 0.0.0.0:* users:((\u0026#34;sshd\u0026#34;,pid=1459,fd=3)) 接收队列（Recv-Q）和发送队列（Send-Q），它们通常应该是 0。当你发现它们不是 0 时，说明有网络包的堆积发生。\n当套接字处于连接状态（Established）时\nRecv-Q 表示套接字缓冲还没有被应用程序取走的字节数（即接收队列长度）。 Send-Q 表示还没有被远端主机确认的字节数（即发送队列长度）。 当套接字处于监听状态（Listening）时\nRecv-Q 表示全连接队列的长度。 Send-Q 表示全连接队列的最大长度。 所谓全连接，是指服务器收到了客户端的 ACK，完成了 TCP 三次握手，然后就会把这个连接挪到全连接队列中。这些全连接中的套接字，还需要被 accept() 系统调用取走，服务器才可以开始真正处理客户端的请求。\n所谓半连接是指还没有完成 TCP 三次握手的连接，连接只进行了一半。服务器收到了客户端的 SYN 包后，就会把这个连接放到半连接队列中，然后再向客户 端发送 SYN+ACK 包。\n协议栈统计信息\n1 2 3 4 5 6 7 8 9 10 $ ss -s Total: 186 (kernel 1446) TCP: 4 (estab 1, closed 0, orphaned 0, synrecv 0, timewait 0/0), ports 0 Transport Total IP IPv6 * 1446 - - RAW 2 1 1 UDP 2 2 0 TCP 4 3 1 ... ","permalink":"https://jdxj.github.io/posts/cmd/ss/","summary":"查看套接字、网络栈、网络接口以及路由表的信息","title":"ss"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 $ ip -s addr show dev eth0 2: eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 78:0d:3a:07:cf:3a brd ff:ff:ff:ff:ff:ff inet 10.240.0.30/12 brd 10.255.255.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::20d:3aff:fe07:cf2a/64 scope link valid_lft forever preferred_lft forever RX: bytes packets errors dropped overrun mcast 9542432350 40809397 0 0 0 193 TX: bytes packets errors dropped carrier collsns 4815625265 32637658 0 0 0 0 ip 输出中的 LOWER_UP ，都表示物理网络是连通的，即网卡已经连接到了交换机或者路由器中。如果你看不到它们，通常表示网线被拔掉了。\nMTU 的大小。MTU 默认大小是 1500，根据网络架构的不同（比如是否使用了 VXLAN 等叠加网络），你可能需要调大或者调小 MTU 的数值。\nerrors 表示发生错误的数据包数，比如校验错误、帧同步错误等；\ndropped 表示丢弃的数据包数，即数据包已经收到了 Ring Buffer，但因为内存不足等原因丢包；\noverruns 表示超限数据包数，即网络 I/O 速度过快，导致 Ring Buffer 中的数据包来不及处理（队列满）而导致的丢包；\ncarrier 表示发生 carrirer 错误的数据包数，比如双工模式不匹配、物理电缆出现问题等；collisions 表示碰撞数据包数。\n","permalink":"https://jdxj.github.io/posts/cmd/ip/","summary":"1 2 3 4 5 6 7 8 9 10 11 $ ip -s addr show dev eth0 2: eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 78:0d:3a:07:cf:3a brd ff:ff:ff:ff:ff:ff inet 10.240.0.30/12 brd 10.255.255.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::20d:3aff:fe07:cf2a/64 scope link valid_lft forever preferred_lft forever RX: bytes packets errors dropped overrun mcast 9542432350 40809397 0 0 0 193 TX: bytes packets","title":"ip"},{"content":" 带宽，表示链路的最大传输速率，单位通常为 b/s （比特 / 秒）。 吞吐量，表示单位时间内成功传输的数据量，单位通常为 b/s（比特 / 秒）或者 B/s（字节 / 秒）。吞吐量受带宽限制，而吞吐量 / 带宽，也就是该网 络的使用率。 延时，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。在不同场景中，这一指标可能会有不同含义。比如，它可以表示，建立连接需要的 时间（比如 TCP 握手延时），或一个数据包往返所需的时间（比如 RTT）。 PPS，是 Packet Per Second（包 / 秒）的缩写，表示以网络包为单位的传输速率。PPS 通常用来评估网络的转发能力，比如硬件交换机，通常可以达到 线性转发（即 PPS 可以达到或者接近理论最大值）。而基于 Linux 服务器的转发，则容易受网络包大小的影响。 网络的可用性（网络能否正常通信） 并发连接数（TCP 连接数量） 丢包率（丢包百分比） 重传率（重新传输的网络包比例） ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/network/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/","summary":"带宽，表示链路的最大传输速率，单位通常为 b/s （比特 / 秒）。 吞吐量，表示单位时间内成功传输的数据量，单位通常为 b/s（比特 / 秒）或者 B/s（字节","title":"网络性能指标"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/cmd/find/","summary":"原文","title":"find"},{"content":"I/O性能指标 文件系统 I/O 性能指标\n存储空间的使用情况，包括容量、使用量以及剩余空间 索引节点的使用情况，它也包括容量、使用量以及剩余量等三个指标 缓存使用情况，包括页缓存、目录项缓存、索引节点缓存以及各个具体文件系统（如 ext4、XFS 等）的缓存。 文件 I/O, IOPS（包括 r/s 和 w/s）、响应时间（延迟）以及吞吐量（B/s）等。 磁盘 I/O 性能指标\n使用率，是指磁盘忙处理 I/O 请求的百分比。过高的使用率（比如超过 60%）通常意味着磁盘 I/O 存在性能瓶颈。 IOPS（Input/Output Per Second），是指每秒的 I/O 请求数。 吞吐量，是指每秒的 I/O 请求大小。 响应时间，是指从发出 I/O 请求到收到响应的间隔时间。 free命令中的buffer分析 根据指标找工具 根据工具查指标 迅速分析 I/O 的性能瓶颈 先用 iostat 发现磁盘 I/O 性能瓶颈； 再借助 pidstat ，定位出导致瓶颈的进程； 随后分析进程的 I/O 行为； 最后，结合应用程序的原理，分析这些 I/O 的来源 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/file-system/%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9Fio%E7%93%B6%E9%A2%88/","summary":"I/O性能指标 文件系统 I/O 性能指标 存储空间的使用情况，包括容量、使用量以及剩余空间 索引节点的使用情况，它也包括容量、使用量以及剩余量等三个指标","title":"分析系统I/O瓶颈"},{"content":" 1 2 3 4 $ opensnoop 12280 python 6 0 /tmp/9046db9e-fe25-11e8-b13f-0242ac110002/650.txt 12280 python 6 0 /tmp/9046db9e-fe25-11e8-b13f-0242ac110002/651.txt 12280 python 6 0 /tmp/9046db9e-fe25-11e8-b13f-0242ac110002/652.txt ","permalink":"https://jdxj.github.io/posts/cmd/opensnoop/","summary":"动态跟踪内核中的 open 系统调用","title":"opensnoop"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 切换到工具目录 $ cd /usr/share/bcc/tools # -C 选项表示输出新内容时不清空屏幕 $ ./filetop -C TID COMM READS WRITES R_Kb W_Kb T FILE 514 python 0 1 0 2832 R 669.txt 514 python 0 1 0 2490 R 667.txt 514 python 0 1 0 2685 R 671.txt 514 python 0 1 0 2392 R 670.txt 514 python 0 1 0 2050 R 672.txt ... TID COMM READS WRITES R_Kb W_Kb T FILE 514 python 2 0 5957 0 R 651.txt 514 python 2 0 5371 0 R 112.txt 514 python 2 0 4785 0 R 861.txt 514 python 2 0 4736 0 R 213.txt 514 python 2 0 4443 0 R 45.txt filetop 输出了 8 列内容，分别是线程 ID、线程命令行、读写次数、读写的大小（单位 KB）、文件类型以及读写的文件名称。\n","permalink":"https://jdxj.github.io/posts/cmd/filetop/","summary":"跟踪内核中文件的读写情况","title":"filetop"},{"content":"“文件”不只有普通文件，还包括了目录、块设备、动态库、网络套接字等。\n1 2 3 4 5 6 7 $ lsof -p 18940 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME python 18940 root cwd DIR 0,50 4096 1549389 / python 18940 root rtd DIR 0,50 4096 1549389 / … python 18940 root 2u CHR 136,0 0t0 3 /dev/pts/0 python 18940 root 3w REG 8,1 117944320 303 /tmp/logtest.txt FD 表示文件描述符号，TYPE 表示文件类型，NAME 表示文件路径。 这个进程打开了文件 /tmp/logtest.txt，并且它的文件描述符是 3 号，而 3 后面的 w ，表示以写的方式打开。 1 2 3 4 $ lsof -p 27458 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME ... mysqld 27458 999 38u REG 8,1 512440000 2601895 /var/lib/mysql/test/products.MYD 38 后面的 u 表示， mysqld 以读写的方式访问文件。 1 2 3 4 5 6 7 $ lsof -p 9085 redis-ser 9085 systemd-network 3r FIFO 0,12 0t0 15447970 pipe redis-ser 9085 systemd-network 4w FIFO 0,12 0t0 15447970 pipe redis-ser 9085 systemd-network 5u a_inode 0,13 0 10179 [eventpoll] redis-ser 9085 systemd-network 6u sock 0,9 0t0 15447972 protocol: TCP redis-ser 9085 systemd-network 7w REG 8,1 8830146 2838532 /data/appendonly.aof redis-ser 9085 systemd-network 8u sock 0,9 0t0 15448709 protocol: TCP 描述符编号为 3 的是一个 pipe 管道，5 号是 eventpoll，7 号是一个普通文件，而 8 号是一个 TCP socket。\n1 2 3 4 5 6 7 # -i表示显示网络套接字信息 $ lsof -i COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME redis-ser 9085 systemd-network 6u IPv4 15447972 0t0 TCP localhost:6379 (LISTEN) redis-ser 9085 systemd-network 8u IPv4 15448709 0t0 TCP localhost:6379-\u0026gt;localhost:32996 (ESTABLISHED) python 9181 root 3u IPv4 15448677 0t0 TCP *:http (LISTEN) python 9181 root 5u IPv4 15449632 0t0 TCP localhost:32996-\u0026gt;localhost:6379 (ESTABLISHED) ","permalink":"https://jdxj.github.io/posts/cmd/lsof/","summary":"用来查看进程打开文件列表","title":"lsof"},{"content":" 1 2 3 4 5 $ iotop Total DISK READ : 0.00 B/s | Total DISK WRITE : 7.85 K/s Actual DISK READ: 0.00 B/s | Actual DISK WRITE: 0.00 B/s TID PRIO USER DISK READ DISK WRITE SWAPIN IO\u0026gt; COMMAND 15055 be/3 root 0.00 B/s 7.85 K/s 0.00 % 0.00 % systemd-journald 前两行分别表示，进程的磁盘读写大小总数和磁盘真实的读写大小总数。因为缓存、缓冲区、I/O 合并等因素的影响，它们可能并不相等。\n剩下的部分，则是从各个角度来分别表示进程的 I/O 情况，包括线程 ID、I/O 优先级、每秒读磁盘的大小、每秒写磁盘的大小、换入和等待 I/O 的时钟百 分比等。\n","permalink":"https://jdxj.github.io/posts/cmd/iotop/","summary":"I/O性能分析","title":"iotop"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 # 随机读 fio -name=randread -direct=1 -iodepth=64 -rw=randread -ioengine=libaio -bs=4k -size=1G -numjobs=1 -runtime=1000 -group_reporting -filename=/dev/sdb # 随机写 fio -name=randwrite -direct=1 -iodepth=64 -rw=randwrite -ioengine=libaio -bs=4k -size=1G -numjobs=1 -runtime=1000 -group_reporting -filename=/dev/sdb # 顺序读 fio -name=read -direct=1 -iodepth=64 -rw=read -ioengine=libaio -bs=4k -size=1G -numjobs=1 -runtime=1000 -group_reporting -filename=/dev/sdb # 顺序写 fio -name=write -direct=1 -iodepth=64 -rw=write -ioengine=libaio -bs=4k -size=1G -numjobs=1 -runtime=1000 -group_reporting -filename=/dev/sdb direct，表示是否跳过系统缓存。1就表示跳过系统缓存。 iodepth，表示使用异步 I/O（asynchronous I/O，简称 AIO）时，同时发出的 I/O 请求上限。在上面的示例中，设置的是 64。 rw，表示 I/O 模式。read/write 分别表示顺序读 / 写，而 randread/randwrite 则分别表示随机读 / 写。 ioengine，表示 I/O 引擎，它支持同步（sync）、异步（libaio）、内存映射（mmap）、网络（net）等各种 I/O 引擎。 bs，表示 I/O 的大小。 filename，表示文件路径，当然，它可以是磁盘路径（测试磁盘性能），也可以是文件路径（测试文件系统性能）。示例中设置成了磁盘 /dev/sdb。 不过注意，用磁盘路径测试写，会破坏这个磁盘中的文件系统，所以在使用前，你一定要事先做好数据备份。 输出结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 read: (g=0): rw=read, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=libaio, iodepth=64 fio-3.1 Starting 1 process Jobs: 1 (f=1): [R(1)][100.0%][r=16.7MiB/s,w=0KiB/s][r=4280,w=0 IOPS][eta 00m:00s] read: (groupid=0, jobs=1): err= 0: pid=17966: Sun Dec 30 08:31:48 2018 read: IOPS=4257, BW=16.6MiB/s (17.4MB/s)(1024MiB/61568msec) slat (usec): min=2, max=2566, avg= 4.29, stdev=21.76 clat (usec): min=228, max=407360, avg=15024.30, stdev=20524.39 lat (usec): min=243, max=407363, avg=15029.12, stdev=20524.26 clat percentiles (usec): | 1.00th=[ 498], 5.00th=[ 1020], 10.00th=[ 1319], 20.00th=[ 1713], | 30.00th=[ 1991], 40.00th=[ 2212], 50.00th=[ 2540], 60.00th=[ 2933], | 70.00th=[ 5407], 80.00th=[ 44303], 90.00th=[ 45351], 95.00th=[ 45876], | 99.00th=[ 46924], 99.50th=[ 46924], 99.90th=[ 48497], 99.95th=[ 49021], | 99.99th=[404751] bw ( KiB/s): min= 8208, max=18832, per=99.85%, avg=17005.35, stdev=998.94, samples=123 iops : min= 2052, max= 4708, avg=4251.30, stdev=249.74, samples=123 lat (usec) : 250=0.01%, 500=1.03%, 750=1.69%, 1000=2.07% lat (msec) : 2=25.64%, 4=37.58%, 10=2.08%, 20=0.02%, 50=29.86% lat (msec) : 100=0.01%, 500=0.02% cpu : usr=1.02%, sys=2.97%, ctx=33312, majf=0, minf=75 IO depths : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=0.1%, \u0026gt;=64=100.0% submit : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, \u0026gt;=64=0.0% complete : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.1%, \u0026gt;=64=0.0% issued rwt: total=262144,0,0, short=0,0,0, dropped=0,0,0 latency : target=0, window=0, percentile=100.00%, depth=64 Run status group 0 (all jobs): READ: bw=16.6MiB/s (17.4MB/s), 16.6MiB/s-16.6MiB/s (17.4MB/s-17.4MB/s), io=1024MiB (1074MB), run=61568-61568msec Disk stats (read/write): sdb: ios=261897/0, merge=0/0, ticks=3912108/0, in_queue=3474336, util=90.09% slat ，是指从 I/O 提交到实际执行 I/O 的时长（Submission latency）； clat ，是指从 I/O 提交到 I/O 完成的时长（Completion latency）； lat ，指的是从 fio 创建 I/O 到 I/O 完成的总时长。 对同步 I/O 来说，由于 I/O 提交和 I/O 完成是一个动作，所以 slat 实际上就是 I/O 完成的时间，而 clat 是 0。而从示例可以看到，使用异步 I/O（libaio）时，lat 近似等于 slat + clat 之和。\nbw, 吞吐量 iops, 每秒 I/O 的次数 ","permalink":"https://jdxj.github.io/posts/cmd/fio/","summary":"文件系统和磁盘 I/O 性能基准测试工具","title":"fio"},{"content":" 使用率，是指磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈。 饱和度，是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着磁盘存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求。 IOPS（Input/Output Per Second），是指每秒的 I/O 请求数。 吞吐量，是指每秒的 I/O 请求大小。 响应时间，是指 I/O 请求从发出到收到响应的间隔时间。 不要孤立地去比较某一指标，而要结合读写比例、I/O 类型（随机还是连续）以及 I/O 的大小，综合来分析。\n在数据库、大量小文件等这类随机读写比较多的场景中，IOPS 更能反映系统的整体性能； 而在多媒体等顺序读写较多的场景中，吞吐量才更能反映系统的整体性能。 进程 I/O 观测 pidstat\n1 2 3 $ pidstat -d 1 13:39:51 UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command 13:39:52 102 916 0.00 4.00 0.00 0 rsyslogd iotop\n1 2 3 4 5 $ iotop Total DISK READ : 0.00 B/s | Total DISK WRITE : 7.85 K/s Actual DISK READ: 0.00 B/s | Actual DISK WRITE: 0.00 B/s TID PRIO USER DISK READ DISK WRITE SWAPIN IO\u0026gt; COMMAND 15055 be/3 root 0.00 B/s 7.85 K/s 0.00 % 0.00 % systemd-journald ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/file-system/%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/","summary":"使用率，是指磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈。 饱和度，是指磁盘处理 I/O 的繁忙程度。过高的饱","title":"磁盘性能指标"},{"content":" 我们可以把 Linux 存储系统的 I/O 栈，由上到下分为三个层次，分别是文件系统层、通用块层和设备层。\n文件系统层，包括虚拟文件系统和其他各种文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过通用块层，来存储和管理磁盘 数据。 通用块层，包括块设备 I/O 队列和 I/O 调度器。它会对文件系统的 I/O 请求进行排队，再通过重新排序和请求合并，然后才要发送给下一级的设备层。 设备层，包括存储设备和相应的驱动程序，负责最终物理设备的 I/O 操作。 存储系统的 I/O ，通常是整个系统中最慢的一环。所以， Linux 通过多种缓存机制来优化 I/O 效率。\n为了优化文件访问的性能，会使用页缓存、索引节点缓存、目录项缓存等多种缓存机制，以减少对下层块设备的直接调用。 为了优化块设备的访问效率，会使用缓冲区，来缓存块设备的数据。 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/file-system/io%E6%A0%88/","summary":"我们可以把 Linux 存储系统的 I/O 栈，由上到下分为三个层次，分别是文件系统层、通用块层和设备层。 文件系统层，包括虚拟文件系统和其他各种文件系统的具体实","title":"I/O栈"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 按下c按照缓存大小排序，按下a按照活跃对象数排序 $ slabtop Active / Total Objects (% used) : 277970 / 358914 (77.4%) Active / Total Slabs (% used) : 12414 / 12414 (100.0%) Active / Total Caches (% used) : 83 / 135 (61.5%) Active / Total Size (% used) : 57816.88K / 73307.70K (78.9%) Minimum / Average / Maximum Object : 0.01K / 0.20K / 22.88K OBJS ACTIVE USE OBJ SIZE SLABS OBJ/SLAB CACHE SIZE NAME 69804 23094 0% 0.19K 3324 21 13296K dentry 16380 15854 0% 0.59K 1260 13 10080K inode_cache 58260 55397 0% 0.13K 1942 30 7768K kernfs_node_cache 485 413 0% 5.69K 97 5 3104K task_struct 1472 1397 0% 2.00K 92 16 2944K kmalloc-2048 ","permalink":"https://jdxj.github.io/posts/cmd/slabtop/","summary":"找占用内存最多的缓存类型","title":"slabtop"},{"content":"文件读写方式的各种差异，导致 I/O 的分类多种多样。最常见的有，缓冲与非缓冲 I/O、直接与非直接 I/O、阻塞与非阻塞 I/O、同步与异步 I/O 等。\n缓冲/非缓冲I/O\n缓冲 I/O，是指利用标准库缓存来加速文件的访问，而标准库内部再通过系统调度访问文件。 非缓冲 I/O，是指直接通过系统调用来访问文件，不再经过标准库缓存。 无论缓冲 I/O 还是非缓冲 I/O，它们最终还是要经过系统调用来访问文件。 系统调用后，还会通过页缓存，来减少磁盘的 I/O 操作。 直接/非直接I/O\n直接 I/O，是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件。 非直接 I/O 正好相反，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。 直接 I/O、非直接 I/O，本质上还是和文件系统交互。如果是在数据库等场景中，你还会看到，跳过文件系统读写磁盘的情况，也就是我们通常所说的裸I/O。 阻塞/非阻塞I/O\n所谓阻塞 I/O，是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务。 所谓非阻塞 I/O，是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。 同步/异步I/O\n所谓同步 I/O，是指应用程序执行 I/O 操作后，要一直等到整个 I/O 完成后，才能获得 I/O 响应。 所谓异步 I/O，是指应用程序执行 I/O 操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I/O 完成后，响应会用事件通知的方式， 告诉应用程序。 参考 IO模型浅析-阻塞、非阻塞、IO复用、信号驱动、异步IO、同步IO ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/file-system/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fio/","summary":"文件读写方式的各种差异，导致 I/O 的分类多种多样。最常见的有，缓冲与非缓冲 I/O、直接与非直接 I/O、阻塞与非阻塞 I/O、同步与异步 I/O 等。 缓冲/","title":"文件系统I/O"},{"content":" 在 Linux 中一切皆文件。不仅普通的文件和目录，就连块设备、套接字、管道等，也都要通过统一的文件系统来管理。\n索引节点，简称为 inode，用来记录文件的元数据，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟 文件内容一样，都会被持久化存储到磁盘中。所以记住，索引节点同样占用磁盘空间。 目录项，简称为 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过， 不同于索引节点，目录项是由内核维护的一个内存数据结构，所以通常也被叫做目录项缓存。 目录项和索引节点的关系是多对一，你可以简单理解为，一个文件可以有多个别名。\n磁盘读写的最小单位是扇区，然而扇区只有 512B 大小，如果每次都读写这么小的单位，效率一定很低。所以，文件系统又把连续的扇区组成了逻辑块，然后每 次都以逻辑块为最小单元，来管理数据。常见的逻辑块大小为 4KB，也就是由连续的 8 个扇区组成。\n超级块，存储整个文件系统的状态。如索引节点和逻辑块的使用情况等。 索引节点区，用来存储索引节点。 数据块区，则用来存储文件数据。 逻辑块，是由连续磁盘扇区构成的最小读写单元，用来存储文件数据。 目录项是一个内存缓存；而超级块、索引节点和逻辑块，都是存储在磁盘中的持久化数据。\n索引节点的容量 也就是Inode个数, 是在格式化磁盘时设定好的，一般由格式化工具自动生成。当你发现索引节点空间不足，但磁盘空间充足时，很可能就是过多小文件导致的。\n1 2 3 4 # -i 参数，查看索引节点的使用情况 $ df -i /dev/sda1 Filesystem Inodes IUsed IFree IUse% Mounted on /dev/sda1 3870720 157460 3713260 5% / 缓存 可以用 free 或 vmstat，来观察页缓存的大小。\n1 2 3 4 $ cat /proc/meminfo | grep -E \u0026#34;SReclaimable|Cached\u0026#34; Cached: 748316 kB SwapCached: 0 kB SReclaimable: 179508 kB 查看文件系统中的目录项和索引节点缓存\n内核使用 Slab 机制，管理目录项和索引节点的缓存。/proc/meminfo 只给出了 Slab 的整体大小，具体到每一种 Slab 缓存，还要查看 /proc/slabinfo 这个文件。\n1 2 3 4 5 6 7 8 9 10 $ cat /proc/slabinfo | grep -E \u0026#39;^#|dentry|inode\u0026#39; # name \u0026lt;active_objs\u0026gt; \u0026lt;num_objs\u0026gt; \u0026lt;objsize\u0026gt; \u0026lt;objperslab\u0026gt; \u0026lt;pagesperslab\u0026gt; : tunables \u0026lt;limit\u0026gt; \u0026lt;batchcount\u0026gt; \u0026lt;sharedfactor\u0026gt; : slabdata \u0026lt;active_slabs\u0026gt; \u0026lt;num_slabs\u0026gt; \u0026lt;sharedavail\u0026gt; xfs_inode 0 0 960 17 4 : tunables 0 0 0 : slabdata 0 0 0 ... ext4_inode_cache 32104 34590 1088 15 4 : tunables 0 0 0 : slabdata 2306 2306 0hugetlbfs_inode_cache 13 13 624 13 2 : tunables 0 0 0 : slabdata 1 1 0 sock_inode_cache 1190 1242 704 23 4 : tunables 0 0 0 : slabdata 54 54 0 shmem_inode_cache 1622 2139 712 23 4 : tunables 0 0 0 : slabdata 93 93 0 proc_inode_cache 3560 4080 680 12 2 : tunables 0 0 0 : slabdata 340 340 0 inode_cache 25172 25818 608 13 2 : tunables 0 0 0 : slabdata 1986 1986 0 dentry 76050 121296 192 21 1 : tunables 0 0 0 : slabdata 5776 5776 0 dentry 行表示目录项缓存 inode_cache 行，表示 VFS 索引节点缓存 其余的则是各种文件系统的索引节点缓存。 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/file-system/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/","summary":"在 Linux 中一切皆文件。不仅普通的文件和目录，就连块设备、套接字、管道等，也都要通过统一的文件系统来管理。 索引节点，简称为 inode，用来记录文件","title":"Linux文件系统架构"},{"content":"内存性能指标 第一类\n已用内存和剩余内存很容易理解，就是已经使用和还未使用的内存。 共享内存是通过 tmpfs 实现的，所以它的大小也就是 tmpfs 使用的内存大小。tmpfs 其实也是一种特殊的缓存。 可用内存是新进程可以使用的最大内存，它包括剩余内存和可回收缓存。 缓存包括两部分，一部分是磁盘读取文件的页缓存，用来缓存从磁盘读取的数据，可以加快以后再次访问的速度。另一部分，则是 Slab 分配器中的可回收内 存。 缓冲区是对原始磁盘块的临时存储，用来缓存将要写入磁盘的数据。这样，内核就可以把分散的写集中起来，统一优化磁盘写入。 第二类\n虚拟内存，包括了进程代码段、数据段、共享内存、已经申请的堆内存和已经换出的内存等。这里要注意，已经申请的内存，即使还没有分配物理内存，也算 作虚拟内存。 常驻内存是进程实际使用的物理内存，不过，它不包括 Swap 和共享内存。 共享内存，既包括与其他进程共同使用的真实的共享内存，还包括了加载的动态链接库以及程序的代码段等。 Swap 内存，是指通过 Swap 换出到磁盘的内存。 缺页异常\n可以直接从物理内存中分配时，被称为次缺页异常。 需要磁盘 I/O 介入（比如 Swap）时，被称为主缺页异常。 第三类\nSwap 的已用空间、剩余空间、换入速度和换出速度 根据指标找工具 根据工具查指标 迅速分析内存的性能瓶颈 先用 free 和 top，查看系统整体的内存使用情况。 再用 vmstat 和 pidstat，查看一段时间的趋势，从而判断出内存问题的类型。 最后进行详细分析，比如内存分配分析、缓存 / 缓冲区分析、具体进程的内存使用分析等。 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/memory/%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95/","summary":"内存性能指标 第一类 已用内存和剩余内存很容易理解，就是已经使用和还未使用的内存。 共享内存是通过 tmpfs 实现的，所以它的大小也就是 tmpfs 使用的内存大小。t","title":"内存问题定位方法"},{"content":"可回收的内存\n文件页: buffer, cache 匿名页: 应用程序动态分配的堆内存 现在的内存便宜多了，服务器一般也会配置很大的内存，那是不是说 Swap 就没有用武之地了呢？\n一个很典型的场景就是，即使内存不足时，有些应用程序也并不想被 OOM 杀死，而是希望能缓一段时间，等待人工介入，或者等系统自动释放其他进程的内 存，再分配给它。 笔记本电脑的休眠和快速开机的功能，也基于 Swap 。休眠时，把系统的内存存入磁盘，这样等到再次开机时，只要从磁盘中加载内存就可以。这样就省去了 很多应用程序的初始化过程，加快了开机速度。 Swap 是为了回收内存，那么 Linux 到底在什么时候需要回收内存呢？\n有新的大块内存分配请求，但是剩余内存不足。直接内存回收 专门的内核线程用来定期回收内存，也就是 kswapd0 kswapd0 定义了三个内存阈值（watermark，也称为水位），分别是页最小阈值（pages_min）、页低阈值（pages_low）和页高阈值（pages_high）。 剩余内存，则使用 pages_free 表示。\nswappiness 对文件页的回收，当然就是直接回收缓存，或者把脏页写回磁盘后再回收。 对匿名页的回收，其实就是通过 Swap 机制，把它们写入磁盘后再释放内存。 swappiness 用来调整使用 Swap 的积极程度。\nswappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。 即使你把它设置成 0，当剩余内存 + 文件页小于页高阈值时，还是会发生 Swap。 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/memory/swap/","summary":"可回收的内存 文件页: buffer, cache 匿名页: 应用程序动态分配的堆内存 现在的内存便宜多了，服务器一般也会配置很大的内存，那是不是说 Swap 就没有用武之地了呢？ 一","title":"swap"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 # -a 表示显示每个内存分配请求的大小以及地址 # -p 指定案例应用的PID号 $ /usr/share/bcc/tools/memleak -a -p $(pidof app) WARNING: Couldn\u0026#39;t find .text section in /app WARNING: BCC can\u0026#39;t handle sym look ups for /app addr = 7f8f704732b0 size = 8192 addr = 7f8f704772d0 size = 8192 addr = 7f8f704712a0 size = 8192 addr = 7f8f704752c0 size = 8192 32768 bytes in 4 allocations from stack [unknown] [app] [unknown] [app] start_thread+0xdb [libpthread-2.27.so] ","permalink":"https://jdxj.github.io/posts/cmd/memleak/","summary":"检测内存泄漏","title":"memleak"},{"content":" 栈内存由系统自动分配和管理。一旦程序运行超出了这个局部变量的作用域，栈内存就会被系统自动回收，所以不会产生内存泄漏的问题。 堆内存由应用程序自己来分配和管理。除非程序退出，这些堆内存并不会被系统自动释放，而是需要应用程序明确调用库函数 free() 来释放它们。如果应 用程序没有正确释放堆内存，就会造成内存泄漏。 只读段，包括程序的代码和常量，由于是只读的，不会再去分配新的内存，所以也不会产生内存泄漏。 数据段，包括全局变量和静态变量，这些变量在定义时就已经确定了大小，所以也不会产生内存泄漏。 内存映射段，包括动态链接库和共享内存，其中共享内存由程序动态分配和管理。所以，如果程序在分配后忘了回收，就会导致跟堆内存类似的泄漏问题。 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/memory/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/","summary":"栈内存由系统自动分配和管理。一旦程序运行超出了这个局部变量的作用域，栈内存就会被系统自动回收，所以不会产生内存泄漏的问题。 堆内存由应用程序自","title":"内存泄漏"},{"content":"https://github.com/tobert/pcstat\nCached 就是 /bin/ls 在缓存中的大小 Percent 则是缓存的百分比 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 之前没运行过ls $ pcstat /bin/ls +---------+----------------+------------+-----------+---------+ | Name | Size (bytes) | Pages | Cached | Percent | |---------+----------------+------------+-----------+---------| | /bin/ls | 133792 | 33 | 0 | 000.000 | +---------+----------------+------------+-----------+---------+ # 运行ls之后 $ ls $ pcstat /bin/ls +---------+----------------+------------+-----------+---------+ | Name | Size (bytes) | Pages | Cached | Percent | |---------+----------------+------------+-----------+---------| | /bin/ls | 133792 | 33 | 33 | 100.000 | +---------+----------------+------------+-----------+---------+ ","permalink":"https://jdxj.github.io/posts/cmd/pcstat/","summary":"查看文件在内存中的缓存大小以及缓存比例","title":"pcstat"},{"content":"/usr/share/bcc/tools\n1 2 3 4 $ cachetop 11:58:50 Buffers MB: 258 / Cached MB: 347 / Sort: HITS / Order: ascending PID UID CMD HITS MISSES DIRTIES READ_HIT% WRITE_HIT% 13029 root python 1 0 0 100.0% 0.0% READ_HIT 和 WRITE_HIT ，分别表示读和写的缓存命中率\ncachetop 工具并不把直接 I/O 算进来\n","permalink":"https://jdxj.github.io/posts/cmd/cachetop/","summary":"提供了每个进程的缓存命中情况","title":"cachetop"},{"content":" 1 2 3 4 5 6 # 以 1 秒的时间间隔，输出了 3 组缓存统计数据 $ cachestat 1 3 TOTAL MISSES HITS DIRTIES BUFFERS_MB CACHED_MB 2 0 2 1 17 279 2 0 2 1 17 279 2 0 2 1 17 279 TOTAL ，表示总的 I/O 次数； MISSES ，表示缓存未命中的次数； HITS ，表示缓存命中的次数； DIRTIES， 表示新增到缓存中的脏页数； BUFFERS_MB 表示 Buffers 的大小，以 MB 为单位； CACHED_MB 表示 Cache 的大小，以 MB 为单位。 ","permalink":"https://jdxj.github.io/posts/cmd/cachestat/","summary":"提供了整个操作系统缓存的读写命中情况","title":"cachestat"},{"content":"man free\nBuffers 是内核缓冲区用到的内存，对应的是 /proc/meminfo 中的 Buffers 值。 Cache 是内核页缓存和 Slab 用到的内存，对应的是 /proc/meminfo 中的 Cached 与 SReclaimable 之和。 1 2 3 4 5 $ cat /proc/meminfo | grep -E \u0026#34;SReclaimable|Cached|Buffers\u0026#34; Buffers: 818084 kB Cached: 7201820 kB SwapCached: 0 kB SReclaimable: 939332 kB man proc\nBuffers 是对原始磁盘块的临时存储，也就是用来缓存磁盘的数据，通常不会特别大（20MB 左右）。这样，内核就可以把分散的写集中起来，统一优化磁 盘的写入，比如可以把多次小的写合并成单次大的写等等。 Cached 是从磁盘读取文件的页缓存，也就是用来缓存从文件读取的数据。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访 问缓慢的磁盘。SReclaimable 是 Slab 的一部分。Slab 包括两部分，其中的可回收部分，用 SReclaimable 记录；而不可回收部分，用 SUnreclaim 记录。 1 2 3 4 5 6 7 8 9 10 11 Buffers %lu Relatively temporary storage for raw disk blocks that shouldn\u0026#39;t get tremendously large (20MB or so). Cached %lu In-memory cache for files read from the disk (the page cache). Doesn\u0026#39;t include SwapCached. ... SReclaimable %lu (since Linux 2.6.19) Part of Slab, that might be reclaimed, such as caches. SUnreclaim %lu (since Linux 2.6.19) Part of Slab, that cannot be reclaimed on memory pressure. 写文件时会用到 Cache 缓存数据，而写磁盘则会用到 Buffer 来缓存数据。\n读文件时数据会缓存到 Cache 中，而读磁盘时数据会缓存到 Buffer 中。\n结论 Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中。\n","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/memory/buffer%E5%92%8Ccache%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"man free Buffers 是内核缓冲区用到的内存，对应的是 /proc/meminfo 中的 Buffers 值。 Cache 是内核页缓存和 Slab 用到的内存，对应的是 /proc/meminfo 中的 Cached 与 SReclaimable 之和。 1 2 3 4 5 $ cat /proc/meminfo | grep -E \u0026#34;SReclaimable|Cached|Buffers\u0026#34; Buffers: 818084 kB Cached: 7201820","title":"buffer和cache的区别"},{"content":"CPU 性能指标 性能工具 迅速分析 CPU 的性能瓶颈 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/cpu/cpu%E4%BC%98%E5%8C%96/","summary":"CPU 性能指标 性能工具 迅速分析 CPU 的性能瓶颈","title":"cpu优化"},{"content":"sar 可以用来查看系统的网络收发情况，还有一个好处是，不仅可以观察网络收发的吞吐量（BPS，每秒收发的字节数），还可以观察网络收发的 PPS，即每秒 收发的网络帧数。\n1 2 3 4 5 6 7 # -n DEV 表示显示网络收发的报告，间隔1秒输出一组数据 $ sar -n DEV 1 15:03:46 IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s %ifutil 15:03:47 eth0 12607.00 6304.00 664.86 358.11 0.00 0.00 0.00 0.01 15:03:47 docker0 6302.00 12604.00 270.79 664.66 0.00 0.00 0.00 0.00 15:03:47 lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 15:03:47 veth9f6bbcd 6302.00 12604.00 356.95 664.66 0.00 0.00 0.00 0.05 第一列：表示报告的时间。 第二列：IFACE 表示网卡。 第三、四列：rxpck/s 和 txpck/s 分别表示每秒接收、发送的网络帧数，也就是 PPS。 第五、六列：rxkB/s 和 txkB/s 分别表示每秒接收、发送的千字节数，也就是 BPS。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 间隔1秒输出一组数据 # -r表示显示内存使用情况，-S表示显示Swap使用情况 $ sar -r -S 1 04:39:56 kbmemfree kbavail kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty 04:39:57 6249676 6839824 1919632 23.50 740512 67316 1691736 10.22 815156 841868 4 04:39:56 kbswpfree kbswpused %swpused kbswpcad %swpcad 04:39:57 8388604 0 0.00 0 0.00 04:39:57 kbmemfree kbavail kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty 04:39:58 6184472 6807064 1984836 24.30 772768 67380 1691736 10.22 847932 874224 20 04:39:57 kbswpfree kbswpused %swpused kbswpcad %swpcad 04:39:58 8388604 0 0.00 0 0.00 … 04:44:06 kbmemfree kbavail kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty 04:44:07 152780 6525716 8016528 98.13 6530440 51316 1691736 10.22 867124 6869332 0 04:44:06 kbswpfree kbswpused %swpused kbswpcad %swpcad 04:44:07 8384508 4096 0.05 52 1.27 各个指标名称前面的 kb 前缀，表示这些指标的单位是 KB。\nkbcommit，表示当前系统负载需要的内存。它实际上是为了保证系统内存不溢出，对需要内存的估计值。 %commit，就是这个值相对总内存的百分比。 kbactive，表示活跃内存，也就是最近使用过的内存，一般不会被系统回收。 kbinact，表示非活跃内存，也就是不常访问的内存，有可能会被系统回收。 1 2 3 4 5 6 7 8 9 # -n 参数就可以查看网络的统计信息 # 数字1表示每隔1秒输出一组数据 $ sar -n DEV 1 Linux 4.15.0-1035 (ubuntu) 01/06/19 _x86_64_ (2 CPU) 13:21:40 IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s %ifutil 13:21:41 eth0 18.00 20.00 5.79 4.25 0.00 0.00 0.00 0.00 13:21:41 docker0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 13:21:41 lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 rxpck/s 和 txpck/s 分别是接收和发送的 PPS，单位为包 / 秒。 rxkB/s 和 txkB/s 分别是接收和发送的吞吐量，单位是 KB/ 秒。 rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数，单位是包 / 秒。 %ifutil 是网络接口的使用率，即半双工模式下为 (rxkB/s+txkB/s)/Bandwidth，而全双工模式下为 max(rxkB/s, txkB/s)/Bandwidth。 ","permalink":"https://jdxj.github.io/posts/cmd/sar/","summary":"系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据","title":"sar"},{"content":" 1 2 3 4 # -S参数表示设置TCP协议的SYN（同步序列号），-p表示目的端口为80 # -i u100表示每隔100微秒发送一个网络帧 # 注：如果你在实践过程中现象不明显，可以尝试把100调小，比如调成10甚至1 $ hping3 -S -p 80 -i u100 192.168.0.30 ","permalink":"https://jdxj.github.io/posts/cmd/hping3/","summary":"构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等","title":"hping3"},{"content":" 1 $ strace -p 6082 1 2 3 4 5 6 7 8 9 10 11 12 $ strace -p 18940 strace: Process 18940 attached ... mmap(NULL, 314576896, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0f7aee9000 mmap(NULL, 314576896, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0f682e8000 write(3, \u0026#34;2018-12-05 15:23:01,709 - __main\u0026#34;..., 314572844 ) = 314572844 munmap(0x7f0f682e8000, 314576896) = 0 write(3, \u0026#34;\\n\u0026#34;, 1) = 1 munmap(0x7f0f7aee9000, 314576896) = 0 close(3) = 0 stat(\u0026#34;/tmp/logtest.txt.1\u0026#34;, {st_mode=S_IFREG|0644, st_size=943718535, ...}) = 0 从 write() 系统调用上，我们可以看到，进程向文件描述符编号为 3 的文件中，写入了 300MB 的数据。 后面的 stat() 调用，你可以看到，它正在获取 /tmp/logtest.txt.1 的状态。 这种“点 + 数字格式”的文件，在日志回滚中非常常见。 1 2 # -f 查看线程 $ strace -p pid -f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # -f表示跟踪子进程和子线程，-T表示显示系统调用的时长，-tt表示显示跟踪时间 $ strace -f -T -tt -p 9085 [pid 9085] 14:20:16.826131 epoll_pwait(5, [{EPOLLIN, {u32=8, u64=8}}], 10128, 65, NULL, 8) = 1 \u0026lt;0.000055\u0026gt; [pid 9085] 14:20:16.826301 read(8, \u0026#34;*2\\r\\n$3\\r\\nGET\\r\\n$41\\r\\nuuid:5b2e76cc-\u0026#34;..., 16384) = 61 \u0026lt;0.000071\u0026gt; [pid 9085] 14:20:16.826477 read(3, 0x7fff366a5747, 1) = -1 EAGAIN (Resource temporarily unavailable) \u0026lt;0.000063\u0026gt; [pid 9085] 14:20:16.826645 write(8, \u0026#34;$3\\r\\nbad\\r\\n\u0026#34;, 9) = 9 \u0026lt;0.000173\u0026gt; [pid 9085] 14:20:16.826907 epoll_pwait(5, [{EPOLLIN, {u32=8, u64=8}}], 10128, 65, NULL, 8) = 1 \u0026lt;0.000032\u0026gt; [pid 9085] 14:20:16.827030 read(8, \u0026#34;*2\\r\\n$3\\r\\nGET\\r\\n$41\\r\\nuuid:55862ada-\u0026#34;..., 16384) = 61 \u0026lt;0.000044\u0026gt; [pid 9085] 14:20:16.827149 read(3, 0x7fff366a5747, 1) = -1 EAGAIN (Resource temporarily unavailable) \u0026lt;0.000043\u0026gt; [pid 9085] 14:20:16.827285 write(8, \u0026#34;$3\\r\\nbad\\r\\n\u0026#34;, 9) = 9 \u0026lt;0.000141\u0026gt; [pid 9085] 14:20:16.827514 epoll_pwait(5, [{EPOLLIN, {u32=8, u64=8}}], 10128, 64, NULL, 8) = 1 \u0026lt;0.000049\u0026gt; [pid 9085] 14:20:16.827641 read(8, \u0026#34;*2\\r\\n$3\\r\\nGET\\r\\n$41\\r\\nuuid:53522908-\u0026#34;..., 16384) = 61 \u0026lt;0.000043\u0026gt; [pid 9085] 14:20:16.827784 read(3, 0x7fff366a5747, 1) = -1 EAGAIN (Resource temporarily unavailable) \u0026lt;0.000034\u0026gt; [pid 9085] 14:20:16.827945 write(8, \u0026#34;$4\\r\\ngood\\r\\n\u0026#34;, 10) = 10 \u0026lt;0.000288\u0026gt; [pid 9085] 14:20:16.828339 epoll_pwait(5, [{EPOLLIN, {u32=8, u64=8}}], 10128, 63, NULL, 8) = 1 \u0026lt;0.000057\u0026gt; [pid 9085] 14:20:16.828486 read(8, \u0026#34;*3\\r\\n$4\\r\\nSADD\\r\\n$4\\r\\ngood\\r\\n$36\\r\\n535\u0026#34;..., 16384) = 67 \u0026lt;0.000040\u0026gt; [pid 9085] 14:20:16.828623 read(3, 0x7fff366a5747, 1) = -1 EAGAIN (Resource temporarily unavailable) \u0026lt;0.000052\u0026gt; [pid 9085] 14:20:16.828760 write(7, \u0026#34;*3\\r\\n$4\\r\\nSADD\\r\\n$4\\r\\ngood\\r\\n$36\\r\\n535\u0026#34;..., 67) = 67 \u0026lt;0.000060\u0026gt; [pid 9085] 14:20:16.828970 fdatasync(7) = 0 \u0026lt;0.005415\u0026gt; [pid 9085] 14:20:16.834493 write(8, \u0026#34;:1\\r\\n\u0026#34;, 4) = 4 \u0026lt;0.000250\u0026gt; 1 2 3 4 5 6 7 8 # -e指定系统调用 $ strace -f -p 9085 -T -tt -e fdatasync strace: Process 9085 attached with 4 threads [pid 9085] 14:22:52.013547 fdatasync(7) = 0 \u0026lt;0.007112\u0026gt; [pid 9085] 14:22:52.022467 fdatasync(7) = 0 \u0026lt;0.008572\u0026gt; [pid 9085] 14:22:52.032223 fdatasync(7) = 0 \u0026lt;0.006769\u0026gt; ... [pid 9085] 14:22:52.139629 fdatasync(7) = 0 \u0026lt;0.008183\u0026gt; ","permalink":"https://jdxj.github.io/posts/cmd/strace/","summary":"跟踪进程系统调用的工具","title":"strace"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 间隔1秒输出10组数据 $ dstat 1 10 You did not select any stats, using -cdngy by default. --total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system-- usr sys idl wai stl| read writ| recv send| in out | int csw 0 0 96 4 0|1219k 408k| 0 0 | 0 0 | 42 885 0 0 2 98 0| 34M 0 | 198B 790B| 0 0 | 42 138 0 0 0 100 0| 34M 0 | 66B 342B| 0 0 | 42 135 0 0 84 16 0|5633k 0 | 66B 342B| 0 0 | 52 177 0 3 39 58 0| 22M 0 | 66B 342B| 0 0 | 43 144 0 0 0 100 0| 34M 0 | 200B 450B| 0 0 | 46 147 0 0 2 98 0| 34M 0 | 66B 342B| 0 0 | 45 134 0 0 0 100 0| 34M 0 | 66B 342B| 0 0 | 39 131 0 0 83 17 0|5633k 0 | 66B 342B| 0 0 | 46 168 0 3 39 59 0| 22M 0 | 66B 342B| 0 0 | 37 134 ","permalink":"https://jdxj.github.io/posts/cmd/dstat/","summary":"它吸收了 vmstat、iostat、ifstat 等几种工具的优点，可以同时观察系统的 CPU、磁盘 I/O、网络以及内存使用情况。","title":"dstat"},{"content":"进程状态 当 iowait 升高时，进程很可能因为得不到硬件的响应，而长时间处于不可中断状态。从 ps 或者 top 命令的输出中，你可以发现它们都处于 D 状态，也 就是不可中断状态（Uninterruptible Sleep）。\n1 2 3 4 5 6 7 8 9 10 $ top PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 28961 root 20 0 43816 3148 4040 R 3.2 0.0 0:00.01 top 620 root 20 0 37280 33676 908 D 0.3 0.4 0:00.01 app 1 root 20 0 160072 9416 6752 S 0.0 0.1 0:37.64 systemd 1896 root 20 0 0 0 0 Z 0.0 0.0 0:00.00 devapp 2 root 20 0 0 0 0 S 0.0 0.0 0:00.10 kthreadd 4 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 kworker/0:0H 6 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 mm_percpu_wq 7 root 20 0 0 0 0 S 0.0 0.0 0:06.37 ksoftirqd/0 R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。 D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中 断打断。 Z 是 Zombie 的缩写，如果你玩过“植物大战僵尸”这款游戏，应该知道它的意思。它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收 它的资源（比如进程的描述符、PID 等）。 S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。 I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们 有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。 T 或者 t，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。 向一个进程发送 SIGSTOP 信号，它就会因响应这个信号变成暂停状态（Stopped）； 再向它发送 SIGCONT 信号，进程又会恢复运行（如果进程是终端里直接启动的，则需要你用 fg 命令，恢复到前台运行）。 用调试器（如 gdb）调试一个进程时，在使用断点中断进程后，进程就会变成跟踪状态，这其实也是一种特殊的暂停状态，只不过你可以用调试器来跟踪并 按需要控制进程的运行。 X，也就是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令中看到它。 不可中断状态 这其实是为了保证进程数据与硬件状态一致，并且正常情况下，不可中断状态在很短时间内就会结束。所以，短时的不可中断状态进程，我们一 般可以忽略。但如果系统或硬件发生了故障，进程可能会在不可中断状态保持很久，甚至导致系统中出现大量不可中断进程。这时，你就得注意下，系统是不是 出现了 I/O 等性能问题。\n僵尸进程 这是多进程应用很容易碰到的问题。正常情况下，当一个进程创建了子进程后，它应该通过系统调用 wait() 或者 waitpid() 等待子进程结束，回收子进程 的资源；而子进程在结束时，会向它的父进程发送 SIGCHLD 信号，所以，父进程还可以注册 SIGCHLD 信号的处理函数，异步回收资源。如果父进程没这么做， 或是子进程执行太快，父进程还没来得及处理子进程状态，子进程就已经提前退出，那这时的子进程就会变成僵尸进程。\n通常，僵尸进程持续的时间都比较短，在父进程回收它的资源后就会消亡；或者在父进程退出后，由 init 进程回收后也会消亡。\n一旦父进程没有处理子进程的终止，还一直保持运行状态，那么子进程就会一直处于僵尸状态。大量的僵尸进程会用尽 PID 进程号，导致新进程不能创建，所 以这种情况一定要避免。\n","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/cpu/%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/","summary":"进程状态 当 iowait 升高时，进程很可能因为得不到硬件的响应，而长时间处于不可中断状态。从 ps 或者 top 命令的输出中，你可以发现它们都处于 D 状态，也 就是不可","title":"不可中断进程和僵尸进程"},{"content":" 1 $ execsnoop ","permalink":"https://jdxj.github.io/posts/cmd/execsnoop/","summary":"是一个专为短时进程设计的工具。它通过 ftrace 实时监控进程的 exec() 行为，并输出短时进程的基本信息，包括进程 PID、父进程 PID、命令行参数以及执行的结果。","title":"execsnoop"},{"content":" 1 2 3 4 5 6 7 8 9 10 # -a 表示输出命令行选项 # p表PID # s表示指定进程的父进程 $ pstree -aps 3084 systemd,1 └─dockerd,15006 -H fd:// └─docker-containe,15024 --config /var/run/docker/containerd/containerd.toml └─docker-containe,3991 -namespace moby -workdir... └─app,4009 └─(app,3084) 1 2 3 4 5 6 7 # -t表示显示线程，-a表示显示命令行参数 $ pstree -t -a -p 27458 mysqld,27458 --log_bin=on --sync_binlog=1 ... ├─{mysqld},27922 ├─{mysqld},27923 └─{mysqld},28014 ","permalink":"https://jdxj.github.io/posts/cmd/pstree/","summary":"用树状形式显示所有进程之间的关系","title":"pstree"},{"content":"指标实际上来自 /proc/diskstats\n1 2 3 4 5 6 7 # -d -x表示显示所有磁盘I/O的指标 $ iostat -d -x 1 Device r/s w/s rkB/s wkB/s rrqm/s wrqm/s %rrqm %wrqm r_await w_await aqu-sz rareq-sz wareq-sz svctm %util loop0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 loop1 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 sda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 sdb 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 %util ，就是我们前面提到的磁盘 I/O 使用率； r/s+ w/s ，就是 IOPS； rkB/s+wkB/s ，就是吞吐量； r_await+w_await ，就是响应时间。 饱和度通常也没有其他简单的观测方法，不过，你可以把观测到的，平均请求队列长度或者读写请求完成的等待时间，跟基准测试的结果（比如通过 fio）进行 对比，综合评估磁盘的饱和情况。\n1 2 3 4 5 6 # -d表示显示I/O性能指标，-x表示显示扩展统计（即所有I/O指标） $ iostat -x -d 1 Device r/s w/s rkB/s wkB/s rrqm/s wrqm/s %rrqm %wrqm r_await w_await aqu-sz rareq-sz wareq-sz svctm %util loop0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 sdb 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 sda 0.00 64.00 0.00 32768.00 0.00 0.00 0.00 0.00 0.00 7270.44 1102.18 0.00 512.00 15.50 99.20 参考 磁盘性能指标 fio ","permalink":"https://jdxj.github.io/posts/cmd/iostat/","summary":"磁盘 I/O 性能观测工具","title":"iostat"},{"content":"全局描述符表 在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，在每个段能够访问之前，必须先进行登记。\n当你访问的偏移地址超出段的界限时，处理器就会阻止这种访问，并产生一个叫作内部异常的中断。 和一个段有关的信息需要8字节来描述，所以称为段描述符(Segment Descriptor)，每个段都需要一个描述符。为了存放这些描述符，需要在内存中开辟出一 段空间。在这段空间里，所有的描述符都是挨在一起集中存放的，这就构成了一个描述符表。\n最主要的描述符表是全局描述符表(Global Descriptor Table, GDT)，所谓全局，意味着该表是为整个软硬件系统服务的。 在进入保护模式前，必须要定义全局描述符表。 全局描述符表寄存器GDTR\nGDTR的32位线性基地址部分保存的是全局描述符表在内存中的起始线性地址 16位边界部分保存的是全局描述符表的边界(表内最后1字节的偏移量) 因为GDT的界限是16位的，所以，该表最大是2^16字节，也就是65536字节(64KB)。又因为一个描述符占8字节，故最多可以定义8192个描述符。\n由于在进入保护模式之后，处理器要立即按新的内存访问模式工作，所以，必须在进入保护模式之前定义GDT。但是，由于在实模式下只能访问1MB的内存，故 GDT通常都定义在1MB以下的内存范围中。当然，允许在进入保护模式之后换个位置重新定义GDT。\nGDT和GDTR的关系\n存储器的段描述符 进入保护模式前的内存映象\n描述符不是由用户程序自己建立的，而是在加载时，由操作系统根据你的程序结构而建立的，而用户程序通常是无法建立和修改GDT的, 超出这个范围，或者未 按预定的方法访问这些段，都将被处理器阻止。\n存储器的段描述符格式\n下面是低32位（低双字） 上面是高32位（高双字） 描述符中指定了32位的段起始地址，以及20位的段边界。 在实模式下，段地址并非真实的物理地址，在计算物理地址时，还要左移4位（乘以16） 在32位保护模式下，段地址是32位的线性地址，如果未开启分页功能，该线性地址就是物理地址。 描述符中的段基地址和段界限不是连续的, 32位处理器为了保持同80286的兼容，只能在旧描述符的格式上进行扩充，这是不得已的做法 段基地址可以是0～4GB范围内的任意地址，不过，还是建议应当选取那些16字节对齐的地址。尽管对于INTEL处理器来说，允许不对齐的地址，但是，对齐能够 使程序在访问代码和数据时的性能最大化。\n有两种决定段大小的方法\n规定偏移量从0开始，那么偏移量的最大值就是段边界。这种方法适用于任何类型的段，包括代码段、数据段和栈段 段内偏移量是从最大值开始往下递减的，而且这种方法是为栈段设计的。对于这种段，描述符中的段界限就是段内不可使用的最小偏移量 访问栈段时，取决于段描述符中的B位, 可能使用SP，也可能使用ESP 如果是使用SP，段内偏移量的最大值是0xFFFF 如果是使用ESP，段内偏移量的最大值是0xFFFFFFFF G位是粒度(Granularity)位，用于解释段界限的含义。\n当G位是“0”时，段界限以字节为单位。此时，段的扩展范围是从1字节到1兆字节(1B～1MB)，因为描述符中的界限值是20位的。 如果该位是“1”，那么，段界限是以4KB为单位的。这样，段的扩展范围（段的大小）是从4KB到4GB。 S位用于指定描述符的类型(Descriptor Type)。\n当该位是“0”时，表示是一个系统段 为“1”时，表示是一个代码段或者数据段（栈段也是特殊的数据段）。 DPL表示描述符的特权级(Descriptor Privilege Level, DPL)。共有4种处理器支持的特权级别，分别是0、1、2、3，其中0是最高特权级别，3是最低特 权级别。\n特权级是一个数字，可以赋给一个程序，用来决定该程序能够执行哪些指令，或者能够访问哪些系统资源；也可以赋给系统资源，用来决定哪些程序可以访问 它们。 刚进入保护模式时执行的代码具有最高特权级0（可以看成从实模式那里继承来的），这些代码通常都是操作系统代码，因此它的特权级别最高。每当操作系统 加载一个用户程序时，它通常都会指定一个稍低的特权级，比如3特权级。 不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令（特权指令）只能由0特权级的程序来执行，为的就是安全。 描述符的特权级用于指定要访问该段所必须具有的最低特权级。如果这里的数值是2，那么，只有特权级别为0、1和2的程序才能访问该段，而特权级为3的程 序访问该段时，处理器会予以阻止。 P是段存在位(Segment Present)。P位用于指示描述符所对应的段是否存在。\n一般来说，描述符所指示的段都位于内存中。但是，当内存空间紧张时，有可能只是建立了描述符，对应的内存空间并不存在，这时，就应当把描述符的P位 清零，表示段并不存在。另外，同样是在内存空间紧张的情况下，会把很少用到的段换出到硬盘中，腾出空间给当前急需内存的程序使用（当前正在执行的）， 这时，同样要把段描述符的P位清零。当再次轮到它执行时，再装入内存，然后将P位置1。 P位是由处理器负责检查的。每当通过描述符访问内存中的段时，如果P位是“0”，处理器就会产生一个异常中断。通常，该中断处理过程是由操作系统提供的， 该处理过程的任务是负责将该段从硬盘换回内存，并将P位置1。 D/B位是“默认操作尺寸”(Default Operation Size)或者“默认的栈指针尺寸”(Default Stack Pointer Size)，又或者“上部边界”(Upper Bound)标 志。\n设立该标志位，主要是为了能够在32位处理器上兼容运行16位保护模式的程序。尽管这种程序现在已经非常罕见了 该标志位对不同的段有不同的效果。 对于代码段，此位称作“D”位，用于指示指令中默认的有效地址和操作数尺寸。D=0表示指令中的有效地址或者操作数是16位的；D=1，指示32位的有效地 址或者操作数。 对于栈段和向下扩展的数据段来说，该位被叫作“B”位，用于指定在进行隐式的栈操作时，是使用寄存器SP还是寄存器ESP，隐式的栈操作指令包括push、 pop和call等。如果该位是“0”，在访问那个段时，使用寄存器SP，否则就是使用寄存器ESP。 L位是64位代码段标志(64-bit Code Segment)，保留此位给64位处理器使用。\nTYPE字段共4位，用于指示描述符的子类型，或者说是类别\n对于数据段来说，这4位分别是X、E、W、A位；而对于代码段来说，这4位则分别是X、C、R、A位。 X表示是否可以执行(eXecutable)。数据段总是不可执行的，X=0；代码段总是可以执行的，X=1。 对于数据段来说，E位指示段的扩展方向。E=0是向上扩展的，也就是向高地址方向扩展的，是普通的数据段；E=1是向下扩展的，也就是向低地址方向扩展的， 通常是栈段。 W位指示段的读写属性，或者说段是否可写，W=0的段是不允许写入的，否则会引发处理器异常中断；W=1的段是可以正常写入的。 对于代码段来说，C位指示段是否为特权级依从的(Conforming)。C=0表示非依从的代码段，这样的代码段可以从与它特权级相同的代码段调用，或者通过门 调用；C=1表示允许从低特权级的程序转移到该段执行。 R位指示代码段是否允许读出。代码段总是可以执行的，但是，为了防止程序被破坏，它是不能写入的。至于是否有读出的可能，由R位指定。R=0表示不能读 出，如果企图去读一个R=0的代码段，会引发处理器异常中断；如果R=1，则代码段是可以读出的，即可以把这个段的内容当成ROM一样使用。 数据段和代码段的A位是已访问(Accessed)位，用于指示它所指向的段最近是否被访问过。在描述符创建的时候，应该清零。之后，每当该段被访问时，处理 器自动将该位置“1”。对该位的清零是由软件（操作系统）负责的，通过定期监视该位的状态，就可以统计出该段的使用频率。当内存空间紧张时，可以把不 经常使用的段退避到硬盘上，从而实现虚拟内存管理。 AVL是软件可以使用的位(Available)，通常由操作系统来用，处理器并不使用它。\n安装存储器的段描述符并加载GDTR 处理器规定，GDT中的第一个描述符必须是空描述符，或者叫“哑描述符”、NULL描述符\n一个未初始化的选择子往往也是0，使用这样的描述符将默认选择GDT中的0号描述符，但未必是我们的本意。因此处理器要求将第一个描述符定义成空描述符。 加载描述符表的线性基地址和界限到寄存器GDTR，这要使用lgdt指令，该指令的格式为\nlgdt指令从指定的内存地址处加载6字节的数据到寄存器GDTR，其中包括32位的GDT线性地址及16位的界限值。\n该指令在实模式和保护模式下都可以执行，但是在实模式下使用16位的有效地址m访问内存；在32位保护模式下使用32位的有效地址m访问内存。 在这6字节的内存区域中，要求前（低）16位是GDT的界限值，后（高）32位是GDT的基地址。 在初始状态下（计算机启动之后），寄存器GDTR的基地址被初始化为0x00000000；界限值为0xFFFF。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/","summary":"全局描述符表 在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，在每个段能够访问之前，必须先进行登记。 当你访问的偏移地址超出段的界限时","title":"保护模式"},{"content":"16位处理器的内存寻址方式\n指定有效地址可以使用基址寄存器BX、BP，变址（索引）寄存器SI和DI，同时还可以加上一个8位或16位的位移。 32位处理器兼容16位处理器的寻址方式，可以运行传统的16位代码。但是，由于32位的处理器都拥有32位的寄存器和算术逻辑部件，而且同内存芯片之间的数 据通路至少是32位的，因此，所有需要从寄存器或者内存地址处取得操作数的指令都被扩充，以适应32位的算术逻辑操作\n32位处理器也有自己独立的内存寻址方式\n指定有效地址可以使用全部的32位通用寄存器作为基址寄存器。同时，还可以再加上一个除ESP外的32位通用寄存器作为变址寄存器。变址寄存器还允许乘以 1、2、4或者8作为比例因子。最后，还允许加上一个8位或者32位的位移。 16位处理器的内存寻址方式不允许在指令中使用栈指针寄存器SP。因此，像这条指令就是不正确的\n1 mov ax, [sp] 但是，在32位处理器上，允许在内存操作数中使用栈指针寄存器ESP。因此，下面的指令形式是合法的\n1 mov eax, [esp] ","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/32%E4%BD%8D%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/","summary":"16位处理器的内存寻址方式 指定有效地址可以使用基址寄存器BX、BP，变址（索引）寄存器SI和DI，同时还可以加上一个8位或16位的位移。 32","title":"32位处理器的寻址方式"},{"content":"流水线 为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解成若干个细小的步骤，并分配给相应的单元来完成。各个单元的执行是独立的、并行的。如 此一来，各个步骤的执行在时间上就会重叠起来，这种执行指令的方法就是流水线(Pipe-Line)技术。\n2000年之后推出的Pentium 4处理器采用了NetBurst微结构，它进一步分解指令的执行过程，采用了31级超深流水线。\n高速缓存 寄存器的速度是最快的，原因在于它使用了触发器，这是一种利用反馈原理制作的存储电路. 触发器的工作速度是纳秒(ns)级别的 制作内存芯片的材料一般是电容和单个的晶体管，由于电容需要定时刷新，使得它的访问速度变得很慢，通常是几十纳秒 硬盘是机电设备，是机械和电子的混合体，它的速度最慢，通常在毫秒级(ms)。 在这种情况下，因为需要等待内存和硬盘这样的慢速设备，处理器便无法全速运行。为了缓解这一矛盾，高速缓存(Cache)技术应运而生。高速缓存是处理器与 内存(DRAM)之间的一个静态存储器，容量较小，但速度可以与处理器匹配。\n高速缓存的用处源于程序在运行时所具有的局部性规律。\n高速缓存的装载是以块为单位的，包括那个所需数据的邻近内容。为此，需要额外的时间来等待块从内存载入高速缓存，在该过程中所损失的时间称为不中惩罚 (miss penalty)。\n高速缓存的复杂性在于，每一款处理器可能都有不同的实现。在一些复杂的处理器内部，会存在多级Cache，分别应用于各个独立的执行部件。\n乱序执行 为了实现流水线技术，需要将指令拆分成更小的可独立执行部分，即拆分成微操作(micro-operations)，简写为μops。\n一旦将指令拆分成微操作，处理器就可以在必要的时候乱序执行(Out-Of-Order Execution)程序。\n这里，指令add eax，［mem2］可以拆分为两个微操作。如此一来，在执行逻辑左移指令的同时，处理器可以提前从内存中读取mem2的内容。典型的，如果数 据不在高速缓存中（不中），那么处理器在获取mem1的内容之后，会立即开始获取mem2的内容，与此同时，shl指令的执行早就开始了。\n将指令拆分成微操作，也可以使得栈的操作更有效率\n1 2 push eax call func push eax指令可以拆分成两个微操作，即可以表述为以下的等价形式\n1 2 sub esp, 4 mov [esp], eax 即使寄存器EAX的内容还没有准备好，微操作sub esp，4也可以执行。call指令执行时需要在当前栈中保存返回地址，在以前，该操作只能等待push eax指令 执行结束，因为它需要ESP的新值。感谢微操作，现在，call指令在微操作sub esp，4执行结束时就可以无延迟地立即开始执行。\n寄存器重命名 以上代码片段做了两件事，但互不相干：将mem1里的内容左移3次（乘以8），并将mem3里的内容加2。如果我们为最后三条指令使用不同的寄存器，那么将更明 显地看出这两件事的无关性。并且，处理器实际上也是这样做的。处理器为最后三条指令使用了另一个不同的临时寄存器，因此，左移（乘法）和加法可以并行 地处理。\nIA-32架构的处理器只有8个32位通用寄存器，但通常都会被我们全部派上用场（甚至还觉得不够）。因此，我们不能奢望在每个计算当中都使用新的寄存器。 不过，在处理器内部，却有大量的临时寄存器可用，处理器可以重命名这些寄存器以代表一个逻辑寄存器，比如EAX。\n寄存器重命名以一种完全自动和非常简单的方式工作。每当指令写逻辑寄存器时，处理器就为那个逻辑寄存器分配一个新的临时寄存器。\n假定现在mem1的内容在高速缓存里，可以立即取得，但mem2的内容不在高速缓存中。这意味着，左移操作可以在加法之前开始（使用临时寄存器代替EAX）。为 左移的结果使用一个新的临时寄存器，其好处是寄存器EAX中仍然是以前的内容，它将一直保持这个值，直到寄存器EBX中的内容就绪，然后同它一起做加法运算。 如果没有寄存器重命名机制，左移操作将不得不等待从内存中读取mem2的内容到寄存器EBX及加法操作完成。\n在所有的操作都完成之后，那个代表寄存器EAX最终结果的临时寄存器的内容被写入真实的寄存器EAX中，该处理过程称为引退(Retirement)。\n所有通用寄存器、栈指针、标志、浮点寄存器，甚至段寄存器都有可能被重命名。\n分支目标预测 流水线并不是百分之百完美的解决方案。实际上，有很多潜在的因素会使得流水线不能达到最佳的效率。一个典型的情况是，如果遇到一条转移指令，则后面那 些已经进入流水线的指令就都无效了。换句话说，我们必须清空(Flush)流水线，从要转移到的目标位置处重新取指令放入流水线。\n在现代处理器中，流水线操作分为很多步骤，包括取指令、译码、寄存器分配和重命名、微操作排序、执行和引退。\n流水线的最大问题是代码中经常存在分支。举个例子，一个条件转移允许指令流前往任意两个方向。如果这里只有一个流水线，那么，直到那个分支开始执行， 在此之前，处理器将不知道应该用哪个分支填充流水线。流水线越长，处理器在用错误的分支填充流水线时，浪费的时间越多。\n分支预测的核心问题是，转移会发生还是不会发生。换句话说，条件转移指令的条件会不会成立。\n1 jne branch5 在这条指令还没有执行的时候，处理器就必须提前预测相等的条件在这条指令执行的时候是否成立。这当然是很困难的，几乎不可能。想想看，如果能够提前 知道结果，还执行这些指令干嘛。 但是，从统计学的角度来看，有些事情一旦出现，下一次还会出现的概率较大。一个典型的例子就是循环 当jnz指令第一次执行时，转移一定会发生。那么，处理器就可以预测，下一次它还会转移到标号lops处，而不是顺序往下执行。事实上， 这个预测通常是很准的。\n在处理器内部，有一个小容量的高速缓存器，叫分支目标缓存器(Branch Target Buffer, BTB)。当处理器执行了一条分支语句后，它会在BTB中记录当前 指令的地址、分支目标的地址，以及本次分支预测的结果。下一次，在那条转移指令实际执行前，处理器会查找BTB，看有没有最近的转移记录。如果能找到对 应的条目，则推测执行和上一次相同的分支，把该分支的指令送入流水线。\n当该指令实际执行时，如果预测是失败的，那么，清空流水线，同时刷新BTB中的记录。这个代价较大。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%B9%E7%82%B9/","summary":"流水线 为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解成若干个细小的步骤，并分配给相应的单元来完成。各个单元的执行是独立的、并行","title":"现代处理器的结构和特点"},{"content":"IA-32架构的基本执行环境 寄存器的扩展 32位处理器内部的通用寄存器\n指令的源操作数和目的操作数必须具有相同的长度，个别特殊用途的指令除外。\n如果目的操作数是32位寄存器，源操作数是立即数，那么，立即数被视为32位的\n32位处理器的指令指针、标志和段寄存器\n在32位模式下，对内存的访问从理论上来说不需要再分段，因为它有32根地址线，可以自由访问任何一个内存位置。但是，IA-32架构的处理器是基于分段模型 的，因此，32位处理器依然需要以段为单位访问内存，即使它工作在32位模式下。不过，它也提供了一种变通的方案，即只分一个段，段的基地址是 0x00000000，段的长度（大小）是4GB。在这种情况下，可以视为不分段，即平坦模型(Flat Mode)。\n每个程序都有属于自己的内存空间。在16位模式下，一个程序可以自由地访问不属于它的内存位置，甚至可以对那些地方的内容进行修改。这当然是不安全的， 也不合法，但却没有任何机制来限制这种行为。在32位模式下，处理器要求在加载程序时，先定义该程序所拥有的段，然后才允许使用这些段。定义段时，除基 地址（起始地址）外，还附加了段界限、特权级别、类型等属性。当程序访问一个段时，处理器将用固件实施各种检查工作，以防止对内存的违规访问。\n在32位模式下，传统的段寄存器，如CS、SS、DS、ES，保存的不再是16位逻辑段地址，而是段的选择子，即用于选择所要访问的段，因此，这一部分也叫作段 选择器。除段选择器外，每个段寄存器还包括一个不可见部分，称为描述符高速缓存器，里面有段的基地址和各种访问属性。这部分内容程序不可访问，由处理 器自动使用。\n32位处理器增加了两个额外的段寄存器FS和GS。对于某些复杂的程序来说，多出两个段寄存器可能会令它们感到高兴。\n基本的工作模式 1982年的时候，INTEL公司推出了80286处理器。这也是一款16位的处理器，大部分的寄存器都和8086处理器一样。因此，80286和8086一样，因为段寄存器 是16位的，而且只能使用16位的偏移地址，在实模式下只能使用64KB的段；尽管它有24根地址线，理论上可以访问2^24，即16MB的内存，但依然只能分成多个 段来进行。\n但是，80286和8086不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是逻辑段地址，而是段选择子，真正的段地址 位于段寄存器的描述符高速缓存中，是24位的。因此，运行在保护模式下的80286处理器可以访问全部16MB内存。\n80286处理器访问内存时，不再需要将段地址左移，因为在段寄存器的描述符高速缓存器中有24位的段物理基地址。这样一来， 段可以位于16MB内存空间中的任何位置，而不再限于低端1MB范围内，也不必非得是位于16字节对齐的地方。不过，由于80286的通用寄存器是16位的， 只能提供16位的偏移地址，因此，和8086一样，即使是运行在保护模式下，段的长度依然不能超过64KB。对段长度的限制妨碍了80286处理器的应用，这 就是16位保护模式很少为人所知的原因。\n1985年的80386处理器是INTEL公司的第一款32位产品，而且获得了极大成功，是后续所有32位产品的基础。和8086、80286不同， 80386处理器的寄存器是32位的，而且拥有32根地址线，可以访问2^32，即4GB的内存。\n80386，以及所有后续的32位处理器，都兼容实模式，可以运行实模式下的8086程序。而且，在刚加电时，这些处理器都自动处于实模式下，此时，它相 当于一个非常快速的8086处理器。只有在进行一番设置之后，才能运行在保护模式下。\n线性地址和分页 传统上，段地址和偏移地址称为逻辑地址，偏移地址叫作有效地址(Effective Address, EA)，在指令中给出有效地址的方式叫作寻址方式(Addressing Mode)。\n1 inc word [bx + si + 0x06] 在分段模型下，内存的分配是不定长的，程序大时，就分配一大块内存；程序小时，就分配一小块。时间长了，内存空间就会碎片化，就有可能出现一种情况： 内存空间是有的，但都是小块，无法分配给某个任务。为了解决这个问题，IA-32处理器支持分页功能，分页功能将物理内存空间划分成逻辑上的页。页的大小 一般为4KB，通过使用页，可以简化内存管理。\n当页功能开启时，段部件产生的地址就不再是物理地址了，而是线性地址(Linear Address)，线性地址还要经页部件转换后，才是物理地址。\n线性地址的概念用来描述任务的地址空间。IA-32处理器上的每个任务都拥有4GB的虚拟内存空间，这是一段长4GB的平坦空间，就像一段平直的线段，因此叫 线性地址空间。相应的，由段部件产生的地址，就对应着这条线段上的每个点，这就是线性地址。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/32%E4%BD%8Dx86/","summary":"IA-32架构的基本执行环境 寄存器的扩展 32位处理器内部的通用寄存器 指令的源操作数和目的操作数必须具有相同的长度，个别特殊用途的指令除外。 如","title":"32位x86"},{"content":"外部硬件中断 从处理器外面来的中断信号\n外部硬件中断是通过两个信号线引入处理器内部的。从很早的时候起，也就是8086处理器的时代，这两根线的名字就叫NMI和INTR。\n可屏蔽中断. 对于那些不紧急，不用着急处理的中断信号，应该从INTR引脚输入。 非屏蔽中断(Non Maskable Interrupt, NMI). 所有严重事件都必须无条件地加以处理，由这类事件引发的中断信号应当通过NMI引脚送入处理器 电池即将耗尽、内存校验错误、I/O检验错误 非屏蔽中断 尽管非屏蔽中断在处理器内部是不可屏蔽的, 但是，在处理器外部却有一个开关来控制非屏蔽中断信号能否进入处理器\nINTEL处理器规定，NMI中断信号由0跳变到1后，至少要维持4个以上的时钟周期才算是有效的，才能被识别。\n当一个中断发生时，处理器将会通过中断引脚NMI和INTR得到通知。除此之外，它还应当知道发生了什么事，以便采取适当的处理措施。每种类型的中断都被统 一编号，这称为中断类型号、中断向量或者中断号。\n由于不可屏蔽中断的特殊性——几乎所有触发NMI的事件对处理器来说都是致命的，甚至是不可纠正的。在这种情况下，努力去搞清楚发生了什么，通常没有太大 的意义，这样的事最好留到关机之后，让专业维修人员来做。也正是这个原因，在实模式下，NMI被赋予了统一的中断号2，不再进行细分。一旦发生2号中 断，处理器和软件系统通常会放弃继续正常工作的“念头”，也不会试图纠正已经发生的问题和错误，很可能只是由软件系统给出一个提示信息。\n可屏蔽中断 需要区分中断的类型和来源 需要一个代理，来接受外部设备发出的中断信号 该代理的任务还包括对它们进行仲裁，以决定让它们中的哪一个优先向处理器提出服务请求 单处理器系统的中断机制\n8259中断代理芯片(中断控制器) INTEL处理器允许256个中断，中断号的范围是0～255，8259负责提供其中的15个，但中断号并不固定。之所以不固定，是因为当初设计的时候，允许软件根 据自己的需要灵活设置中断号，以防止发生冲突。该中断控制器芯片有自己的端口号，可以像访问其他外部设备一样用in和out指令来改变它的状态，包括各引 脚的中断号。正是因为这样，它又叫可编程中断控制器(Programmable Interrupt Controller, PIC)。\n8259主片的引脚0(IR0)接的是系统定时器/计数器芯片；从片的引脚0(IR0)接的是实时时钟芯片RTC. 这两块芯片的固定连接即使是在硬件更新换代非常频繁 的今天，也依然没有改变。\n在8259芯片内部，有中断屏蔽寄存器(Interrupt Mask Register, IMR)，这是个8位寄存器，对应着该芯片的8个中断输入引脚，对应的位是0还是1，决定 了从该引脚来的中断信号是否能够通过8259送往处理器（0表示允许，1表示阻断，这可能出乎你的意料）\n主片的端口号是0x20和0x21，从片的端口号是0xa0和0xa1 可以通过这些端口访问8259芯片，设置它的工作方式，包括IMR的内容。 当一个中断正在处理时，其他中断也会陆续到来，甚至会有多个中断同时发生的情况, 8259芯片会记住它们，并按一定的策略决定先为谁服务\n中断的优先级和引脚是相关的，主片的IR0引脚优先级最高，IR7引脚优先级最低，从片也是如此。当然，还要考虑到从片是级联在主片的IR2引脚上的。\n当一个中断事件正在处理时，如果来了一个优先级更高的中断事件时，允许暂时中止当前的中断处理，先为优先级较高的中断事件服务，这称为中断嵌套。\n实模式下的中断向量表 在实模式下，处理器要求将中断处理程序的入口点集中存放到内存中从物理地址0x00000开始到0x003ff结束，共1KB的空间内，这就是所谓的中断向量表 (Interrupt Vector Table, IVT)。\n每个中断在中断向量表中占2个字，分别是中断处理程序的偏移地址和逻辑段地址。\n当中断发生时，如果从外部硬件到处理器之间的道路都是畅通的，那么，处理器在执行完当前的指令后，会立即着手为硬件服务。它首先会响应中断，告诉 8259芯片准备着手处理该中断。接着，它还会要求8259芯片把中断号送过来。 处理器拿着这个中断号，要按顺序做以下几件事 保护断点的现场。首先要将标志寄存器FLAGS压栈，然后清除它的IF位和TF位。再将当前的代码段寄存器CS和指令指针寄存器IP压栈。 执行中断处理程序。由于处理器已经拿到了中断号，它将该号码乘以4, 就得到了该中断入口点在中断向量表中的偏移地址。接着，从表中依次取出中断程 序的偏移地址和段地址，并分别传送到IP和CS，处理器就开始执行中断处理程序了。 返回到断点接着执行。所有中断处理程序的最后一条指令必须是中断返回指令iret。这将导致处理器依次从栈中弹出（恢复）IP、CS和FLAGS的原始内容， 于是转到主程序接着执行。 中断随时可能发生，中断向量表的建立和初始化工作是由BIOS在计算机启动时负责完成的。BIOS为每个中断号填写入口地址，因为它不知道多数中断处理 程序的位置，所以，一律将它们指向一个相同的入口地址，在那里，只有一条指令：iret。也就是说，当这些中断发生时，只做一件事，那就是立即返回。当计 算机启动后，操作系统和用户程序再根据自己的需要，来修改某些中断的入口地址，使它指向自己的代码。\n实时时钟、CMOS RAM和BCD编码 实时时钟电路(Real Time Clock, RTC)和两小块由互补金属氧化物(CMOS)材料组成的静态存储器(CMOS RAM)。实时时钟电路负责计时，而日期和时间的数 值则存储在这块存储器中。\nCMOS RAM中保存的日期和时间通常是以二进制编码的十进制数(Binary Coded Decimal, BCD)，这是默认状态，如果需要，也可以设置成按正常的二进制数 来表示。\nCMOS RAM中的时间信息\nCMOS RAM的访问，需要通过两个端口来进行\n0x70或者0x74是索引端口，用来指定CMOS RAM内的单元 0x71或者0x75是数据端口，用来读写相应单元里的内容 端口0x70的最高位(bit 7)是控制NMI中断的开关。当它为0时，允许NMI中断到达处理器，为1时，则阻断所有的NMI信号，其他7个比特，即0～6位，则实际上 用于指定CMOS RAM单元的索引号\n寄存器A各位功能说明\n续表 寄存器B各位功能说明\n续表 寄存器C各位功能说明\n寄存器D各位功能说明\n实时时钟RTC的中断信号 实时时钟RTC电路可以产生三种中断信号，分别是：\n周期性中断(Periodic Interrupt, PF), 每隔一段时间重复发生一次 更新周期结束中断(Update-ended Interrupt, UI), 每隔一秒，实时时钟电路将更新CMOS RAM里面的时间和日期。在每个更新周期结束时，如果允许的 话，实时时钟电路可以发出一个中断信号，表示本次更新周期已经结束 闹钟中断(Alarm Interrupt, AI), 类似于我们日常用的闹钟，当实时时钟到达指定的闹点时，如果允许的话，将产生闹钟中断信号。 内部中断 内部中断发生在处理器内部，是在执行指令的过程中出现了问题或者故障引起的。\n内部中断不受标志寄存器IF位的影响，也不需要中断识别总线周期，它们的中断类型是固定的，可以立即转入相应的处理过程。\n当处理器检测到div或者idiv指令的除数为0时，或者除法的结果溢出时，将产生中断0（0号中断），这就是除法错中断。 当处理器遇到非法指令时，将产生中断6。 软中断 在编写程序的时候，我们可以随时用指令来产生中断，这种类型的中断叫作软中断。软中断也不需要中断识别总线周期，中断号在指令中给出。\n产生软中断的指令\n1 2 3 int3 int imm8 into int3是断点中断指令，机器指令码为0xCC。 int指令的机器码为2字节，第一字节是操作码0xCD，第2字节给出了中断号。 into是溢出中断指令，机器码为0xCE，也是单字节指令。当处理器执行这条指令时，如果标志寄存器的OF位是1，那么，将产生4号中断。否则，这条指令什 么也不做。 BIOS中断 之所以称为BIOS中断，是因为这些中断功能是在计算机加电之后，BIOS程序执行期间建立起来的。换句话说，这些中断功能在加载和执行主引导扇区之前，就已 经可以使用了。\nBIOS中断，又称BIOS功能调用，主要是为了方便地使用最基本的硬件访问功能。不同的硬件使用不同的中断号，比如，使用键盘服务时，中断号是0x16\n1 int 0x16 为了区分针对同一硬件的不同功能，使用寄存器AH来指定具体的功能编号。\n1 2 3 ; 从键盘读取一个按键 mov ah, 0x00; 从键盘读字符 int 0x16; 键盘服务, 返回时, 字符代码在寄存器al中 BIOS是怎么建立起这套功能调用中断的？它又是怎么知道如何访问硬件的？\nBIOS可能会为一些简单的外围设备提供初始化代码和功能调用代码，并填写中断向量表，但也有一些BIOS中断是由外部设备接口自己建立的。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/%E4%B8%AD%E6%96%AD/","summary":"外部硬件中断 从处理器外面来的中断信号 外部硬件中断是通过两个信号线引入处理器内部的。从很早的时候起，也就是8086处理器的时代，这两根线的名字","title":"中断"},{"content":"光标寄存器 打印字符超过一行时, 显卡不会自动换行, 需要程序控制光标\n两个光标寄存器组成16位, 存储了光标位置 = 80*i+j (0\u0026lt;=i\u0026lt;=24, 0\u0026lt;=j\u0026lt;=79)\n指定光标寄存器. 访问显卡中的寄存器需要通过数据端口0x3d4指定要访问哪个寄存器 光标寄存器编号\n14(0x0e), 高8位 15(0x0f), 低8位 读写数据. 通过数据端口0x3d5来进行 打印字符流程\n1 2 3 4 5 6 7 8 9 10 11 12 13 ; 取当前光标位置 mov dx,0x3d4 mov al,0x0e out dx,al mov dx,0x3d5 in al,dx ;高8位 mov ah,al mov dx,0x3d4 mov al,0x0f out dx,al mov dx,0x3d5 in al,dx ;低8位 显存地址 向映射到内存空间的显存地址写入ascii就能打印字符\n显存地址为0xb800, 每两个字节显示一个字符, 低字节存储ascii, 高字节存储属性.\n光标位置*2可以得到某字符在内存中的偏移\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/%E6%96%87%E6%9C%AC%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%8E%A7%E5%88%B6%E6%98%BE%E5%8D%A1/","summary":"光标寄存器 打印字符超过一行时, 显卡不会自动换行, 需要程序控制光标 两个光标寄存器组成16位, 存储了光标位置 = 80*i+j (0\u0026lt;=i\u0026lt;=24, 0\u0026lt;=j\u0026lt;=79) 指定光标寄存器. 访问显卡中的","title":"文本模式下控制显卡"},{"content":"处理器可以用过程调用指令转移到这段代码执行，在遇到过程返回指令时重新返回到调用处的下一条指令接着执行。\n要调用过程，需要该过程的地址。一般来说，过程的第一条指令需要一个标号，以方便引用该过程。\n参数传递最简单的办法是通过寄存器。\n在调用过程前，主程序会用到一些寄存器，在过程返回之后，可能还要继续使用。但是，在每个过程内部，也可能会用到一些寄存器。由于可用的寄存器很少， 所以有可能用到和主程序相同的寄存器。为了让主程序的执行不失连续性，在过程的开头，应当将本过程要用到（内容肯定会被破坏）的寄存器临时压栈，并在 返回到调用点之前出栈恢复。\n8086处理器支持四种调用方式 16位相对近调用 近调用的意思是被调用的目标过程位于当前代码段内，而非另一个不同的代码段，所以只需要得到偏移地址即可。\n16位相对近调用是三字节指令，操作码为0xE8，后跟16位的操作数，因为是相对调用，故该操作数是当前call指令相对于目标过程的偏移量。\n用目标过程的汇编地址减去当前call指令的下一条指令的汇编地址，保留16位的结果。 1 call near proc_1 近调用的特征是在指令中使用关键字“near”。“proc_1”是程序中的一个标号。在编译阶段，编译器用标号proc_1处的汇编地址减去本指令的下一条指令的汇编 地址（可以用本指令的汇编地址加上本指令的长度3得到），保留16位结果，作为机器指令的操作数部分。\n关键字“near”不是必需的，如果call指令中没有提供任何关键字，则编译器认为该指令是近调用。\n被调用过程可在call之前或之后, 所以call后的16位操作数是有符号数, 被调用过程的首地址必须位于距离当前call指令-32768～32767字节的地方\n在指令执行阶段，处理器看到操作码0xE8，就知道它应当调用一个过程。于是，它\n用指令指针寄存器IP的当前内容（它已经指向下一条指令）加上指令中的操作数，得到一个新的偏移地址。 将指令指针寄存器IP的原有内容压入栈 用刚才计算出的偏移地址取代指令指针寄存器IP原有的内容。这直接导致处理器的执行流转移到目标位置处。 注意以下形式, 在call指令后跟一个标号和跟一个数值没有什么不同。标号是数值的等价形式，是代表标号处的汇编地址。在指令编译阶段，它首先会被转化成 数值。所以，你在call指令后跟一个数值，只是帮了编译器的忙，帮它省了一个转化步骤，它依然会用这个数值减去当前指令的下一条指令的汇编地址，来得到 一个偏移量。\n1 call 0x0500 16位间接绝对近调用 这种调用也是近调用，只能调用当前代码段内的过程，指令中的操作数不是偏移量，而是被调用过程的真实偏移地址，故称为绝对地址。不过，这个偏移地 址不是直接出现在指令中的，而是由16位的通用寄存器或者16位的内存单元间接给出的。\n默认ds\n由于间接绝对近调用的机器指令操作数是16位的绝对地址，因此，它可以调用当前代码段任何位置处的过程。\n16位直接绝对远调用 这种调用属于段间调用(far call), 远调用既需要被调用过程所在的段地址，也需要该过程在段内的偏移地址。\n1 call 0x2000:0x0030 处理器在执行时\n首先将代码段寄存器CS的当前内容压栈 再把指令指针寄存器IP的当前内容压栈。 用指令中给出的段地址代替CS原有的内容，用指令中给出的偏移地址代替指令指针寄存器IP原有的内容。这直接导致处理器从新的位置开始执行。 16位间接绝对远调用 这也属于段间调用, 被调用过程所在的段地址和偏移地址是间接给出的.\n间接远调用必须使用关键字“far” 段地址和偏移地址在内存中的其他位置，指令中仅仅给出的是该位置的偏移地址，需要处理器在执行指令的时候自行按图索骥，找到它们。\n前两条指令是等效的，不同之处仅仅在于，第一条指令直接给出的是数值，而第二条指令用的是标号。\n实际情况类似于\n1 2 3 4 ; 0x0102是偏移地址, 0x2000是段地址 proc_1 dw 0x0102, 0x2000 ; 为了调用该过程，可以在代码段内使用这条指令 call far [proc_1] 当这条指令执行时\n处理器访问由段寄存器DS指向的数据段，从指令中指定的偏移地址（由标号proc_1提供）处取得两个字（分别是段地址0x2000和偏移地址0x0102）； 接着，将代码段寄存器CS和指令指针寄存器IP的当前内容分别压栈； 最后，用刚才取得的段地址和偏移地址分别取代CS和IP的原值。 过程返回 ret是近返回指令，从栈中弹出一个字到指令指针寄存器IP中。 retf是远返回指令(return far), 处理器分别从栈中弹出两个字到指令指针寄存器IP和代码段寄存器CS中 尽管call指令通常需要ret/retf和它配对，遥相呼应，但ret/retf指令却并不依赖于call指令\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/","summary":"处理器可以用过程调用指令转移到这段代码执行，在遇到过程返回指令时重新返回到调用处的下一条指令接着执行。 要调用过程，需要该过程的地址。一般来说","title":"过程调用"},{"content":"加载器需要了解如何加载用户程序 加载器与用户程序之间的协议部分\n1 SECTION header vstart=0 因为它是“头部”，所以，该段当然必须是第一个被定义的段，且总是位于整个源程序的开头。\n用户程序头部起码要包含以下信息\n用户程序的尺寸，即以字节为单位的大小。这对加载器来说是很重要的，加载器需要根据这一信息来决定读取多少个逻辑扇区 应用程序的入口点，包括段地址和偏移地址。加载器并不清楚用户程序的分段情况，更不知道第一条要执行的指令在用户程序中的位置。因此，必须在头部给 出第一条指令的段地址和偏移地址，这就是所谓的应用程序入口点(Entry Point)。 段重定位表。用户程序可能包含不止一个段, 程序加载到内存后，每个段的地址必须重新确定一下。段的重定位是加载器的工作，它需要知道每个段在用户程 序内的位置 加载流程 1. 初始化和决定加载位置 可用于加载用户程序的空间范围\n物理地址0x0FFFF以下，是加载器及其栈的势力范围；物理地址A0000以上，是BIOS和外围设备的势力范围 可用的空间就位于0x10000～9FFFF，差不多500多KB。 2. 从硬盘读取用户程序 I/O接口 和处理器打交道的硬件很多，不单是硬盘，还有显示器、网络设备、扬声器（喇叭）和话筒（麦克风）、键盘、鼠标等。\n总线技术\n解决多种I/O接口与处理器相连的问题 总线可以认为是一排电线，所有的外围设备，包括处理器，都连接到这排电线上。但是，每个连接到这排电线上的器件都必须拥有电子开关，以使它们随时能 够同这排电线连接，或者从这排电线上断开（脱离）。 输入输出控制设备集中器(I/O Controller Hub,ICH)芯片\n避免各个I/O设备与处理器通信的冲突问题 该芯片的作用是连接不同的总线，并协调各个I/O接口对处理器的访问。在个人计算机上，这块芯片就是所谓的南桥。 计算机内部总线系统\n处理器是通过端口(Port)来和外围设备打交道的。本质上，端口就是一些寄存器，类似于处理器内部的寄存器。不同之处仅仅在于，这些叫作端口的寄存器位于 I/O接口电路中。\n端口在不同的计算机系统中有着不同的实现方式。在一些计算机系统中，端口号是映射到内存地址空间的。而在另一些计算机系统中，端口是独立编址的，不和 内存发生关系。\nINTEL处理器，早期是独立编址的，现在既有内存映射的，也有独立编址的。 在INTEL的系统中，只允许65536（十进制数）个端口存在，端口号从0到65535(0x0000～0xffff)。因为是独立编址，所以，端口的访问不能使用类似于mov 这样的指令，取而代之的是in和out指令。\n1 2 3 in al, dx ; 或 in ax, dx 通过硬盘控制器端口读扇区数据 采用LBA28来访问硬盘. 个人计算机上的主硬盘控制器被分配了8位端口，端口号从0x1f0到0x1f7。\n设置要读取的扇区数量 1 2 3 mov dx, 0x1f2; 目标端口0x1f2 mov al, 0x01 ; 1个扇区 out dx, al 如果写入的值为0，则表示要读取256个扇区。每读一个扇区，这个数值就减1。因此，如果在读写过程中发生错误，该端口包含着尚未读取的扇区数。\n设置起始LBA扇区号 28位的扇区号太长，需要将其分成4段，其中，0x1f3号端口存放的是0～7位；0x1f4号端口存放的是8～15位；0x1f5号端口存放的是16～23位，最后4位在 0x1f6号端口。\n假定我们要读写的起始逻辑扇区号为0x02\n在现行的体系下，每个PATA/SATA接口允许挂接两块硬盘，分别是主盘(Master)和从盘(Slave)。0x1f6端口的低4位用于存放逻辑扇区号的24～27位，第4位 用于指示硬盘号，0表示主盘，1表示从盘。高3位是“111”，表示LBA模式(0xe0)。\n端口1f6各位的含义\n向端口0x1f7写入0x20，请求硬盘读 等待读写操作完成 端口0x1f7既是命令端口，又是状态端口。硬盘内部操作期间，它将0x1f7端口的第7位置“1”，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明 自己已经忙完了，同时将第3位置“1”，意思是准备好了，请求主机发送或者接收数据。\n端口0x1f7部分状态位的含义\n接收数据\nand al, 0x88这条指令保留住寄存器AL中的第7位和第3位，其他无关的位都清零。\n连续取出数据 0x1f0是硬盘接口的数据端口，而且还是一个16位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。\n1 2 3 4 5 6 7 mov cx, 256 ; 总共要读取的字数 mov dx, 0x1f0 .readw: in ax, dx mov [bx], ax add bx, 2 loop .readw 0x1f1端口是错误寄存器，包含硬盘驱动器最后一次执行命令后的状态\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/","summary":"加载器需要了解如何加载用户程序 加载器与用户程序之间的协议部分 1 SECTION header vstart=0 因为它是“头部”，所以，该段当然必须是第一个被定义的段，且总是位于整个源","title":"加载器工作流程"},{"content":"定义段 1 2 3 SECTION 段名称 ; 或 SEGMENT 段名称 未定义段的内容自成一个段\n在编写源程序时定义的段也必须至少按16字节对齐。\n要在编写程序时指定段的对齐方式，应该使用“align=”子句，并指定一个具体的对齐。\n“align=16”就表示段是16字节对齐的 “align=32”就表示段是32字节对齐的。 用户程序的一般结构\n1 2 3 4 5 6 7 8 section data1 align=16 db 0x55 section data2 align=16 db 0xaa section data3 align=16 db 0x99 每个段都有一个汇编地址，它是相对于整个程序开头(0)的。为了方便取得该段的汇编地址，NASM编译器提供了以下的表达式\n1 section.段名称.start “vstart=0”子句使该段中的标号相对于该段计算, 而不是程序的开头\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/%E6%AE%B5/","summary":"定义段 1 2 3 SECTION 段名称 ; 或 SEGMENT 段名称 未定义段的内容自成一个段 在编写源程序时定义的段也必须至少按16字节对齐。 要在编写程序时指定段的对齐方式，应该","title":"段"},{"content":"寻址方式就是如何找到要操作的数据，以及如何找到存放操作结果的地方。\n寄存器寻址 指令执行时，操作的数位于寄存器中\n1 2 3 mov ax, cx add bx, 0xf000 inc dx 立即寻址 又叫立即数寻址。也就是说，指令的操作数是一个立即数\n1 2 3 4 add bx, 0xf000 ; 标号是数值的等价形式, 代表汇编地址, ; 在编译阶段被转化为一个立即数. mov dx, label_a 内存寻址 所谓的内存寻址方式，就是如何在指令中指定操作数的偏移地址，供处理器访问内存时使用，这个偏移地址也叫有效地址(Effective Address, EA)。换句话 说，内存寻址方式就是在指令中指定偏移地址（有效地址）如何计算。\n直接寻址 偏移地址或者说有效地址是直接给出的，是一个用标号或者数字直接给出的具体数值。\n1 2 3 mov ax, [0x5c0f]; ds add word [0x0230], 0x5000; ds xor byte [es:label_b], 0x05 基址寻址 先指定一个基准位置，数据的偏移地址（有效地址）取决于它到基准位置的位移或者说距离(Displacement)。\n要使用基址寻址的话，必须在指令的地址部分使用基址寄存器BX或者BP来提供一个基准地址。\n1 2 mov [bx], dx; ds add byte [bx], 0x55; ds 基址寻址的动机是采用“基地址+位移”的方式计算有效地址\n1 2 3 4 5 6 buffer dw 0x20, 0x100, 0x0f, 0x300, 0xff00 mov bx, buffer inc word [bx] inc word [bx + 2] inc word [bx + 4] ... 在基址寻址方式中，基址寄存器也可以是BP\n1 2 mov ax, [bp]; ss mov dx, [bp - 2] 在基址寻址方式中，基地址原则上是固定不变的。换句话说，通常不改变BX和BP，而是在BX和BP的基础上加一个位移。但是，有时候为了方便，可以通过增加 BX和BP的方式来访问数据，这可以看成在操作的过程中动态设置新的基地址。\n变址寻址 变址寻址类似于基址寻址，唯一不同之处在于这种寻址方式使用的是变址寄存器（或称索引寄存器）SI和DI。\n1 2 3 4 5 6 mov [si], dx; ds add ax, [di]; ds xor word [si], 0x8000 mov [si + 0x100], al and byte [di + label_a], 0x80 基址变址寻址 使用基址变址的操作数可以使用一个基址寄存器（BX或者BP），外加一个变址寄存器（SI或者DI）。\n1 2 mov ax, [bx + si]; ds add word [bx + di], 0x3000; ds 基址变址寻址允许在基址寄存器和变址寄存器的基础上再带一个位移，但它必须是一个数值。\n1 2 mov [bx + si + 0x100], al and byte [bx + di + label_a], 0x80 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/8086%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/","summary":"处理器的一生，是忙碌的一生，只要它工作着，就必定是在取指令和执行指令。它就像勤劳的牛，吃的是电，挤出来的还是电，不过是另一种形式的电。","title":"8086处理器的寻址方式"},{"content":"8086标志寄存器 ZF, 当处理器执行一条算术或者逻辑运算指令后, 如果计算结果为0，这一位被置成1，表示计算结果为0是“真”的；否则清除此位(0)。 DF, 通过将这一位清0或者置1，就能控制movsb和movsw的传送方向。 SF, 如果计算结果的最高位是比特“0”，处理器把SF位置“0”，否则SF位置“1”。 PF, 当运算结果出来后，如果最低8位中，有偶数个为1的比特，则PF=1；否则PF=0。 CF, 当处理器进行算术操作时，如果最高位有向前进位或借位的情况发生，则CF=1；否则CF=0。 inc, dec不影响cf位 OF, 该标志的意思是，假定你进行的是有符号数运算，如果运算结果是正确的，那么OF=0，否则OF=1。 IF, 中断标志(Interrupt Flag)。当IF为0时，所有从处理器INTR引脚来的中断信号都被忽略掉；当其为1时，处理器可以接受和响应中断。 cli(CLear Interrupt flag)用于清除IF标志位；sti(SeT Interrupt flag)用于置位IF标志。\n影响标志位的指令 or指令对标志寄存器的影响是：OF和CF位被清零，SF、ZF、PF位的状态依计算结果而定，AF位的状态未定义。\nand指令执行后，OF和CF位被清零，SF、ZF、PF位的状态依计算结果而定，AF位的状态未定义。\nmul指令执行后，要是结果的高一半为全0，则OF和CF清零，否则置1。对SF、ZF、AF和PF标志的影响未定义。\ntest指令执行后，OF=CF=0；对ZF、SF和PF的影响视测试结果而定；对AF的影响未定义。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/","summary":"8086标志寄存器 ZF, 当处理器执行一条算术或者逻辑运算指令后, 如果计算结果为0，这一位被置成1，表示计算结果为0是“真”的；否则清除此位(0)","title":"标志寄存器"},{"content":"在64位处理器上，这些寄存器再次被扩展，达到了64位，即RAX、RBX、RCX、RDX、RSI、RDI、RBP、RSP和RIP。同时，它们的低32位（包括低16位）依然保 持从前的用法。\n除此之外，64位的x86处理器还新增了8个64位的通用寄存器R8、R9、R10、R11、R12、R13、R14和R15。\n在32位和64位处理器中，除了段寄存器CS、SS、DS和ES，还新增了两个段寄存器FS和GS\n在32位和64位处理器中，以上6个段寄存器都依然是16位的，但都额外增加了一个不可访问的部分，叫作段描述符高速缓存器。段描述符高速缓存器由处理器内 部使用，不能在程序中访问，里面存放了段的起始地址、段的扩展范围，以及段的各种属性\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%89%A9%E5%B1%95/","summary":"在64位处理器上，这些寄存器再次被扩展，达到了64位，即RAX、RBX、RCX、RDX、RSI、RDI、RBP、RSP和RIP。同时，它们的","title":"通用寄存器的扩展"},{"content":"div 无符号除法指令 可以做两种类型的除法\n16位被除数(必须放在ax中), 8位除数(通用寄存器/内存), 执行后商在al中, 余数在ah中 1 2 3 4 5 6 7 8 9 div cl div byte [0x0023] ; 使用标号 dividnd dw 0x3f0 divisor db 0x3f ... mov ax, [dividnd] ; 相当于 mov ax, [0xf000], 相对于ds div byte [divisor]; 相当于 div byte [0xf002] 32位被除数, 16位除数 因为16位的处理器无法直接提供32位的被除数，故要求被除数的高16位在寄存器DX中，低16位在寄存器AX中。 指令执行后，商在寄存器AX中，余数在寄存器DX中\n1 2 div cx div word [0x0230] idiv 有符号除法 用法和div相同\n1 2 3 mov ax, 0x0400 mov bl, 0xf0 idiv bl mul mul指令可以用8位的通用寄存器或者内存单元中的数和寄存器AL中的内容相乘，结果是16位，在AX寄存器中；也可以用16位的通用寄存器或者内存单元中的数 和寄存器AX中的内容相乘，结果是32位，高16位和低16位分别在DX和AX中。\nxor 异或 目的操作数可以是通用寄存器和内存单元，源操作数可以是通用寄存器、内存单元和立即数（不允许两个操作数同时为内存单元）\n1 2 ; 清零 xor dx, dx mov dx，0的机器码是BA 00 00；而xor dx，dx的机器码则是31 D2，不但较短，而且，因为xor dx，dx的两个操作数都是通用寄存器，所以执行速 度最快。\nadd 目的操作数可以是8位或者16位的通用寄存器，或者指向8位或者16位实际操作数的内存地址； 源操作数可以是相同数据宽度的8位或者16位通用寄存器、指向8位或者16位实际操作数的内存地址，或者立即数，但不允许两个操作数同时为内存单元。 相加后，结果保存在目的操作数中。 sub 目的操作数可以是8位或者16位通用寄存器，也可以是8位或者16位的内存单元；源操作数可以是通用寄存器，也可以是内存单元或者立即数（不允许两个操作数 同时为内存单元）。\n1 2 3 sub ah, al sub dx, ax sub [label_a], ch 无条件转移指令 相对短转移 相对短转移的操作码为0xEB，操作数是相对于目标位置的偏移量，仅1字节，是个有符号数。由于这个原因，该指令属于段内转移指令，而且只允许转移到距离 当前指令-128～127字节的地方。相对短转移指令必须使用关键字“short”。\n1 jmp short infinite 在源程序编译阶段，编译器会检查标号infinite所代表的值，如果数值超过了1字节所能允许的数值范围，则无法通过编译。否则，编译器用目标位置的汇编地 址减去当前指令的下一条指令的汇编地址，保留1字节的结果，作为机器指令的操作数。\n相对短转移指令的汇编语言操作数只能是标号和数值。\n1 jmp short 0x2000 在指令执行时，处理器把指令中的操作数加到指令指针寄存器IP上，这会导致指令的执行流程转向目标地址处。\n16位相对近转移 机器指令操作码为0xE9，而且，该指令的长度为3字节，操作码0xE9后面还有一个16位（2字节）的操作数。\n因为是近转移，故其属于段内转移。“相对”的意思同样是指它的操作数是一个相对量，是相对于目标位置处的偏移量。在源程序编译阶段，编译器用目标位置的 汇编地址减去当前指令的下一条指令的汇编地址，保留16位的结果，作为机器指令的操作数。由于这是一个16位的有符号数，故可以转移到距离当前指令 -32768～32767字节的地方。\n16位相对近转移指令应当使用关键字“near”\n1 2 jmp near infinite jmp near 0x3000 如果没有指定关键字short或者near，那么，如果目标位置距离当前指令-128～127字节，则自动采用short；否则，采用near。\n16位间接绝对近转移 这种转移方式也是近转移，即只在段内转移。但是，转移到的目标偏移地址不是在指令中直接给出的，而是用一个16位的通用寄存器或者内存地址来间接给出的。\n指令中的关键字“near”可以省略 1 2 3 jmp near bx jmp near cx jmp [jump_dest]; ds 16位直接绝对远转移 1 jmp 0x0000:0x7c00 执行这条指令后，处理器用指令中给出的段地址代替段寄存器CS的原有内容，用给出的偏移地址代替IP寄存器的原有内容，从而跳转到另一个不同的代码段中， 即执行一个段间转移。\n16位间接绝对远转移 远转移的目标地址可以通过访问内存来间接得到，这叫间接远转移，但是要使用关键字“far”。假如在某程序的数据段内声明了标号jump_far，并在其后初始化 了两个字：\n1 2 ; 偏移地址, 段地址 jump_far dw 0x33c0, 0xf000 转移指令\n1 jmp far [jump_far] 处理器执行这条指令后，访问段寄存器DS所指向的数据段，从指令中给出的偏移地址处取出两个字，分别用来替代段寄存器CS和指令指针寄存器IP的内容。\n1 2 3 jmp far [0x04] jmp far [bx] jmp far [bx + si] “16位”的意思是，要转移到的目标位置的偏移地址是16位的。\n条件转移指令 jns 1 2 ; 如果未设置符号位，则转移到标号“show”所在的位置处执行。 jns show 它和jmp指令很相似，它也是相对转移指令，编译后的机器指令操作数也是一个相对偏移量，是用标号处的汇编地址减去当前指令的下一条指令的汇编地址得到的。\n相反的指令js\njz 结果为零（ZF标志为1）则转移；jnz的意思是结果不为零（ZF标志为0）则转移。\njo 结果溢出（OF标志为1）则转移，jno的意思是结果未溢出（OF标志为0）则转移。\njc 有进位（CF标志为1）则转移，jnc的意思是没有进位（CF标志为0）则转移。\njp 如果PF标志为1则转移，jnp的意思是如果PF标志不为1（为0）则转移。\n与cmp配合的条件转移指令 jcxz(jump if CX is zero) 当寄存器CX的内容为零时则转移。\n如果寄存器CX的内容为零，则转移到标号show；否则不转移，继续往下执行。\n1 jcxz show cmp 目的操作数可以是8位或者16位通用寄存器，也可以是8位或者16位内存单元；源操作数可以是与目的操作数宽度一致的通用寄存器、内存单元或者立即数，但两 个操作数同时为内存单元的情况除外。\n1 2 3 cmp al, 0x08 cmp dx, bx cmp [label_a], cx cmp指令在功能上和sub指令相同，唯一不同之处在于，cmp指令仅仅根据计算的结果设置相应的标志位，而不保留计算结果，因此也就不会改变两个操作数的原 有内容。cmp指令将会影响到CF、OF、SF、ZF、AF和PF标志位。\ntimes 重复后面的指令 1 times 20 mov ax, bx 批量数据传送 movsb movsw movsb和movsw指令执行时，原始数据串的段地址由DS指定，偏移地址由SI指定，简写为DS:SI；要传送到的目的地址由ES:DI指定；传送的字节数(movsb)或 者字数(movsw)由CX指定。\n除此之外，还要指定是正向传送还是反向传送，正向传送是指传送操作的方向是从内存区域的低地址端到高地址端；反向传送则正好相反。正向传送时，每传送 一字节(movsb)或者一个字(movsw)，SI和DI加1或者加2；反向传送时，每传送一字节(movsb)或者一个字(movsw)时，SI和DI减去1或者减去2。不管是正向 传送还是反向传送，也不管每次传送的是字节还是字，每传送一次，CX的内容自动减1\n方向控制 cld, 传送方向从低到高 std, 传送方向从高到低 rep 重复执行指令 cx不为零则重复\n1 rep movsw loop 循环 1 2 3 4 5 6 digit: xor dx,dx div si mov [bx],dl ;保存数位 inc bx loop digit 在执行loop时\n将cx减1 如果cx不为零, 则转移到指定位置, 否则执行后面的指令 inc 加1 1 2 3 inc al inc byte [bx]; ds inc word [label_a]; ds dec 减1 neg 求相反数 1 2 3 neg al neg dx neg word [label_a] 扩展有符号数 cbw(convert byte to word) cwd(convert word to double-world) cbw操作al, 扩展到ax\n如果寄存器AL中的内容为01001111，那么执行该指令后，寄存器AX中的内容为0000000001001111； 如果寄存器AL中的内容为10001101，执行该指令后，寄存器AX中的内容为1111111110001101。 cwd操作ax, 扩展到dx:ax\n如果寄存器AX中的内容为0100111101111001，那么执行该指令后，寄存器DX中的内容为0000000000000000，寄存器AX中的内容不变； 如果寄存器AX中的内容为1000110110001011，那么执行该指令后，寄存器DX中的内容为1111111111111111，寄存器AX中的内容同样不变。 事实上，符号位是数的一部分，和其他比特一起共同表示数的大小，同时又用来判断数的正负。\nor 目的操作数可以是8位或者16位的通用寄存器，或者包含8/16位实际操作数的内存单元，源操作数可以是与目的操作数数据宽度相同的通用寄存器、内存单元或 者立即数。不允许目的操作数和源操作数都是内存单元的情况出现。结果位于目的操作数中。\n1 2 mov al, 0x55 or al, 0xaa and and指令的两个操作数都应当是字节或者字。其中，目的操作数可以是通用寄存器和内存单元；源操作数可以是通用寄存器、内存单元或者立即数，但不允许两个 操作数同时为内存单元，而且它们在数据宽度上应当一致。结果保存在目的操作数中。\n1 and al, 0x55 push 在16位的处理器上，push指令的操作数可以是16位的寄存器或者内存单元。\n1 2 push ax push word [label_a] 处理器在执行push指令时，首先将栈指针寄存器SP的内容减去操作数的字长（以字节为单位的长度，在16位处理器上是2），然后，把要压入栈的数据存放到逻 辑地址SS:SP所指向的内存位置\n8086处理器不能在栈中压入立即数\npop 将逻辑地址SS:SP处的一个字弹出到16位寄存器/内存, 然后将SP的内容加上操作数的字长(2)。\n1 2 pop ax pop word [label_a] 其他 在8086处理器上，如果要用寄存器来提供偏移地址，只能使用寄存器BX、SI、DI、BP，不能使用其他寄存器。\nINTEL8086处理器只允许以下几种基址寄存器和变址寄存器的组合\n1 2 3 4 [bx + si] [bx + di] [bp + si] [bp + di] in, out in指令的目的操作数必须是寄存器AL或者AX，当访问8位的端口时，使用寄存器AL；访问16位的端口时，使用AX。in指令的源操作数应当是寄存器DX，用来指 定端口号。\nin al，dx的机器指令码是0xEC，in ax，dx的机器指令码是0xED，都是一字节的。之所以如此简短，是因为in指令不允许使用别的通用寄存器，也不允许使 用内存地址作为操作数。\nin指令还有2字节的形式。此时，前一字节是操作码0xE4或者0xE5，分别用于指示8位或者16位端口访问；后一字节是立即数，指示端口号。\n这种指令形式的源操作数部分只允许一字节，故只能访问0～255(0x00～0xff)号端口 out指令正好和in指令相反，目的操作数可以是8位立即数或者寄存器DX，源操作数必须是寄存器AL或者AX。\nshr 逻辑右移 “挤”出来的比特被移到标志寄存器的CF位, 左边空出来的位置用比特“0”填充。\n格式\n例子\n注意，源操作数为1的逻辑右移指令是特殊设计的优化指令，比如以上的shr ah，1，它的机器码是D1 E8；而类似的指令shr ah，5则拥有完全不同的机器码 C1 E8 05。\n如果shr指令的源操作数是寄存器，则只能使用CL. 寄存器CL只用来提供移动次数，而不用于限定和暗示目的操作数的字长。因此，对于目的操作数是内存地址 的情况，必须用关键字byte或者word等来加以限定。\n1 2 shr al, cl shr byte [bx], cl shr的配对指令是逻辑左移指令shl(SHift logical Left)，它的指令格式和shr相同，只不过它是向左移动的。\nror 循环右移 每右移一次，移出的比特既送到标志寄存器的CF位，也送进左边空出的位。\nror的配对指令是循环左移指令rol(ROtate Left)。ror、rol、shl、shr的指令格式都是相同的。\n伪指令 声明空间 db(declare byte) 声明字节 1 2 ; 声明5个初始值为0的字节 db 0,0,0,0,0 dw(declare word) 声明字 dd(declare double) 声明双字 dq(declare quad word) 声明四字 resb REServe Byte, 保留空间, 但不初始化\n1 2 3 4 5 ; 保留256B空间 resb 256 ;类似指令 resw 100 ; 声明100个未初始化的字 resd 50 ; 声明50个未初始化的双字 iret 中断返回指令\n没有操作数，执行这条指令时，处理器依次从栈中弹出数值到IP、CS和标志寄存器。\ncli 清中断\nsti 开放中断\nhlt 使处理器停止执行指令，并处于停机状态，这将降低处理器的功耗。处于停机状态的处理器可以被外部中断唤醒并恢复执行，而且会继续执行hlt后面的指令。\ntest test指令在功能上和and指令是一样的，都是将两个操作数按位进行逻辑“与”，并根据结果设置相应的标志位。但是，test指令执行后，运算结果被丢弃\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/nasm%E6%8C%87%E4%BB%A4/","summary":"div 无符号除法指令 可以做两种类型的除法 16位被除数(必须放在ax中), 8位除数(通用寄存器/内存), 执行后商在al中, 余数在ah中 1 2 3 4 5 6","title":"nasm指令"},{"content":" 1 infi: jmp near infi 标号可以由字母、数字、_、$、#、@、~、.、?组成，但必须以字母、. _和?中的任意一个打头。\n$标记 1 2 jmp near $; 等同于 infi: jmp near infi $$标记 代表当前汇编节（段）的起始汇编地址。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/nasm%E6%A0%87%E5%8F%B7/","summary":"1 infi: jmp near infi 标号可以由字母、数字、_、$、#、@、~、.、?组成，但必须以字母、. _和?中的任意一个打头。 $标记 1 2 jmp near $; 等同于 infi: jmp near infi $$标","title":"nasm标号"},{"content":" K是闪烁位，为0时不闪烁，为1时闪烁；I是亮度位，为0时正常亮度，为1时呈高亮。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/%E5%AD%97%E7%AC%A6%E6%A8%A1%E5%BC%8F/","summary":"K是闪烁位，为0时不闪烁，为1时闪烁；I是亮度位，为0时正常亮度，为1时呈高亮。","title":"字符模式"},{"content":" 8086地址空间为1MB, ROM占内存空间顶端64KB(0xF0000~0xFFFFF), DRAM占内存空间低640KB(0x00000~0x9FFFF), 其他分配给了外围设备 8086加电或者复位时，CS=0xFFFF，IP=0x0000，所以，它取的第一条指令位于物理地址0xFFFF0，正好位于ROM中 ROM中位于物理地址0xFFFF0的地方，通常是一个跳转指令，它通过改变CS和IP的内容，使处理器从ROM中的较低地址处开始取指令执行。jmp 0xf000:0xe05b 硬盘的第一个扇区是0面0道1扇区，或者说是0头0柱1扇区，这个扇区称为主引导扇区。如果计算机的设置是从硬盘启动的，那么，ROM-BIOS将读取硬盘主 引导扇区的内容，将它加载到内存地址0x0000:0x7c00, 然后用一个jmp指令跳到那里接着执行jmp 0x0000:0x7c00 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/8086%E5%BC%95%E5%AF%BC%E8%BF%87%E7%A8%8B/","summary":"8086地址空间为1MB, ROM占内存空间顶端64KB(0xF0000~0xFFFFF), DRAM占内存空间低640KB(0x00000~0","title":"8086引导过程"},{"content":"分段机制能解决程序重定位问题.\n在进行数据传送或者算术逻辑运算的时候，使用算术逻辑部件(ALU)。比如，将AX的内容和CX的内容相加，结果仍在AX中，那么，在相加的结果返回到AX之前， 需要通过一个叫数据暂存器的寄存器中转。 处理器能够自动运行，这是控制器的功劳。为了加快指令执行速度，8086内部有一个6字节的指令预取队列，在处理器忙着执行那些不需要访问内存的指令时， 指令预取部件可以趁机访问内存预取指令。这时，多达6字节的指令流可以排队等待解码和执行。 8086内部有4个段寄存器。其中，CS是代码段寄存器，DS是数据段寄存器，ES是附加段(Extra Segment)寄存器。附加段的意思是，它是额外赠送的礼物， 当需要在程序中同时使用两个数据段时，DS指向一个，ES指向另一个。可以在指令中指定使用DS和ES中的哪一个，如果没有指定，则默认使用DS。SS是栈段(Stack Segment)寄存器 IP是指令指针(Instruction Pointer)寄存器，它只和CS一起使用，而且只有处理器才能直接改变它的内容。当一段代码开始执行时，CS保存代码段的段 地址，IP则指向段内偏移。这样，由CS和IP共同形成逻辑地址，并由总线接口部件变换成物理地址来取得指令。然后，处理器会自动根据当前指令的长度来改 变IP的值，使它指向下一条指令。 8086地址线20位, 而段寄存器16位, 由于段寄存器长度的限制，段不能起始于任意位置，也不是所有内存地址都可以作为段地址，段只能起始于那些能够被16 整除的物理内存地址。\n即段寄存器只存地址前16位, 且只存后4位是0的地址 8086处理器在形成物理地址时，先将段寄存器的内容乘以16或者左移4位，形成20位的段地址，然后再同16位的偏移地址相加，得到20位的物理地址。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/x86/8086%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/","summary":"分段机制能解决程序重定位问题. 在进行数据传送或者算术逻辑运算的时候，使用算术逻辑部件(ALU)。比如，将AX的内容和CX的内容相加，结果仍在","title":"8086的内存分段机制"},{"content":"构图法 居中法构图 主体在画面中占比很大\n合影\n拍对称的场景\n三分法构图 横向主线条出现的时候往往就是地平线、水平线一类的。如果地面或者海面上的景物比较重要，就将地平线或者水平线放在上三分线上，以保证地面和海面有足够的空 间。如果是画面中天空部分的景物比较重要，就将地平线或者水平线放在下三分线上。\n上横向三分线\n下横向三分线\n纵向主线条就是一个人，或者主体就是人啊、车辆一类的，那么往往就有一个朝向问题。\n永远使拍摄的主体朝向比较空旷的一面 马上要撞墙\n下压水平线会让画面的辽阔感更强\n有时候拍摄者不想把主体放置在三分线交点上，一般来说就是拍摄者不想让照片看起来舒服，或者是拍摄者觉得不放在这里更好。其实这样的情况很多见，比如一张照 片想表达一些诸如压抑、困顿、无奈等负面情绪的时候就可以使用这样的构图法。这样您的作品不仅是主体本身的表现让人觉得不舒服，构图也能帮助您强化这种不舒 服的感觉。\n重复法 单一主体重复\n结合虚实\n反例\n引导线法 三角构图法 画面看起来舒服、稳定的情况就是画面中三角形的底边是与画面的底边平行的。直白地说就是三角形是“坐在”画面中的。如果您希望画面看起来舒服、稳定，就可以采 用这样的构图方法。如果是三角形的一个角在画面最下面呢？三角形的角出现在画面最下面会给人不稳定的感觉，会让人觉得三角形会向一边倾斜，或者“扎”下来。\n人物趴在钢琴上，显现出来的就是一个以钢琴为底边的三角形，显得稳定。但是钢琴本身又形成了一个角在画面下面的三角形。这样的“不稳定”会让画面显得有冲击力， 更有“侵略性”。给人一种画面扑面而来的感觉。\n框架构图法 对于画框，可以是周围环境中的固定元素，也可以是移动的元素，比如人。通过“人缝”去拍摄另一个人是常见的人文拍摄方法，这也属于框架构图法。\n构图的一些常识 横构图和竖构图 对横构图来说，其会给人一种稳定和宽阔的感觉。那么拍摄大场景风光，包括大场景街拍、人文题材都适合使用横构图。\n竖构图的使用，则更多的是要表达画面的纵深，以及高低的感受。\n点 点在画面中心会受力均衡，所以显得呆板。点在画面上方会显得上浮。点在画面下方会显得下沉。\n在拍摄会飞的元素时，我们可以考虑将其放在画面的上半部分。\n对于拍摄人，在一般情况下尽量不要让大家“飘”在天上。\n线条 横向的线条会让画面显得开阔。\n纵向的线条会让画面显得高耸。\n曲线会让画面显得柔和以及绵延。\n形状 画面中我们常见的形状无非是三角形、方形和圆形等。\n正三角形会让画面显得稳定，倒三角形会让画面显得不稳，或者有冲击力。\n楔形。在我们表达速度感的时候，如果主体恰好以楔形的形态出现，则能够大大增强这种速度感。\n方形体现在画面中，常见于拍摄建筑物。可以说绝大多数的建筑物不管是什么形状的，都是底边在地面上的，多数建筑物就是以方形的样子存在的。\n圆形在画面中出现的时候，画面会显得聚拢。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/photography/%E6%9E%84%E5%9B%BE/","summary":"构图法 居中法构图 主体在画面中占比很大 合影 拍对称的场景 三分法构图 横向主线条出现的时候往往就是地平线、水平线一类的。如果地面或者海面上的景物比较","title":"构图"},{"content":"MF 手动对焦, 使用时机\n相机只能手动对焦。比如徕卡M等，不会使用自动对焦的转接环。 非要对焦在无反差的地方（比如说拍白墙）或者很暗的环境。 对于高速无规则运动的物体，手动对焦可能成功率更高一些。 拍摄微距题材时，因为自动对焦往往会对不到您想要的位置，所以您可以手动对焦。 其他自动对焦无法使用的时候。 AF 自动对焦, AF-S 单次自动对焦, AF-C 连续自动对焦\nAF-S（佳能叫ONE SHOT）就是对好焦后，半按着快门按钮就算是把对焦点锁定了，只要不松开快门按钮，不按下快门按钮，相机是不会继续对焦的，除非松开快 门按钮再对焦，或者按下快门按钮拍完一张照片后才会再对焦。拍摄不动或者不怎么动的物体的时候，这个模式很好用。所以其适合用于拍摄风景，以及动作变化不 大的人文或人像作品。 AF-C（佳能叫SERVO）就是只要一直半按着快门按钮，相机就会一直不停地自动对焦。拍摄运动的物体的时候，这个模式比较好用。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/photography/%E5%AF%B9%E7%84%A6/","summary":"MF 手动对焦, 使用时机 相机只能手动对焦。比如徕卡M等，不会使用自动对焦的转接环。 非要对焦在无反差的地方（比如说拍白墙）或者很暗的环境。 对于高速","title":"对焦"},{"content":" 要点 景深和光圈、焦距、拍摄距离有关。 前景深比后景深要浅（短），前面的容易“虚”，后面的不容易虚。 随着拍摄距离、焦距、光圈等参数的变化，后景深变化特别快，前景深变化慢。 景深范围如果小的话，“实”的区域就小，这被我们称为浅景深。景深范围大的话，实的区域就大，这被我们称为深景深。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/photography/%E6%99%AF%E6%B7%B1/","summary":"要点 景深和光圈、焦距、拍摄距离有关。 前景深比后景深要浅（短），前面的容易“虚”，后面的不容易虚。 随着拍摄距离、焦距、光圈等参数的变化，后景深","title":"景深"},{"content":"一般来说，感光度标准值是ISO 100。部分厂商生产的相机的感光度标准值是ISO 200。在“胶片时代”，胶片的感光度越高，银盐颗粒越大，照片的胶料感越强，所 以看起来越粗糙。在“数码时代”,CCD和CMOS的感光度越高，CCD和CMOS越容易被电信号干扰，照片的噪点越多，所以看起来也越粗糙。细腻的照片看起来更好，所以 在拍照时能选择较低的感光度（标准值）的时候，一般都建议选择低感光度。\n感光度提高造成的画质下降主要表现为4个现象。\n先出现的是“锐度下降”和“细节损失”，这时的画质还不算糟糕。 随后出现的就是“噪点增加”，大家对于高感光度画质差的主要印象就是噪点的大量增加，其实到这个时候，画质依然在可接受的范围。 最后出现的就是“色彩偏移”，我们会发现，在画面暗部区域有大量不明色块，这时候画面的锐度已经下降得非常严重，同时噪点的数量也到了难以接受的程度 可以说非特殊情况，我们最好不要使用这么高的感光度。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/photography/%E6%84%9F%E5%85%89%E5%BA%A6/","summary":"一般来说，感光度标准值是ISO 100。部分厂商生产的相机的感光度标准值是ISO 200。在“胶片时代”，胶片的感光度越高，银盐颗粒越大，照片的","title":"感光度"},{"content":"快门速度就是指曝光时间。快门速度越高，曝光时间越短，相对来说曝光量越小。快门速度越低，曝光时间越长，相对来说曝光量越大。\n一般来说：\n比1/4秒速度低的，就是很低的快门速度； 比1/60秒速度低的，就是慢门； 比1/250秒速度高的，就是高速快门； 比1/2000秒速度高的，就是很高的高速快门。 B门就是按住快门按钮，您按多久快门就打开多久。T门就是按一下快门按钮，快门打开，再按一下快门按钮，快门就闭合。\n相机快门速度一般最低就是30秒，而B门和T门则是想曝光多久都可以，可以超过30秒的限制。\n安全快门\n老手 最低的快门速度 = 焦距倒数 新手 最低的快门速度 = 焦距的2倍的倒数 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/photography/%E5%BF%AB%E9%97%A8/","summary":"快门速度就是指曝光时间。快门速度越高，曝光时间越短，相对来说曝光量越小。快门速度越低，曝光时间越长，相对来说曝光量越大。 一般来说： 比1/4秒","title":"快门"},{"content":"光圈决定了通光速率 光圈越大照片越明亮\n拍摄星空最小需要f/2.8 光圈影响虚化效果 光圈越大越容易虚化\n85mm焦距和f/1.4光圈\n85mm焦距和f/16光圈\n小光圈能拍出星芒效果 f/11左右 如果镜头的光圈叶片是单数的，星芒的瓣数就是光圈叶片的2倍。 如果镜头的光圈叶片是双数的，则星芒的瓣数和光圈叶片数保持一致。 手机镜头的光圈通常并不是圆孔的，所以很难拍摄出星芒效果。 大光圈可以让前景消失 当使用大光圈时，如果有离您相机很近的前景，比如铁丝网、栅栏等躲不开的东西，则这些东西可能会消失。因为大光圈强大的虚化能力，能将很近的东西虚化成看不 到。\n小光圈可以检验镜头清洁度 大光圈可以拍出不同形状的光斑 光斑虚化的形状往往就是光圈孔的形状。如果我们将光圈开到最大，则可以在镜头前面加一张卡纸，在卡纸中间刻出我们想要的形状的洞——要保证比最大光圈时的光圈 孔小。卡纸中的洞就成了真正的光圈，虚化出的光斑就是卡纸中间洞的形状了。\n要点 光圈是表示镜头中孔径大小的一个比值； 光圈越大光圈值越小，光圈越小光圈值越大； 光圈越大照片越容易拍明亮，光圈越小照片越容易拍暗； 光圈越大虚化效果越强，光圈越小虚化效果越弱。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/photography/%E5%85%89%E5%9C%88%E7%9A%84%E4%BD%9C%E7%94%A8/","summary":"光圈决定了通光速率 光圈越大照片越明亮 拍摄星空最小需要f/2.8 光圈影响虚化效果 光圈越大越容易虚化 85mm焦距和f/1.4光圈 85mm焦距和f","title":"光圈的作用"},{"content":"取景范围 选择拍什么而不拍什么\n坏景\n好一些景\n好景\n拍摄主体是教堂 取景进画面的元素尽量对主题有帮助\n取景角度 经典的斜上45°俯拍\n取景角度也可以决定画面中有哪些元素\n挡住了后面的人 取景时机 很多照片是等出来的\n诱导\n连拍/视频选帧\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/photography/%E5%8F%96%E6%99%AF/","summary":"取景范围 选择拍什么而不拍什么 坏景 好一些景 好景 拍摄主体是教堂 取景进画面的元素尽量对主题有帮助 取景角度 经典的斜上45°俯拍 取景角度也可以决定画面","title":"取景"},{"content":"透视就是近大远小\n使用广角镜头拍摄往往离得近，所以透视效果明显； 使用长焦镜头拍摄往往离得远，所以透视效果不明显。 24mm,f/1.4\n拍摄距离非常短，所以有强烈的透视感。 35mm,f/1.4\n拍摄距离很短，也有很强的透视感。 50mm,f/1.4\n拍摄距离适中，透视感没有那么强，适合拍人像。 85mm,f/1.4\n拍摄距离适中，虚化效果又好，适合拍人像。 24mm的焦距把人物的脸都拍变形了，而50mm和85mm的焦距就很好，背景虚化效果也特别明显。对圆脸的人物来说使用50mm的焦距拍摄透视效果比较好。如果是 “锥子脸”的人物，那么使用85mm的焦距也许是最好的。\n一般来说24mm或者35mm的焦距更加适合拍摄人物全身照。半身和特写拍摄这种常用的人像拍摄方式，更应该用50mm或者85mm这样的焦距拍摄。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/photography/%E7%84%A6%E8%B7%9D%E4%B8%8E%E9%80%8F%E8%A7%86/","summary":"透视就是近大远小 使用广角镜头拍摄往往离得近，所以透视效果明显； 使用长焦镜头拍摄往往离得远，所以透视效果不明显。 24mm,f/1.4 拍摄距离非常短，所以有强烈的","title":"焦距与透视"},{"content":"35mm胶片实际尺寸36mm*24mm, 3:2, 称为135全画幅或35mm全画幅\n200mm焦距的镜头安装在135全画幅机身拍摄的效果\n200mm焦距的镜头和APS-C机身拍摄的效果\n相当于把焦距变长\n实际焦距为200mm的镜头，装在APS-C机身上，等效焦距变成了300mm。 对APS-C画幅来说，除了佳能相机是×1.6，其他品牌的相机都是×1.5，松下和奥之心（原奥林巴斯）的M/43系数是×2，因为传感器更小，所以等效焦距会变得更 长。 实际焦距×焦距转换系数=35mm焦距等效焦距 要点 全画幅相机只能用全画幅镜头 全画幅镜头既可以用在全画幅相机上，也可以用在半画幅相机（APS-C画幅相机的俗称）上 换镜头上面标注的焦距都是实际焦距。全画幅镜头和半画幅专用镜头都是如此 只要是半画幅机身，不管用什么镜头，就一定要通过焦距转换系数来求得等效焦距 全画幅系数是1，就是不需要计算，等效焦距就是实际焦距。尼康、索尼、宾得、富士半画幅相机的焦距转换系数是1.5。佳能半画幅相机的焦距转换系数是1.6。 奥之心和松下的M/43系数是乘2 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/photography/%E7%AD%89%E6%95%88%E7%84%A6%E8%B7%9D/","summary":"长焦易得，广角难求","title":"等效焦距"},{"content":"超广角 24mm以下 大场景，建筑啊、风景 也适合在狭小空间内部拍摄，能把小空间拍摄得“很大” 16mm\n标准广角 24~28mm 风景 24mm\n一般广角 35mm 大师焦距, 人文眼 拍摄人文题材的时候需要表达交代主体和背景环境的关系 35mm\n标准镜头 50mm 近似人眼的透视效果，适合拍摄人文照片 55mm\n人像镜头 85mm 有很好的背景虚化效果 保持和模特之间有适当的“交流”距离 85mm\n超广角变焦镜头 (11mm、12mm、14mm、16mm、18mm) ~ (24mm, 35mm) 标准变焦镜头 (24mm, 28mm) ~ (70mm, 85mm, 105mm, 120mm) 长焦镜头 200mm 300mmm 望远镜头, 摄远镜头 鸟类，荷花，运动物体 200mm\n超长焦镜头 300mm以上 野生动物、运动题材, 日出、日落，满月、弦月 600mm\n中长焦变焦镜头 (70mm, 100mm) ~ (200mm, 300mm, 400mm) 远的景物, 人像, 街拍人文 超长焦变焦镜头 (150mm, 200mm) ~ (500mm, 600mm) 远的景物, 野生动物 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/photography/%E4%B8%8D%E5%90%8C%E7%84%A6%E8%B7%9D%E9%80%82%E5%90%88%E7%9A%84%E9%A2%98%E6%9D%90/","summary":"拍摄什么题材，就带上什么镜头。","title":"不同焦距适合的题材"},{"content":" ","permalink":"https://jdxj.github.io/posts/articles/jdxj/photography/%E4%B8%8D%E5%90%8C%E7%84%A6%E8%B7%9D%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A7%86%E8%A7%92/","summary":"","title":"不同焦距对应的不同视角"},{"content":"proxy_pass指令 proxy_method指令 proxy_http_version指令 proxy_set_header指令 proxy_set_body指令 proxy_pass_request_headers指令 proxy_pass_request_body指令 proxy_request_buffering ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/proxy%E6%A8%A1%E5%9D%97/","summary":"content阶段","title":"proxy模块"},{"content":" round-robin ip_hash hash/一致性hash least_conn ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/","summary":"round-robin ip_hash hash/一致性hash least_conn","title":"Nginx负载均衡算法"},{"content":"upstream相关指令 upstream keepalive keepalive_requests keepalive_timeout server指令 proxy_http_version指令 proxy_set_header指令 resolver指令 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4/","summary":"upstream相关指令 upstream keepalive keepalive_requests keepalive_timeout server指令 proxy_http_version指令 proxy_set_header指令 resolver","title":"Nginx反向代理相关指令"},{"content":"默认不启用, 启用\u0026ndash;with-http_geoip_module\ngeoip_city指令 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/geoip%E6%A8%A1%E5%9D%97/","summary":"默认不启用, 启用\u0026ndash;with-http_geoip_module geoip_city指令","title":"geoip模块"},{"content":"geo指令 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/geo%E6%A8%A1%E5%9D%97/","summary":"geo指令","title":"geo模块"},{"content":"实现AB测试\nmurmurHash2算法\nhash(key)/max * 100%\nsplit_clients ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/split_clients%E6%A8%A1%E5%9D%97/","summary":"实现AB测试 murmurHash2算法 hash(key)/max * 100% split_clients","title":"split_clients模块"},{"content":"类似于编程语言中的switch\nmap指令 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/map%E6%A8%A1%E5%9D%97/","summary":"类似于编程语言中的switch map指令","title":"map模块"},{"content":"防盗链\n默认不启用, 启用-with-http_secure_link_module\n原理, 客户端只能拿到哈希过的url, url需要包含的信息\n资源位置 用户信息 时间戳 密钥 secure_link指令 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/secure_link%E6%A8%A1%E5%9D%97/","summary":"防盗链 默认不启用, 启用-with-http_secure_link_module 原理, 客户端只能拿到哈希过的url, url需要包含的信息 资源","title":"secure_link模块"},{"content":"valid_referers指令 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/referer%E6%A8%A1%E5%9D%97/","summary":"valid_referers指令","title":"referer模块"},{"content":"用于加工响应内容\ncopy_filter 复制包体内容\npostpone_filter 处理子请求\nheader_filter 构造响应头部\nwrite_filter 发送响应\nsub_filter 默认不启用, 启用\u0026ndash;with-http_sub_module\n替换响应中的字符串\naddition 在body前或之后增加内容\n默认不启用, 启用\u0026ndash;with-http_addition_module\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/http_filter%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9D%97/","summary":"content阶段之前或之后","title":"http_*_filter系列模块"},{"content":"log_format指令 combined格式 access_log指令 日志路径可以包含变量, 不打开cache时, 每记录一条日志都要打开, 关闭日志文件, 有性能问题\nopen_log_file_cache ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/log%E6%A8%A1%E5%9D%97/","summary":"log阶段","title":"log模块"},{"content":"当url以/结尾时, 尝试以html/xml/json/jsonp等格式返回root/alias中指向目录的目录结构\nautoindex指令 autoindex_exact_size指令 autoindex_format指令 autoindex_localtime指令 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/autoindex%E6%A8%A1%E5%9D%97/","summary":"content阶段","title":"autoindex模块"},{"content":"index指令 访问/时, 默认找index.html\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/index%E6%A8%A1%E5%9D%97/","summary":"content阶段","title":"index模块"},{"content":"mirror指令 mirror_request_body指令 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/mirror%E6%A8%A1%E5%9D%97/","summary":"precontent阶段","title":"mirror模块"},{"content":"try_files指令 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/try_files%E6%A8%A1%E5%9D%97/","summary":"precontent阶段","title":"try_files模块"},{"content":"默认不启用, 启用\u0026ndash;with-http_auth_request_module\nauth_request指令 auth_request_set指令 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/auth_request%E6%A8%A1%E5%9D%97/","summary":"access阶段","title":"auth_request模块"},{"content":"rfc2617\nauth_basic指令 auth_basic_user_file指令 文件格式\nname1:pwd:comment ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/auth_basic%E6%A8%A1%E5%9D%97/","summary":"access阶段","title":"auth_basic模块"},{"content":"allow指令 deny指令 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/access%E6%A8%A1%E5%9D%97/","summary":"access阶段","title":"access模块"},{"content":"leaky bucket算法\nlimit_req_zone指令 limit_req指令 limit_req_log_level指令 limit_req_status指令 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/limit_req%E6%A8%A1%E5%9D%97/","summary":"preaccess阶段","title":"limit_req模块"},{"content":"limit_conn_zone指令 limit_conn指令 limit_conn_log_level指令 limit_conn_status指令 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/limit_conn%E6%A8%A1%E5%9D%97/","summary":"preaccess阶段","title":"limit_conn模块"},{"content":"find_config阶段 location指令 匹配规则 前缀字符串\n字符串 前缀匹配 = 精确匹配 ^~ 匹配上后不再进行其他location的正则表达式匹配 正则表达式\n~ ~* 内部跳转\n@ 匹配顺序 merge_slashes指令 access阶段 satisfy指令 access阶段的模块\naccess auth_basic auth_request 执行逻辑\nall, 相当于\u0026amp;\u0026amp; any, 相当于|| content阶段 root指令 alias指令 request_filename变量 目标文件的绝对路径\ndocument_root变量 由uri和root/alias规则生成的目标文件所在目录的绝对路径\nrealpath_root变量 将document_root中的软链接等换成真实路径\ntypes指令 default_type指令 types_hash_bucket_size指令 types_hash_max_size指令 log_not_found指令 server_name_in_redirect on 返回的重定向url的域名为server_name指令中的主域名 port_in_redirect on 重定向中的url带port absolute_redirect off 返回重定向url时, 不带域名 on 带域名, 如果请求中有Host头部, 则重定向url的域名为Host所指定的域名 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/http_core%E6%A8%A1%E5%9D%97/","summary":"find_config阶段, access阶段, content阶段","title":"http_core模块"},{"content":"return指令 nginx自定义状态码\n444: 关闭连接, 不向用户返回内容 http\n301永久重定向 302临时重定向, 禁止被缓存 303临时重定向, 允许改变方法, 禁止被缓存 307临时重定向, 不允许改变方法, 禁止被缓存 308永久重定向, 不允许改变方法 error_page指令 rewrite指令 if指令 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/rewrite%E6%A8%A1%E5%9D%97/","summary":"rewrite阶段","title":"rewrite模块"},{"content":"拿到真实用户ip地址\nX-Forwarded-For用于传递ip X-Real-IP用于传递用户ip realip提供的变量\nbinary_remote_addr remote_addr 默认不启用realip模块, 启用\u0026ndash;with-http_realip_module\n拿到直接tcp的远程地址\nrealip_remote_addr realip_remote_port 模块指令\nset_real_ip_from 从被信任的主机获取real_ip real_ip_header 从哪里获取real_ip, 顺序X-Real-IP, X-Forwarded-For, proxy_protocol real_ip_recursive 取与客户端不同的前一个地址 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/realip%E6%A8%A1%E5%9D%97/","summary":"postread阶段","title":"realip模块"},{"content":"阶段 编号 阶段 说明 官方模块 1 post_read 读完header之后 realip 2 server_rewrite server级别的重写 rewrite 3 find_config 使用重写后的url匹配location 4 rewrite location级别的重写 rewrite 5 post_rewrite 判断是否需要阶段跳转 6 preaccess 进行访问控制之前进行一些操作 limit_req, limt_conn 7 access 访问控制 access, auth_basic , auth_request 8 post_access 访问控制后续处理 9 precontent 生成响应前检查指定文件是否存在 try_files, mirrors 10 content 生成响应阶段 concat, random_index, index, auto_index, static 11 log 写入日志 access_log 模块执行顺序 模块执行顺序不是依次执行, 可能会跳过某些模块, 或者跳转到前面阶段的某些模块再次执行\n模块间的相对顺序参考objs/ngx_modules.c 参考 Nginx 的 11 个执行阶段详解 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/nginx%E5%A4%84%E7%90%86http%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/","summary":"阶段 编号 阶段 说明 官方模块 1 post_read 读完header之后 realip 2 server_rewrite server级别的重写 rewrite 3 find_config 使用重写后的url匹配location 4 rewrite location","title":"Nginx处理http请求的11个阶段"},{"content":"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 密钥交 身份 对称加密算法 摘要算法 换算法 验证 加密强度 分组模式 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/tls%E5%AE%89%E5%85%A8%E5%A5%97%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/","summary":"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 密钥交 身份 对称加密算法 摘要算法 换算法 验证 加密强度 分组模式","title":"TLS安全套件格式说明"},{"content":" 1 $ nginx -s reopen # USR1 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/nginx%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/","summary":"1 $ nginx -s reopen # USR1","title":"Nginx日志切割"},{"content":" 备份原有nginx可执行文件, 并复制新可执行文件 通知使用新文件 1 $ kill -USR2 旧pid 通知优雅关闭旧worker 1 $ kill -WINCH 旧pid ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/%E7%83%AD%E9%83%A8%E7%BD%B2nginx/","summary":"备份原有nginx可执行文件, 并复制新可执行文件 通知使用新文件 1 $ kill -USR2 旧pid 通知优雅关闭旧worker 1 $ kill -WINCH 旧pid","title":"热部署nginx"},{"content":" 1 2 3 $ ./configure --prefix=... $ make $ make install ","permalink":"https://jdxj.github.io/posts/articles/jdxj/nginx/%E7%BC%96%E8%AF%91nginx/","summary":"1 2 3 $ ./configure --prefix=... $ make $ make install","title":"编译nginx"},{"content":"String的特点 string类型的数据是不可变的 一旦声明了一个string类型的标识符，无论是常量还是变量，该标识符所指代的数据在整个程序的生命周期内便无法更改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; // chapter3/sources/string_immutable1.go func main() { // 原始字符串 var s string = \u0026#34;hello\u0026#34; fmt.Println(\u0026#34;original string:\u0026#34;, s) // 切片化后试图改变原字符串 sl := []byte(s) sl[0] = \u0026#39;t\u0026#39; fmt.Println(\u0026#34;slice:\u0026#34;, string(sl)) fmt.Println(\u0026#34;after reslice, the original string is:\u0026#34;, string(s)) } /* 输出 original string: hello slice: tello after reslice, the original string is: hello */ 对string进行切片化后，Go编译器会为切片变量重新分配底层存储而不是共用string的底层存储，因此对切片的修改并未对原string的数据产生任何影响。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) // chapter3/sources/string_immutable2.go func main() { // 原始string var s string = \u0026#34;hello\u0026#34; fmt.Println(\u0026#34;original string:\u0026#34;, s) // 试图通过unsafe指针改变原始string modifyString(\u0026amp;s) fmt.Println(s) } func modifyString(s *string) { // 取出第一个8字节的值 // p是stringStruct的地址 p := (*uintptr)(unsafe.Pointer(s)) // 获取底层数组的地址 var array *[5]byte = (*[5]byte)(unsafe.Pointer(*p)) var len *int = (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(s)) + unsafe.Sizeof((*uintptr)(nil)))) for i := 0; i \u0026lt; (*len); i++ { fmt.Printf(\u0026#34;%p =\u0026gt; %c\\n\u0026#34;, \u0026amp;((*array)[i]), (*array)[i]) p1 := \u0026amp;((*array)[i]) v := (*p1) (*p1) = v + 1 // try to change the character } } /* 输出 original string: hello 0x49b7d3 =\u0026gt; h unexpected fault address 0x49b7d3 fatal error: fault [signal SIGSEGV: segmentation violation code=0x2 addr=0x49b7d3 pc=0x483417] */ 对string的底层的数据存储区仅能进行只读操作，一旦试图修改那块区域的数据程序将崩溃.\n零值可用 1 2 3 var s string fmt.Println(s) // s = \u0026#34;\u0026#34; fmt.Println(len(s)) // 0 获取长度的时间复杂度是O(1)级别 Go string类型数据是不可变的，因此一旦有了初值，那块数据就不会改变，其长度也不会改变。Go将这个长度作为一个字段存储在运行时的string类型的内部表示 结构中. len(s)实际上就是读取存储在运行时中的那个长度值\n支持通过+/+=操作符进行字符串连接 1 2 3 4 5 s := \u0026#34;Rob Pike, \u0026#34; s = s + \u0026#34;Robert Griesemer, \u0026#34; s += \u0026#34; Ken Thompson\u0026#34; fmt.Println(s) // Rob Pike, Robert Griesemer, Ken Thompson 支持各种比较关系操作符：==、!= 、\u0026gt;=、\u0026lt;=、\u0026gt;和\u0026lt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // chapter3/sources/string_compare.go func main() { // == s1 := \u0026#34;世界和平\u0026#34; s2 := \u0026#34;世界\u0026#34; + \u0026#34;和平\u0026#34; fmt.Println(s1 == s2) // true // != s1 = \u0026#34;Go\u0026#34; s2 = \u0026#34;C\u0026#34; fmt.Println(s1 != s2) // true // \u0026lt; 和 \u0026lt;= s1 = \u0026#34;12345\u0026#34; s2 = \u0026#34;23456\u0026#34; fmt.Println(s1 \u0026lt; s2) // true fmt.Println(s1 \u0026lt;= s2) // true // \u0026gt; 和 \u0026gt;= s1 = \u0026#34;12345\u0026#34; s2 = \u0026#34;123\u0026#34; fmt.Println(s1 \u0026gt; s2) // true fmt.Println(s1 \u0026gt;= s2) // true } 由于Go string是不可变的，因此如果两个字符串的长度不相同，那么无须比较具体字符串数据即可断定两个字符串是不同的。\n对非ASCII字符提供原生支持 Go语言源文件默认采用的Unicode字符集。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import \u0026#34;fmt\u0026#34; // chapter3/sources/string_nonascii.go func main() { // 中文字符 Unicode码点 UTF8编码 // 中 U+4E2D E4B8AD // 国 U+56FD E59BBD // 欢 U+6B22 E6ACA2 // 迎 U+8FCE E8BF8E // 您 U+60A8 E682A8 s := \u0026#34;中国欢迎您\u0026#34; rs := []rune(s) sl := []byte(s) for i, v := range rs { var utf8Bytes []byte for j := i * 3; j \u0026lt; (i+1)*3; j++ { utf8Bytes = append(utf8Bytes, sl[j]) } fmt.Printf(\u0026#34;%s =\u0026gt; %X =\u0026gt; %X\\n\u0026#34;, string(v), v, utf8Bytes) } } /* 输出 中 =\u0026gt; 4E2D =\u0026gt; E4B8AD 国 =\u0026gt; 56FD =\u0026gt; E59BBD 欢 =\u0026gt; 6B22 =\u0026gt; E6ACA2 迎 =\u0026gt; 8FCE =\u0026gt; E8BF8E 您 =\u0026gt; 60A8 =\u0026gt; E682A8 */ 原生支持多行字符串 Go语言直接提供了通过反引号构造“所见即所得”的多行字符串的方法\n1 2 3 4 5 6 7 8 9 10 // chapter3/sources/string_multilines.go const s = `好雨知时节，当春乃发生。 随风潜入夜，润物细无声。 野径云俱黑，江船火独明。 晓看红湿处，花重锦官城。` func main() { fmt.Println(s) } string的内部表示 1 2 3 4 5 // $GOROOT/src/runtime/string.go type stringStruct struct { str unsafe.Pointer len int } runtime包中实例化一个字符串对应的函数\n1 2 3 4 5 6 7 8 9 10 11 // $GOROOT/src/runtime/string.go func rawstring(size int) (s string, b []byte) { p := mallocgc(uintptr(size), nil, false) stringStructOf(\u0026amp;s).str = p stringStructOf(\u0026amp;s).len = size *(*slice)(unsafe.Pointer(\u0026amp;b)) = slice{p, size, size} return } rawstring调用后，新申请的内存区域还未被写入数据，b就是供后续运行时层向其中写入数据（\u0026ldquo;hello\u0026rdquo;）用的。写完数据后，该slice就可以被回收掉了\n字符串的高效构造 Go还提供了其他一些构造字符串的方法\nfmt.Sprintf strings.Join strings.Builder bytes.Buffer 结论\n在能预估出最终字符串长度的情况下，使用预初始化的strings.Builder连接构建字符串效率最高； strings.Join连接构建字符串的平均性能最稳定，如果输入的多个字符串是以[]string承载的，那么strings.Join也是不错的选择； 使用操作符连接的方式最直观、最自然，在编译器知晓欲连接的字符串个数的情况下，使用此种方式可以得到编译器的优化处理； fmt.Sprintf虽然效率不高，但也不是一无是处，如果是由多种不同类型变量来构建特定格式的字符串，那么这种方式还是最适合的。 字符串相关的高效转换 注意新版本的Go可能提供相关转换\nstring和[]rune、[]byte可以双向转换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // chapter3/sources/string_slice_to_string.go func main() { rs := []rune{ 0x4E2D, 0x56FD, 0x6B22, 0x8FCE, 0x60A8, } s := string(rs) fmt.Println(s) sl := []byte{ 0xE4, 0xB8, 0xAD, 0xE5, 0x9B, 0xBD, 0xE6, 0xAC, 0xA2, 0xE8, 0xBF, 0x8E, 0xE6, 0x82, 0xA8, } s = string(sl) fmt.Println(s) } /*输出 中国欢迎您 中国欢迎您 */ 无论是string转slice还是slice转string，转换都是要付出代价的，这些代价的根源在于string是不可变的，运行时要为转换后的类型分配新内存。\n在Go运行时层面，字符串与rune slice、byte slice相互转换对应的函数如下\n// $GOROOT/src/runtime/string.go slicebytetostring: []byte -\u0026gt; string slicerunetostring: []rune -\u0026gt; string stringtoslicebyte: string -\u0026gt; []byte stringtoslicerune: string -\u0026gt; []rune slice类型是不可比较的，而string类型是可比较的，因此在日常Go编码中，我们会经常遇到将slice临时转换为string的情况。\n在运行时中有一个名为slicebytetostringtmp的函数就是协助实现这一优化的\n1 2 3 4 5 6 7 8 9 10 11 12 13 // $GOROOT/src/runtime/string.go func slicebytetostringtmp(b []byte) string { if raceenabled \u0026amp;\u0026amp; len(b) \u0026gt; 0 { racereadrangepc(unsafe.Pointer(\u0026amp;b[0]), uintptr(len(b)), getcallerpc(), funcPC(slicebytetostringtmp)) } if msanenabled \u0026amp;\u0026amp; len(b) \u0026gt; 0 { msanread(unsafe.Pointer(\u0026amp;b[0]), uintptr(len(b))) } return *(*string)(unsafe.Pointer(\u0026amp;b)) } 使用这个函数的前提是：在原slice被修改后，这个string不能再被使用了。因此这样的优化是针对以下几个特定场景的\nstring(b)用在map类型的key中 1 2 3 b := []byte{\u0026#39;k\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;y\u0026#39;} m := make(map[string]string) m[string(b)] = \u0026#34;value\u0026#34; string(b)用在字符串连接语句中 1 2 b := []byte{\u0026#39;t\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;y\u0026#39;} s := \u0026#34;hello \u0026#34; + string(b) + \u0026#34;!\u0026#34; string(b)用在字符串比较中 1 2 3 4 5 6 s := \u0026#34;tom\u0026#34; b := []byte{\u0026#39;t\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;y\u0026#39;} if s \u0026lt; string(b) { ... } Go编译器对用在for-range循环中的string到[]byte的转换也有优化处理，它不会为[]byte进行额外的内存分配\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // chapter3/sources/string_for_range_covert_optimize.go func convert() { s := \u0026#34;中国欢迎您，北京欢迎您\u0026#34; sl := []byte(s) for _, v := range sl { _ = v } } func convertWithOptimize() { s := \u0026#34;中国欢迎您，北京欢迎您\u0026#34; for _, v := range []byte(s) { _ = v } } func main() { fmt.Println(testing.AllocsPerRun(1, convert)) fmt.Println(testing.AllocsPerRun(1, convertWithOptimize)) } /*输出 1 0 */ ","permalink":"https://jdxj.github.io/posts/articles/jdxj/go/string/","summary":"String的特点 string类型的数据是不可变的 一旦声明了一个string类型的标识符，无论是常量还是变量，该标识符所指代的数据在整个程序","title":"Go String"},{"content":"原文\n也可以使用寄存器\u0026quot;+\n","permalink":"https://jdxj.github.io/posts/articles/wzy_1988/vim/","summary":"原文 也可以使用寄存器\u0026quot;+","title":"Vim中复制粘贴缩进错乱问题的解决方案"},{"content":"Vim不使用单一的剪贴板进行剪切、复制与粘贴操作，而是为这些操作提供了多组寄存器。当使用删除、复制与粘贴命令时，我们可以明确指定它们中的某一个进行操 作。\n引用一个寄存器 未指定寄存器则使用无名寄存器\n\u0026#34;{register} 在命令行中使用\n:delete c :put c 无名寄存器 \u0026quot;\u0026quot; x、s、d{motion}、c{motion} 与y{motion} 命令（以及它们对应的大写命令）都会覆盖无名寄存器中的内容。\n复制专用寄存器 \u0026quot;0 当我们使用 y{motion} 命令时，要复制的文本不仅会被拷贝到无名寄存器中，而且也被拷贝到了复制专用寄存器中\n有名寄存器 \u0026quot;a-\u0026quot;z 用小写字母引用有名寄存器，会覆盖该寄存器的原有内容，而换用大写字母的话，则会将新内容添加到该寄存器的原有内容之后。\n黑洞寄存器\u0026quot;_ 放到这里的文本真地是有去无回了。\n系统剪切板 \u0026quot;+ Vim的加号寄存器与系统剪贴板等效 也可在插入模式下使用\u0026lt;C-r\u0026gt;+粘贴 选择专用寄存器 \u0026quot;* Vim 的星号寄存器对应主剪贴板 X11视窗系统支持另一种被叫作主剪贴板（primary）的剪贴板，它保存着上次被高亮选中的文本，可以用鼠标中键（如果有的话）把它们粘贴出来。 Windows与Mac OS X操作系统并没有主剪贴板的概念，因此\u0026quot;+寄存器与\u0026quot;*寄存器可以混用，它们都代表系统剪贴板。\n表达式寄存器 \u0026quot;= 做运算 其他寄存器 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%AF%84%E5%AD%98%E5%99%A8/","summary":"Vim不使用单一的剪贴板进行剪切、复制与粘贴操作，而是为这些操作提供了多组寄存器。当使用删除、复制与粘贴命令时，我们可以明确指定它们中的某一","title":"寄存器"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%9C%A8%E5%8C%B9%E9%85%8D%E6%8B%AC%E5%8F%B7%E9%97%B4%E8%B7%B3%E8%BD%AC/","summary":"","title":"% 在匹配括号间跳转"},{"content":" ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E8%87%AA%E5%8A%A8%E4%BD%8D%E7%BD%AE%E6%A0%87%E8%AE%B0/","summary":"","title":"自动位置标记"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%9B%9E%E5%88%B0%E4%BD%8D%E7%BD%AE%E6%A0%87%E8%AE%B0/","summary":"","title":"`{mark} 回到位置标记"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E8%AE%BE%E7%BD%AE%E4%BD%8D%E7%BD%AE%E6%A0%87%E8%AE%B0/","summary":"","title":"m{a-zA-Z} 设置位置标记"},{"content":"文本对象就是基于结构定义的文本区域\n文本对象允许我们操作括号、被引用的文本、XML标签以及其他文本中的常见结构。 Vim 的文本对象由两个字符组成，第一个字符永远是 i 或是 a。我们一般说，以 i 开头的文本对象会选择分隔符内部的文本，而以 a 开头的文本对象则会选择 包括分隔符在内的整个文本。 部分 Vim 内置的文本对象\nVim 的文本对象分为两类：\n一类是操作分隔符的文本对象，如 i)、i\u0026quot; 和 it； 另一类用于操作文本块，如单词、句子和段落。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E6%96%87%E6%9C%AC%E5%AF%B9%E8%B1%A1/","summary":"文本对象就是基于结构定义的文本区域 文本对象允许我们操作括号、被引用的文本、XML标签以及其他文本中的常见结构。 Vim 的文本对象由两个字符组成，第","title":"文本对象"},{"content":"由非空白字符序列组成，字串间以空白字符分隔\nW, B, E, gE\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%9F%BA%E4%BA%8E%E5%AD%97%E4%B8%B2%E7%9A%84%E7%A7%BB%E5%8A%A8/","summary":"由非空白字符序列组成，字串间以空白字符分隔 W, B, E, gE","title":"基于字串的移动"},{"content":"一个单词由字母、数字、下划线，或其他非空白字符的序列组成，单词间以空白字符分隔\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%9F%BA%E4%BA%8E%E5%8D%95%E8%AF%8D%E7%9A%84%E7%A7%BB%E5%8A%A8/","summary":"一个单词由字母、数字、下划线，或其他非空白字符的序列组成，单词间以空白字符分隔","title":"基于单词的移动"},{"content":" ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%9C%A8%E5%AE%9E%E9%99%85%E8%A1%8C%E4%B8%8E%E5%B1%8F%E5%B9%95%E8%A1%8C%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","summary":"","title":"在实际行与屏幕行移动的命令"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/catonmat/vim/","summary":"原文","title":"Here is why vim uses hjkl keys as arrow keys"},{"content":"在所有行后添加分号\n:%normal A; ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F%E5%91%BD%E4%BB%A4/","summary":"在所有行后添加分号 :%normal A;","title":":[range]normal {cmd}重复执行普通模式命令"},{"content":"在运行过一次@:后，后面就可以用@@命令来重复它。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E9%87%8D%E5%A4%8D%E4%B8%8A%E6%AC%A1ex%E5%91%BD%E4%BB%A4/","summary":"在运行过一次@:后，后面就可以用@@命令来重复它。","title":"@: 重复上次ex命令"},{"content":"简写\n:m ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E7%A7%BB%E5%8A%A8%E8%A1%8C/","summary":"简写 :m","title":":[range]move{address} 移动行"},{"content":"简写\n:co :t 例子\n把第6行复制到当前行下方 :6copy. 注意\n该复制不使用寄存器 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%A4%8D%E5%88%B6%E8%A1%8C/","summary":"简写 :co :t 例子 把第6行复制到当前行下方 :6copy. 注意 该复制不使用寄存器","title":":[range]copy{address} 复制行到指定位置"},{"content":"出于历史原因，在命令行模式中执行的命令又被称做 Ex 命令\n在我们按/调出查找提示符或用\u0026lt;C-r\u0026gt;=访问表达式寄存器时，命令行模式也会被激活。\n查看ex命令\n:h ex-cmd-index 有些命令在插入模式和命令行模式中可以通用。例如，可以用\u0026lt;C-w\u0026gt;和\u0026lt;C-u\u0026gt;分别删除至上个单词的开头及行首，也可以用\u0026lt;C-v\u0026gt;或\u0026lt;C-k\u0026gt;来插入键盘上找 不到的字符，还可以用\u0026lt;C-r\u0026gt;{register}命令把任意寄存器的内容插入到命令行. 然而，有些命令行模式中的组合键在插入模式中不存在\nex命令 :print 回显当前行, 简写:p\n可以合起来使用命令\n:3p [range] 可以用行号、位置标记或是查找模式来指定范围的开始位置及结束位置。\n行号 把光标移动到该数字所指定的行上\n:1 :{start},{end}指定行范围 :2,5p :.,$p 位置标记 $ 文件末尾 % 当前文件所有行 :%p :%s/Practical/Pragmatic/ 用高亮选区指定范围 在可视模式下高亮选区后, 按下:后, 在命令行出现:'\u0026lt;,'\u0026gt;\n'\u0026lt;表示选区首行 '\u0026gt;表示选区末行 之后再输入要执行的命令.\n用模式指定范围 与:{start},{end}类似, 使用:/start/,/end/形式, 特殊字符需要转义\n:/\u0026lt;html\u0026gt;/,/\u0026lt;\\/html\u0026gt;/p 用偏移对地址进行修正 偏移的一般形式\n:{address}+n 如果 n 被省略，那么缺省偏移量为1。{address} 可以是一个行号、一个位置标记，或是一个查找模式。\n:.,.+3p :/\u0026lt;html\u0026gt;/+1,/\u0026lt;\\/html\u0026gt;/-1p 结论 定义范围的语法非常灵活，既可以混合搭配行号、位置标记以及查找模式，也可以对它们加以偏移。\n第0行在文件中并不真实存在，但它作为一个地址，在某些特定场景下会很有用处。特别是，在把指定范围内的行复制或移动到文件开头时，可以用它做 :copy{address} 及 :move{address} 命令的最后一个参数。\n在定义一个[range]时，它总是代表一系列连续行，不过 :global 命令也可以在一系列非连续行上执行Ex 命令\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F/","summary":"出于历史原因，在命令行模式中执行的命令又被称做 Ex 命令 在我们按/调出查找提示符或用\u0026lt;C-r\u0026gt;=访问表达式寄存器时，命令行模式也会被","title":": 进入命令行模式"},{"content":"如果上次的选区被删除了，它也许会工作得不太正常。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/gv/","summary":"如果上次的选区被删除了，它也许会工作得不太正常。","title":"gv 重选上次的选区"},{"content":" v 激活面向字符的可视模式 V 激活面向行的可视模式 \u0026lt;C-v\u0026gt; 激活面向列块的可视模式 可以在不同风格的可视模式间切换\n可以用o来切换活动端点\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E4%B8%89%E7%A7%8D%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F/","summary":"v 激活面向字符的可视模式 V 激活面向行的可视模式 \u0026lt;C-v\u0026gt; 激活面向列块的可视模式 可以在不同风格的可视模式间切换 可以用o来切换活动端点","title":"三种可视模式"},{"content":"在可视模式选中一些文本后, 按\u0026lt;C-g\u0026gt;进入选择模式, 随后可以直接对选中文本进行修改, 同时进入插入模式.\n可重复使用\u0026lt;C-g\u0026gt;在可视模式与选择模式之间切换 很少会用到选择模式。这一模式的存在，只是为了迎合那些想让Vim更像其他文本编辑器的用户。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E9%80%89%E6%8B%A9%E6%A8%A1%E5%BC%8F/","summary":"在可视模式选中一些文本后, 按\u0026lt;C-g\u0026gt;进入选择模式, 随后可以直接对选中文本进行修改, 同时进入插入模式. 可重复使用\u0026lt;C-g\u0026","title":"\u003cC-g\u003e 进入选择模式"},{"content":"gR会进入虚拟替换模式, 它会把制表符当成一组空格进行处理.\n在虚拟替换模式中，是按屏幕上实际显示的宽度来替换字符的，而不是按文件中所保存的字符进行替换。\n单次版本的替换模式及虚拟替换模式\nr{char} gr{char} ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/r/","summary":"gR会进入虚拟替换模式, 它会把制表符当成一组空格进行处理. 在虚拟替换模式中，是按屏幕上实际显示的宽度来替换字符的，而不是按文件中所保存的字符","title":"R 进入替换模式"},{"content":"\u0026lt;C-k\u0026gt;12 ½ 查看更多二合字符\n:h digraphs-default :digraphs :h digraph-table ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E6%8F%92%E5%85%A5%E4%BA%8C%E5%90%88%E5%AD%97%E7%AC%A6/","summary":"\u0026lt;C-k\u0026gt;12 ½ 查看更多二合字符 :h digraphs-default :digraphs :h digraph-table","title":"\u003cC-k\u003e{char1}{char2} 插入二合字符"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/ga/","summary":"","title":"ga 查看光标下字符编码"},{"content":" \u0026lt;C-v\u0026gt;+三位十进制数字, 不足三位回车即可输入 \u0026lt;C-v\u0026gt;u+四位十六进制unicode码点, 不足四位回车即可输入 \u0026lt;C-v\u0026gt;+非数字, 插入按键本身表示的字符 \u0026lt;C-v\u0026gt;065 A \u0026lt;C-v\u0026gt;u00bf ¿ ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E6%8F%92%E5%85%A5%E4%BB%BB%E6%84%8F%E5%AD%97%E7%AC%A6/","summary":"\u0026lt;C-v\u0026gt;+三位十进制数字, 不足三位回车即可输入 \u0026lt;C-v\u0026gt;u+四位十六进制unicode码点, 不足四位回车即可输入 \u0026","title":"\u003cC-v\u003e{code} 插入任意字符"},{"content":"\u0026lt;C-r\u0026gt;=6*35\u0026lt;CR\u0026gt; ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AF%84%E5%AD%98%E5%99%A8/","summary":"\u0026lt;C-r\u0026gt;=6*35\u0026lt;CR\u0026gt;","title":"\u003cC-r\u003e= 利用表达式寄存器进行运算"},{"content":"\u0026lt;C-r\u0026gt;\u0026lt;C-p\u0026gt;{register}按原义插入寄存器内的文本，并修正任何不必要的缩进\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E7%B2%98%E8%B4%B4%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC/","summary":"\u0026lt;C-r\u0026gt;\u0026lt;C-p\u0026gt;{register}按原义插入寄存器内的文本，并修正任何不必要的缩进","title":"\u003cC-r\u003e{register} 粘贴寄存器中的文本"},{"content":"在此模式中，我们可以执行一个普通模式命令，执行完后，马上就又返回到插入模式。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E6%8F%92%E5%85%A5-%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F/","summary":"在此模式中，我们可以执行一个普通模式命令，执行完后，马上就又返回到插入模式。","title":"\u003cC-o\u003e 插入-普通模式"},{"content":" \u0026lt;Esc\u0026gt; \u0026lt;C-[\u0026gt; ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%9B%9E%E5%88%B0%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F/","summary":"\u0026lt;Esc\u0026gt; \u0026lt;C-[\u0026gt;","title":"回到普通模式"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%88%A0%E8%87%B3%E8%A1%8C%E9%A6%96/","summary":"","title":"\u003cC-u\u003e 删至行首"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%88%A0%E9%99%A4%E5%89%8D%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D/","summary":"","title":"\u003cC-w\u003e 删除前一个单词"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%88%A0%E9%99%A4%E5%89%8D%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6/","summary":"","title":"\u003cC-h\u003e 删除前一个字符"},{"content":"操作符待决模式就是一个只接受动作命令的状态。这个状态在我们调用操作符时被激活，然后什么也不做，直到我们提供了一个动作命令，完成整个操作。当操作符待 决模式被激活时，我们可以像平常一样按\u0026lt;Esc\u0026gt;中止该操作，返回到普通模式。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%BE%85%E5%86%B3%E6%A8%A1%E5%BC%8F/","summary":"Operator-Pending mode","title":"操作符待决模式"},{"content":"Vim的操作符\n查看完整的操作符 :h operator Vim的语法只有一条额外规则，即当一个操作符命令被连续调用两次时，它会作用于当前行。\n所以 dd 删除当前行，而 \u0026gt;\u0026gt; 缩进当前行。 gU 命令是一种特殊情况，我们既可以用 gUgU ，也可以用简化版的 gUU 来使它作用于当前行。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E6%A8%A1%E5%BC%8F-%E6%93%8D%E4%BD%9C%E7%AC%A6+%E5%8A%A8%E4%BD%9C%E5%91%BD%E4%BB%A4-%E6%93%8D%E4%BD%9C/","summary":"Vim的操作符 查看完整的操作符 :h operator Vim的语法只有一条额外规则，即当一个操作符命令被连续调用两次时，它会作用于当前行。 所以 dd 删除当前行，而 \u0026gt;\u0026gt;","title":"模式: 操作符+动作命令=操作"},{"content":"set nrformats=\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E6%8A%8A%E6%89%80%E6%9C%89%E6%95%B0%E5%AD%97%E5%BD%93%E6%88%90%E5%8D%81%E8%BF%9B%E5%88%B6/","summary":"set nrformats=","title":"把所有数字当成十进制"},{"content":"abc124def\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%AF%B9%E6%95%B0%E5%AD%97%E6%89%A7%E8%A1%8C%E5%87%8F%E6%B3%95/","summary":"abc124def","title":"[count]\u003cC-x\u003e 对数字执行减法"},{"content":"如果光标不在数字上，那么\u0026lt;C-a\u0026gt;命令将在当前行正向查找一个数字，如果找到了，它就径直跳到那里。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%AF%B9%E6%95%B0%E5%AD%97%E6%89%A7%E8%A1%8C%E5%8A%A0%E6%B3%95/","summary":"如果光标不在数字上，那么\u0026lt;C-a\u0026gt;命令将在当前行正向查找一个数字，如果找到了，它就径直跳到那里。","title":"[count]\u003cC-a\u003e 对数字执行加法"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E6%98%9F/","summary":"","title":"* 查找光标处的单词"},{"content":" ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E9%87%8D%E5%A4%8D%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%9B%9E%E9%80%80/","summary":"","title":"重复操作及回退"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E9%80%97%E5%8F%B7/","summary":"","title":", 返回前一个f所查找的字符"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%88%86%E5%8F%B7/","summary":"","title":"; 查找下一个f指定的字符"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/f/","summary":"","title":"f{char} 在当前行查找字符"},{"content":" ","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E5%A4%8D%E5%90%88%E5%91%BD%E4%BB%A4/","summary":"","title":"复合命令"},{"content":"理想模式：用一键移动，另一键执行\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E6%A8%A1%E5%BC%8F-%E7%A7%BB%E5%8A%A8+%E6%93%8D%E4%BD%9C/","summary":"理想模式：用一键移动，另一键执行","title":"模式: 移动+操作"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E7%BC%A9%E8%BF%9B/","summary":"","title":"\u003eG 增加缩进"},{"content":"修改指\n改变文档内文本的任意操作，其中包括在普通模式、可视模式以及命令行模式中所触发的命令 在插入模式中输入（或删除）的文本: i{insert some text}\u0026lt;Esc\u0026gt; 在插入模式中使用\u0026lt;Up\u0026gt; \u0026lt;Down\u0026gt; \u0026lt;Left\u0026gt; \u0026lt;Right\u0026gt;会产生新撤销块, 可以把这想象为先切换回普通模式，然后用 h、j、k 或 l 命令对光标进行了移动\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/u/","summary":"修改指 改变文档内文本的任意操作，其中包括在普通模式、可视模式以及命令行模式中所触发的命令 在插入模式中输入（或删除）的文本: i{insert some text}\u0026lt;Esc\u0026gt; 在插入模式中","title":"u 撤销修改"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/vim/%E7%82%B9/","summary":"","title":". 重复上次修改/普通模式命令"},{"content":"8.1 道高一尺魔高一丈的网站应用攻击与防御 8.1.1 XSS攻击 XSS攻击即跨站点脚本攻击（Cross Site Script），指黑客通过篡改网页，注入恶意HTML脚本，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方 式。\n常见的XSS攻击类型有两种\n一种是反射型，攻击者诱使用户点击一个嵌入恶意脚本的链接，达到攻击的目的 图8.1 反射型XSS攻击\n另外一种XSS攻击是持久型XSS攻击，黑客提交含有恶意脚本的请求，保存在被攻击的Web站点的数据库中，用户浏览网页时，恶意脚本被包含在正常页面中，达到 攻击的目的 图8.2 持久型XSS攻击\n主要防范手段\n消毒. 即对某些html危险字符转义 HttpOnly. 即浏览器禁止页面JavaScript访问带有HttpOnly属性的Cookie 8.1.2 注入攻击 图8.3 SQL注入攻击\nSQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者获取数据库表结构信息的手段有如下几种。\n开源 错误回显 盲注 防御SQL注入攻击首先要避免被攻击者猜测到表名等数据库表结构信息，此外还可以采用如下方式\n消毒. 过滤请求数据中可能注入的SQL 参数绑定. 使用预编译手段，绑定参数是最好的防SQL注入方法 除了SQL注入，攻击者还根据具体应用，注入OS命令、编程语言代码等，利用程序漏洞，达到攻击目的。\n8.1.3 CSRF攻击 CSRF（Cross Site Request Forgery，跨站点请求伪造），攻击者通过跨站请求，以合法用户的身份进行非法操作\n其核心是利用了浏览器Cookie或服务器Session策略，盗取用户身份。 图8.4 CSRF攻击\nCSRF的防御手段主要是识别请求者身份\n表单Token. CSRF是一个伪造用户请求的操作，所以需要构造用户请求的所有参数才可以。表单Token通过在请求参数中增加随机数的办法来阻止攻击者获得所有 请求参数 验证码. 请求提交时，需要用户输入验证码，以避免在用户不知情的情况下被攻击者伪造请求。但是输入验证码是一个糟糕的用户体验，所以请在必要时使用 Referer check. HTTP请求头的Referer域中记录着请求来源，可通过检查请求来源，验证其是否合法。很多网站使用这个功能实现图片防盗链 8.1.4 其他攻击和漏洞 Error Code\n也称作错误回显，许多Web服务器默认是打开异常信息输出的，即服务器端未处理的异常堆栈信息会直接输出到客户端浏览器，这种方式虽然对程序调试和错误报告有 好处，但同时也给黑客造成可乘之机。\nHTML注释\n程序最终发布前需要进行代码review或自动扫描，避免HTML注释漏洞。\n文件上传\n如果上传的是可执行的程序，并通过该程序获得服务器端命令执行能力，那么攻击者几乎可以在服务器上为所欲为，并以此为跳板攻击集群环境的其他机器。最有效的 防御手段是设置上传文件白名单，只允许上传可靠的文件类型。此外还可以修改文件名、使用专门的存储等手段，保护服务器免受上传文件攻击。\n路径遍历\n攻击者在请求的URL中使用相对路径，遍历系统未开放的目录和文件。防御方法主要是将JS、CSS等资源文件部署在独立服务器、使用独立域名，其他文件不使用静态 URL访问，动态参数不包含文件路径信息。\n8.1.5 Web应用防火墙 ModSecurity\n图8.5 ModSecurity架构原理\n8.1.6 网站安全漏洞扫描 网站安全漏洞扫描工具是根据内置规则，构造具有攻击性的URL请求，模拟黑客攻击行为，用以发现网站安全漏洞的工具。\n8.2 信息加密技术及密钥安全管理 8.2.1 单向散列加密 图8.6 单向散列加密\n8.2.2 对称加密 图8.8 对称加密\n8.2.3 非对称加密 图8.9 非对称加密\n8.2.4 密钥安全管理 一种方案是把密钥和算法放在一个独立的服务器上，甚至做成一个专用的硬件设施，对外提供加密和解密服务\n另一种方案是将加解密算法放在应用系统中，密钥则放在独立服务器中，为了提高密钥的安全性，实际存储时，密钥被切分成数片，加密后分别保存在不同存储介质中\n8.3 信息过滤与反垃圾 常用的信息过滤与反垃圾手段有以下几种\n8.3.1 文本匹配 正则表达式匹配 Trie树的变种 多级Hash表 还需要对信息做降噪预处理，然后再进行匹配\n8.3.2 分类算法 贝叶斯分类算法 8.3.3 黑名单 8.4 电子商务风险控制 8.4.1 风险 账户风险：包括账户被黑客盗用，恶意注册账号等几种情形。 买家风险：买家恶意下单占用库存进行不正当竞争；黄牛利用促销抢购低价商品；此外还有良品拒收，欺诈退款及常见于B2B交易的虚假询盘等。 卖家风险：不良卖家进行恶意欺诈的行为，例如货不对板，虚假发货，炒作信用等，此外还有出售违禁商品、侵权产品等。 交易风险：信用卡盗刷，支付欺诈，洗钱套现等。 8.4.2 风控 机器自动风控的技术手段主要有规则引擎和统计模型。\n规则引擎\n当交易的某些指标满足一定条件时，就会被认为具有高风险的欺诈可能性。比如用户来自欺诈高发地区；交易金额超过某个数值；和上次登录的地址距离差距很大；用 户登录地与收货地不符；用户第一次交易等等。\n规则引擎是一种将业务规则和规则处理逻辑相分离的技术\n图8.14 基于规则引擎的风险控制系统\n统计模型\n规则引擎虽然技术简单，但是随着规则的逐渐增加，会出现规则冲突，难以维护等情况，而且规则越多，性能也越差。目前大型网站更倾向于使用统计模型进行风控。\n风控领域使用的统计模型使用分类算法或者更复杂的机器学习算法进行智能统计。\n图8.15 基于统计模型的风险控制系统\n8.5 小结 ","permalink":"https://jdxj.github.io/posts/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E7%AC%AC2%E7%AF%87-%E6%9E%B6%E6%9E%84/8-%E5%9B%BA%E8%8B%A5%E9%87%91%E6%B1%A4-%E7%BD%91%E7%AB%99%E7%9A%84%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/","summary":"8.1 道高一尺魔高一丈的网站应用攻击与防御 8.1.1 XSS攻击 XSS攻击即跨站点脚本攻击（Cross Site Script），指黑客通过篡改网页，注入恶意HTM","title":"8 固若金汤: 网站的安全架构"},{"content":"扩展性（Extensibility）\n指对现有系统影响最小的情况下，系统功能可持续扩展或提升的能力。表现在系统基础设施稳定不需要经常变更，应用之间较少依赖和耦合，对需求变更可以敏捷响应。 它是系统架构设计层面的开闭原则（对扩展开放，对修改关闭），架构设计考虑未来功能扩展，当系统增加新功能时，不需要对现有系统的结构和代码进行修改。\n伸缩性（Scalability）\n指系统能够通过增加（减少）自身资源规模的方式增强（减少）自己计算处理事务的能力。如果这种增减是成比例的，就被称作线性伸缩性。在网站架构中，通常指利 用集群的方式增加服务器数量、提高系统的整体事务吞吐能力。\n7.1 构建可扩展的网站架构 可以说，度量一个开发框架、设计模式、编程语言优劣的重要尺度就是衡量它是不是让软件开发过程和软件产品更加低耦合。\n设计网站可扩展架构的核心思想是模块化，并在此基础之上，降低模块间的耦合性，提高模块的复用性。\n在大型网站中，这些模块通过分布式部署的方式，独立的模块部署在独立的服务器（集群）上，从物理上分离模块之间的耦合关系，进一步降低耦合性提高复用性。\n模块分布式部署以后具体聚合方式主要有分布式消息队列和分布式服务。\n7.2 利用分布式消息队列降低系统耦合性 7.2.1 事件驱动架构 事件驱动架构（Event Driven Architecture）：通过在低耦合的模块之间传输事件消息，以保持模块的松散耦合，并借助事件消息的通信完成模块间合作\n图7.1 利用消息队列实现的事件驱动架构\n7.2.2 分布式消息队列 图7.2 分布式消息队列架构原理\n在伸缩性方面，由于消息队列服务器上的数据可以看作是被即时处理的，因此类似于无状态的服务器，伸缩性设计比较简单。将新服务器加入分布式消息队列集群中， 通知生产者服务器更改消息队列服务器列表即可。\n在可用性方面，为了避免消费者进程处理缓慢，分布式消息队列服务器内存空间不足造成的问题，如果内存队列已满，会将消息写入磁盘，消息推送模块在将内存队列 消息处理完以后，将磁盘内容加载到内存队列继续处理。\n为了避免消息队列服务器宕机造成消息丢失，会将消息成功发送到消息队列的消息存储在消息生产者服务器，等消息真正被消息消费者服务器处理后才删除消息。在消 息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中其他的服务器发布消息。\n7.3 利用分布式服务打造可复用的业务平台 如果说分布式消息队列通过消息对象分解系统耦合性，不同子系统处理同一个消息；那么分布式服务则通过接口分解系统耦合性，不同子系统通过相同的接口描述进行 服务调用。\n图7.3 巨无霸系统示意图\n巨无霸应用系统带来如下几点问题\n编译、部署困难 代码分支管理困难 数据库连接耗尽 新增业务困难 解决方案就是拆分\n纵向拆分：将一个大应用拆分为多个小应用，如果新增业务较为独立，那么就直接将其设计部署为一个独立的Web应用系统。 横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务，不需要依赖具体的模块代码，即可快速搭建一个应用系统，而模 块内业务逻辑变化的时候，只要接口保持一致就不会影响业务程序和其他模块。 图7.4 业务及模块拆分独立部署的分布式服务架构\n7.3.1 Web Service与企业级分布式服务 图7.5 WebService架构原理\n7.3.2 大型网站分布式服务的需求与特点 负载均衡 失效转移 高效的远程通信 整合异构系统 对应用最少侵入 版本管理 实时监控 7.3.3 分布式服务框架设计 图7.6 分布式服务框架Dubbo的架构原理\n7.4 可扩展的数据结构 无需修改表结构就可以新增字段呢？许多NoSQL数据库使用的ColumnFamily（列族）设计就是一个解决方案。ColumnFamily最早在Google的Bigtable中使用， 这是一种面向列族的稀疏矩阵存储格式\n表7.1 ColumnFamily数据存储格式\n使用支持ColumnFamily结构的NoSQL数据库，创建表的时候，只需要指定ColumnFamily的名字，无需指定字段（Column），可以在数据写入时再指定，通过这种 方式，数据表可以包含数百万的字段，使得应用程序的数据结构可以随意扩展。而在查询时，可以通过指定任意字段名称和值进行查询。\n7.5 利用开放平台建设网站生态圈 图7.7 开放平台架构原理\nAPI 接口：是开放平台暴露给开发者使用的一组API，其形式可以是RESTful、WebService、RPC等各种形式。 协议转换：将各种API输入转换成内部服务可以识别的形式，并将内部服务的返回封装成API的格式。 安全：除了一般应用需要的身份识别、权限控制等安全手段，开放平台还需要分级的访问带宽限制，保证平台资源被第三方应用公平合理使用，也保护网站内部服务 不会被外部应用拖垮。 审计：记录第三方应用的访问情况，并进行监控、计费等。 路由：将开放平台的各种访问路由映射到具体的内部服务。 流程：将一组离散的服务组织成一个上下文相关的新服务，隐藏服务细节，提供统一接口供开发者调用。 7.6 小结 ","permalink":"https://jdxj.github.io/posts/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E7%AC%AC2%E7%AF%87-%E6%9E%B6%E6%9E%84/7-%E9%9A%8F%E9%9C%80%E5%BA%94%E5%8F%98-%E7%BD%91%E7%AB%99%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84/","summary":"扩展性（Extensibility） 指对现有系统影响最小的情况下，系统功能可持续扩展或提升的能力。表现在系统基础设施稳定不需要经常变更，应用","title":"7 随需应变: 网站的可扩展架构"},{"content":"所谓网站的伸缩性是指不需要改变网站的软硬件设计，仅仅通过改变部署的服务器数量就可以扩大或者缩小网站的服务处理能力。\n6.1 网站架构的伸缩性设计 6.1.1 不同功能进行物理分离实现伸缩 图6.1 通过物理分离实现服务器伸缩\n纵向分离（分层后分离）：将业务处理流程上的不同部分分离部署，实现系统伸缩性\n图6.2 通过纵向分离部署实现系统伸缩性\n横向分离（业务分割后分离）：将不同的业务模块分离部署，实现系统伸缩性\n图6.3 通过横向分离部署实现系统伸缩性\n6.1.2 单一功能通过集群规模实现伸缩 集群伸缩性又可分为应用服务器集群伸缩性和数据服务器集群伸缩性。这两种集群由于对数据状态管理的不同，技术实现也有非常大的区别。而数据服务器集群也可分 为缓存数据服务器集群和存储数据服务器集群，这两种集群的伸缩性设计也不大相同。\n6.2 应用服务器集群的伸缩性设计 图6.4 负载均衡实现应用服务器伸缩性\n6.2.1 HTTP重定向负载均衡 图6.5 HTTP重定向负载均衡原理\n不推荐\n6.2.2 DNS域名解析负载均衡 图6.6 DNS域名解析负载均衡原理\n大型网站总是部分使用DNS域名解析，利用域名解析作为第一级负载均衡手段，即域名解析得到的一组服务器并不是实际提供Web服务的物理服务器，而是同样提供负 载均衡服务的内部服务器，这组内部负载均衡服务器再进行负载均衡，将请求分发到真实的Web服务器上。\n6.2.3 反向代理负载均衡 图6.7 反向代理负载均衡原理\n反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。\n6.2.4 IP负载均衡 图6.8 IP负载均衡原理\n关键在于真实物理Web服务器响应数据包如何返回给负载均衡服务器。\n一种方案是负载均衡服务器在修改目的IP地址的同时修改源地址，将数据包源地址设为自身IP，即源地址转换（SNAT），这样Web服务器的响应会再回到负载均衡 服务器； 另一种方案是将负载均衡服务器同时作为真实物理服务器集群的网关服务器，这样所有响应数据都会到达负载均衡服务器。 6.2.5 数据链路层负载均衡 图6.9 数据链路层负载均衡原理\n用户请求到达负载均衡服务器114.100.80.10后，负载均衡服务器将请求数据的目的mac地址修改为00:0c:29:d2，并不修改数目包目标IP地址，由于Web服务器 集群所有服务器的虚拟IP地址都和负载均服务器的IP地址相同，因此数据可以正常传输到达mac地址00:0c:29:d2对应的服务器，该服务器处理完成后发送响应数据 到网站的网关服务器，网关服务器直接将该数据包发送到用户浏览器（通过互联网），响应数据不需要通过负载均衡服务器。\n使用三角传输模式的链路层负载均衡是目前大型网站使用最广的一种负载均衡手段。在Linux平台上最好的链路层负载均衡开源产品是LVS（Linux Virtual Server）。\n6.2.6 负载均衡算法 轮询（Round Robin，RR） 加权轮询（Weighted Round Robin，WRR） 随机（Random） 最少连接（Least Connections） 源地址散列（Source Hashing） 6.3 分布式缓存集群的伸缩性设计 和所有服务器都部署相同应用的应用服务器集群不同，分布式缓存服务器集群中不同服务器中缓存的数据各不相同\n6.3.1 Memcached分布式缓存集群的访问模型 图6.10 Memcached分布式缓存访问模型\n6.3.2 Memcached分布式缓存集群的伸缩性挑战 简单的hash在增加缓存服务器时导致命中率降低\n6.3.3 分布式缓存的一致性Hash算法 图6.11 一致性Hash算法原理\n图6.12 增加节点后的一致性Hash环结构\n解决上述一致性Hash算法带来的负载不均衡问题，也可以通过使用虚拟层的手段：将每台物理缓存服务器虚拟为一组虚拟缓存服务器，将虚拟服务器的Hash值放置在 Hash环上，KEY在环上先找到虚拟服务器节点，再得到物理服务器的信息。\n图6.13 使用虚拟节点的一致性Hash环\n6.4 数据存储服务器集群的伸缩性设计 6.4.1 关系数据库集群的伸缩性设计 市场上主要的关系数据都支持数据复制功能，使用这个功能可以对数据库进行简单伸缩。\n图6.14 MySQL集群伸缩性方案\n除了数据库主从读写分离，前面提到的业务分割模式也可以用在数据库，不同业务数据表部署在不同的数据库集群上，即俗称的数据分库。这种方式的制约条件是跨库 的表不能进行Join操作。\n数据库分片, 将一张表拆开分别存储在多个数据库中。\n图6.15 Cobar部署模型\n应用程序通过JDBC驱动访问Cobar集群，Cobar服务器根据SQL和分库规则分解SQL，分发到MySQL集群不同的数据库实例上执行（每个MySQL实例都部署为主/从结 构，保证数据高可用）。\n图6.16 Cobar系统组件模型\n6.4.2 NoSQL数据库的伸缩性设计 大型网站遇到了关系数据库难以克服的缺陷——糟糕的海量数据处理能力及僵硬的设计约束\nNoSQL，主要指非关系的、分布式的数据库设计模式。也有许多专家将NoSQL解读为Not Only SQL，表示NoSQL只是关系数据库的补充，而不是替代方案。一般而言， NoSQL数据库产品都放弃了关系数据库的两大重要基础：以关系代数为基础的结构化查询语言（SQL）和事务一致性保证（ACID）。而强化其他一些大型网站更关注的 特性：高可用性和可伸缩性。\n应用最广泛的是Apache HBase\nHBase为可伸缩海量数据储存而设计，实现面向在线业务的实时数据访问延迟。HBase的伸缩性主要依赖其可分裂的HRegion及可伸缩的分布式文件系统HDFS实现。\n图6.19 HBase架构\nHBase中，数据以HRegion为单位进行管理，也就是说应用程序如果想要访问一个数据，必须先找到HRegion，然后将数据读写操作提交给HRegion，由HRegion完 成存储层面的数据操作。每个HRegion中存储一段Key值区间[key1,key2)的数据，HRegionServer是物理服务器，每个HRegionServer上可以启动多个 HRegion实例。当一个HRegion中写入的数据太多，达到配置的阈值时，HRegion会分裂成两个HRegion，并将HRegion在整个集群中进行迁移，以使 HregionServer的负载均衡。\n所有HRegion的信息（存储的Key值区间、所在HRegionServer地址、访问端口号等）都记录在HMaser服务器上，为了保证高可用，HBase启动多个HMaser，并 通过Zookeeper（一个支持分布式一致性的数据管理服务）选举出一个主服务器，应用程序通过Zookeeper获得主HMaser的地址，输入Key值获得这个Key所在的 HRegionServer地址，然后请求HRegionServer上的HRegion，获得需要的数据。\n图6.20 HBase数据寻址过程时序图\n6.5 小结 ","permalink":"https://jdxj.github.io/posts/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E7%AC%AC2%E7%AF%87-%E6%9E%B6%E6%9E%84/6-%E6%B0%B8%E6%97%A0%E6%AD%A2%E5%A2%83-%E7%BD%91%E7%AB%99%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84/","summary":"所谓网站的伸缩性是指不需要改变网站的软硬件设计，仅仅通过改变部署的服务器数量就可以扩大或者缩小网站的服务处理能力。 6.1 网站架构的伸缩性设计 6.1.1 不","title":"6 永无止境: 网站的伸缩性架构"},{"content":"5.1 网站可用性的度量与考核 5.1.1 网站可用性度量 业界通常用多少个9来衡量网站的可用性\n网站不可用时间（故障时间）=故障修复时间点-故障发现（报告）时间点\n网站年度可用性指标=（1-网站不可用时间/年度总时间）×100%\n对于大多数网站而言，2个9是基本可用，网站年度不可用时间小于88小时；\n3个9是较高可用，网站年度不可用时间小于9小时；\n4个9是具有自动恢复能力的高可用，网站年度不可用时间小于53分钟；\n5个9是极高可用性，网站年度不可用时间小于5分钟。\n5.1.2 网站可用性考核 可用性指标是网站架构设计的重要指标，对外是服务承诺，对内是考核指标。从管理层面，可用性指标是网站或者产品的整体考核指标，具体到每个工程师的考核，更 多的是使用故障分。\n故障分是指对网站故障进行分类加权计算故障责任的方法。 故障分=故障时间（分钟）× 故障权重 表5.1 网站故障分类权重表示例\n不同的公司有不同的企业文化和市场策略，这些因素也会影响到系统可用性的架构决策\n5.2 高可用的网站架构 实现高可用架构的主要手段是数据和服务的冗余备份及失效转移，一旦某些服务器宕机，就将服务切换到其他可用的服务器上，如果磁盘损坏，则从备份的磁盘读取数 据。\n图5.2 网站架构基本分层模型\n应用层主要负责具体业务逻辑处理； 服务层负责提供可复用的服务； 数据层负责数据的存储与访问。 图5.3 应用和数据分离部署的网站架构\n在复杂的大型网站架构中，划分的粒度会更小、更详细，结构更加复杂，服务器规模更加庞大，但通常还是能够把这些服务器划分到这三层中。\n图5.4 分层后按模块分割的网站架构模型\n网站的可用性架构设计不但要考虑实际的硬件故障引起的宕机，还要考虑网站升级发布引起的宕机，而后者更加频繁，不能因为系统可以接受偶尔的停机故障就降低可 用性设计的标准。\n5.3 高可用的应用 无状态设计\n5.3.1 通过负载均衡进行无状态服务的失效转移 对于应用服务器集群，实现这种服务器可用状态实时监测、自动转移失败任务的机制是负载均衡。\n图5.5 利用负载均衡服务器实现高可用的应用服务\n5.3.2 应用服务器集群的Session管理 集群环境下，Session管理主要有以下几种手段\nSession复制\n适用于较小的集群规模\n应用服务器开启Web容器的Session复制功能，在集群中的几台服务器之间同步Session对象，使得每台服务器上都保存所有用户的Session信息，这样任何一台机 器宕机都不会导致Session数据的丢失，而服务器使用Session时，也只需要在本机获取即可。\n图5.6 使用Session复制实现应用服务器共享Session\nSession绑定\n很少有网站利用这个算法进行Session管理\nSession绑定可以利用负载均衡的源地址Hash算法实现，负载均衡服务器总是将来源于同一IP的请求分发到同一台服务器上, 保证Session总能在这台服务器上获取。 这种方法又被称作会话黏滞\n图5.7 利用负载均衡的会话黏滞机制将请求绑定到特定服务器\n利用Cookie记录Session\n将Session记录在客户端，每次请求服务器的时候，将Session放在请求中发送给服务器，服务器处理完请求后再将修改过的Session响应给客户端。\n图5.8 利用Cookie记录Session信息\n缺点\ncookie大小有限制 每次都传输cookie, 影响性能 用户可以关闭cookie功能 Session服务器\n利用独立部署的Session服务器（集群）统一管理Session，应用服务器每次读写Session时，都访问Session服务器\n图5.9 利用Session服务器共享Session\n5.4 高可用的服务 可复用的服务和应用一样，也是无状态的服务，因此可以使用类似负载均衡的失效转移策略实现高可用的服务。\n具体实践中，还有以下几点高可用的服务策略。\n分级管理\n运维上将服务器进行分级管理，核心应用和服务优先使用更好的硬件，在运维响应速度上也格外迅速。 服务部署上也进行必要的隔离，避免故障的连锁反应。 超时设置\n由于服务端宕机、线程死锁等原因，可能导致应用程序对服务端的调用失去响应，进而导致用户请求长时间得不到响应，同时还占用应用程序的资源，不利于及时将访 问请求转移到正常的服务器上。\n异步调用\n应用对服务的调用通过消息队列等异步方式完成，避免一个服务失败导致整个应用请求失败的情况。 对于那些必须确认服务调用成功才能继续下一步操作的应用也不合适使用异步调用。 服务降级\n拒绝服务：拒绝低优先级应用的调用，减少服务调用并发数，确保核心应用正常使用；或者随机拒绝部分请求调用，节约资源，让另一部分请求得以成功 关闭功能：关闭部分不重要的服务，或者服务内部关闭部分不重要的功能，以节约系统开销，为重要的服务和功能让出资源。 幂等性设计\n虚假失败\n服务重复调用是无法避免的，应用层也不需要关心服务是否真的失败，只要没有收到调用成功的响应，就可以认为调用失败，并重试服务调用。因此必须在服务层保证 服务重复调用和调用一次产生的结果相同，即服务具有幂等性。\n5.5 高可用的数据 保证数据存储高可用的手段主要是数据备份和失效转移机制。\n数据备份是保证数据有多个副本，任意副本的失效都不会导致数据的永久丢失，从而实现数据完全的持久化。 失效转移机制则保证当一个数据副本不可访问时，可以快速切换访问数据的其他副本，保证系统可用。 对缓存可用性的两种观点\n缓存已经成为网站数据服务的重要组成部分，事实上承担了业务中绝大多数的数据读取访问服务，缓存服务失效可能会导致数据库负载过高而宕机，进而影响整个网 站的可用性，因此缓存服务需要实现和数据存储服务同样的高可用。 缓存服务不是数据存储服务，缓存服务器宕机引起缓存数据丢失导致服务器负载压力过高应该通过其他手段解决，而不是提高缓存服务本身的高可用。 5.5.1 CAP原理 图5.10 CAP原理\n在大型网站应用中，数据规模总是快速扩张的，因此可伸缩性即分区耐受性必不可少，规模变大以后，机器数量也会变得庞大，这时网络和服务器故障会频繁出现，要 想保证应用可用，就必须保证分布式处理系统的高可用性。所以在大型网站中，通常会选择强化分布式存储系统的可用性（A）和伸缩性（P），而在某种程度上放弃一 致性（C）。\n数据一致性又可分为如下几点\n数据强一致\n各个副本的数据在物理存储中总是一致的；数据更新操作结果和操作响应总是一致的，即操作响应通知更新失败，那么数据一定没有被更新，而不是处于不确定状态。\n数据用户一致\n即数据在物理存储中的各个副本的数据可能是不一致的，但是终端用户访问时，通过纠错和校验机制，可以确定一个一致的且正确的数据返回给用户。\n数据最终一致\n这是数据一致性中较弱的一种，即物理存储的数据可能是不一致的，终端用户访问到的数据可能也是不一致的（同一用户连续访问，结果不同；或者不同用户同时访问， 结果不同），但系统经过一段时间（通常是一个比较短的时间段）的自我恢复和修正，数据最终会达到一致。\n5.5.2 数据备份 数据冷备，即定期将数据复制到某种存储介质（磁带，光盘……）上并物理存档保管，如果系统存储损坏，那么就从冷备的存储设备中恢复数据。\n冷备的优点是简单和廉价，成本和技术难度都较低。 缺点是不能保证数据最终一致，由于数据是定期复制，因此备份设备中的数据比系统中的数据陈旧. 同时也不能保证数据可用性，从冷备存储中恢复数据需要较长的 时间，而这段时间无法访问数据，系统也不可用。 数据热备可分为两种：异步热备方式和同步热备方式。\n异步方式是指多份数据副本的写入操作异步完成，应用程序收到数据服务系统的写操作成功响应时，只写成功了一份，存储系统将会异步地写其他副本（这个过程有 可能会失败）。 图5.11 数据异步热备\n同步方式是指多份数据副本的写入操作同步完成，即应用程序收到数据服务系统的写成功响应时，多份数据都已经写操作成功。但是当应用程序收到数据写操作失败 的响应时，可能有部分副本或者全部副本都已经写成功了（因为网络或者系统故障，无法返回操作成功的响应） 同步热备具体实现的时候，为了提高性能，在应用程序客户端并发向多个存储服务器同时写入数据，然后等待所有存储服务器都返回操作成功的响应后，再通知 应用程序写操作成功。 图5.12 数据同步热备\n关系数据库热备机制就是通常所说的Master-Slave同步机制。实践中，通常使用读写分离的方法访问Slave和Master数据库，写操作只访问Master数据库，读操 作只访问Slave数据库。\n5.5.3 失效转移 失效转移操作由三部分组成：失效确认、访问转移、数据恢复。\n1. 失效确认\n系统确认一台服务器是否宕机的手段有两种：心跳检测和应用程序访问失败报告\n图5.13 存储服务器失效确认\n2. 访问转移\n确认某台数据存储服务器宕机后, 当其中一台宕机后，应用程序根据配置直接切换到对等服务器上。如果存储是不对等的，那么就需要重新计算路由，选择存储服务器。\n3. 数据恢复\n因为某台服务器宕机，所以数据存储的副本数目会减少，必须将副本的数目恢复到系统设定的值，否则，再有服务器宕机时，就可能出现无法访问转移（所有副本的服 务器都宕机了），数据永久丢失的情况。\n5.6 高可用网站的软件质量保证 一些与传统软件开发不同的质量保证手段\n5.6.1 网站发布 网站的发布过程事实上和服务器宕机效果相当, 由于应用的不断发布，用户需要面对的是每周一到两次的宕机故障。\n图5.14 网站应用发布流程\n发布过程中，每次关闭的服务器都是集群中的一小部分，并在发布完成后立即可以访问，因此整个发布过程不影响用户使用。\n5.6.2 自动化测试 对整个网站功能进行全面的回归测试。 需要测试各种浏览器的兼容性 Selenium工具\n5.6.3 预发布验证 即使是经过严格的测试，软件部署到线上服务器之后还是经常会出现各种问题, 因此在网站发布时，并不是把测试通过的代码包直接发布到线上服务器，而是先发布到 预发布机器上，开发工程师和测试工程师在预发布服务器上进行预发布验证，执行一些典型的业务流程，确认系统没有问题后才正式发布。\n预发布服务器是一种特殊用途的服务器，它和线上的正式服务器唯一的不同就是没有配置在负载均衡服务器上，外部用户无法访问\n图5.15 网站应用预发布\n在预发布机器上进行测试所产生的测试数据可能会暴露给用户\n快速失败（fast failed）即如果系统在启动时发现问题就立刻抛出异常，停止启动让工程师介入排查错误，而不是启动后执行错误的操作。\n5.6.4 代码控制 网站代码控制的核心问题是如何进行代码管理，既能保证代码发布版本的稳定正确，同时又能保证不同团队的开发互不影响。\n5.6.5 自动化发布 很多网站选择周四作为发布日，这样一周前面有三天时间可以准备发布，后面还有一天时间可以挽回错误。如果选择周五发布，发现问题就必须要周末加班了。\n图5.17 网站火车发布模型\n由于火车发布模型是基于规则驱动的流程，所以这个流程可以自动化。\n5.6.6 灰度发布 应用发布成功后，仍然可能发现因为软件问题而引入的故障，这时候就需要做发布回滚，即卸载刚刚发布的软件，将上一个版本的软件包重新发布，使系统复原，消除 故障。\n大型网站会使用灰度发布模式，将集群服务器分成若干部分，每天只发布一部分服务器，观察运行稳定没有故障，第二天继续发布一部分服务器，持续几天才把整个集 群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可。\n图5.18 网站灰度发布模型\n灰度发布也常用于用户测试，即在部分服务器上发布新版本，其余服务器保持老版本（或者发布另一个版本），然后监控用户操作行为，收集用户体验报告，比较用户 对两个版本的满意度，以确定最终的发布版本。这种手段也被称作AB测试。\n5.7 网站运行监控 5.7.1 监控数据采集 用户行为日志收集 服务器端日志收集 客户端浏览器日志收集 服务器性能监控 运行数据报告. 缓冲命中率、平均响应延迟时间、每分钟发送邮件数目、待处理的任务总数等。 5.7.2 监控管理 系统报警 失效转移 自动优雅降级 5.8 小结 对公司而言，可用性关系网站的生死存亡。对个人而言，可用性关系到自己的绩效升迁。工程师对架构做了许多优化、对代码做了很多重构，对性能、扩展性、伸缩性 做了很多改善，但别人未必能直观地感受到，也许你的直接领导都不知道你做的这些意义何在。但如果你负责的产品出了重大故障，CEO都会知道你的名字。事物总是 先求生存，然后求发展。保证网站可用，万无一失，任重而道远。\n","permalink":"https://jdxj.github.io/posts/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E7%AC%AC2%E7%AF%87-%E6%9E%B6%E6%9E%84/5-%E4%B8%87%E6%97%A0%E4%B8%80%E5%A4%B1-%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/","summary":"5.1 网站可用性的度量与考核 5.1.1 网站可用性度量 业界通常用多少个9来衡量网站的可用性 网站不可用时间（故障时间）=故障修复时间点-故障发现（报告）时间","title":"5 万无一失: 网站的高可用架构"},{"content":"网站性能是客观的指标，可以具体体现到响应时间、吞吐量等技术指标，同时也是主观的感受，而感受则是一种与具体参与者相关的微妙的东西，用户的感受和工程师 的感受不同，不同的用户感受也不同。\n4.1 网站性能测试 性能测试是性能优化的前提和基础，也是性能优化结果的检查和度量标准。不同视角下的网站性能有不同的标准，也有不同的优化手段。\n4.1.1 不同视角下的网站性能 用户视角的网站性能\n从用户角度，网站性能就是用户在浏览器上直观感受到的网站响应速度快还是慢。用户感受到的时间，包括用户计算机和网站服务器通信的时间、网站服务器处理的时 间、用户计算机浏览器构造请求解析响应数据的时间\n图4.1 用户视角的网站性能\n在实践中，使用一些前端架构优化手段，通过优化页面HTML式样、利用浏览器端的并发和异步特性、调整浏览器缓存策略、使用CDN服务、反向代理等手段，使浏览器 尽快地显示用户感兴趣的内容、尽可能近地获取页面内容，即使不优化应用程序和架构，也可以很大程度地改善用户视角下的网站性能。\n开发人员视角的网站性能\n开发人员关注的主要是应用程序本身及其相关子系统的性能，包括响应延迟、系统吞吐量、并发处理能力、系统稳定性等技术指标。主要的优化手段有使用缓存加速数 据读取，使用集群提高吞吐能力，使用异步消息加快请求响应及实现削峰，使用代码优化手段改善程序性能。\n运维人员视角的网站性能\n运维人员更关注基础设施性能和资源利用率，如网络运营商的带宽能力、服务器硬件的配置、数据中心网络架构、服务器和网络带宽的资源利用率等。主要优化手段有 建设优化骨干网、使用高性价比定制服务器、利用虚拟化技术优化资源利用等。\n4.1.2 性能测试指标 响应时间\n表4.1 常用系统操作响应时间表\n如果测试目标操作本身需要花费的时间极少，比如几微秒，那么测试程序就无法测试得到系统的响应时间。实践中通常采用的办法是重复请求，比如一个请求操作重复 执行一万次，测试一万次执行需要的总响应时间之和，然后除以一万，得到单次请求的响应时间。\n并发数\n指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对于网站而言，并发数即网站并发用户数，指同时提交请求的用户数目。\n测试程序通过多线程模拟并发用户的办法来测试系统的并发处理能力，为了真实模拟用户行为，测试程序并不是启动多线程然后不停地发送请求，而是在两次请求之间 加入一个随机等待时间，这个时间被称作思考时间。\n吞吐量\n指单位时间内系统处理的请求数量，体现系统的整体处理能力。对于网站，可以用“请求数/秒”或是“页面数/秒”来衡量，也可以用“访问人数/天”或是 “处理的业务数/小时”等来衡量。TPS（每秒事务数）是吞吐量的一个常用量化指标，此外还有HPS（每秒HTTP请求数）、QPS（每秒查询数）等。\n网站性能优化的目的，除了改善用户体验的响应时间，还要尽量提高系统吞吐量，最大限度利用服务器资源。\n性能计数器\n它是描述服务器或操作系统性能的一些数据指标。包括System Load、对象与线程数、内存使用、CPU使用、磁盘与网络I/O等指标。这些指标也是系统监控的重要参 数，对这些指标设置报警阈值，当监控系统发现性能计数器超过阈值时，就向运维和开发人员报警，及时发现处理系统异常。\n4.1.3 性能测试方法 性能测试\n以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。\n负载测试\n对系统不断地增加并发请求以增加系统压力，直到系统的某项或多项性能指标达到安全临界值，如某种资源已经呈饱和状态，这时继续对系统施加压力，系统的处理能 力不但不能提高，反而会下降。\n压力测试\n超过安全负载的情况下，对系统继续施加压力，直到系统崩溃或不能再处理任何请求，以此获得系统最大压力承受能力。\n稳定性测试\n被测试系统在特定硬件、软件、网络环境条件下，给系统加载一定业务压力，使系统运行一段较长时间，以此检测系统是否稳定。在不同生产环境、不同时间点的请求 压力是不均匀的，呈波浪特性，因此为了更好地模拟生产环境，稳定性测试也应不均匀地对系统施加压力。\n图4.3 性能测试曲线\n图4.4 并发用户访问响应时间曲线\n4.1.4 性能测试报告 表4.2 性能测试结果报告\n4.1.5 性能优化策略 1. 性能分析\n必须对请求经历的各个环节进行分析，排查可能出现性能瓶颈的地方，定位问题。\n检查请求处理的各个环节的日志，分析哪个环节响应时间不合理、超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是CPU，是代码问 题还是架构设计不合理，或者系统资源确实不足。\n2. 性能优化\n根据网站分层架构，可分为Web前端性能优化、应用服务器性能优化、存储服务器性能优化3大类。\n4.2 Web前端性能优化 4.2.1 浏览器访问优化 减少http请求\n合并CSS、合并JavaScript、合并图片 使用浏览器缓存\n使用http缓存相关头部: Cache-Control, Expires 静态资源文件变化需要及时应用到客户端浏览器, 可通过改变文件名实现, 而不是更新JavaScript文件内容 使用浏览器缓存策略的网站在更新静态资源时, 应采用批量更新的方法 比如需要更新10个图标文件，不宜把10个文件一次全部更新，而是应一个文件一个文件逐步更新，并有一定的间隔时间，以免用户浏览器突然大量缓存失效，集 中更新缓存，造成服务器负载骤增、网络堵塞的情况。 启用压缩\n减少通信传输的数据量 压缩对服务器和浏览器产生一定的压力，在通信带宽良好，而服务器资源不足的情况下要权衡考虑。 CSS放在页面最上面、JavaScript放在页面最下面\n浏览器会在下载完全部CSS之后才对整个页面进行渲染，因此最好的做法是将CSS放在页面最上面，让浏览器尽快下载CSS 浏览器在加载JavaScript后立即执行，有可能会阻塞整个页面，造成页面显示缓慢，因此JavaScript最好放在页面最下面。但如果页面解析时就需要用到 JavaScript，这时放在底部就不合适了。 减少Cookie传输\n哪些数据需要写入Cookie需要慎重考虑 对于某些静态资源的访问，如CSS、Script等，发送Cookie没有意义，可以考虑静态资源使用独立域名访问，避免请求静态资源时发送Cookie 4.2.2 CDN加速 图4.5 利用CDN的网站架构\n将数据缓存在离用户最近的地方，使用户以最快速度获取数据\n4.2.3 反向代理 图4.6 利用反向代理的网站架构\n保护网站 缓存静态/动态内容 负载均衡 4.3 应用服务器性能优化 4.3.1 分布式缓存 缓存的基本原理\n一方面缓存访问速度快，可以减少数据访问的时间，另一方面如果缓存的数据是经过计算处理得到的，那么被缓存的数据无需重复计算即可直接使用，因此缓存还起到 减少计算时间的作用。\n缓存的本质是一个内存Hash表 网站数据访问通常遵循二八定律，即80%的访问落在20%的数据上 合理使用缓存\n频繁修改的数据. 一般说来，数据的读写比在2:1以上，即写入一次缓存，在数据更新前至少读取两次，缓存才有意义。 没有热点的访问. 如果应用系统访问数据没有热点，不遵循二八定律，即大部分数据访问并没有集中在小部分数据上，那么缓存就没有意义，因为大部分数据还没有 被再次访问就已经被挤出缓存了。 数据不一致与脏读 一般会对缓存的数据设置失效时间，一旦超过失效时间，就要从数据库中重新加载。因此应用要容忍一定时间的数据不一致 还有一种策略是数据更新时立即更新缓存，不过这也会带来更多系统开销和事务一致性的问题。 缓存可用性. 发生缓存雪崩 不能简单地重启缓存服务器和数据库服务器来恢复网站访问。 通过缓存热备等手段提高缓存可用性. 这种设计显然有违缓存的初衷，缓存根本就不应该被当做一个可靠的数据源来使用。 通过分布式缓存服务器集群，将缓存数据分布到集群多台服务器上可在一定程度上改善缓存的可用性。当一台缓存服务器宕机的时候，只有部分缓存数据丢失， 重新从数据库加载这部分数据不会对数据库产生很大影响。 缓存预热. 新启动的缓存系统如果没有任何数据，在重建缓存数据的过程中，系统的性能和数据库负载都不太好，那么最好在缓存系统启动时就把热点数据加载好， 这个缓存预加载手段叫作缓存预热（warm up）。 缓存穿透. 一个简单的对策是将不存在的数据也缓存起来（其value值为null）。 分布式缓存架构\n一种是以JBoss Cache为代表的需要更新同步的分布式缓存 一种是以Memcached为代表的不互相通信的分布式缓存。 JBoss Cache的分布式缓存在集群中所有服务器中保存相同的缓存数据，当某台服务器有缓存数据更新的时候，会通知集群中其他机器更新缓存数据或清除缓存数据. JBoss Cache通常将应用程序和缓存部署在同一台服务器上，应用程序可从本地快速获取缓存数据，但是这种方式带来的问题是缓存数据的数量受限于单一服务器的 内存空间，而且当集群规模较大的时候，缓存更新信息需要同步到集群所有机器，其代价惊人。因而这种方案更多见于企业应用系统中，而很少在大型网站使用。\n图4.9 需要更新同步的JBoss Cache\nMemcached采用一种集中式的缓存集群管理，也被称作互不通信的分布式架构方式。缓存与应用分离部署，缓存系统部署在一组专门的服务器上，应用程序通过一致性 Hash等路由算法选择缓存服务器远程访问缓存数据，缓存服务器之间不通信，缓存集群的规模可以很容易地实现扩容，具有良好的可伸缩性。\nMemcached\n图4.10 不互相通信的Memcached\n虽然近些年许多NoSQL产品层出不穷，在数据持久化、支持复杂数据结构、甚至性能方面有许多产品优于Memcached，但Memcached由于其简单、稳定、专注的特点， 仍然在分布式缓存领域占据着重要地位。\n4.3.2 异步操作 可改善网站的扩展性, 还可改善网站系统的性能\n由于消息队列服务器处理速度远快于数据库（消息队列服务器也比数据库具有更好的伸缩性），因此用户的响应延迟可得到有效改善。 消息队列具有很好的削峰作用 由于数据写入消息队列后立即返回给用户，数据在后续的业务校验、写数据库等操作可能失败，因此在使用消息队列进行业务异步处理后，需要适当修改业务流程进 行配合 4.3.3 使用集群 避免单一服务器因负载压力过大而响应缓慢，使用户请求具有更好的响应延迟特性\n图4.15 利用负载均衡技术改善性能\n4.3.4 代码优化 多线程 将对象设计为无状态对象 使用局部对象 并发访问资源时使用锁 资源复用, 要尽量减少那些开销很大的系统资源的创建和销毁 单例 对象池 线程池 数据结构. 在不同场景中合理使用恰当的数据结构，灵活组合各种数据结构改善数据读写和计算特性可极大优化程序的性能。 垃圾回收. 理解垃圾回收机制有助于程序优化和参数调优，以及编写内存安全的代码。 4.4 存储性能优化 4.4.1 机械硬盘vs. 固态硬盘 在网站应用中，大部分应用访问数据都是随机的，这种情况下SSD具有更好的性能表现。\n4.4.2 B+树vs. LSM树 为了改善数据访问特性，文件系统或数据库系统通常会对数据排序后存储，加快数据检索速度，这就需要保证数据在不断更新、插入、删除后依然有序，传统关系数据 库的做法是使用B+树\n由于每次磁盘访问都是随机的，而传统机械硬盘在数据随机访问时性能较差，每次数据访问都需要多次访问磁盘影响数据访问性能。 图4.20 B+树原理示意图\n目前许多NoSQL产品采用LSM树作为主要数据结构\n图4.21 LSM树原理示意图\n数据在内存中仍然还是一棵排序树，当数据量超过设定的内存阈值后，会将这棵排序树和磁盘上最新的排序树合并。当这棵排序树的数据量也超过设定阈值后，和磁盘 上下一级的排序树合并。合并过程中，会用最新更新的数据覆盖旧的数据（或者记录为不同版本）。\n当数据访问以写操作为主，而读操作则集中在最近写入的数据上时，使用LSM树可以极大程度地减少磁盘的访问次数，加快访问速度。\n4.4.3 RAID vs. HDFS 图4.22 常用RAID技术原理图\n假设服务器有N块磁盘。\nRAID0\n数据在从内存缓冲区写入磁盘时，根据磁盘数量将数据分成N份，这些数据同时并发写入N块磁盘，使得数据整体写入速度是一块磁盘的N倍。读取时也一样，因此 RAID0具有极快的数据读写速度，但是RAID0不做数据备份，N块磁盘中只要有一块损坏，数据完整性就被破坏，所有磁盘的数据都会损坏。\nRAID1\n数据在写入磁盘时，将一份数据同时写入两块磁盘，这样任何一块磁盘损坏都不会导致数据丢失，插入一块新磁盘就可以通过复制数据的方式自动修复，具有极高的可 靠性。\nRAID10\n结合RAID0和RAID1两种方案，将所有磁盘平均分成两份，数据同时在两份磁盘写入，相当于RAID1，但是在每一份磁盘里面的N/2块磁盘上，利用RAID0技术并发读 写，既提高可靠性又改善性能，不过RAID10的磁盘利用率较低，有一半的磁盘用来写备份数据。\nRAID3\n在数据写入磁盘的时候，将数据分成N-1份，并发写入N-1块磁盘，并在第N块磁盘记录校验数据，任何一块磁盘损坏（包括校验数据磁盘），都可以利用其他N-1块磁 盘的数据修复。\n但是在数据修改较多的场景中，修改任何磁盘数据都会导致第N块磁盘重写校验数据，频繁写入的后果是第N块磁盘比其他磁盘容易损坏，需要频繁更换，所以RAID3很 少在实践中使用。\nRAID5\nRAID5和RAID3很相似，但是校验数据不是写入第N块磁盘，而是螺旋式地写入所有磁盘中。这样校验数据的修改也被平均到所有磁盘上，避免RAID3频繁写坏一块磁 盘的情况。\nRAID6\n如果数据需要很高的可靠性，在出现同时损坏两块磁盘的情况下（或者运维管理水平比较落后，坏了一块磁盘但是迟迟没有更换，导致又坏了一块磁盘），仍然需要修 复数据，这时候可以使用RAID6。\nRAID6和RAID5类似，但是数据只写入N-2块磁盘，并螺旋式地在两块磁盘中写入校验信息（使用不同算法生成）。\n表4.3 几种RAID技术比较\nRAID技术可以通过硬件实现，比如专用的RAID卡或者主板直接支持，也可以通过软件实现。RAID技术在传统关系数据库及文件系统中应用比较广泛，但是在大型网站 比较喜欢使用的NoSQL，以及分布式文件系统中，RAID技术却遭到冷落。\n在HDFS（Hadoop分布式文件系统）中，系统在整个存储集群的多台服务器上进行数据并发读写和备份，可以看作在服务器集群规模上实现了类似RAID的功能， 因此不需要磁盘RAID。\nHDFS以块（Block）为单位管理文件内容，一个文件被分割成若干个Block，当应用程序写文件时，每写完一个Block，HDFS就将其自动复制到另外两台机器上，保 证每个Block有三个副本，即使有两台服务器宕机，数据依然可以访问，相当于实现了RAID1的数据复制功能。\n图4.23 HDFS架构原理图\n在HDFS中有两种重要的服务器角色：NameNode（名字服务节点）和DataNode（数据存储节点）。\nNameNode在整个HDFS中只部署一个实例，提供元数据服务，相当于操作系统中的文件分配表（FAT），管理文件名Block的分配，维护整个文件系统的目录树结构。 DataNode则部署在HDFS集群中其他所有服务器上，提供真正的数据存储服务。 4.5 小结 ","permalink":"https://jdxj.github.io/posts/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E7%AC%AC2%E7%AF%87-%E6%9E%B6%E6%9E%84/4-%E7%9E%AC%E6%97%B6%E5%93%8D%E5%BA%94-%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84/","summary":"网站性能是客观的指标，可以具体体现到响应时间、吞吐量等技术指标，同时也是主观的感受，而感受则是一种与具体参与者相关的微妙的东西，用户的感受和","title":"4 瞬时响应: 网站的高性能架构"},{"content":"3.1 性能 因为性能问题几乎无处不在，所以优化网站性能的手段也非常多，从用户浏览器到数据库，影响用户请求的所有环节都可以进行性能优化。\n在浏览器端，可以通过浏览器缓存、使用页面压缩、合理布局页面、减少Cookie传输等手段改善性能。 还可以使用CDN，将网站静态内容分发至离用户最近的网络服务商机房，使用户通过最短访问路径获取数据。可以在网站机房部署反向代理服务器，缓存热点文件， 加快请求响应速度，减轻应用服务器负载压力。 在应用服务器端，可以使用服务器本地缓存和分布式缓存，通过缓存在内存中的热点数据处理用户请求，加快请求处理过程，减轻数据库负载压力。 也可以通过异步操作将用户请求发送至消息队列等待后续任务处理，而当前请求直接返回响应给用户。 在网站有很多用户高并发请求的情况下，可以将多台应用服务器组成一个集群共同对外服务，提高整体处理能力，改善性能。 在代码层面，也可以通过使用多线程、改善内存管理等手段优化性能。 在数据库服务器端，索引、缓存、SQL优化等性能优化手段都已经比较成熟。而方兴未艾的NoSQL数据库通过优化数据模型、存储结构、伸缩特性等手段在性能方面 的优势也日趋明显。 衡量网站性能有一系列指标，重要的有响应时间、TPS、系统性能计数器等，通过测试这些指标以确定系统设计是否达到目标。这些指标也是网站监控的重要参数，通 过监控这些指标可以分析系统瓶颈，预测网站容量，并对异常指标进行报警，保障系统可用性。\n3.2 可用性 网站高可用的主要手段是冗余，应用部署在多台服务器上同时提供访问，数据存储在多台服务器上互相备份，任何一台服务器宕机都不会影响应用的整体可用，也不会 导致数据丢失。\n对于应用服务器而言，多台应用服务器通过负载均衡设备组成一个集群共同对外提供服务，任何一台服务器宕机，只需把请求切换到其他服务器就可实现应用的高可用， 但是一个前提条件是应用服务器上不能保存请求的会话信息。否则服务器宕机，会话丢失，即使将用户请求转发到其他服务器上也无法完成业务处理。\n对于存储服务器，由于其上存储着数据，需要对数据进行实时备份，当服务器宕机时需要将数据访问转移到可用的服务器上，并进行数据恢复以保证继续有服务器宕机 的时候数据依然可用。\n除了运行环境，网站的高可用还需要软件开发过程的质量保证。通过预发布验证、自动化测试、自动化发布、灰度发布等手段，减少将故障引入线上环境的可能，避免 故障范围扩大。\n3.3 伸缩性 所谓伸缩性是指通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。\n对于应用服务器集群，只要服务器上不保存数据，所有服务器都是对等的，通过使用合适的负载均衡设备就可以向集群中不断加入服务器。 对于缓存服务器集群，加入新的服务器可能会导致缓存路由失效，进而导致集群中大部分缓存数据都无法访问。虽然缓存的数据可以通过数据库重新加载，但是如果 应用已经严重依赖缓存，可能会导致整个网站崩溃。需要改进缓存路由算法保证缓存数据的可访问性。 关系数据库虽然支持数据复制，主从热备等机制，但是很难做到大规模集群的可伸缩性，因此关系数据库的集群伸缩性方案必须在数据库之外实现，通过路由分区等 手段将部署有多个数据库的服务器组成一个集群。 至于大部分NoSQL数据库产品，由于其先天就是为海量数据而生，因此其对伸缩性的支持通常都非常好，可以做到在较少运维参与的情况下实现集群规模的线性伸缩。 3.4 扩展性 衡量网站架构扩展性好坏的主要标准就是在网站增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或者很少改动既有业务功能就可以上线新 产品。\n主要手段是事件驱动架构和分布式服务。\n事件驱动架构在网站通常利用消息队列实现，将用户请求和其他业务事件构造成消息发布到消息队列，消息的处理者作为消费者从消息队列中获取消息进行处理。通过 这种方式将消息产生和消息处理分离开来，可以透明地增加新的消息生产者任务或者新的消息消费者任务。\n分布式服务则是将业务和可复用服务分离开来，通过分布式服务框架调用。新增产品可以通过调用可复用的服务实现自身的业务逻辑，而对现有产品没有任何影响。可 复用服务升级变更的时候，也可以通过提供多版本服务对应用实现透明升级，不需要强制应用同步变更。\n大型网站为了保持市场地位，还会吸引第三方开发者，调用网站服务，使用网站数据开发周边产品，扩展网站业务。第三方开发者使用网站服务的主要途径是大型网站 提供的开放平台接口。\n3.5 安全性 衡量网站安全架构的标准就是针对现存和潜在的各种攻击与窃密手段，是否有可靠的应对策略。\n3.6 小结 ","permalink":"https://jdxj.github.io/posts/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E7%AC%AC1%E7%AF%87-%E6%A6%82%E8%BF%B0/3-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%A6%81%E7%B4%A0/","summary":"3.1 性能 因为性能问题几乎无处不在，所以优化网站性能的手段也非常多，从用户浏览器到数据库，影响用户请求的所有环节都可以进行性能优化。 在浏览器端，","title":"3 大型网站核心架构要素"},{"content":"2.1 网站架构模式 2.1.1 分层 表2.1 网站分层架构\n通过分层，可以更好地将一个庞大的软件系统切分成不同的部分，便于分工合作开发和维护；各层之间具有一定的独立性，只要维持调用接口不变，各层可以根据具体 问题独立演化发展而不需要其他层必须做出相应调整。\n但是分层架构也有一些挑战，就是必须合理规划层次边界和接口，在开发过程中，严格遵循分层架构的约束，禁止跨层次的调用（应用层直接调用数据层）及逆向调用 （数据层调用服务层，或者服务层调用应用层）。\n分层架构是逻辑上的，在物理部署上，三层结构可以部署在同一个物理机器上，但是随着网站业务的发展，必然需要对已经分层的模块分离部署，即三层结构分别部署 在不同的服务器上，使网站拥有更多的计算资源以应对越来越多的用户访问。\n2.1.2 分割 如果说分层是将软件在横向方面进行切分，那么分割就是在纵向方面对软件进行切分。网站越大，功能越复杂，服务和数据处理的种类也越多，将这些不同的功能和服 务分割开来，包装成高内聚低耦合的模块单元，一方面有助于软件的开发和维护；另一方面，便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力。\n2.1.3 分布式 优点\n提高了并发访问和数据量处理能力 缺点\n分布式通过网络调用, 对性能造成严重影响 保持数据一致性非常困难 开发管理维护困难 常用的分布式方案\n分布式应用和服务 分布式静态资源 分布式数据和存储 分布式计算 分布式配置 分布式锁 分布式文件 2.1.4 集群 即多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。\n因为服务器集群有更多服务器提供相同服务，因此可以提供更好的并发特性，当有更多用户访问的时候，只需要向集群中加入新的机器即可。同时因为一个应用由多台 服务器提供，当某台服务器发生故障时，负载均衡设备或者系统的失效转移机制会将请求转发到集群中其他服务器上，使服务器故障不影响用户使用。\n2.1.5 缓存 大型网站架构设计在很多方面都使用了缓存设计\nCDN 反向代理 本地缓存 分布式缓存 使用缓存有两个前提条件\n一是数据访问热点不均衡，某些数据会被更频繁的访问，这些数据应该放在缓存中； 二是数据在某个时间段内有效，不会很快过期，否则缓存的数据就会因已经失效而产生脏读，影响结果的正确性。 网站应用中，缓存除了可以加快数据访问速度，还可以减轻后端应用和数据存储的负载压力，这一点对网站数据库架构至关重要，网站数据库几乎都是按照有缓存的前 提进行负载能力设计的。\n2.1.6 异步 异步架构是典型的生产者消费者模式，两者不存在直接调用，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站扩展新功能非常便利。除此 之外，使用异步消息队列还有如下特性。\n提高系统可用性。消费者服务器发生故障，数据会在消息队列服务器中存储堆积，生产者服务器可以继续处理业务请求，系统整体表现无故障。消费者服务器恢复正 常后，继续处理消息队列中的数据。 加快网站响应速度。处在业务处理前端的生产者服务器在处理完业务请求后，将数据写入消息队列，不需要等待消费者服务器处理就可以返回，响应延迟减少。 消除并发访问高峰。使用消息队列将突然增加的访问请求数据放入消息队列中，等待消费者服务器依次处理，就不会对整个网站负载造成太大压力。 但需要注意的是，使用异步方式处理业务可能会对用户体验、业务流程造成影响，需要网站产品设计方面的支持。\n2.1.7 冗余 要想保证在服务器宕机的情况下网站依然可以继续服务，不丢失数据，就需要一定程度的服务器冗余运行，数据冗余备份，这样当某台服务器宕机时，可以将其上的服 务和数据访问转移到其他机器上。\n数据库冷热备份 灾备数据中心 2.1.8 自动化 在无人值守的情况下网站可以正常运行，一切都可以自动化是网站的理想状态。目前大型网站的自动化架构设计主要集中在发布运维方面。\n发布过程自动化 自动化代码管理 自动化测试 自动化安全检测 自动化部署 自动化监控 自动化报警 自动化失效转移 自动化失效恢复 自动化降级 自动化分配资源 2.1.9 安全 网站在安全架构方面也积累了许多模式\n通过密码和手机校验码进行身份认证； 登录、交易等操作需要对网络通信进行加密，网站服务器上存储的敏感数据如用户信息等也进行加密处理； 为了防止机器人程序滥用网络资源攻击网站，网站使用验证码进行识别；对于常见的用于攻击网站的XSS攻击、SQL注入、进行编码转换等相应处理； 对于垃圾信息、敏感信息进行过滤； 对交易转账等重要操作根据交易模式和交易信息进行风险控制。 2.2 架构模式在新浪微博的应用 图2.1 新浪微博的系统架构\n在新浪微博的早期架构中，微博发布使用同步推模式，用户发表微博后系统会立即将这条微博插入到数据库所有粉丝的订阅列表中，当用户量比较大时，特别是明星用 户发布微博时，会引起大量的数据库写操作，超出数据库负载，系统性能急剧下降，用户响应延迟加剧。\n后来新浪微博改用异步推拉结合的模式，用户发表微博后系统将微博写入消息队列后立即返回，用户响应迅速，消息队列消费者任务将微博推送给所有当前在线粉丝的 订阅列表中，非在线用户登录后再根据关注列表拉取微博订阅列表。\n由于微博频繁刷新，新浪微博使用多级缓存策略，热门微博和明星用户的微博缓存在所有的微博服务器上，在线用户的微博和近期微博缓存在分布式缓存集群中，对于 微博操作中最常见的“刷微博”操作，几乎全部都是缓存访问操作，可以获得很好的系统性能。\n为了提高系统的整体可用性和性能，新浪微博启用了多个数据中心。\n这些数据中心既是地区用户访问中心，用户可以就近访问最近的数据中心以加快访问速度，改善系统性能； 同时也是数据冗余复制的灾备中心，所有的用户和微博数据通过远程消息系统在不同的数据中心之间同步，提高系统可用性。 新浪微博还开发了一系列自动化工具，包括自动化监控，自动化发布，自动化故障修复等，这些自动化工具还在持续开发中，以改善运维水平提高系统可用性。\n由于微博的开放特性，新浪微博也遇到了一系列的安全挑战，垃圾内容、僵尸粉、微博攻击从未停止，除了使用一般网站常见的安全策略，新浪微博在开放平台上使用 多级安全审核的策略以保护系统和用户。\n2.3 小结 好的设计绝对不是模仿，不是生搬硬套某个模式，而是对问题深刻理解之上的创造与创新，即使是“微创新”，也是让人耳目一新的似曾相识。山寨与创新的最大区别不 在于是否抄袭，是否模仿，而在于对问题和需求是否真正理解与把握。\n","permalink":"https://jdxj.github.io/posts/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E7%AC%AC1%E7%AF%87-%E6%A6%82%E8%BF%B0/2-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/","summary":"2.1 网站架构模式 2.1.1 分层 表2.1 网站分层架构 通过分层，可以更好地将一个庞大的软件系统切分成不同的部分，便于分工合作开发和维护；各层之间具有一定的","title":"2 大型网站架构模式"},{"content":"1.1 大型网站软件系统的特点 高并发，大流量 高可用 海量数据 用户分布广泛，网络情况复杂 安全环境恶劣 需求快速变更，发布频繁 渐进式发展 1.2 大型网站架构演化发展历程 1.2.1 初始阶段的网站架构 图1.1 初始阶段的网站架构\n应用程序、数据库、文件等所有的资源都在一台服务器上。\n1.2.2 应用服务和数据服务分离 图1.2 应用服务和数据服务分离\n应用和数据分离后整个网站使用三台服务器\n应用服务器需要处理大量的业务逻辑，因此需要更快更强大的CPU； 数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的硬盘和更大的内存； 文件服务器需要存储大量用户上传的文件，因此需要更大的硬盘。 网站又一次面临挑战：数据库压力太大导致访问延迟，进而影响整个网站的性能，用户体验受到影响。这时需要对网站架构进一步优化。\n1.2.3 使用缓存改善网站性能 图1.3 网站使用缓存\n网站使用的缓存可以分为两种\n本地缓存的访问速度更快一些，但是受应用服务器内存限制，其缓存数据量有限，而且会出现和应用程序争用内存的情况。 远程分布式缓存可以使用集群的方式，部署大内存的服务器作为专门的缓存服务器，可以在理论上做到不受内存容量限制的缓存服务 单一应用服务器能够处理的请求连接有限，在网站访问高峰期，应用服务器成为整个网站的瓶颈。\n1.2.4 使用应用服务器集群改善网站的并发处理能力 图1.4 应用服务器集群部署\n对网站架构而言，只要能通过增加一台服务器的方式改善负载压力，就可以以同样的方式持续增加服务器不断改善系统性能，从而实现系统的可伸缩性。应用服务器实 现集群是网站可伸缩集群架构设计中较为简单成熟的一种\n1.2.5 数据库读写分离 图1.5 数据库读写分离\n为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离对应用透明。\n1.2.6 使用反向代理和CDN加速网站响应 图1.6 网站使用反向代理和CDN加速访问\nCDN和反向代理的基本原理都是缓存，区别在于\nCDN部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据； 而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直 接返回给用户。 1.2.7 使用分布式文件系统和分布式数据库系统 图1.7 使用分布式文件和分布式数据库系统\n分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同业务的数 据库部署在不同的物理服务器上。\n1.2.8 使用NoSQL和搜索引擎 图1.8 使用NoSQL系统和搜索引擎\nNoSQL和搜索引擎都是源自互联网的技术手段，对可伸缩的分布式特性具有更好的支持。应用服务器则通过一个统一数据访问模块访问各种数据，减轻应用程序管理诸 多数据源的麻烦。\n1.2.9 业务拆分 图1.9 应用拆分\n1.2.10 分布式服务 图1.10 分布式服务\n既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。由这些可复用的业务连接数据库， 提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用共用业务服务完成具体业务操作\n1.3 大型网站架构演化的价值观 网站的价值在于它能为用户提供什么价值，在于网站能做什么，而不在于它是怎么做的，所以在网站还很小的时候就去追求网站的架构是舍本逐末，得不偿失的。小型 网站最需要做的就是为用户提供好的服务来创造价值，得到用户的认可，活下去，野蛮生长。\n1.3.1 大型网站架构技术的核心价值是随网站所需灵活应对 大型网站架构技术的核心价值不是从无到有搭建一个大型网站，而是能够伴随小型网站业务的逐步发展，慢慢地演化成一个大型网站。在这个漫长的技术演化过程中， 不需要放弃什么，不需要推翻什么，不需要剧烈的革命，就那么润物细无声地把一个只有一台服务器，几百个用户的小网站演化成一个几十万台服务器，数十亿用户的 大网站。\n1.3.2 驱动大型网站技术发展的主要力量是网站的业务发展 创新的业务发展模式对网站架构逐步提出更高要求，才使得创新的网站架构得以发展成熟。是业务成就了技术，是事业成就了人，而不是相反。\n1.4 网站架构设计误区 1.4.1 一味追随大公司的解决方案 大公司的经验和成功模式固然重要，值得学习借鉴，但如果因此而变得盲从，就失去了坚持自我的勇气，在架构演化的道路上迟早会迷路。\n1.4.2 为了技术而技术 网站技术是为业务而存在的，除此毫无意义。在技术选型和架构设计中，脱离网站业务发展的实际，一味追求时髦的新技术，可能会将网站技术发展引入崎岖小道，架 构之路越走越难。\n1.4.3 企图用技术解决所有问题 技术是用来解决业务问题的，而业务的问题，也可以通过业务的手段去解决。\n1.5 小结 网站架构技术演化过程难以重现，所以网站架构师更应该对这个过程深刻了解，理解已成熟的网站架构技术方案的来龙去脉和历史渊源，在技术选型和架构决策时才能 有的放矢，直击要害。\n","permalink":"https://jdxj.github.io/posts/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E7%AC%AC1%E7%AF%87-%E6%A6%82%E8%BF%B0/1-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96/","summary":"1.1 大型网站软件系统的特点 高并发，大流量 高可用 海量数据 用户分布广泛，网络情况复杂 安全环境恶劣 需求快速变更，发布频繁 渐进式发展 1.2 大型网站架构演化","title":"1 大型网站架构演化"},{"content":"实战思维 需要动手实践 学习节奏 推进学习进度要考虑知识难易程度 收集反馈 深度学习 思考背后的逻辑是什么 复盘 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%8A%9B/","summary":"实战思维 需要动手实践 学习节奏 推进学习进度要考虑知识难易程度 收集反馈 深度学习 思考背后的逻辑是什么 复盘","title":"学习能力"},{"content":"大量的重复训练 看别人解决问题的思路，不断地模仿练习 在有一定的知识积淀以后，自己不断地尝试解决问题，实现目标 学习经典计算机语言 努力地提高交流水平才是我们应该关心的，而不是研究说话的语法。 关注行业“大牛”的技术博客 审视和观察行业的动向、技术的更新等。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/%E5%A6%82%E4%BD%95%E6%8B%A5%E6%9C%89%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4/","summary":"大量的重复训练 看别人解决问题的思路，不断地模仿练习 在有一定的知识积淀以后，自己不断地尝试解决问题，实现目标 学习经典计算机语言 努力地提高交流水","title":"如何拥有编程思维"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/colobu/regexp/","summary":"原文","title":"[译]Go正则表达式示例"},{"content":"与正则表达式有关的问题很少会有什么终极答案。\n11.6 IP地址 (((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(25[0-5]))\\.){3} ➥((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(25[0-5])) 11.7 URL https?:\\/\\/[-\\w.]+(:\\d+)?(\\/([\\w\\/_.]*)?)? 11.8 完整的URL https?:\\/\\/(\\w*:\\w*@)?[-\\w.]+(:\\d+)?(\\/([\\w\\/_.]*(\\?\\S+)?)?)? 就性能来说，越复杂的模式，执行速度越慢。\n11.9 电子邮件地址 (\\w+\\.)*\\w+@(\\w+\\.)+[A-Za-z]+ ","permalink":"https://jdxj.github.io/posts/books/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%AC%AC11%E7%AB%A0-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","summary":"与正则表达式有关的问题很少会有什么终极答案。 11.6 IP地址 (((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(25[0-5]))\\.){3} ➥((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(25[0-5]))","title":"第11章 常见问题的正则表达式解决方案"},{"content":"在表达式的内部嵌入条件处理。\n10.1 为什么要嵌入条件 并非所有的正则表达式实现都支持条件处理。\n10.2 正则表达式里的条件 10.2.1　反向引用条件 用来定义这种条件的语法是(?(backreference)true)，其中?表明这是一个条件，括号里的backreference是一个反向引用，仅当反向引用立即出现时，才对表 达式求值。\n文本\n1 2 3 4 5 6 7 8 \u0026lt;!-- Nav bar --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;a href=\u0026#34;/home\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/images/home.gif\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;img src=\u0026#34;/images/spacer.gif\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/search\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/images/search.gif\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;img src=\u0026#34;/images/spacer.gif\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/help\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/images/help.gif\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 正则\n(\u0026lt;[Aa]\\s+[^\u0026gt;]+\u0026gt;\\s*)?\u0026lt;[Ii][Mm][Gg]\\s+[^\u0026gt;]+\u0026gt;(?(1)\\s*\u0026lt;\\/[Aa]\u0026gt;) (\u0026lt;[Aa]\\s+[^\u0026gt;]+\u0026gt;\\s*)?匹配一个\u0026lt;A\u0026gt;或\u0026lt;a\u0026gt;标签（以及可能存在的任意属性），这个标签可有可无 \u0026lt;[Ii][Mm][Gg]\\s+[^\u0026gt;]+\u0026gt;匹配一个\u0026lt;img\u0026gt;标签（大小写均可）及其任意属性。 (?(1)\\s*\u0026lt;\\/[Aa]\u0026gt;)的起始部分是一个条件: ?(1)表示仅当第一个反向引用（\u0026lt;A\u0026gt;标签）存在，才继续匹配\\s*\u0026lt;\\/[Aa]\u0026gt; 在条件里，反向引用编号（本例中的1）在条件中不需要被转义。\n条件还可以有else表达式, 语法是(?(backreference)true|false)。\n此语法接受一个条件和两个分别在符合/不符合该条件时执行的表达式。 (\\()?\\d{3}(?(1)\\)|-)\\d{3}-\\d{4} 10.2.2 环视条件 环视条件允许根据向前查看或向后查看操作是否成功来决定要不要执行表达式。\n环视条件的语法与反向引用条件的语法大同小异，只需把反向引用（括号里的反向引用编号）替换为一个完整的环视表达式就行了。\n文本\n1 2 3 4 11111 22222 33333- 44444-4444 正则\n(?#会把33333-也匹配上) \\d{5}(-\\d{4})? (?#排除33333-) \\d{5}(?(?=-)-\\d{4}) 10.3 小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%AC%AC10%E7%AB%A0-%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9D%A1%E4%BB%B6/","summary":"在表达式的内部嵌入条件处理。 10.1 为什么要嵌入条件 并非所有的正则表达式实现都支持条件处理。 10.2 正则表达式里的条件 10.2.1 反向引用条件 用来定义这种条件的语","title":"第10章 嵌入式条件"},{"content":"9.1 环视简介 明知是自己不需要的东西，还把它们检索出来，然后再手动删除，这种做法毫无意义。你真正需要的是想办法构造出一种模式，该模式中包含一些不用被返回的匹配—— 这些匹配是为了找出正确的匹配位置，其自身不属于最终的匹配结果。换句话说，你需要进行“环视”。\n9.2 向前查看 向前查看其实就是一个子表达式, 向前查看模式的语法是一个以?=开头的子表达式，需要匹配的文本跟在=的后面。\n.+(?=:) 任何子表达式都可以转换为向前查看表达式，只要在其之前加上一个?=即可。在同一个搜索模式里可以使用多个向前查看表达式，出现的位置没有任何限制\n9.3 向后查看 向后查看操作符?\u0026lt;=\n它必须出现在一个子表达式里，后面跟随要匹配的文本。\n(?\u0026lt;=\\$)[0-9.]+ 向前查看模式的长度是可变的，其中可以包含.和+等量词，所以非常灵活。向后查看模式则只能是固定长度。几乎所有的正则表达式实现都有此限制。\n9.4 结合向前查看和向后查看 (?\u0026lt;=\u0026lt;[tT][iI][tT][lL][eE]\u0026gt;).*(?=\u0026lt;/[tT][iI][tT][lL][eE]\u0026gt;) 9.5 否定式环视 表9-1　各种环视操作\n(?\u0026lt;=\\$)\\d+ \\b(?\u0026lt;!\\$)\\d+\\b 9.6 小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%AC%AC9%E7%AB%A0-%E7%8E%AF%E8%A7%86/","summary":"lookaround","title":"第9章 环视"},{"content":"8.1 理解反向引用 \u0026lt;[hH][1-6]\u0026gt;.*?\u0026lt;\\/[hH][1-6]\u0026gt; 结束标签对应该匹配的起始标签一无所知\n8.2 反向引用匹配 反向引用允许正则表达式模式引用之前匹配的结果\n[ ]+(\\w+)[ ]+\\1 \\1匹配的内容与第一个分组匹配的内容一样。\n\u0026lt;[hH]([1-6])\u0026gt;.*?\u0026lt;\\/[hH]\\1\u0026gt; 在许多实现里，第0个匹配（\\0）可以用来代表整个正则表达式。\n这种语法存在着一个严重的不足：移动或编辑子表达式（子表达式的位置会因此改变）可能会使模式失效 为了弥补这一不足，一些比较新的正则表达式实现还支持“命名捕获”（named capture）：给某个子表达式起一个唯一的名称，随后用该名称（而不是相对位置） 来引用这个子表达式。 8.3 替换操作 (\\w+[\\w\\.]*@[\\w\\.]+\\.\\w+) \u0026lt;a href=\u0026#34;mailto:$1\u0026#34;\u0026gt;$1\u0026lt;/a\u0026gt; 你需要根据所使用的正则表达式实现修改反向引用指示符。\n大小写转换 表8-1　用来进行大小写转换的元字符\n(\u0026lt;[Hh]1\u0026gt;)(.*?)(\u0026lt;\\/[Hh]1\u0026gt;) $1\\U$2\\E$3 8.4　小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%AC%AC8%E7%AB%A0-%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8/","summary":"backreference","title":"第8章 反向引用"},{"content":"7.1 理解子表达式 用来表明重复次数的元字符（例如，?或*或{2}）只作用于紧挨着它的前一个字符或元字符。\n7.2 使用子表达式进行分组 子表达式是更长的表达式的一部分。划分子表达式的目的是为了将其视为单一的实体来使用。子表达式必须出现在字符(和)之间。\n(\u0026amp;nbsp;){2,} (\\d{1,3}\\.){3}\\d{1,3} 正则里也有操作符优先级\n(19|20)\\d{2} 7.3 子表达式的嵌套 子表达式还可以多重嵌套\n写一个能够匹配预期内容的正则表达式并不难。但是写一个能够考虑到所有可能场景，确保将不需要匹配的内容排除在外的正则表达式可就难多了。\n(((25[0-5])|(2[0-4]\\d)|(1\\d{2})|(\\d{1,2}))\\.){3} ➥(((25[0-5])|(2[0-4]\\d)|(1\\d{2})|(\\d{1,2}))) 只要有任何模式匹配，就不再测试选择结构中的其他模式。\n7.4 小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%AC%AC7%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"subexpression","title":"第7章 使用子表达式"},{"content":"6.1 边界 位置匹配用于指定应该在文本中什么地方进行匹配操作。\n6.2 单词边界 \\bcat\\b \\b匹配的是字符之间的一个位置：一边是单词（能够被\\w匹配的字母数字字符和下划线），另一边是其他内容（能够被\\W匹配的字符）。\n如果你不想匹配单词边界，那么可以使用\\B\n\\B-\\B 6.3 字符串边界 ^\\s*\u0026lt;\\?xml.*\\?\u0026gt; \u0026lt;/[Hh][Tt][Mm][Ll]\u0026gt;\\s*$ 多行模式 (?m)\n在使用时，(?m)必须出现在整个模式的最前面 (?m)^\\s*\\/\\/.*$ 6.4 小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%AC%AC6%E7%AB%A0-%E4%BD%8D%E7%BD%AE%E5%8C%B9%E9%85%8D/","summary":"6.1 边界 位置匹配用于指定应该在文本中什么地方进行匹配操作。 6.2 单词边界 \\bcat\\b \\b匹配的是字符之间的一个位置：一边是单词（能够被\\w匹配的字母数字字符","title":"第6章 位置匹配"},{"content":"5.1 有多少个匹配 5.1.1 匹配一个或多个字符 电子邮件地址\n[\\w.]+@[\\w.]+\\.\\w+ 5.1.2 匹配零个或多个字符 \\w+[\\w.]*@[\\w.]+\\.\\w+ 5.1.3 匹配零个或一个字符 https?:\\/\\/[\\w.\\/]+ [\\r]?\\n[\\r]?\\n 5.2 匹配的重复次数 即使你没有对{和}进行转义，大部分正则表达式实现也能正确地处理它们（根据具体情况把它们解释为普通字符或元字符）。话虽如此，为了避免不必要的麻烦，最好 不要依赖这种行为。\n5.2.1 具体的重复匹配 #[A-Fa-f0-9]{6} 5.2.2 区间范围 \\d{1,2}[-\\/]\\d{1,2}[-\\/]\\d{2,4} 在这个例子里，我们使用了/的转义序列/。这在许多正则表达式实现里是不必要的，但有些正则表达式解析器要求必须这样做。为避免不必要的麻烦，在需要匹配/ 字符本身的时候，最好总是使用它的转义序列。\n5.2.3 匹配“至少重复多少次” \\d+: \\$\\d{3,}\\.\\d{2} 5.3 防止过度匹配 \u0026lt;[Bb]\u0026gt;.*\u0026lt;\\/[Bb]\u0026gt; *和+都是所谓的“贪婪型”（greedy）元字符，其匹配行为是多多益善而不是适可而止。它们会尽可能地从一段文本的开头一直匹配到末尾，而不是碰到第一个匹配时 就停止。\n量词就是贪婪的 懒惰型量词的写法是在贪婪型量词后面加上一个? 表5-1　贪婪型量词和懒惰型量词\n5.4 小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%AC%AC5%E7%AB%A0-%E9%87%8D%E5%A4%8D%E5%8C%B9%E9%85%8D/","summary":"5.1 有多少个匹配 5.1.1 匹配一个或多个字符 电子邮件地址 [\\w.]+@[\\w.]+\\.\\w+ 5.1.2 匹配零个或多个字符 \\w+[\\w.]*@[\\w.]+\\.\\w+ 5.1.3 匹配零个或一个字符 https?:\\/\\/[\\w.\\/]+ [\\r]?\\n[\\r]?\\n 5.2 匹配的重复次数 即使你没有对{和}进行转义，大","title":"第5章 重复匹配"},{"content":"4.1 再谈转义 \\.匹配.，\\[匹配[。每个元字符都可以通过在前面加上一个反斜杠的方法来转义，这样匹配的就是该字符本身而不是其特殊的元字符含义。\n4.2 匹配空白字符 表4-1 空白元字符\n在使用正则表达式匹配行尾标记时，一定要注意文本文件所在的操作系统。\n4.3 匹配特定的字符类型 4.3.1 匹配数字（与非数字） 表4-2　数字元字符\n4.3.2 匹配字母数字（与非字母数字） 表4-3　字母数字元字符\n4.3.3 匹配空白字符（与非空白字符） 表4-4　空白字符元字符\n4.3.4 匹配十六进制或八进制数值 使用ASCII匹配字符\n(?#\\n) \\x0A (?#\\t) \\011 4.4 使用POSIX字符类 表4-5 POSIX字符类\n这里使用的模式以[[开头、以]]结束（两对方括号）。这是使用POSIX字符类所必需的.\n外层的[和]字符用来定义一个字符集合，内层的[和]字符是POSIX字符类本身的组成部分。 #[[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]] ➥[[:xdigit:]] 4.5 小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%AC%AC4%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%85%83%E5%AD%97%E7%AC%A6/","summary":"4.1 再谈转义 \\.匹配.，\\[匹配[。每个元字符都可以通过在前面加上一个反斜杠的方法来转义，这样匹配的就是该字符本身而不是其特殊的元字符含义。 4.2","title":"第4章 使用元字符"},{"content":"3.1 匹配多个字符中的某一个 [ns]a.\\.xls 验证某个模式能不能获得预期的匹配结果并不困难，但如何验证它不会匹配到你不想要的东西可就没那么简单了。\n(?#这种模式最适合用在从全局看需要区分字母大小写，但在某个局部不需要区分字母大小写的搜索操作里。) [Rr]eg[Ee]x 3.2 利用字符集合区间 字符区间的首、尾字符可以是ASCII字符表里的任意字符。但在实际工作中，最常用的字符区间还是数字字符区间和字母字符区间。\n[ns]a[0123456789]\\.xls [ns]a[0-9]\\.xls 在定义一个字符区间的时候，一定要避免让这个区间的尾字符小于它的首字符（例如[3-1]）。这种区间是没有意义的，而且往往会让整个模式失效。\n-（连字符）是一个特殊的元字符，它只有出现在[和]之间的时候才是元字符。在字符集合以外的地方，-只是一个普通字符，只能与-本身相匹配。因此，在正则表达 式里，-字符不需要被转义。\n在同一个字符集合里可以给出多个字符区间。\n[A-Za-z0-9] (?#RGB) #[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f] 3.3 排除 [ns]a[^0-9]\\.xls ^的效果将作用于给定字符集合里的所有字符或字符区间，而不是仅限于紧跟在^字符后面的那一个字符或字符区间。\n3.4 小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%AC%AC3%E7%AB%A0-%E5%8C%B9%E9%85%8D%E4%B8%80%E7%BB%84%E5%AD%97%E7%AC%A6/","summary":"3.1 匹配多个字符中的某一个 [ns]a.\\.xls 验证某个模式能不能获得预期的匹配结果并不困难，但如何验证它不会匹配到你不想要的东西可就没那么简单了。 (?#这种模式","title":"第3章 匹配一组字符"},{"content":"2.1 匹配普通文本 正则表达式可以包含普通文本（甚至可以只包含普通文本）。\n2.1.1 有多少个匹配结果 绝大多数正则表达式的实现都提供了一种能够获得所有匹配结果的机制（通常以数组或是其他的特殊格式形式返回）。\n2.1.2 字母的大小写问题 绝大多数正则表达式的实现也支持不区分字母大小写的匹配操作。\n2.2 匹配任意字符 正则表达式c.t可以匹配到cat和cot\n2.3 匹配特殊字符 \\\n在绝大多数的正则表达式实现里，.就不能匹配换行符。\n2.4 小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%AC%AC2%E7%AB%A0-%E5%8C%B9%E9%85%8D%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6/","summary":"2.1 匹配普通文本 正则表达式可以包含普通文本（甚至可以只包含普通文本）。 2.1.1 有多少个匹配结果 绝大多数正则表达式的实现都提供了一种能够获得所有匹配结","title":"第2章 匹配单个字符"},{"content":"1.1 正则表达式的用途 1.2 如何使用正则表达式 给定一个正则表达式，它要么匹配一些文本（进行一次搜索），要么匹配并替换一些文本（进行一次替换）。\n1.2.1 用正则表达式进行搜索 1.2.2 用正则表达式进行替换 1.3 什么是正则表达式 请注意，语法是正则表达式最容易掌握的部分，真正的挑战在于如何运用语法，如何把实际问题分解为可由正则表达式解决的子问题。\n1.4 使用正则表达式 并非所有的正则表达式实现都是一样的。在不同的应用程序/语言里，正则表达式的语法和功能往往会有明显（有时也不那么明显）的差异。\n1.5 在继续学习之前 同一个问题往往会有多种解决方案。\n1.6 小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%AC%AC1%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/","summary":"1.1 正则表达式的用途 1.2 如何使用正则表达式 给定一个正则表达式，它要么匹配一些文本（进行一次搜索），要么匹配并替换一些文本（进行一次替换）。 1.2.1 用正","title":"第1章 正则表达式入门"},{"content":"总体路径：先框架，后细节\n语法书: 英语语法新思维\n1 单词与分句 1.1 分句 单词聚合在一起，首先构成的单位是分句（clause），分句通常要经过一定的处理，才能成为真正意义上的句子（sentence）。分句可以理解为原始状态的句子， 一般不独立使用。\n分句的范畴比句子更小。 分句不一定是句子。有些分句可以不经处理直接当作简单句使用，属于句子。而有些分句不作简单句，只是并列句或复合句的一部分。 句子一定是分句（如简单句，它有且只有一个分句），或包含了若干分句（如并列句、复合句）。 1.2 分句中的成分 构成分句的单词也有多重身份，第一重为词性, 第二重是成分\n分句中的成分一共有7种：主语、谓语、宾语、表语、定语、状语、宾语补足语。它们的地位各不相同，前4种是核心成分，后3种为非核心成分（或修饰成分）。非核 心成分通常用于服务核心成分。\n1. 主语\n动作的发出者；核心成分，主要由名词、代词充当。\n例如：The native hadoop library is supported on *nix platforms only.\n这个句子中，hadoop library是主语。\n2. 谓语\n指动作或状态，与主语是搭档；核心成分，由动词充当。\n例如：In other words super is impersonating the user joe.\n其中，is impersonating是谓语。\n3. 宾语\n动作的承受者；核心成分，主要由名词、代词充当。\n例如：上个分句中，the user joe是宾语。\n宾语实际上与主语的性质相同，只是位置不一样。\n4. 表语\n说明主语的状态或特征，核心成分；一般在系动词后面；be动词是最常见的一种系动词（进行时动态中的be除外）；主要由形容词、名词充当。\n例如：Hadoop components are rack-aware.\n其中，rack-aware是表语。\n5. 定语\n主要用于修饰、限定名词，非核心成分；一个分句里可能有n个（n≥0）；形式多样，可由形容词、名词、介词短语（通常是“介词+名词”结构）、分词短语、分句（从 句）等充当；主要在被修饰的对象前面，有时在后面。\n例1：KMS caches encryption keys for a short period of time to avoid excessive hits to the underlying KeyProvider.\n这个分句的定语有：\nencryption short excessive underlying 例2：Pipelining is not just a way to reduce the latency cost associated with the round trip time\u0026hellip;\n定语有：\nto reduce the latency cost（不定式短语，修饰way） associated with the round trip time（过去分词短语，修饰cost） 6. 状语\n主要用于修饰动词、分句，有时修饰形容词和副词；非核心成分；一个分句中可能有n个（n≥0）；类型很多，如方式状语、地点状语、目的状语；主要由副词、介词 短语（与做定语时，性质不一样）、从句等充当。\n例如：In both approaches, KMS instances must be specially configured to work properly as a single logical service\u0026hellip;\n这个分句的状语有：\nIn both approaches specially to work properly（properly本身也是状语） as a single logical service 7. 宾语补足语\n简称“宾补”，用于补充说明宾语的特征。要找到它，得先找到宾语；非核心成分，在技术文档中不多见；主要由形容词充当。\n例如： Nfly mount points make it possible\u0026hellip;\n这个分句中，宾语是it, 宾语补足语是possible.\n分句成分综合分析\ncase1:\ncase2:\n小结\n1.3 分句及其分类 前面说的7种成分，都可以在分句中出现，但不是都必须出现。只有主语、谓语（或系动词、表语）对于分句必不可少（祈使句除外），并且只有一个主语、一个谓语 （如果出现并列主语、并列谓语，整体上当作一个）。\n分句有两类：独立分句（independent clause）、从属分句（dependent clause）。\n如果一个分句能够独立地表述一件事，那么它是独立分句，单独拎出来在语法上通常也是正确的。 意思没表达完、不是独立存在（跟在某个从属连词之后）的分句，是从属分句。例如这个句子： 1 However, if you delete the object, you can make a new object with the same name. 1.4 基本句型 主语＋谓语＋宾语, 什么人（或物）做了什么事。\nThe Streams API allows transforming streams of data from input topics to output topics. Kafka works well as a replacement for a more traditional message broker. 主语＋系动词＋表语, 什么人（或物）是怎样的\nEvent streaming is the digital equivalent of the human body\u0026rsquo;s central nervous system. 主语＋谓语＋间接宾语＋直接宾语\nLog compaction gives us a more granular retention mechanism \u0026hellip; 主语＋谓语＋宾语＋宾补\nThis makes it less likely to \u0026ldquo;lose\u0026rdquo; offsets in an application that commits infrequently. 2 句子及其分类 2.1 简单句 只有一套“主语+谓语+宾语”（或“主语+系动词+表语”）\n有些简单句又长又复杂，比复合句都难。\n2.2 并列句 包含两个或更多的独立分句，即有多套“主语+谓语+宾语”（或“主语+系动词+表语”）。并列句中的独立分句之间，地位是平等的。通常用and,but, or, so等并列连词，把这些分句合并在一起。\nIn production environments, the control plane usually runs across multiple computers and a cluster usually runs multiple nodes\u0026hellip; 不是出现了并列连词的句子就一定是并列句。并列连词前后可能接的是某个词或短语，这样不算并列句，要接分句才算。\nShared labels and annotations share a common prefix:app.kubernetes.io. 也不是并列句，and连接的是2个并列谓语：checks, fetches.\nThis command checks that your cluster can be upgraded, and fetches the versions you can upgrade to. 这才是并列句\nYou need to have a Kubernetes cluster, and the kubectl command-line tool must be configured to communicate with your cluster. 2.3 复合句 复合句有且只有一个独立分句（主句），至少有一个从属分句（从句）。\n分句之间一般通过if, that, who, which, when等引导词建立联系。跟在这些引导词之后的是从句，没跟在其后的是主句（引导词省略的情况除外）。\nWhen you create the Deployment, you might set the Deployment spec to specify that you want three replicas of the application to be running. 主从复合句中，有一些从句似乎不是完整的分句，缺少成分。实际上这些从句是完整的，只是它们的主语或宾语，不是常规情况下由名词或代词充当，而是引导词本身 充当了。\nThe kubelet doesn\u0026rsquo;t manage containers which were not created by Kubernetes. 从句的分类\n定语从句\n由于定语一般由形容词充当，所以定语从句可以看作横向发展有点过分的形容词，或称为“大号形容词”，用于修饰它前面（有时是后面）的某个词或句子。定语从 句与被修饰的内容，不一定紧挨着，中间可能有其他词隔开。 When using Server-Side Apply, trying to change a field which is managed by someone else will result in a rejected request (if not forced, see Conflicts). 定语从句修饰field，说明它的特点。 Finally, when using the apply operation you cannot have managedFields in the object that is being applied. 定语从句修饰object. 名词性从句\n性质相当于名词，可理解为“大号名词”。这种从句又有常见的3个子类：\n主语从句, 整个从句充当主句的主语。\nWhat fits best will depend on what that particular controller does. 宾语从句, 从句充当主句中某个动词或介词的宾语。\nThis means that generic implementations had to be in place for types unrecognized by a client. What we have highlighted here is just a taste of what you might expect in the future. 表语从句, 从句充当主句的表语。\nAn issue that comes up rather frequently for new installations of Kubernetes is that a Service is not working properly. 状语从句\n状语通常由副词充当，状语从句则相当于“大号副词”，用于说明主句所描述的事件的时间、条件、目的等。\nHowever, if you delete the object, you can make a new object with the same name. When a field\u0026rsquo;s value changes, ownership moves from its current manager to the manager making the change. 2.4 既含有并列句，又包括复合句 (If an object matches the query, and it does not have a configuration file in the directory, and it has a last-applied-configuration annotation), it is deleted.\n小结\n主要的句子类型\n复合句中从句的主要类型\n3 词语、分句的顺序 3.1 分句、简单句中词语的顺序 分句中的核心成分（主、谓、宾）在顺序方面，英文和中文一致，都使用了SVO结构，即“主语+（谓语）动词+宾语”，动作的发出者（主语）、动作（动词）、动作的 承受者（宾语），依次出场。\n英文分句一旦包含若干修饰成分，尤其是短语形式的，词语的顺序相对中文句子就容易呈现较大的差异。总体而言，在中文句子中，次要的修饰成分先出场，而英文分 句倾向于核心成分先露面，开门见山，不来含蓄那一套。\n3.2 并列句中分句的顺序 英文并列句和中文并列句，在分句之间的排序上几乎一致。\n至于分句内部，如果出现了“违和感指数”较高的词语，参考上一小节内容进行处理。\n3.3 复合句中分句的顺序 名词性从句这种从句是主句的一部分，除了极少数特殊形式，其顺序与中文一致，所以理解的时候感觉自然，“违和感指数”低。\n状语从句它“行踪灵活”，一会儿在主句前面，一会儿在它后面。\n“违和感指数”最高的，非定语从句莫属。它一般位于被修饰的词或句子后面，而中文当中我们不会这样讲话，我们通常会先说修饰的内容。\n4 时态 在编写技术文档的时候，绝大多数时候只用一种时态：一般现在时。这个时态很简单，所以英文文档在时态上是不复杂的。\n时态的含义：在某个时间点或时间段，某个动作呈现的状态。除了特殊情形，分句一般都可以归入某种时态。有些句子包含了多个分句，那么这样的句子可能会出现好 几种时态。因此，要以分句为单位判断时态。\n4.1 一般现在时 一般现在时用来描述目前的动作或状态，强调的是当前一般的情况。如果主语不是第三人称单数（如I, they），动词就用它本来的形式（原形）；若主语是第三人称 单数（如he, she, it及单个的人或物），动词末尾要加s或es。\n4.2 开发中的其他时态 技术文档中偶尔也会出现这4种时态：一般过去时、一般将来时、现在进行时、现在完成时。其他时态在技术文档中出现得更少。\n一般过去时\n表示过去发生了的事情；动词的形式为过去式，多数由词尾加ed构成，少数是不规则的，与原形的长相差别很大。\n由于词尾加了ed的动词，可能是过去式，也可能是过去分词，如果一个句子中存在这种形式的动词，不能认为该句子使用的就是一般过去时。\n一般将来时\n描述将要发生的动作；动词的形式为：will + 动词原形，或am/is/are +going to + 动词原形。注意后者出现了ing，不要把它当作现在进行时。\n现在进行时\n指现在这个瞬间或现阶段，正在发生的动作。它的基本结构是：am/is/are + 动词ing形式。不是一个句子中有动词末尾加了ing，这个句子就一定是现在进行时， 它可能是个非谓语动词\n现在完成时\n表示到目前为止已经完成了什么事情，基本结构是：have/has + 动词的过去分词。其中have/has不能翻译为“有”，它们在这种时态中没有什么含义。过去分词类 似过去式，多数由词尾加ed构成，少数是不规则的。\n4.3 时态的判断 时态的基本结构汇总\n5 被动语态 被动语态在英文文档中很常见，它与时态密切相关，在时态的基础上确立对应的基本结构。\n文档中使用主动语态的句子，在时态上大多是一般现在时，被动语态的句子也是类似情况。一般过去时、一般将来时、现在完成时、含情态动词的被动语态句子，也有 时会出现。\n被动语态的基本结构是：be + 动词的过去分词。结合具体的时态后，这个结构会作相应的调整。理解含义时，加上一个“被”字。\n5.1 开发中最常见的被动语态 一般现在时的被动。基本结构：am/is/are + 过去分词\n5.2 开发中出现的其他被动语态 一般过去时的被动基本结构：was/were + 过去分词\n一般将来时的被动基本结构：will be + 过去分词，或am/is/are + going to be + 过去分词.\n现在完成时的被动基本结构：have/has been + 过去分词\n含情态动词的被动基本结构：情态动词can/may/should等 + be + 过去分词\n被动语态的基本结构表格\n6 非谓语动词 一个分句只有一套“主语+谓语（+宾语）”或“主语+系动词+表语”，其核心成分谓语动词（或系动词），也只有一个（或一套，多个动词构成并列谓语）。\n除了谓语动词，其他动词也可以存在于一个分句中，只是地位更低，并且在形式上有所变化。这类不是谓语的动词，被称为“非谓语动词”，在分句中可能出现，也可能 不出现，看表达的需要。\n非谓语动词包含以下三类：\n动词不定式（to+动词原形） 动词ing（动名词或现在分词） 过去分词 动词不定式（to+动词原形）\n动词不定式通常带有to（也有些不带to，这里只讨论带to的情况），并且to后面接动词才是不定式，接名词等其他词就不是。不定式在分句中除了不能做谓语，其他 成分都能充当。不过它最常充当的成分是状语，表示做某件事情的目的，事情还没发生。\n动词ing（动名词或现在分词）\n动名词兼具名词、动词的特征，它后面可像动词一样接名词，构成“发出动作与承受当作”的关系。 也有时候，动词没“投奔”到名词阵营，而是去跟形容词“厮混”，沾上了一些形容词的特征，变为现在分词，也“夹着一根尾巴（ing）”。 单独使用的情况下，现在分词不能作主语、宾语，其他成分像表语、定语、宾语补足语、状语都能充当。 过去分词\n过去分词与现在分词性质类似，单独情况下，能充当表语、定语、宾语补足语、状语，但不能作主语、宾语。在技术文档中，过去分词主要作定语，表示被动或动作已 完成。\n","permalink":"https://jdxj.github.io/posts/books/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8B%B1%E8%AF%AD/%E7%9C%8B%E6%87%82%E5%8F%A5%E5%AD%90/","summary":"总体路径：先框架，后细节 语法书: 英语语法新思维 1 单词与分句 1.1 分句 单词聚合在一起，首先构成的单位是分句（clause），分句通常要经过一定的处","title":"看懂句子"},{"content":"别让单词搞事情，优先拿下高频词 单词量 单词词性 单词原型 记单词的实用方法 根据读音记 b站搜索BBC音标教程 学音标的时候，重点放在与拼音发音差异很大的音标上 韵母VS元音\n与韵母外形一样或部分类似的元音（17个） 韵母a, o, e, i, u\n元音/ɑ:/,/æ/,/ɒ/,/ɔ:/,/e/,/i:/,/ɪ/,/u:/,/ʊ/\n韵母ai, ei, ie, ao, ou\n元音/aɪ/,/eɪ/,/ɪə/,/eə/,/ʊə/,/ɔɪ/,/əʊ/,/aʊ/\n与韵母差异很大的元音（3个） /ɜ:/,/ʌ/,/ə/\n声母VS辅音\n和声母外形一样或类似的辅音（16个，大部分发音接近） 韵母b, p, m, f, d, t, n, l, g, k, h, j, r, z, s, w\n辅音/b/,/p/,/m/,/f/,/d/,/t/,/n/,/ǀ/,/g/,/k/,/h/,/j/,/r/,/z/,/s/,/w/\n和声母差异很大的辅音（12个） /θ/,/v/,/ð/,/ʃ/,/ŋ/,/ʒ/,/ts/,/tʃ/,/tr/,/dz/,/dʒ/,/dr/\n根据前缀后缀记 一个单词可以同时拥有前缀和后缀，并且数量可能不止一个\n常见前缀\ndis-表示否定或相反的 disabled 禁用的 im-表示否定 immutable 不可变的 in-表示否定 invalid 无效的 mis-表示否定或有误 mismatch 不匹配 multi-“多\u0026hellip;\u0026hellip;” multicast 多点广播 over-“在\u0026hellip;\u0026hellip;之上；过多的” override 重写 re-“重新，再，又” reset 重设 un-表示否定 unchecked 未检查的 常见后缀\n名词后缀\n-age 表示性质或状态 package 包 -ance 表示性质或状态 performance 性能 -er 表示人或物 browser 浏览器 -ity 表示性质或状态 accessibility 可访问性 -ment 表示性质或状态 enhancement 加强 -ness 表示性质或状态 randomness 随机性 -tion/ion 表示性质或状态 annotation 注解, compression 压缩 -or 表示人或物 authenticator 验证器 动词后缀\n-ate “使\u0026hellip;\u0026hellip;化” instantiate 实例化 -ify “使\u0026hellip;\u0026hellip;化” identify 识别 -ize “使\u0026hellip;\u0026hellip;化” serialize 序列化 形容词后缀\n都表示“\u0026hellip;\u0026hellip;的”\n-al additional 额外的 -ble/-able accessible 可访问的 -ive assistive 断言的 -ous instantaneous 瞬时的 副词后缀\n-ly “\u0026hellip;\u0026hellip;地”，表示动作的方式 automatically 自动地 长单词分段记 比较长的单词整体上一下子记下来，可能有点难度，不妨分成几段来记，比如infrastructure，可以分成：in, fra, struc, ture.\n重复去记 一回生，二回自然熟！\n必备技能 技能C1：快速领会单词含义 领会的时候，不用思考甚至纠结用哪个中文词语，来准确翻译对应的英文单词，只需快速感受单词所代表的事物、动作或状态，即“只用意会，无需言传”。\n技能C2：快速、准确判断单词的词性 名词：表示万事万物的名称或性质。例词：accelerator（加速器） 冠词：放在名词前，表示特定还是非特定的。例词：总共有3个，a/an（非特定）, the（特定的） 代词：主要用来代替名词。例词：they（它们） 数词：表示数量或顺序。例词：million（百万） 形容词：主要修饰名词，表示它的特点。例词：random（随机的） 介词：表示名词和其它词之间的关系，类似中介。例词：provide implementations for the iterator中的for（为\u0026hellip;\u0026hellip;） 连词：用来连接词和词、短语和短语、句子和句子。例词：array-based and collection-based APIs中的and（和） 动词：主要表示动作，或与动作相关的状态。例词：extend（扩展） 副词：主要修饰动词，表示它的特征。例词：abstractly（抽象地） 感叹词：表示强烈情感的词。最不重要的一种词，在开发相关的书面资料上几乎没有。 技能C3：一眼看出单词的构成 这里需要看出结构的单词，主要指运用驼峰命名法造出来的类名、方法名或接口名等等。在文档中遇到它们，要一眼看出由哪些单词拼成，通过每个单词的意思得知整 体的意思。\n技能C4：以短语为单位进行阅读 了解短语有两个用处：一是知道单词之间的关联，二是以短语为单位进行阅读，提高阅读速度。因此，我们可以参照各种短语的常见结构，学会识别句子中的短语，开 始习惯以短语为单位阅读英文句子。\n名词短语，结构通常为“限定词+形容词+名词”，例如：a beautiful object 动词短语，结构通常为“动词+名词/名词短语”，例如：create an object 形容词短语，结构通常为“副词+形容词”，例如：very happy 副词短语，结构通常是“副词+副词”，例如：rather quickly 介词短语，结构通常是“介词+名词/代词/动名词”，例如：in October 不定式短语，结构一般为“to+动词/动词短语” ，例如：to make her happy 动名词短语，结构一般为“动名词+其他词” ，例如：(Xiaowang’s job is) creating objects. 现在分词短语，结构一般为“现在分词+其他词” ，例如：(He stood there,) having nothing to do. 过去分词短语，结构一般为“过去分词+其他词” ，例如：(an object)created by Xiaowang 技能C5：单词的其他技能——高效查单词 建议用专业的英文词典软件查单词，比如有道词典、金山词霸，条目清晰，意思准确，配有很多例句。不急的时候还可以看看英文释义，相比简短的中文含义，其描述 更详细、到位。\n技能熟练后的应用 长名称，或者说是特殊的合成词，类名和接口名大多由两种方式构成\n全部由名词拼接，如ConfigurationClassPostProcessor 一个形容词+多个名词, 如AutowiredAnnotationBeanPostProcessor 单词水平上来后，在开发过程中，我们既要能更好地看懂比较复杂的英文名称，也应该学会更规范地给类、方法、变量、参数等命名，让名称精炼、准确、风格统一， 避免出现用company_person表示“公司职员”的情况，而直接用staff。\n","permalink":"https://jdxj.github.io/posts/books/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8B%B1%E8%AF%AD/%E6%90%9E%E5%AE%9A%E5%8D%95%E8%AF%8D/","summary":"别让单词搞事情，优先拿下高频词 单词量 单词词性 单词原型 记单词的实用方法 根据读音记 b站搜索BBC音标教程 学音标的时候，重点放在与拼音发音差异很大","title":"搞定单词"},{"content":"误区 英文和中文是反过来的 英文和中文的异同点\n相同点\n词类基本相同，都有名词、动词、代词、形容词、副词、连词等主要的词语类别。 句子的总体结构相同，核心的词语在排列顺序上一致 主语+谓语（动词）+宾语. 什么人（物）做了什么事情。动作的发出者（主语）、动作（动词）、动作的承受者（宾语） 主语+系动词+表语. 即：什么人（物）是怎么样的。 不同点\n英文句子喜欢先讲重点，中文句子通常先说细节，这导致两者即使总体的句子结构一致，但部分词语（主要是修饰成分）的顺序有所不同 1 2 Xiaowang will play mobile games with his friends this evening. 小王将在今天晚上和朋友一起玩手机游戏。 相对于中文，英文会更多地使用被动语态。这在技术文档中体现得很明显。 1 The filter is configured during the initialization of the ObjectInputFilter.Config class. 在外观上，汉字之间的差异比单词之间的差异大得多。 英文非常重视句子的形式，中文更重视句子的含义。 这当然不是说含义对于英文不重要，而是说英文除了“内在”，也很重视“外在”，要求句子形式规范，意思表达清晰，说话较少拐弯。借助于关联词，句子的逻辑 在形式上就体现出来。如果该用关联词的地方没用，语法上是错误的。 英文长句多，而中文短句多。 好在这种带有凡尔赛气息的长句，大多见于英文报刊杂志，在英文技术文档中出现得并不多。 技术文档中，虽然也免不了有长句，句子中包含了各类从句和短语，但通常结构简单、清晰，容易看懂。 1 2 3 To successfully store and retrieve objects from a hashtable, the objects used as keys must implement the hashCode method and the equals method. 英语不用学，何况机器翻译很好用 机器翻译确实可以给开发带来便利，但它有一定的缺陷，特别是专业领域的长句子，翻译得不到位。\n学英语多背背单词就好了 理解一个英文句子更有难度，因为句子的含义不是所有单词含义的简单相加。理解句子时，需要准确把握词语之间或分句之间的逻辑关系，可能还要有相应的背景知识。 只有经过一定的训练，平时多阅读英文资料，才能快速、准确地看懂句子。\n坑 希望听说读写一并提升 专门去提升目前工作上最需要用到的某项技能，是效率更高的做法。如果还要提升其他技能，等手上的这个完成了再去操作。\n学习内容和工作相关性很弱 有些程序员受到误导，通过看英文电影、电视剧、演讲、小说之类的方式，去提高能用于工作的英语技能。\n要想有效地提高英语能力，不如采用针对性强的学习材料，如语法书、英文文档、源码注释、技术类原版书，专门花两三周时间，集中火力猛攻一把。这个过程可能很 枯燥，但效率高、进步快。\n没抓关键，做了一些无用功 实际上，程序员只要掌握了开发中常见的词汇（基础的通用词汇也要掌握）、必要的语法知识点就行。至于哪些是必要的语法知识点，后面会讲述。\n学习内容难度过大 基础不扎实就开始啃编程方面的英文原版书，或者写英文技术文档，容易因为难度太大挫伤自信心，挣扎于放弃的边缘。步子不要迈得太大，学习材料应与自己的英文 水平一致或略高一点。\n经常碎片化学习 用整块的时间去学习，效率会更高。\n","permalink":"https://jdxj.github.io/posts/books/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8B%B1%E8%AF%AD/%E8%AF%AF%E5%8C%BA%E5%92%8C%E5%9D%91/","summary":"误区 英文和中文是反过来的 英文和中文的异同点 相同点 词类基本相同，都有名词、动词、代词、形容词、副词、连词等主要的词语类别。 句子的总体结构相同，","title":"误区和坑"},{"content":"计算机字符集中的每个字符都有两个属性：码点（code point）和表示这个码点的内存编码（位模式，表示这个字符码点的二进制比特串）。\n所谓码点（这里借用了Unicode字符集中码点的概念）是指将字符集中所有字符“排成一队”，字符在队伍中的唯一序号值。 表52-1　ASCII字符集中字符的码点与内存编码\nASCII字符集中每个字符的码点与其内存编码表示是一致的。 图52-1　同一内存编码表示对应不同字符集中的不同字符\n图52-2　Unicode字符集码点表\nUnicode的前128个码点与ASCII字符码点是一一对应的\nUnicode采用的内存编码表示方案\nutf-16 该方案使用2或4字节表示每个Unicode字符码点。它的优点是编解码简单，因为所有字符都用偶数字节表示；其不足也很明显，比如存在字节序问题、不兼容ASCII 字符内存表示以及空间效率不高等。\nutf-32 该方案固定使用4字节表示每个Unicode字符码点。它的优点也是编解码简单，因为所有字符都用4字节表示；其不足也和UTF-16一样明显，同样存在字节序问题、不 兼容ASCII字符内存表示，且空间效率是这三种方案中最差的。\nutf-8 UTF-8编码使用的字节从1到4不等。前128个与ASCII字符重合的码点（U+0000~U+007F）使用1字节表示；带变音符号的拉丁文、希腊文、西里尔字母、阿拉伯文 等使用2字节来表示；而东亚文字（包括汉字）使用3字节表示；其他极少使用的语言的字符则使用4字节表示。\nUnicode规范中对字节序标记的约定如下\n如果没有提供字节序标记，则默认采用大端字节序解码。 由于UTF-8没有字节序问题，因此这个BOM只是用于表明该数据流采用的是UTF-8编码方案 FF FE UTF-16 小端字节序 FE FF UTF-16 大端字节序 FF FE 00 00 UTF-32 小端字节序 00 00 FE FF UTF-32 大端字节序 EF BB BF UTF-8 在Go中，每个rune对应一个Unicode字符的码点，而Unicode字符在内存中的编码表示则放在[]byte类型中。从rune类型转换为[]byte类型，称为“编码” （encode），而反过来则称为“解码”（decode）\n图52-4　Go语言中Unicode字符的编解码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // chapter9/sources/go-character-set-encoding/rune_encode_and_decode.go // rune -\u0026gt; []byte func encodeRune() { var r rune = 0x4E2D // 0x4E2D为Unicode字符\u0026#34;中\u0026#34;的码点 buf := make([]byte, 3) n := utf8.EncodeRune(buf, r) fmt.Printf(\u0026#34;the byte slice after encoding rune 0x4E2D is \u0026#34;) fmt.Printf(\u0026#34;[ \u0026#34;) for i := 0; i \u0026lt; n; i++ { fmt.Printf(\u0026#34;0x%X \u0026#34;, buf[i]) } fmt.Printf(\u0026#34;]\\n\u0026#34;) fmt.Printf(\u0026#34;the unicode charactor is %s\\n\u0026#34;, string(buf)) } // []byte -\u0026gt; rune func decodeRune() { var buf = []byte{0xE4, 0xB8, 0xAD} r, _ := utf8.DecodeRune(buf) fmt.Printf(\u0026#34;the rune after decoding [0xE4, 0xB8, 0xAD] is 0x%X\\n\u0026#34;, r) } func main() { encodeRune() decodeRune() } 图52-5　将“中国人”三个字符从UTF-8编码表示转换为GB18030编码表示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 // chapter9/sources/go-character-set-encoding/convert_utf8_to_gb18030.go package main import ( \u0026#34;bytes\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;unicode/utf8\u0026#34; \u0026#34;golang.org/x/text/encoding/simplifiedchinese\u0026#34; \u0026#34;golang.org/x/text/transform\u0026#34; ) func dumpToFile(in []byte, filename string) error { f, err := os.OpenFile(filename, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0666) if err != nil { return err } defer f.Close() _, err = f.Write(in) if err != nil { return err } return nil } func utf8ToGB18030(in []byte) ([]byte, error) { if !utf8.Valid(in) { return nil, errors.New(\u0026#34;invalid utf-8 runes\u0026#34;) } r := bytes.NewReader(in) // utf8 -\u0026gt; gb18030 t := transform.NewReader(r, simplifiedchinese.GB18030.NewEncoder()) out, err := ioutil.ReadAll(t) if err != nil { return nil, err } return out, nil } func main() { var src = \u0026#34;中国人\u0026#34; // \u0026lt;=\u0026gt; \u0026#34;\\u4E2D\\u56FD\\u4EBA\u0026#34; var dst []byte for i, v := range src { fmt.Printf(\u0026#34;Unicode字符: %s \u0026lt;=\u0026gt; 码点(rune): %X \u0026lt;=\u0026gt; UTF8编码内存表示: \u0026#34;, string(v), v) s := src[i : i+3] for _, v := range []byte(s) { fmt.Printf(\u0026#34;0x%X \u0026#34;, v) } t, _ := utf8ToGB18030([]byte(s)) fmt.Printf(\u0026#34;\u0026lt;=\u0026gt; GB18030编码内存表示: \u0026#34;) for _, v := range t { fmt.Printf(\u0026#34;0x%X \u0026#34;, v) } fmt.Printf(\u0026#34;\\n\u0026#34;) dst = append(dst, t...) } dumpToFile(dst, \u0026#34;gb18030.txt\u0026#34;) } 真正执行UTF-8到GB18030编码形式转换的是simplifiedchinese.GB18030.NewEncoder方法，它读取以UTF-8编码表示形式存在的字节流（[]byte），并将 其转换为以GB18030编码表示形式的字节流返回。\n将GB18030编码数据转换为UTF-16和UTF-32的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // chapter9/sources/go-character-set-encoding/convert_gb18030_to_utf16_and_utf32.go func catFile(filename string) ([]byte, error) { f, err := os.Open(filename) if err != nil { return nil, err } defer f.Close() return ioutil.ReadAll(f) } func gb18030ToUtf16BE(in []byte) ([]byte, error) { r := bytes.NewReader(in) //gb18030 // gb18030 -\u0026gt; utf8 s := transform.NewReader(r, simplifiedchinese.GB18030.NewDecoder()) // utf8 -\u0026gt; utf16 d := transform.NewReader(s, unicode.UTF16(unicode.BigEndian, unicode.IgnoreBOM).NewEncoder()) out, err := ioutil.ReadAll(d) if err != nil { return nil, err } return out, nil } func gb18030ToUtf32BE(in []byte) ([]byte, error) { r := bytes.NewReader(in) //gb18030 // gb18030 -\u0026gt; utf8 s := transform.NewReader(r, simplifiedchinese.GB18030.NewDecoder()) // utf8 -\u0026gt; utf32 d := transform.NewReader(s, utf32.UTF32(utf32.BigEndian, utf32.IgnoreBOM).NewEncoder()) out, err := ioutil.ReadAll(d) if err != nil { return nil, err } return out, nil } func main() { src, err := catFile(\u0026#34;gb18030.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;open file error:\u0026#34;, err) return } // 从gb18030到utf-16be dst, err := gb18030ToUtf16BE(src) if err != nil { fmt.Println(\u0026#34;convert error:\u0026#34;, err) return } fmt.Printf(\u0026#34;UTF-16BE(no BOM)编码: \u0026#34;) for _, v := range dst { fmt.Printf(\u0026#34;0x%X \u0026#34;, v) } fmt.Printf(\u0026#34;\\n\u0026#34;) // 从gb18030到utf-32be dst1, err := gb18030ToUtf32BE(src) if err != nil { fmt.Println(\u0026#34;convert error:\u0026#34;, err) return } fmt.Printf(\u0026#34;UTF-32BE(no BOM)编码: \u0026#34;) for _, v := range dst1 { fmt.Printf(\u0026#34;0x%X \u0026#34;, v) } fmt.Printf(\u0026#34;\\n\u0026#34;) } ","permalink":"https://jdxj.github.io/posts/articles/jdxj/%E7%94%A8go%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/","summary":"计算机字符集中的每个字符都有两个属性：码点（code point）和表示这个码点的内存编码（位模式，表示这个字符码点的二进制比特串）。 所谓码点","title":"用Go转换字符编码"},{"content":"安装 1 $ go install github.com/go-delve/delve/cmd/dlv@latest 使用 测试代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/jdxj/delve/pkg/foo\u0026#34; ) func main() { a := 3 b := 10 c := foo.Foo(a, b) fmt.Println(c) } 1 2 3 4 5 6 7 8 9 package foo func Foo(step, count int) int { sum := 0 for i := 0; i \u0026lt; count; i++ { sum += step } return sum } dlv debug启动调试\n在macOS下，执行dlv debug前，我们需要首先通过以下命令赋予dlv使用系统调试API的权限：sudo /usr/sbin/DevToolsSecurity -enable。\n设置断点break(b)\n1 (dlv) b main.go:12 查看断点breakpoints(bp)\n1 (dlv) bp 所谓条件断点，指的就是当满足某个条件时，被调试的目标程序才会在该断点处暂停。\n1 2 (dlv) b b2 foo.go:6 (dlv) cond b2 sum \u0026gt; 10 执行程序continue(c)/下一断点\n1 (dlv) c 查看数据\n1 2 3 4 (dlv) whatis a (dlv) p a (dlv) regs (dlv) locals 常用的查看命令\nprint（简写为p）：输出源码中变量的值。 whatis：输出后面的表达式的类型。 regs：当前寄存器中的值。 locals：当前函数栈本地变量列表（包括变量的值）。 args：当前函数栈参数和返回值列表（包括参数和返回值的值）。 examinemem（简写为x）：查看某一内存地址上的值。 next(n)断点处的下一行\nstep(s)单步调试(会进入函数)\n输出函数调用栈信息stack(bt)\n通过up和down命令，可以在函数调用栈的栈帧间进行跳转\n如果要重启调试，无须退出Delve，只需执行restart（简写为r）\ndelve还支持在调试过程中修改变量的值，并手工调用函数set\n1 2 (dlv) set a = 4 (dlv) call foo.Foo(a, b) Delve还可以通过exec子命令直接调试已经构建完的Go二进制程序文件\n1 $ dlv exec ./main.out 调试并发程序 通过Delve提供调试命令，我们可以在各个运行的goroutine间切换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/jdxj/delve/pkg/bar\u0026#34; \u0026#34;github.com/jdxj/delve/pkg/foo\u0026#34; ) func main() { var wg sync.WaitGroup wg.Add(1) go func() { for { d := 2 e := 20 f := bar.Bar(d, e) fmt.Println(f) time.Sleep(2 * time.Second) } wg.Done() }() a := 3 b := 10 c := foo.Foo(a, b) fmt.Println(c) wg.Wait() fmt.Println(\u0026#34;program exit\u0026#34;) } 1 2 3 4 5 6 7 8 9 package bar func Bar(step, count int) int { sum := 1 for i := 0; i \u0026lt; count; i++ { sum *= step } return sum } 启动调试\n1 2 3 4 5 $ dlv debug (dlv) b b1 main.go:19 (dlv) c (dlv) goroutines # 查看goroutine列表 (dlv) goroutine 1 # 切换goroutine Delve还提供了thread和threads命令，通过这两个命令我们可以查看当前启动的线程列表并在各个线程间切换\n调试core dump文件 core dump文件是在程序异常终止或崩溃时操作系统对程序当时的内存状态进行记录并保存而生成的一个数据文件，该文件以core命名，也被称为核心转储文件。\n适用于生产环境中的调试 Delve目前支持对linux/amd64、linux/arm64架构下产生的core文件的调试，以及Windows/amd64架构下产生的minidump小转储文件的调试。 测试代码\n1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;fmt\u0026#34; func main() { var p *int p = nil *p = 1 fmt.Println(\u0026#34;program exit\u0026#34;) } 要想在Linux下让Go程序崩溃时产生core文件，我们需要进行一些设置\n1 2 3 4 5 6 7 $ulimit -c unlimited # 不限制core文件大小 $go build main.go $GOTRACEBACK=crash ./main # 会产生core文件 $ dlv core ./main ./core (dlv) bt (dlv) frame 11 # 跳到main.main函数栈帧 调试运行中的程序 调试器一旦成功挂接到正在运行的进程中，调试器就掌握了进程执行的指挥权，并且正在运行的goroutine都会暂停，等待调试器的进一步指令。\n1 $ dlv attach \u0026lt;pid\u0026gt; ./main.out ","permalink":"https://jdxj.github.io/posts/articles/jdxj/delve/","summary":"安装 1 $ go install github.com/go-delve/delve/cmd/dlv@latest 使用 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/jdxj/delve/pkg/foo\u0026#34; ) func main() { a := 3 b := 10 c := foo.Foo(a, b) fmt.Println(c) } 1 2 3 4 5 6 7 8 9 package foo func Foo(step, count int) int { sum := 0 for","title":"delve"},{"content":"21.1 标准库的使用 表21-1 标准库的头\n当一个文件包含多个标准头时，#include指令的顺序无关紧要。多次包含同一个标准头也是合法的。\n21.1.1 对标准库中所用名字的限制 任何包含了标准头的文件都必须遵守两条规则\n该文件不能将头中定义过的宏的名字用于其他目的。(不能重定义宏) 具有文件作用域的库名（尤其是typedef名）也不可以在文件层次重定义。 由一个下划线和一个大写字母开头或由两个下划线开头的标识符是为标准库保留的标识符。程序不允许为任何目的使用这种形式的标识符。 由一个下划线开头的标识符被保留用作具有文件作用域的标识符和标记。除非在函数内部声明，否则不应该使用这类标识符。 在标准库中所有具有外部链接的标识符被保留用作具有外部链接的标识符。特别是所有标准库函数的名字都被保留。 哪些名字是保留的, 可以在C标准的“future library directions”中找到。\n21.1.2 使用宏隐藏的函数 C标准允许在头中定义与库函数同名的宏，为了起到保护作用，还要求有实际的函数存在。\n\u0026lt;stdio.h\u0026gt;\n1 2 int getchar(void); #define getchar() getc(stdin) 在默认情况下，对getchar的调用会被看作宏调用（因为宏名会在预处理时被替换）。\n在大多数情况下，我们喜欢使用宏来替代实际的函数，因为这样可能会提高程序的运行速度。然而在某些情况下，我们可能需要的是一个真实的函数，可能是为 了尽量缩小可执行代码的大小。\n如果确实存在这种需求，我们可以使用#undef指令来删除宏定义。\n1 2 #include \u0026lt;stdio.h\u0026gt; #undef getchar 也可以通过给名字加圆括号来禁用个别宏调用\n1 ch = (getchar)(); /* instead of ch = getchar(); */ 21.2 C89标准库概述 \u0026lt;assert.h\u0026gt;：诊断 \u0026lt;ctype.h\u0026gt;：字符处理 \u0026lt;errno.h\u0026gt;：错误 \u0026lt;float.h\u0026gt;：浮点类型的特性 \u0026lt;limits.h\u0026gt;：整数类型的大小 \u0026lt;locale.h\u0026gt;：本地化 \u0026lt;math.h\u0026gt;：数学计算 \u0026lt;setjmp.h\u0026gt;：非本地跳转 \u0026lt;signal.h\u0026gt;：信号处理 \u0026lt;stdarg.h\u0026gt;：可变参数 \u0026lt;stddef.h\u0026gt;：常用定义 \u0026lt;stdio.h\u0026gt;：输入/输出 \u0026lt;stdlib.h\u0026gt;：常用实用程序 \u0026lt;string.h\u0026gt;：字符串处理 \u0026lt;time.h\u0026gt;：日期和时间 21.3 C99标准库更新 \u0026lt;complex.h\u0026gt;：复数算术 \u0026lt;fenv.h\u0026gt;：浮点环境 \u0026lt;inttypes.h\u0026gt;：整数类型格式转换 \u0026lt;iso646.h\u0026gt;：拼写转换 \u0026lt;stdbool.h\u0026gt;：布尔类型和值 \u0026lt;stdint.h\u0026gt;：整数类型 \u0026lt;tgmath.h\u0026gt;：泛型数学 \u0026lt;wchar.h\u0026gt;：扩展的多字节和宽字符实用工具 \u0026lt;wctype.h\u0026gt;：宽字符分类和映射实用工具 21.4 \u0026lt;stddef.h\u0026gt;：常用定义 ptrdiff_t。当进行指针相减运算时，其结果的类型。 size_t。sizeof运算符返回的类型。 wchar_t。一种足够大的、可以用于表示所有支持的地区的所有字符的类型。 NULL offsetof 只有少数程序真的需要包含\u0026lt;stddef.h\u0026gt;。\n21.5 \u0026lt;stdbool.h\u0026gt;：布尔类型和值(c99) bool（定义为_Bool）； true（定义为1）； false（定义为0）； __bool_true_false_are_defined（定义为1）。 ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC21%E7%AB%A0-%E6%A0%87%E5%87%86%E5%BA%93/","summary":"21.1 标准库的使用 表21-1 标准库的头 当一个文件包含多个标准头时，#include指令的顺序无关紧要。多次包含同一个标准头也是合法的。 21.1.1 对标准库","title":"第21章 标准库"},{"content":"20.1 位运算符 20.1.1 移位运算符 表20-1 移位运算符\n运算符\u0026laquo;和运算符\u0026raquo;的操作数可以是任意整数类型（包括char型）。对两个操作数都会进行整数提升，返回值的类型是左操作数提升后的类型。\ni \u0026laquo; j的值是将i中的位左移j位后的结果。每次从i的最左端溢出一位，在i的最右端补一个0位。i \u0026raquo; j的值是将i中的位右移j位后的结果。如果i是无符号 数或非负值，则需要在i的左端补0。如果i是负值，其结果是由实现定义的：一些实现会在左端补0，其他一些实现会保留符号位而补1。\n为了可移植性，最好仅对无符号数进行移位运算。 1 2 3 4 5 6 7 8 unsigned short i, j; i = 13; /* i is now 13 (binary 0000000000001101) */ j = i \u0026lt;\u0026lt; 2; /* j is now 52 (binary 0000000000110100) */ j = i \u0026gt;\u0026gt; 2; /* j is now 3 (binary 0000000000000011) */ i = 13; /* i is now 13 (binary 0000000000001101) */ i \u0026lt;\u0026lt;= 2; /* i is now 52 (binary 0000000000110100) */ i \u0026gt;\u0026gt;= 2; /* i is now 3 (binary 0000000000000011) 20.1.2 按位求反运算符、按位与运算符、按位异或运算符和按位或运算符 表20-2 其他位运算符\n运算符~是一元运算符，对其操作数会进行整数提升。其他运算符都是二元运算符，对其操作数进行常用的算术转换。\n1 2 3 4 5 6 7 unsigned short i, j, k; i = 21; /* i is now 21 (binary 0000000000010101) */ j = 56; /* j is now 56 (binary 0000000000111000) */ k = ~i; /* k is now 65514 (binary 1111111111101010) */ k = i \u0026amp; j; /* k is now 16 (binary 0000000000010000) */ k = i ^ j; /* k is now 45 (binary 0000000000101101) */ k = i | j; /* k is now 61 (binary 0000000000111101) */ 优先级从高到低\n~ \u0026amp; ^ | 1 2 3 4 5 i = 21; /* i is now 21 (binary 0000000000010101) */ j = 56; /* j is now 56 (binary 0000000000111000) */ i \u0026amp;= j; /* i is now 16 (binary 0000000000010000) */ i ^= j; /* i is now 40 (binary 0000000000101000) */ i |= j; /* i is now 56 (binary 0000000000111000) */ 20.1.3 用位运算符访问位 位的设置\n1 2 3 4 i = 0x0000; /* i is now 0000000000000000 */ i |= 0x0010; /* i is now 0000000000010000 */ i |= 1 \u0026lt;\u0026lt; j; /* sets bit j */ 位的清除\n1 2 3 4 i = 0x00ff; /* i is now 0000000011111111 */ i \u0026amp;= ~0x0010; /* i is now 0000000011101111 */ i \u0026amp;= ~(1 \u0026lt;\u0026lt; j); /* clears bit j */ 位的测试\n1 2 3 if (i \u0026amp; 0x0010) ... /* tests bit 4 */ if (i \u0026amp; 1 \u0026lt;\u0026lt; j) ... /* tests bit j */ 为了使对于位的操作更容易，经常会给它们起名字。\n1 2 3 #define BLUE 1 #define GREEN 2 #define RED 4 设置、清除或测试BLUE位可以如下进行\n1 2 3 i |= BLUE; /* sets BLUE bit */ i \u0026amp;= ~BLUE; /* clears BLUE bit */ if (i \u0026amp; BLUE)... /* tests BLUE bit */ 同时设置、清除或测试几个位也一样简单\n1 2 3 i |= BLUE | GREEN; /* sets BLUE and GREEN bits */ i \u0026amp;= ~(BLUE | GREEN); /* clears BLUE and GREEN bits */ if (i \u0026amp; (BLUE | GREEN))... /* tests BLUE and GREEN bits */ 20.1.4 用位运算符访问位域 处理一组连续的位（位域）比处理单个位要复杂一点。下面是两种最常见的位域操作的例子。\n修改位域\n1 2 i = i \u0026amp; ~0x0070 | 0x0050; /* stores 101 in bits 4-6 */ i = i \u0026amp; ~0x0070 | j \u0026lt;\u0026lt; 4; 获取位域\n1 2 j = i \u0026amp; 0x0007; /* retrieves bits 0-2 */ j = (i \u0026gt;\u0026gt; 4) \u0026amp; 0x0007; /* retrieves bits 4-6 */ 20.2 结构中的位域 DOS只为日期分配了16位，其中5位用于日，4位用于月，7位用于年\n利用位域，我们可以定义相同形式的C结构\n每个成员后面的数指定了它所占用位的长度。 1 2 3 4 5 6 7 8 9 struct file_date { unsigned int day: 5; unsigned int month: 4; unsigned int year: 7; }; struct file_date { unsigned int day: 5, month: 4, year: 7; }; 位域的类型必须是int、unsigned int或signed int。\n使用int会引起二义性，因为一些编译器将位域的最高位作为符号位，而其他一些编译器则不会。 可移植性技巧: 将所有的位域声明为unsigned int或signed int。 在C99中，位域也可以具有类型_Bool。C99编译器还允许额外的位域类型\n我们可以将位域像结构的其他成员一样使用\n1 2 3 4 struct file_date fd; fd.day = 28; fd.month = 12; fd.year = 8; /* represents 1988 */ C语言不允许将\u0026amp;运算符用于位域。\n1 scanf(\u0026#34;%d\u0026#34;, \u0026amp;fd.day); /*** WRONG ***/ 位域是如何存储的 与编译器有关\nC语言允许省略位域的名字。未命名的位域经常用来作为字段间的“填充”，以保证其他位域存储在适当的位置。\n1 2 3 4 5 struct file_time { unsigned int : 5; /* not used */ unsigned int minutes: 6; unsigned int hours: 5; }; 长度为0的位域是给编译器的一个信号，告诉编译器将下一个位域在一个存储单元的起始位置对齐。假设存储单元是8位长的，编译器会给成员a分配4位，接着跳 过余下的4位到下一个存储单元，然后给成员b分配8位。如果存储单元是16位，编译器会给a分配4位，接着跳过12位，然后给成员b分配8位。\n1 2 3 4 5 struct s { unsigned int a: 4; unsigned int : 0; /* 0-length bit-field */ unsigned int b: 8; }; 20.3 其他底层技术 20.3.1 定义依赖机器的类型 1 2 typedef unsigned char BYTE; typedef unsigned short WORD; 20.3.2 用联合提供数据的多个视角 1 2 3 4 5 6 7 8 9 10 11 union int_date { unsigned short i; struct file_date fd; }; void print_date(unsigned short n) { union int_date u; u.i = n; printf(\u0026#34;%d/%d/%d\\n\u0026#34;, u.fd.month, u.fd.day, u.fd.year + 1980); } 寄存器\n注意字节序 1 2 3 4 5 6 7 8 9 10 11 12 union { struct { WORD ax, bx, cx,dx; } word; struct { BYTE al, ah, bl, bh, cl, ch, dl, dh; } byte; } regs; regs.byte.ah = 0x12; regs.byte.al = 0x34; printf(\u0026#34;AX: %hx\\n\u0026#34;, regs.word.ax); 20.3.3 将指针作为地址使用 1 2 BYTE *p; p = (BYTE *) 0x1000; /* p contains address 0x1000 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* Allows the user to view regions of computer memory */ #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; typedef unsigned char BYTE; int main(void) { unsigned int addr; int i, n; BYTE *ptr; printf(\u0026#34;Address of main function: %x\\n\u0026#34;, (unsigned int) main); printf(\u0026#34;Address of addr variable: %x\\n\u0026#34;, (unsigned int) \u0026amp;addr); printf(\u0026#34;\\nEnter a (hex) address: \u0026#34;); scanf(\u0026#34;%x\u0026#34;, \u0026amp;addr); printf(\u0026#34;Enter number of bytes to view: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34; Address Bytes Characters\\n\u0026#34;); printf(\u0026#34; ------- ----------------------- ----------\\n\u0026#34;); ptr = (BYTE *) addr; for (; n \u0026gt; 0; n -= 10) { printf(\u0026#34;%8X \u0026#34;, (unsigned int) ptr); for (i = 0; i \u0026lt; 10 \u0026amp;\u0026amp; i \u0026lt; n; i++) printf(\u0026#34;%.2X \u0026#34;, *(ptr + i)); for (; i \u0026lt; 10; i++) printf(\u0026#34; \u0026#34;); printf(\u0026#34; \u0026#34;); for (i = 0; i \u0026lt; 10 \u0026amp;\u0026amp; i \u0026lt; n; i++){ BYTE ch = *(ptr + i); if (!isprint(ch)) ch = \u0026#39;.\u0026#39;; printf(\u0026#34;%c\u0026#34;, ch); } printf(\u0026#34;\\n\u0026#34;); ptr += 10; } return 0; } 20.3.4 volatile类型限定符 在一些计算机中，一部分内存空间是“易变”的，保存在这种内存空间的值可能会在程序运行期间发生改变，即使程序自身并未试图存放新值。例如，一些内存空 间可能被用于保存直接来自输入设备的数据。\nvolatile类型限定符使我们可以通知编译器，程序中的某些数据是“易变”的。volatile限定符通常使用在用于指向易变内存空间的指针的声明中：\n1 volatile BYTE *p; /* p will point to a volatile byte */ 我们可能使用下面的循环获取键盘输入的字符，并将它们存入一个缓冲区数组中：\n1 2 3 4 5 6 while (缓冲区未满) { 等待输入; buffer[i] = *p; if (buffer[i++] == \u0026#39;\\n\u0026#39;) break; } 比较好的编译器可能会注意到这个循环既没有改变p，也没有改变*p，因此编译器可能会对程序进行优化，使*p只被取一次\n1 2 3 4 5 6 7 在寄存器中存储*p; while (缓冲区未满) { 等待输入; buffer[i] = 存储在寄存器中的值; if (buffer[i++] == \u0026#39;\\n\u0026#39;) break; } 优化后的程序会不断复制同一个字符来填满缓冲区，这并不是我们想要的程序。将p声明成指向易变的数据的指针可以避免这一问题的发生，因为volatile限定 符会通知编译器*p每一次都必须从内存中重新取。\n","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC20%E7%AB%A0-%E5%BA%95%E5%B1%82%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","summary":"20.1 位运算符 20.1.1 移位运算符 表20-1 移位运算符 运算符\u0026laquo;和运算符\u0026raquo;的操作数可以是任意整数类型（包括char型）。对两个操作","title":"第20章 底层程序设计"},{"content":"19.1 模块 模块的接口就是头文件，头文件中包含那些可以被程序中其他文件调用的函数的原型。模块的实现就是包含该模块中函数的定义的源文件。\n将程序分割成模块有一系列好处\n抽象 可复用性 可维护性 19.1.1 内聚性与耦合性 在设计良好的程序中，模块应该具有下面两个性质\n高内聚性 低耦合性 19.1.2 模块的类型 数据池。数据池是一些相关的变量或常量的集合。在C语言中，这类模块通常只是一个头文件。从程序设计的角度说，通常不建议将变量放在头文件中，但建 议把相关常量放在头文件中。在C库中，\u0026lt;float.h\u0026gt;头和\u0026lt;limits.h\u0026gt;头都属于数据池。 库。库是一个相关函数的集合。例如\u0026lt;string.h\u0026gt;头就是字符串处理函数库的接口。 抽象对象。抽象对象是指对于隐藏的数据结构进行操作的函数的集合。 抽象数据类型（ADT）。将具体数据实现方式隐藏起来的数据类型称为抽象数据类型。客户模块可以使用该类型来声明变量，但不会知道这些变量的具体数据 结构。如果客户模块需要对这种变量进行操作，则必须调用抽象数据类型模块所提供的函数。 19.2 信息隐藏 息隐藏有以下两大优点\n安全性 灵活性 在C语言中，强制信息隐藏的主要工具是static存储类型\n19.3 抽象数据类型 19.3.1 封装 C语言对于封装类型的支持很有限。\n19.3.2 不完整类型 C语言提供的唯一封装工具为不完整类型\n不完整类型将会在程序的其他地方将信息补充完整。 1 struct t; /* incomplete declaration of t */ 不完整类型的使用是受限的。因为编译器不知道不完整类型的大小，所以不能用它来声明变量：\n1 struct t s; /*** WRONG ***/ 可以定义一个指针类型引用不完整类型\n不能对这些变量使用-\u0026gt;运算符，因为编译器对t结构的成员一无所知 1 typedef struct t *T; 19.4 栈抽象数据类型 19.4.1 为栈抽象数据类型定义接口 stackADT.h (version 1)\n1 2 3 4 5 6 7 8 9 10 11 12 #ifndef STACKADT_H #define STACKADT_H #include \u0026lt;stdbool.h\u0026gt; /* C99 only */ typedef struct stack_type *Stack; Stack create(void); void destroy(Stack s); void make_empty(Stack s); bool is_empty(Stack s); bool is_full(Stack s); void push(Stack s, int i); int pop(Stack s); #endif stackclient.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;stackADT.h\u0026#34; int main(void) { Stack s1, s2; int n; s1 = create(); s2 = create(); push(s1, 1); push(s1, 2); n = pop(s1); printf(\u0026#34;Popped %d from s1\\n\u0026#34;, n); push(s2, n); n = pop(s1); printf(\u0026#34;Popped %d from s1\\n\u0026#34;,n); push(s2, n); destroy(s1); while (!is_empty(s2)) printf(\u0026#34;Popped %d from s2\\n\u0026#34;, pop(s2)); push(s2,3); make_empty(s2); if (is_empty(s2)) printf(\u0026#34;s2 is empty\\n\u0026#34;); else printf(\u0026#34;s2 is not empty\\n\u0026#34;); destroy(s2); return 0; } 19.4.2 用定长数组实现栈抽象数据类型 stackADT.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;stackADT.h\u0026#34; #define STACK_SIZE 100 struct stack_type { int contents[STACK_SIZE]; int top; }; static void terminate (const char *message) { printf(\u0026#34;%s\\n\u0026#34;, message); exit(EXIT_FAILURE); } Stack create(void) { Stack s = malloc(sizeof(struct stack_type)); if (s == NULL) terminate(\u0026#34;Error in create: stack could not be created.\u0026#34;); s-\u0026gt;top = 0; return s; } void destroy(Stack s) { free(s); } void make_empty(Stack s) { s-\u0026gt;top = 0; } bool is_empty(Stack s) { return s-\u0026gt;top == 0; } bool is_full(Stack s) { return s-\u0026gt;top == STACK_SIZE; } void push(Stack s, int i) { if (is_full(s)) terminate(\u0026#34;Error in push: stack is full.\u0026#34;); s-\u0026gt;contents[s-\u0026gt;top++] = i; } int pop(Stack s) { if (is_empty(s)) terminate(\u0026#34;Error in pop: stack is empty.\u0026#34;); return s-\u0026gt;contents[--s-\u0026gt;top]; } 19.4.3 改变栈抽象数据类型中数据项的类型 stackADT.h(version 2)\n1 2 3 4 5 6 7 8 9 10 11 12 13 #ifndef STACKADT_H #define STACKADT_H #include /* C99 only */ typedef int Item; typedef struct stack_type *Stack; Stack create(void); void destroy(Stack s); void make_empty(Stack s); bool is_empty(Stack s); bool is_full(Stack s); void push(Stack s, Item i); Item pop (Stack s); #endif stackADT.c\n1 2 3 4 struct stack_type { Item contents[STACK_SIZE]; int top; }; push和pop的函数体部分没有改变，相应的改变仅仅是把push的第二个参数和pop的返回值改成了Item类型。\n可以通过修改stackADT.h中Item类型的定义来任意修改数据项类型了。\n仍然需要对它进行重新编译 19.4.4 用动态数组实现栈抽象数据类型 1 2 3 4 5 6 7 struct stack_type { Item *contents; int top; int size; }; Stack create(int size); stackADT2.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include #include #include \u0026#34;stackADT2.h\u0026#34; struct stack_type { Item *contents; int top; int size; }; static void terminate (const char *message) { printf(\u0026#34;%s\\n\u0026#34;, message); exit(EXIT_FAILURE); } Stack create(int size) { Stack s = malloc(sizeof(struct stack_type)); if (s == NULL) terminate(\u0026#34;Error in create: stack could not be created.\u0026#34;); s-\u0026gt;contents = malloc(size * sizeof(Item)); if (s-\u0026gt;contents == NULL) { free(s); terminate(\u0026#34;Error in create: stack could not be created.\u0026#34;); } s-\u0026gt;top = 0; s-\u0026gt;size = size; return s; } void destroy(Stack s) { free(s-\u0026gt;contents); free(s); } void make_empty(Stack s) { s-\u0026gt;top = 0; } bool is_empty(Stack s) { return s-\u0026gt;top == 0; } bool is_full (Stack s) { return s-\u0026gt;top == s-\u0026gt;size; } void push(Stack s, Item i) { if (is_full(s)) terminate(\u0026#34;Error in push: stack is full.\u0026#34;); s-\u0026gt;contents[s-\u0026gt;top++] = i; } Item pop(Stack s) { if (is_empty(s)) terminate(\u0026#34;Error in pop: stack is empty.\u0026#34;); return s-\u0026gt;contents[--s-\u0026gt;top]; } 19.4.5 用链表实现栈抽象数据类型 1 2 3 4 5 6 7 8 struct node { Item data; struct node *next; }; struct stack_type { struct node *top; }; stackADT3.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;stackADT.h\u0026#34; struct node { Item data; struct node *next; }; struct stack_type { struct node *top; }; static void terminate(const char *message) { printf(\u0026#34;%s\\n\u0026#34;, message); exit(EXIT_FAILURE); } Stack create(void) { Stack s = malloc(sizeof(struct stack_type)); if (s == NULL) terminate(\u0026#34;Error in create: stack could not be created.\u0026#34;); s-\u0026gt;top = NULL; return s; } void destroy(Stack s) { make_empty(s); free(s); } void make_empty(Stack s) { while (!is_empty(s)) pop(s); } bool is_empty(Stack s) { return s-\u0026gt;top == NULL; } bool is_full(Stack s) { return false; } void push(Stack s, Item i) { struct node *new_node = malloc(sizeof(struct node)); if (new_node == NULL) terminate(\u0026#34;Error in push: stack is full.\u0026#34;); new_node-\u0026gt;data = i; new_node-\u0026gt;next = s-\u0026gt;top; s-\u0026gt;top = new_node; } Item pop(Stack s) { struct node *old_top; Item i; if (is_empty(s)) terminate(\u0026#34;Error in pop: stack is empty.\u0026#34;); old_top = s-\u0026gt;top; i = old_top-\u0026gt;data; s-\u0026gt;top = old_top-\u0026gt;next; free(old_top); return i; } 19.5 抽象数据类型的设计问题 这里的抽象数据类型存在一些问题，使其达不到工业级强度。\n19.5.1 命名惯例 目前的栈抽象数据类型函数都采用简短、便于记忆的名字：create、destroy、make_empty、is_empty、is_full、push和pop。如果在一个程序中有多个 抽象数据类型，两个模块中很可能具有同名函数，这样就出现了名字冲突。\n19.5.2 错误处理 程序员可以通过在每次调用pop之前调用is_empty，在每次调用push之前调用is_full，来避免从空栈中弹出数据项或者向满栈里压入数据项。所以从理论上 来讲，对pop和push的调用没有理由会出错。（但在链表实现中，调用is_full并没有效果，后续调用push仍然可能出错。）\n一个可选的方案是让push和pop函数返回一个bool值说明函数调用是否成功。\n让pop返回一个指向弹出的值的指针而不是返回该值本身，那就可以让pop返回NULL来表示此时栈为空 C标准库里包含带参数的assert宏，可以在指定的条件不满足时终止程序。\n19.5.3 通用抽象数据类型 最常见的一种方法是使用void *作为数据项类型\n1 2 void push(Stack s, void *p); void *pop(Stack s); 使用void *作为数据项类型有两个缺点。\n第一，这种方法不适用于无法用指针形式表示的数据。数据项可以是字符串（用指向字符串第一个字符的指针表示）或动态分配的结构，但不能是int、 double之类的基本类型。 第二，不能进行错误检测。存放void *数据项的栈允许各种类型的指针共存，所以无法检测出由压入错误的指针类型导致的错误。 int, float不能用指针表示?\n19.5.4 新语言中的抽象数据类型 ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC19%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","summary":"19.1 模块 模块的接口就是头文件，头文件中包含那些可以被程序中其他文件调用的函数的原型。模块的实现就是包含该模块中函数的定义的源文件。 将程序分割成","title":"第19章 程序设计"},{"content":"18.1 声明的语法 1 2 3 4 // int变量 int i; // 函数变量 float f(float); 声明说明符 声明符;\n声明说明符（declaration specifier）描述声明的变量或函数的性质。声明符（declarator）给出了它们的名字，并且可以提供关于其性质的额外信息。\n声明说明符分为以下3大类\n存储类型。存储类型一共有4种：auto、static、extern和register。在声明中最多可以出现一种存储类型。如果存储类型存在，则必须把它放置在最前 面。 类型限定符。C89只有两种类型限定符：const和volatile。C99还有一个限定符restrict。声明可以包含零个或多个限定符。 类型说明符。关键字void、char、short、int、long、float、double、signed和unsigned都是类型说明符。这些单词可以组合使用，这些单词出现的 顺序并不重要（int unsigned long和long unsigned int完全一样）。类型说明符也包括结构、联合和枚举的说明（例如 struct point{int x, y;}、struct {int x, y;}或者struct point）。用typedef创建的类型名也是类型说明符。 C99还有第四种声明说明符，即函数说明符，它只用于函数声明。这一类说明符只有一个，即关键字inline。 类型限定符和类型说明符必须跟随在存储类型的后边，但是两者的顺序没有限制。\n声明符包括标识符（简单变量的名字）、后边跟随[]的标识符（数组名）、前边放置*的标识符（指针名）和后边跟随()的标识符（函数名）。声明符之间用逗 号分隔。表示变量的声明符后边可以跟随初始化式。\ncase1 case2 case3 case4 18.2 存储类型 存储类型可以用于变量以及较小范围的函数和形式参数的说明。\n18.2.1 变量的性质 C程序中的每个变量都具有以下3个性质\n存储期限。变量的存储期限决定了为变量预留和内存被释放的时间。具有自动存储期限的变量在所属块被执行时获得内存单元，并在块终止时释放内存单元， 从而会导致变量失去值。具有静态存储期限的变量在程序运行期间占有同一个的存储单元，也就允许变量无限期地保留它的值。 作用域。变量的作用域是指可以引用变量的那部分程序文本。变量可以有块作用域（变量从声明的地方一直到所在块的末尾都是可见的）或者文件作用域（变 量从声明的地方一直到所在文件的末尾都是可见的）。 链接。变量的链接确定了程序的不同部分可以共享此变量的范围。具有外部链接的变量可以被程序中的几个（或许全部）文件共享。具有内部链接的变量只能 属于单独一个文件，但是此文件中的函数可以共享这个变量。（如果具有相同名字的变量出现在另一个文件中，那么系统会把它作为不同的变量来处理。）无 链接的变量属于单独一个函数，而且根本不能被共享。 变量的默认存储期限、作用域和链接都依赖于变量声明的位置。\n在块（包括函数体）内部声明的变量具有自动存储期限、块作用域，并且无链接。 在程序的最外层（任意块外部）声明的变量具有静态存储期限、文件作用域和外部链接。 可以通过指定明确的存储类型（auto、static、extern和register）来改变变量的性质。\n18.2.2 auto存储类型 auto存储类型只对属于块的变量有效。auto变量具有自动存储期限（无需惊讶）、块作用域，并且无链接。auto存储类型几乎从来不用明确地指明，因为对于 在块内部声明的变量，它是默认的。\n18.2.3 static存储类型 static存储类型可以用于全部变量，而无需考虑变量声明的位置。\n当用在块外部时，单词static说明变量具有内部链接。 当用在块内部时，static把变量的存储期限从自动的变成了静态的。 在用于块外部的声明时，static本质上使变量只在声明它的文件内可见。只有出现在同一文件中的函数可以看到此变量。\nstatic变量具有以下一些有趣的性质\n块内的static变量只在程序执行前进行一次初始化，而auto变量则会在每次出现时进行初始化（当然，需假设它有初始化式）。 每次函数被递归调用时，它都会获得一组新的auto变量。但是，如果函数含有static变量，那么此函数的全部调用都可以共享这个static变量。 虽然函数不应该返回指向auto变量的指针，但是函数返回指向static变量的指针是没有错误的。 1 2 3 4 5 6 7 8 9 10 11 char digit_to_hex_char(int digit) { const char hex_chars[16] = \u0026#34;0123456789ABCDEF\u0026#34;; return hex_chars[digit]; } char digit_to_hex_char(int digit) { // 由于static型变量只进行一次初始化，这样做就改进了digit_to_hex_char函数的速度。 static const char hex_chars[16] = \u0026#34;0123456789ABCDEF\u0026#34;; return hex_chars[digit]; } 18.2.4 extern存储类型 extern存储类型使几个源文件可以共享同一个变量。\n1 2 // 编译器不会为i分配存储单元 extern int i; 变量的extern声明不是定义这一规则有一个例外。对变量进行初始化的extern声明是变量的定义。\n1 2 3 extern int i = 0; // 等效于 int i = 0; 这条规则可以防止多个extern声明用不同方法对变量进行初始化。\nextern声明中的变量始终具有静态存储期限。变量的作用域依赖于声明的位置。如果声明在块内部，那么变量具有块作用域；否则，变量具有文件作用域：\n确定extern型变量的链接有一定难度。如果变量在文件中较早的位置（任何函数定义的外部）声明为static，那么它具有内部链接；否则（通常情况下）， 变量具有外部链接。\n18.2.5 register存储类型 声明变量具有register存储类型就要求编译器把变量存储在寄存器中，而不是像其他变量一样保留在内存中。\n指明变量的存储类型是register是一种请求，而不是命令。编译器可以选择把register型变量存储在内存中。\nregister存储类型只对声明在块内的变量有效。register变量具有和auto变量一样的存储期限、作用域和链接。但是，register变量缺乏auto变量所具有 的一种性质：由于寄存器没有地址，所以对register变量使用取地址运算符\u0026amp;是非法的。即使编译器选择把变量存储在内存中，这一限制仍适用。\nregister存储类型最好用于需要频繁进行访问或更新的变量。\n1 2 3 4 5 6 7 8 int sum_array(int a[], int n) { register int i; int sum = 0; for (i = 0; i \u0026lt; n; i++) sum += a[i]; return sum; } 18.2.6 函数的存储类型 只有extern和static\n在函数声明开始处的单词extern说明函数具有外部链接，也就是允许其他文件调用此函数； static说明是内部链接，也就是说只能在定义函数的文件内部调用此函数。 如果不指明函数的存储类型，那么会假设函数具有外部链接。 1 2 3 extern int f(int i); static int g(int i); int h(int i); 把g声明为static不能完全阻止在别的文件中对它进行调用，通过函数指针进行间接调用仍然是可能的。\n函数的形式参数具有和auto变量相同的性质：自动存储期限、块作用域和无链接。唯一能用于形式参数的存储类型是register。\n18.2.7 小结 1 2 3 4 5 6 7 8 9 10 11 int a; extern int b; static int c; void f(int d, register int e) { auto int g; int h; static int i; extern int j; register int k; } 表18-1 变量和形式参数的性质\n由于这里没有显示出变量b和j的定义，所以不可能确定它们的链接。在大多数情况下，变量会定义在另一个文件中，并且具有外部链接。 在这4种存储类型之中，最重要的是extern和static。auto没有任何效果，而现代编译器已经使register变得不如以前重要了。\n18.3 类型限定符 C语言中一共有两种类型限定符：const和volatile\nC99还有第三种类型限定符，即restrict，它只用于指针 程序可以访问const型对象的值，但是无法改变它的值\n当为特定类型的应用（特别是嵌入式系统）编写程序时，编译器可以用单词const来识别需要存储到ROM（只读存储器）中的数据。 可以用#define指令为数值、字符或字符串常量创建名字。const可用于产生任何类型的只读对象，包括数组、指针、结构和联合。 const对象遵循与变量相同的作用域规则，而用#define创建的常量不受这些规则的限制。特别是，不能用#define创建具有块作用域的常量。 和宏的值不同，const对象的值可以在调试器中看到。 不同于宏，const对象不可以用于常量表达式。 1 2 3 const int n = 10; int a[n]; /*** WRONG ***/ // 在C99中，如果a具有自动存储期限，那么这个例子是合法的——它会被视为变长数组；但是如果a具有静态存储期限，那么这个例子是不合法的。 对const对象应用取地址运算符（\u0026amp;）是合法的，因为它有地址。宏没有地址。 18.4 声明符 声明符包含标识符（声明的变量或函数的名字），标识符的前边可能有符号*，后边可能有[]或()。\n1 2 3 4 int i; int *p; int a[10]; extern int a[]; C99为数组形式参数声明中方括号内的内容提供了两种额外 的选项。\n一个是关键字static，后面跟着的表达式指明数组的最小长度； 另一个是符号*，它可以用在函数原型中以指示变长数组参数。 用()结尾的声明符表示函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 int abs(int i); void swap(int *a, int *b); int find_largest(int a[], int n); // C语言允许在函数声明中省略形式参数的名字 int abs(int); void swap(int *, int *); int find_largest(int [], int); // 圆括号内可以为空 int abs(); void swap(); int find_largest(); 圆括号内置为空不等同于把单词void放置在圆括号内，后者说明没有实际参数。圆括号内为空的这种函数声明风格正在迅速消失。它比C89的原型形式差，因为 它不允许编译器检查函数调用是否有正确的实际参数。\n复杂声明\n1 2 3 int *ap[10]; float *fp(float); void (*pf)(int); 18.4.1 解释复杂声明 1 int *(*x[10])(void); 两条简单的规则可以用来理解任何声明\n始终从内往外读声明符。换句话说，定位声明的标识符，并且从此处开始解释声明。 在作选择时，始终使[]和()优先于*。如果*在标识符的前面，而标识符后边跟着[]，那么标识符表示数组而不是指针。同样地，如果*在标识符的前面， 而标识符后边跟着()，那么标识符表示函数而不是指针。（当然，可以使用圆括号来使[]和()相对于*的优先级无效。） 首先，定位声明的标识符（x）。在x前有*，而后边又跟着[]。因为[]优先级高于*，所以取右侧（x是数组）。接下来，从左侧找到数组中元素的类型（指针）。 再接下来，到右侧找到指针所指向的数据类型（不带实际参数的函数）。最后，回到左侧看每个函数返回的内容（指向int型的指针）。\n函数不能返回数组\n1 int f(int)[]; /*** WRONG ***/ 函数不能返回函数\n1 int g(int)(int); /*** WRONG ***/ 函数型的数组也是不可能的\n1 int a[10](int); /*** WRONG ***/ 我们可以用指针来获得所需的效果。函数不能返回数组，但可以返回指向数组的指针；函数不能返回函数，但可以返回指向函数的指针；函数型的数组不合法， 但是数组可以包含指向函数的指针。\n18.4.2 使用类型定义来简化声明 1 2 3 4 5 6 int *(*x[10])(void); typedef int *Fcn(void); typedef Fcn *Fcn_ptr; typedef Fcn_ptr Fcn_ptr_array[10]; Fcn_ptr_array x; 18.5 初始化式 不要把声明中的符号=和赋值运算符相混淆，初始化和赋值不一样。\n1 2 3 4 5 int i = 5 /2 ; /* i is initially 2 */ int j = 5.5; /* converted to 5 */ // 指针变量的初始化式必须是具有和变量相同类型或void*类型的指针表达式 int *p = \u0026amp;i; int a[5] = {1, 2, 3, 4, 5}; 在C99中，由于指定初始化式的存在，花括号中的初始化式可以有其他形式。\n具有静态存储期限的变量的初始化式必须是常量\n1 2 3 #define FIRST 1 #define LAST 100 static int i = LAST - FIRST + 1; 如果变量具有自动存储期限，那么它的初始化式不需要是常量\n1 2 3 4 5 int f(int n) { int last = n - 1; ... } 包含在花括号中的数组、结构或联合的初始化式必须只包含常量表达式，不允许有变量或函数调用\n1 2 3 4 // N是常量, powers的初始化是合法的 #define N 2 int powers[5] = {1, N, N * N, N * N * N, N * N * N * N}; // 在C99中，仅当变量具有静态存储期限时, 程序将无法通过编译 (没理解这句话) 自动类型的结构或联合的初始化式可以是另外一个结构或联合\n1 2 3 4 5 void g(struct part part1) { struct part part2 = part1; ... } 虽然初始化式需要是具有适当类型的表达式，但是它们不需要一定是变量或形式参数名。例如，part2的初始化式可以是*p，其中p具有struct part *类型； 也可以是f(part1)，其中f是返回part结构类型的函数。\n未初始化的变量 变量的初始化值依赖于变量的存储期限\n具有自动存储期限的变量没有默认的初始值。不能预测自动变量的初始值，而且每次变量变为有效时值可能不同。 具有静态存储期限的变量默认情况下的值为零。用calloc分配的内存是简单的给字节的位置零，而静态变量不同于此，它是基于类型的正确初始化，即整型 变量初始化为0，浮点变量初始化为0.0，而指针则初始化为空指针。 18.6 内联函数(c99) C99函数声明中有一个C89中不存在的选项：可以包含关键字inline。\n“内联”表明编译器把函数的每一次调用都用函数的机器指令来代替。这种方法虽然会使被编译程序的大小增加一些，但是可以避免函数调用的常见额外开销。\n不过，把函数声明为inline并不是强制编译器将代码内联编译，只是建议编译器应该使函数调用尽可能地快，也许在函数调用时才执行内联展开。编译器可以忽 略这一建议。\n18.6.1 内联定义 首先将average的内联定义放入头文件（命名为average.h）中\n1 2 3 4 5 6 7 #ifndef AVERAGE_H #define AVERAGE_H inline double average(double a, double b) { return (a + b) / 2; } #endif 再创建与之匹配的源文件average.c\n1 2 #include \u0026#34;average.h\u0026#34; extern double average(double a, double b); 18.6.2 对内联函数的限制 C99对具有外部链接的内联函数（未对具有内部链接的内联函数做约束）做了如下限制\n函数中不能定义可改变的static变量 函数中不能引用具有内部链接的变量 这样的函数可以定义同时为static和const的变量，但是每个内联定义都需要分别创建该变量的副本。\n18.6.3 在GCC中使用内联函数 ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC18%E7%AB%A0-%E5%A3%B0%E6%98%8E/","summary":"18.1 声明的语法 1 2 3 4 // int变量 int i; // 函数变量 float f(float); 声明说明符 声明符; 声明说明符（declaration specifier）描述声明的变量或函","title":"第18章 声明"},{"content":"17.1 动态存储分配 即在程序执行期间分配内存单元的能力。\n17.1.1 内存分配函数 这些函数都是声明在\u0026lt;stdlib.h\u0026gt;中\nmalloc函数——分配内存块，但是不对内存块进行初始化。 calloc函数——分配内存块，并且对内存块进行清零。 realloc函数——调整先前分配的内存块大小。 由于函数无法知道计划存储在内存块中的数据是什么类型的，所以它不能返回int类型、char类型等普通类型的指针。取而代之的，函数会返回void *类型的值。 void *类型的值是“通用”指针，本质上它只是内存地址。\n17.1.2 空指针 当调用内存分配函数时，总存在这样的可能性：找不到满足我们需要的足够大的内存块。如果真的发生了这类问题，函数会返回空指针（null pointer）。 在把函数的返回值存储到指针变量中以后，需要判断该指针变量是否为空指针。\n1 2 3 4 p = malloc(10000); if (p == NULL) { /* allocation failed; take appropriate action */ } 名为NULL的宏在6个头\u0026lt;locale.h\u0026gt;、\u0026lt;stddef.h\u0026gt;、\u0026lt;stdio.h\u0026gt;、\u0026lt;stdlib.h\u0026gt;、\u0026lt;string.h\u0026gt;和\u0026lt;time.h\u0026gt;中都有定义。（C99的\u0026lt;wchar.h\u0026gt;也定义了NULL。）\n17.2 动态分配字符串 17.2.1 使用malloc函数为字符串分配内存 1 2 3 4 5 void *malloc(size_t size); p = (char *) malloc(n + 1); // 可以不用强制转换 p = malloc(n + 1); 17.2.2 在字符串函数中使用动态存储分配 1 2 3 4 5 6 7 8 9 10 11 12 char *concat(const char *s1, const char *s2) { char *result ; result = malloc(strlen(s1) + strlen(s2) + 1); if (result == NULL) { printf(\u0026#34;Error: malloc failed in concat\\n\u0026#34;); exit (EXIT_FAILURE); } strcpy(result, s1); strcat(result, s2); return result; } 17.2.3 动态分配字符串的数组 17.3 动态分配数组 17.3.1 使用malloc函数为数组分配存储空间 1 2 3 4 int *a; a = malloc(n * sizeof(int)); for (i = 0; i \u0026lt; n; i++) a[i] = 0; 17.3.2 calloc函数 1 2 // 元素个数, 元素大小 void *calloc(size_t nmemb, size_t size); calloc函数会通过把所有位设置为0的方式进行初始化。\n通过调用以1作为第一个实际参数的calloc函数，可以为任何类型的数据项分配空间：\n1 2 struct point { int x, y; } *p; p = calloc(1, sizeof(struct point)); 17.3.3 realloc函数 1 void *realloc(void *ptr, size_t size); 当调用realloc函数时，ptr必须指向先前通过malloc、calloc或realloc的调用获得的内存块。size表示内存块的新尺寸，新尺寸可能会大于或小于原有尺 寸。虽然realloc函数不要求ptr指向正在用作数组的内存，但实际上通常是这样的。\nC标准列出了几条关于realloc函数的规则。\n当扩展内存块时，realloc函数不会对添加进内存块的字节进行初始化。 如果realloc函数不能按要求扩大内存块，那么它会返回空指针，并且在原有的内存块中的数据不会发生改变。 如果realloc函数被调用时以空指针作为第一个实际参数，那么它的行为就将像malloc函数一样。 如果realloc函数被调用时以0作为第二个实际参数，那么它会释放掉内存块。 一旦realloc函数返回，请一定要对指向内存块的所有指针进行更新，因为realloc函数可能会使内存块移动到了其他地方。\n17.4 释放存储空间 17.4.1 free函数 1 2 3 4 5 6 void free(void *ptr); p = malloc(...); q = malloc(...); free(p); p = q; free函数的实际参数必须是先前由内存分配函数返回的指针。（参数也可以是空指针，此时free调用不起作用。）如果参数是指向其他对象（比如变量或数组 元素）的指针，可能会导致未定义的行为。\n17.4.2 “悬空指针”问题 1 2 3 4 5 char *p = malloc(4); ... free(p); ... strcpy(p, \u0026#34;abc\u0026#34;); /*** WRONG ***/ 17.5 链表 17.5.1 声明结点类型 1 2 3 4 5 struct node { int value; /* data stored in the node */ struct node *next; /* pointer to the next node */ }; struct node *first = NULL; 在结构有一个指向相同结构类型的指针成员时（就像node中那样），要求使用结构标记。\n17.5.2 创建结点 1 2 3 struct node *new_node; new_node = malloc(sizeof(struct node)); (*new_node).value = 10; 在*new_node两边的圆括号是强制要求的，因为运算符.的优先级高于运算符*\n17.5.3 -\u0026gt;运算符 1 2 new_node-\u0026gt;value = 10; scanf(\u0026#34;%d\u0026#34;, \u0026amp;new_node-\u0026gt;value); 17.5.4 在链表的开始处插入结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct node *add_to_list(struct node *list, int n) { struct node *new_node; new_node = malloc(sizeof(struct node)); if (new_node == NULL) { printf(\u0026#34;Error: malloc failed in add_to list\\n\u0026#34;); exit(EXIT_FAILURE); } new_node-\u0026gt;value = n; new_node-\u0026gt;next = list; return new_node; } first = add_to_list(first, 10); first = add_to_list(first, 20); 17.5.5 搜索链表 1 2 for (p = first; p != NULL; p = p-\u0026gt;next) ... 17.5.6 从链表中删除结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct node *delete_from_list(struct node *list, int n) { struct node *cur, *prev; for (cur = list, prev = NULL; cur != NULL \u0026amp;\u0026amp; cur-\u0026gt;value != n; prev = cur, cur = cur-\u0026gt;next) ; if (cur == NULL) return list; /* n was not found */ if (prev == NULL) list = list-\u0026gt;next; /* n is in the first node */ else prev-\u0026gt;next = cur-\u0026gt;next; /* n is in some other node */ free (cur); return list; } 17.5.7 有序链表 往有序列表中插入结点会更困难一些，但是搜索会更快\n17.6 指向指针的指针 1 2 3 4 5 6 7 8 9 10 11 12 13 void_add_to_list(struct node **list, int n) { struct node *new_node; new_node = malloc(sizeof(struct node)); if (new_node == NULL) { printf(\u0026#34;Error: malloc failed in add_to_list\\n\u0026#34;); exit(EXIT_FAILURE); } new_node-\u0026gt;value = n; new_node-\u0026gt;next = *list; *list = new_node; } add_to_list(\u0026amp;first, 10); 17.7 指向函数的指针 17.7.1 函数指针作为参数 1 2 3 4 5 6 7 8 9 10 double integrate(double (*f)(double), double a, double b); // 等价 double integrate(double f(double), double a, double b); result = integrate(sin, 0.0, PI / 2); // integrate内调用f y = (*f)(x); // 也可以 y = f(x); 17.7.2 qsort函数 此函数的原型可以在\u0026lt;stdlib.h\u0026gt;中找到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 void qsort(void *base, size_t nmemb, size_t size, int (*compar) (const void *, const void *)); qsort(inventory, num_parts, sizeof(struct part), compare_parts); int compare_parts(const void *p, const void *q) { const struct part *p1 = p; const struct part *q1 = q; if (p1-\u0026gt;number \u0026lt; q1-\u0026gt;number) return -1; else if (p1-\u0026gt;number == q1-\u0026gt;number) return 0; else return 1; } // 使用强制类型转换 int compare_parts(const void *p, const void *q) { if (((struct part *) p)-\u0026gt;number \u0026lt; ((struct part *) q)-\u0026gt;number) return -1; else if (((struct part *) p)-\u0026gt;number == ((struct part *) q)-\u0026gt;number) return 0; else return 1; } // 移除if int compare_parts(const void *p, const void *q) { return ((struct part *) p)-\u0026gt;number - ((struct part *) q)-\u0026gt;number; } 17.7.3 函数指针的其他用途 可以把函数指针存储在变量中，或者用作数组的元素，再或者用作结构或联合的成员，甚至可以编写返回函数指针的函数\n指向函数的指针\n1 2 3 4 5 6 void (*pf)(int); pf = f; (*pf)(i); // 或 pf(i); 函数指针数组\n1 2 3 4 5 6 7 8 9 10 11 void (*file_cmd[])(void) = {new_cmd, open_cmd, close_cmd, close_all_cmd, save_cmd, save_as_cmd, save_all_cmd, print_cmd, exit_cmd }; (*file_cmd[n])(); /* or file_cmd[n](); */ 17.8 受限指针(c99) 1 int * restrict p; 这样做的目的是，如果指针p指向的对象在之后需要修改，那么该对象不会允许通过除指针p之外的任何方式访问（其他访问对象的方式包括让另一个指针指向同 一个对象，或者让指针p指向命名变量）。如果一个对象有多种访问方式，通常把这些方式互称为别名。\n17.9 灵活数组成员(c99) ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC17%E7%AB%A0-%E6%8C%87%E9%92%88%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/","summary":"17.1 动态存储分配 即在程序执行期间分配内存单元的能力。 17.1.1 内存分配函数 这些函数都是声明在\u0026lt;stdlib.h\u0026gt;中 malloc函数——分配","title":"第17章 指针的高级应用"},{"content":"16.1 结构变量 16.1.1 结构变量的声明 1 2 3 4 5 struct { int number; char name[NAME_LEN+1]; int on_hand; } part1, part2; 16.1.2 结构变量的初始化 1 2 3 4 5 6 struct { int number; char name[NAME_LEN+1]; int on_hand; } part1 = {528, \u0026#34;Disk drive\u0026#34;, 10}, part2 = {914, \u0026#34;Printer cable\u0026#34;, 5}; 初始化式中的成员数可以少于它所初始化的结构，就像数组那样，任何“剩余的”成员都用0作为它的初始值。\n16.1.3 指定初始化(c99) 1 {.number = 528, .name = \u0026#34;Disk drive\u0026#34;, .on_hand = 10} 值\u0026quot;Disk drive\u0026quot;的前面并没有指示符，所以编译器会认为它用于初始化结构中位于number之后的成员。初始化式中没有涉及的成员都设为0。\n1 {.number = 528, \u0026#34;Disk drive\u0026#34;, .on_hand = 10} 16.1.4 对结构的操作 访问结构内的成员\n1 2 3 4 5 6 7 8 9 10 11 12 13 printf(\u0026#34;Part number: %d\\n\u0026#34;, part1.number); printf(\u0026#34;Part name: %s\\n\u0026#34;, part1.name); printf(\u0026#34;Quantity on hand: %d\\n\u0026#34;, part1.on_hand); Part1.number = 258; /* changes part1\u0026#39;s part number */ Part1.on_hand++; /* increments part1\u0026#39;s quantity on hand */ scanf(\u0026#34;%d\u0026#34;, \u0026amp;part1.on_hand); // 复制每个字段 part2 = part1; // 可以复制数组 struct { int a[10]; } a1, a2; a1 = a2; /* legal, since a1 and a2 are structures */ 不能使用运算符==和!=来判定两个结构相等还是不等。\n16.2 结构类型 C语言提供了两种命名结构的方法：可以声明“结构标记”，也可以使用typedef来定义类型名\n16.2.1 结构标记的声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct part { int number; char name[NAME_LEN+1]; int on_hand; };// 注意分号 struct part part1, part2; // 不能通过漏掉单词struct来缩写这个声明 part part1, part2; /*** WRONG ***/ // 同时声明变量 struct part { int number; char name[NAME_LEN+1]; int on_hand; } part1, part2; // 所有声明为struct part类型的结构彼此之间是兼容的 struct part part1 = {528, \u0026#34;Disk drive\u0026#34;, 10}; struct part part2; part2 = part1; /* legal; both parts have the same type */ 16.2.2 结构类型的定义 1 2 3 4 5 6 typedef struct { int number; char name[NAME_LEN+1]; int on_hand; } Part; Part part1, part2; 16.2.3 结构作为参数和返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void print_part(struct part p) { printf(\u0026#34;Part number: %d\\n\u0026#34;, p.number); printf(\u0026#34;Part name: %s\\n\u0026#34;, p.name); printf(\u0026#34;Quantity on hand: %d\\n\u0026#34;, p.on_hand); } print_part(part1); struct part build_part(int number, const char * name, int on_hand) { struct part p; p.number = number; strcpy (p.name, name); p.on_hand = on_hand; return p; } part1 = build_part(528, \u0026#34;Disk drive\u0026#34;, 10); void f(struct part part1) { struct part part2 = part1; ... } 16.2.4 复合字面量(c99) 1 2 3 4 5 6 7 print_part((struct part) {528, \u0026#34;Disk drive\u0026#34;, 10}); part1 = (struct part) {528, \u0026#34;Disk drive\u0026#34;, 10}; // typedef也可以 print_part((struct part) {.on_hand = 10, .name = \u0026#34;Disk drive\u0026#34;, .number = 528}); 复合字面量不会提供完全的初始化，所以任何未初始化的成员默认值为0。\n16.3 嵌套的数组和结构 16.3.1 嵌套的结构 1 2 3 4 5 6 7 8 9 10 11 12 struct person_name { char first[FIRST_NAME_LEN+1]; char middle_initial; char last[LAST_NAME_LEN+1]; }; struct student { struct person_name name; int_id, age; char sex; } student1, student2; strcpy(student1.name.first, \u0026#34;Fred\u0026#34;); 16.3.2 结构数组 1 2 3 4 5 struct part inventory[100]; print_part(inventory[i]); inventory[i].number = 883; inventory[i].name[0] = \u0026#39;\\0\u0026#39;; 16.3.3 结构数组的初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const struct dialing_code country_codes[] = {{\u0026#34;Argentina\u0026#34;, 54}, {\u0026#34;Bangladesh\u0026#34;, 880}, {\u0026#34;Brazi1\u0026#34;, 55}, {\u0026#34;Burma (Myanmar)\u0026#34;, 95}, {\u0026#34;China\u0026#34;, 86}, {\u0026#34;Colombia\u0026#34;, 57}, {\u0026#34;Congo, Dem. Rep. of\u0026#34;, 243}, {\u0026#34;Egypt\u0026#34;, 20}, {\u0026#34;Ethiopia\u0026#34;, 251}, {\u0026#34;France\u0026#34;, 33}, {\u0026#34;Germany\u0026#34;, 49}, {\u0026#34;India \u0026#34;, 91}, {\u0026#34;Indonesia\u0026#34; 62}, {\u0026#34;Iran\u0026#34;, 98}, {\u0026#34;Italy\u0026#34;, 39}, {\u0026#34;Japan\u0026#34;, 81}, {\u0026#34;Mexico\u0026#34;, 52}, {\u0026#34;Nigeria\u0026#34;, 234}, {\u0026#34;Pakistan\u0026#34;, 92}, {\u0026#34;Philippines\u0026#34;, 63}, {\u0026#34;Poland\u0026#34;, 48}, {\u0026#34;Russia\u0026#34;, 7}, {\u0026#34;South Africa\u0026#34;, 27}, {\u0026#34;Korea\u0026#34; 82}, {\u0026#34;Spain\u0026#34;, 34}, {\u0026#34;Sudan\u0026#34; 249}, {\u0026#34;Thailand\u0026#34;, 66}, {\u0026#34;Turkey\u0026#34;, 90}, {\u0026#34;Ukraine\u0026#34;, 380}, {\u0026#34;United Kingdom\u0026#34;, 44}, {\u0026#34;United States\u0026#34;, 1}, {\u0026#34;Vietnam\u0026#34;, 84}}; C99的指定初始化式允许每一项具有多个指示符。\n指示符是指[], . 1 2 struct part inventory[100] = {[0].number = 528, [0].on_hand = 10, [0].name[0] = \u0026#39;\\0\u0026#39;}; 16.4 联合 编译器只为联合中最大的成员分配足够的内存空间。\n1 2 3 4 5 6 7 8 9 union { int i; double d; } u; struct { int i; double d; } s; 访问联合成员\n如果把一个值存储到u.d中，那么先前存储在u.i中的值将会丢失。 1 2 u.i = 82; u.d = 74.8; 初始化\n1 2 3 4 5 6 7 8 9 union { int i; double d; } u = {0}; union { int i; double d; } u = {.d = 10.0}; 16.4.1 用联合来节省空间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct catalog_item { int stock_number; double price; int item_type; union { struct { char title[TITLE_LEN+1]; char author[AUTHOR_LEN+1]; int num_pages; } book; struct { char design[DESIGN_LEN+1]; } mug; struct { char design[DESIGN_LEN+1]; int colors; int sizes; } shirt; } item; }; printf(\u0026#34;%s\u0026#34;, c.item.book.title); C标准提到了一种特殊情况：联合的两个或多个成员是结构，而这些结构最初的一个或多个成员是相匹配的。（这些成员的顺序应该相同，类型也要兼容，但名字 可以不一样。）如果当前某个结构有效，则其他结构中的匹配成员也有效。\n1 2 strcpy(c.item.mug.design, \u0026#34;Cats\u0026#34;); printf(\u0026#34;%s\u0026#34;, c.item.shirt.design); /* prints \u0026#34;Cats\u0026#34; */ 16.4.2 用联合来构造混合的数据结构 1 2 3 4 5 6 7 typedef union { int i; double d; } Number; Number number_array[1000]; number_array[0].i = 5; number_array[1].d = 8.395; 16.4.3 为联合添加“标记字段” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define INT_KIND 0 #define DOUBLE_KIND 1 typedef struct { int kind; /* tag field */ union{ int i; double d; } u; } Number; n.kind = INT_KIND; n.u.i = 82; void print_number(Number n) { if (n.kind == INT_KIND) printf(\u0026#34;%d\u0026#34;, n.u.i); else printf(\u0026#34;%g\u0026#34;, n.u.d); } 16.5 枚举 1 enum {CLUBS, DIAMONDS, HEARTS, SPADES} s1, s2; 枚举常量的名字必须不同于作用域范围内声明的其他标识符。\n16.5.1 枚举标记和类型名 1 2 3 4 5 enum suit {CLUBS, DIAMONDS, HEARTS, SPADES}; enum suit s1, s2; typedef enum {CLUBS, DIAMONDS, HEARTS, SPADES} Suit; Suit s1, s2; 16.5.2 枚举作为整数 在系统内部，C语言会把枚举变量和常量作为整数来处理。\n在枚举suit的例子中，CLUBS、DIAMONDS、HEARTS和SPADES分别表示0、1、2和3。\n可以为枚举常量自由选择不同的值。\n1 2 3 // 可以不用按照特定的顺序 enum suit {CLUBS = 1, DIAMONDS = 2, HEARTS = 3, SPADES = 4}; // 两个或多个枚举常量具有相同的值甚至也是合法的 当没有为枚举常量指定值时，它的值比前一个常量的值大1。（第一个枚举常量的值默认为0。）\n1 enum EGA_colors {BLACK, LT_GRAY = 7, DK_GRAY, WHITE = 15}; 枚举的值只不过是一些稀疏分布的整数，所以C语言允许把它们与普通整数进行混合\n1 2 3 4 5 6 int i; enum {CLUBS, DIAMONDS, HEARTS, SPADES} s; i = DIAMONDS; /* i is now 1 */ s = 0; /* s is now 0 (CLUBS) */ s++; /* s is now 1 (DIAMONDS) */ i = s + 2; /* i is now 3 */ 16.5.3 用枚举声明“标记字段” 1 2 3 4 5 6 7 typedef struct { enum {INT_KIND, DOUBLE_KIND} kind; union { int i; double d; } u; } Number; ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC16%E7%AB%A0-%E7%BB%93%E6%9E%84-%E8%81%94%E5%90%88%E5%92%8C%E6%9E%9A%E4%B8%BE/","summary":"16.1 结构变量 16.1.1 结构变量的声明 1 2 3 4 5 struct { int number; char name[NAME_LEN+1]; int on_hand; } part1, part2; 16.1.2 结构变量的初始化 1 2 3 4 5 6 struct { int number; char name[NAME_LEN+1]; int on_hand; } part1 = {528, \u0026#34;Disk drive\u0026#34;, 10}, part2 = {914, \u0026#34;Printer cable\u0026#34;, 5}; 初始化式中","title":"第16章 结构, 联合和枚举"},{"content":"15.1 源文件 根据惯例，源文件的扩展名为.c。\n15.2 头文件 #include指令，此指令使得在任意数量的源文件中共享信息成为可能，这些信息可以是函数原型、宏定义、类型定义等。\n根据惯例，头文件的扩展名为.h。\n15.2.1 #include指令 第一种格式用于属于C语言自身库的头文件\n1 #include \u0026lt;文件名\u0026gt; 第二种格式用于所有其他头文件，也包含任何自己编写的文件\n1 #include \u0026#34;文件名\u0026#34; #include \u0026lt;文件名\u0026gt;：搜寻系统头文件所在的目录（或多个目录）。（例如，在UNIX系统中，通常把系统头文件保存在目录/usr/include中。） #include \u0026ldquo;文件名\u0026rdquo;：先搜寻当前目录，然后搜寻系统头文件所在的目录（或多个目录）。 在#include指令中的文件名可以含有帮助定位文件的信息，比如目录的路径或驱动器号：\n1 2 3 // 不推荐带路径 #include \u0026#34;c:\\cprogs\\utils.h\u0026#34; /* Windows path */ #include \u0026#34;/cprogs/utils.h\u0026#34; /* UNIX path */ #include指令还有一种不太常用的格式\n1 #include 记号 1 2 3 4 5 6 7 8 #if defined(IA32) #define CPU_FILE \u0026#34;ia32.h\u0026#34; #elif defined(IA64) #define CPU_FILE \u0026#34;ia64.h\u0026#34; #elif defined(AMD64) #define CPU_FILE \u0026#34;amd64.h\u0026#34; #endif #include CPU_FILE 15.2.2 共享宏定义和类型定义 1 2 3 4 5 6 #define BOOL int #define TRUE 1 #define FALSE 0 // 任何需要这些宏的源文件只需简单包含下面这一行 #include \u0026#34;boolean.h\u0026#34; 类型定义在头文件中也是很普遍的。\n1 2 3 #define TRUE 1 #define FALSE 0 typedef int Bool; 15.2.3 共享函数原型 既然在文件foo.c中定义了函数f，我们把头文件命名为foo.h。除了在调用函数f的源文件中包含foo.h，还需要在foo.c中包含它，从而使编译器可以验证 foo.h中函数f的原型和foo.c中f的函数定义相匹配。\nstack.h\n1 2 3 4 5 void make_empty(void); int is_empty (void); int is_full (void); void push(int i); int pop (void); 文件calc.c中将包含stack.h以便编译器检查在后面的文件中出现的栈函数的任何调用。文件stack.c中也将包含stack.h以便编译器验证stack.h中的函数 原型是否与stack.c中的定义相匹配。\n15.2.4 共享变量声明 声明也是定义变量\n1 int i; /* declares i and defines it as well */ 声明变量\n1 extern int i; /* declares i without defining it */ extern告诉编译器，变量i是在程序中的其他位置定义的（很可能是在不同的源文件中），因此不需要为i分配空间。\nextern可以用于所有类型的变量。在数组的声明中使用extern时，可以省略数组的长度：\n1 extern int a[]; 为了避免不一致，通常把共享变量的声明放置在头文件中。需要访问特定变量的源文件可以包含相应的头文件。此外，含有变量定义的源文件需要包含含有相应 变量声明的头文件，这样编译器就可以检查声明与定义是否匹配。\n15.2.5 嵌套包含 头文件自身也可以包含#include指令。\n15.2.6 保护头文件 两次包含同一个头文件不总是会导致编译错误。如果文件只包含宏定义、函数原型和/或变量声明，那么将不会有任何困难。然而，如果文件包含类型定义，则会 带来编译错误。\n此外，在程序开发期间，避免同一个头文件的不必要重复编译可以节省一些时间。\n为了防止头文件多次包含，用#ifndef和#endif指令来封闭文件的内容。\n1 2 3 4 5 6 #ifndef BOOLEAN_H #define BOOLEAN_H #define TRUE 1 #define FALSE 0 typedef int Bool; #endif 15.2.7 头文件中的#error指令 1 2 3 #ifndef __STDC__ #error This header requires a Standard C compiler #endif 15.3 把程序划分成多个文件 15.4 构建多文件程序 1 gcc -o justify justify.c line.c word.c 15.4.1 makefile 15.4.2 链接期间的错误 15.4.3 重新构建程序 15.4.4 在程序外定义宏 1 gcc -DDEBUG=1 foo.c 如果-D选项命名的宏没有指定值，那么这个值被设为1。\n许多编译器也支持-U选项，这个选项用于删除宏的定义，效果相当于#undef。\n","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC15%E7%AB%A0-%E7%BC%96%E5%86%99%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F/","summary":"15.1 源文件 根据惯例，源文件的扩展名为.c。 15.2 头文件 #include指令，此指令使得在任意数量的源文件中共享信息成为可能，这些信息可以是函数原型","title":"第15章 编写大型程序"},{"content":"14.1 预处理器的工作原理 #define指令定义了一个宏——用来代表其他东西的一个名字. 当这个宏在后面的程序中使用到时，预处理器“扩展”宏，将宏替换为其定义值。\n#include指令告诉预处理器打开一个特定的文件，将它的内容作为正在编译的文件的一部分“包含”进来。\n预处理器的输入是一个C语言程序，程序可能包含指令。预处理器会执行这些指令，并在处理过程中删除这些指令。预处理器的输出是另一个C程序：原程序编辑 后的版本，不再包含指令。预处理器的输出被直接交给编译器，编译器检查程序是否有错误，并将程序翻译为目标代码（机器指令）。\n预处理器不仅仅是执行了指令，还做了一些其他的事情。特别值得注意的是，它将每一处注释都替换为一个空格字符。有一些预处理器还会进一步删除不必要的 空白字符，包括每一行开始用于缩进的空格符和制表符。\n预处理器仅知道少量C语言的规则。因此，它在执行指令时非常有可能产生非法的程序。经常是原始程序看起来没问题，使错误查找起来很难。对于较复杂的程序， 检查预处理器的输出可能是找到这类错误的有效途径。\n14.2 预处理指令 宏定义。#define指令定义一个宏，#undef指令删除一个宏定义。 文件包含。#include指令导致一个指定文件的内容被包含到程序中。 条件编译。#if、#ifdef、#ifndef、#elif、#else和#endif指令可以根据预处理器可以测试的条件来确定是将一段文本块包含到程序中还是将其排除在 程序之外。 剩下的#error、#line和#pragma指令是更特殊的指令，较少用到。 指令总是在第一个换行符处结束，除非明确地指明要延续。\n1 2 3 4 #define DISK_CAPACITY (SIDES * \\ TRACKS_PER_SIDE * \\ SECTORS_PER_TRACK * \\ BYTES_PER_SECTOR) 指令可以出现在程序中的任何地方。但我们通常将#define和#include指令放在文件的开始，其他指令则放在后面，甚至可以放在函数定义的中间。\n14.3 宏定义 14.3.1 简单的宏 #define 标识符 替换列表\n宏的替换列表可以包括标识符、关键字、数值常量、字符常量、字符串字面量、操作符和排列。\n不要在宏定义中放置任何额外的符号，否则它们会被作为替换列表的一部分。\n1 2 3 4 5 6 7 #define N = 100 /*** WRONG ***/ ... int a[N]; /* becomes int a[= 100]; */ // 在宏定义的末尾使用分号结尾是另一个常见错误 #define N 100; /*** WRONG ***/ ... int a[N]; /* becomes int a[100;]; */ 编译器可以检测到宏定义中绝大多数由多余符号所导致的错误。但是，编译器只会将每一个使用这个宏的地方标为错误，而不会直接找到错误的根源——宏定义本 身，因为宏定义已经被预处理器删除了。\n可以使用宏给数值、字符值和字符串值命名\n1 2 3 4 5 6 7 #define STE_LEN 80 #define TRUE 1 #define FALSE 0 #define PI 3.14159 #define CR \u0026#39;\\r\u0026#39; #define EOS \u0026#39;\\0\u0026#39; #define MEM_ERR \u0026#34;Error: not enough memory\u0026#34; 14.3.2 带参数的宏 #define 标识符(x1, x2,\u0026hellip;, xn)替换列表\n其中x\u0026hellip;是标识符（宏的参数）。这些参数可以在替换列表中根据需要出现任意次。\n在宏的名字和左括号之间必须没有空格。如果有空格，预处理器会认为是在定义一个简单的宏，其中x\u0026hellip;是替换列表的一部分。 1 2 3 4 5 #define MAX(x,y) ((x)\u0026gt;(y)?(x):(y)) #define IS_EVEN(n) ((n)%2==0) i = MAX(j+k, m-n); if (IS_EVEN(i)) i++; 带参数的宏可以包含空的参数列表\n1 #define getchar() getc(stdin) 缺点\n宏参数没有类型检查 无法用一个指针来指向一个宏 宏可能会不止一次地计算它的参数 1 2 n = MAX(i++, j); n = ((i++)\u0026gt;(j)?(i++):(j)); 14.3.3 #运算符 #运算符将宏的一个参数转换为字符串字面量。它仅允许出现在带参数的宏的替换列表中。\n1 2 3 4 5 6 7 #define PRINT_INT(n) printf(#n \u0026#34; = %d\\n\u0026#34;, n) PRINT_INT(i/j); // 变为 printf(\u0026#34;i/j\u0026#34; \u0026#34; = %d\\n\u0026#34;, i/j); // 等价于 printf(\u0026#34;i/j = %d\\n\u0026#34;, i/j); 14.3.4 ##运算符 ##运算符可以将两个记号（如标识符）“粘合”在一起，成为一个记号。\n1 2 3 4 5 #define MK_ID(n) i##n int MK_ID(1), MK_ID(2), MK_ID(3); // 变为 int i1, i2, i3; 用C实现泛型\n1 2 3 4 5 6 7 8 9 #define GENERIC_MAX(type) \\ type type##_max(type x, type y) \\ { \\ return x \u0026gt; y ? x : y; \\ } GENERIC_MAX(float) // 变为 float float_max(float x, float y) { return x \u0026gt; y ? x : y; } 14.3.5 宏的通用属性 宏的替换列表可以包含对其他宏的调用 1 2 #define PI 3.14159 #define TWO_PI (2*PI) 宏定义的作用范围通常到出现这个宏的文件末尾 宏不可以被定义两遍，除非新的定义与旧的定义是一样的 宏可以使用#undef指令“取消定义”. 如果N没有被定义成一个宏，#undef指令没有任何作用。 1 #undef N 14.3.6 宏定义中的圆括号 如果我们少用几个圆括号，宏有时可能会得到意想不到的\n如果宏的替换列表中有运算符，那么始终要将替换列表放在括号中 1 #define TWO_PI (2*3.14159) 如果宏有参数，每个参数每次在替换列表中出现时都要放在圆括号中 1 #define SCALE(x) ((x)*10) 14.3.7 创建较长的宏 在创建较长的宏时，逗号运算符会十分有用\n1 2 3 4 // 先gets, 再puts #define ECHO(s) (gets(s), puts(s)) ECHO(str); /* 替换为 (gets(str), puts(str)); */ 定义复合语句：\n1 2 3 4 5 6 7 8 #define ECHO(s) \\ do { \\ gets(s); \\ puts(s); \\ } while (0) ECHO(str); /* becomes do { gets(str); puts(str); } while (0); */ 14.3.8 预定义宏 表14-1 预定义宏\n14.3.9 C99中新增的预定义宏 表14-2 C99中新增的预定义宏\n14.3.10 空的宏参数 C99允许宏调用中的任意或所有参数为空。当然这样的调用需要有和一般调用一样多的逗号\n1 2 3 4 5 6 7 8 9 #define ADD(x,y) (x+y) i = ADD(j,k); // 变为 i = (j+k); i = ADD(,k); // 变为 i = (+k); 当空参数是#或##运算符的操作数时，用法有特殊规定。如果空的实际参数被#运算符“字符串化”，则结果为\u0026quot;\u0026quot;（空字符串）\n1 2 3 4 5 #define MK_STR(x) #x ... char empty_string[] = MK_STR(); // 变为 char empty_string[] = \u0026#34;\u0026#34;; 1 2 3 4 5 #define JOIN(x,y,z) x##y##z ... int JOIN(a,b,c), JOIN(a,b,), JOIN(a,,c), JOIN(,,c); // 变为 int abc, ab, ac, c; 14.3.11 参数个数可变的宏 在C89中，如果宏有参数，那么参数的个数是固定的。在C99中，这个条件被适当放宽了，允许宏具有可变长度的参数列表\n宏具有可变参数个数的主要原因是：它可以将参数传递给具有可变参数个数的函数，如printf和scanf。\n1 2 3 4 5 6 7 8 9 10 #define TEST(condition, ...) ((condition)? \\ printf(\u0026#34;Passed test: %s\\n\u0026#34;, #condition): \\ printf(__VA_ARGS__)) TEST(voltage \u0026lt;= max_voltage, \u0026#34;Voltage %d exceeds %d\\n\u0026#34;, voltage, max_voltage); // 变为 ((voltage \u0026lt;= max_voltage)? printf(\u0026#34;Passed test: %s\\n\u0026#34;, \u0026#34;voltage \u0026lt;= max_voltage\u0026#34;): printf(\u0026#34;Voltage %d exceeds %d\\n\u0026#34;, voltage, max_voltage)); 14.3.12 __func__标识符 C99的另一个新特性是__func__标识符。__func__与预处理器无关\n每一个函数都可以访问__func__标识符，它的行为很像一个存储当前正在执行的函数的名字的字符串变量。\n其作用相当于在函数体的一开始包含如下声明 1 static const char __func__[] = \u0026#34;function-name\u0026#34;; 这个标识符的存在使得我们可以写出如下的调试宏\n1 2 #define FUNCTION_CALLED() printf(\u0026#34;%s called\\n\u0026#34;, __func__); #define FUNCTION_RETURNS() printf(\u0026#34;%s returns\\n\u0026#34;, __func__); __func__的另一个用法：作为参数传递给函数，让函数知道调用它的函数的名字。\n14.4 条件编译 14.4.1 #if指令和#endif指令 1 2 3 4 5 #define DEBUG 1 #if DEBUG printf(\u0026#34;Value of i: %d\\n\u0026#34;, i); printf(\u0026#34;Value of j: %d\\n\u0026#34;, j); #endif #if指令会把没有定义过的标识符当作是值为0的宏对待\n14.4.2 defined运算符 defined运算符通常与#if指令结合使用\n1 2 3 4 5 6 7 8 9 #if defined(DEBUG) ... #endif // 括号不是必须的 #if defined DEBUG // 由于defined运算符仅检测DEBUG是否有定义，所以不需要给DEBUG赋值 #define DEBUG 14.4.3 #ifdef指令和#ifndef指令 #ifdef指令测试一个标识符是否已经定义为宏\n1 2 3 4 5 6 #ifdef 标识符 当标识符被定义为宏时需要包含的代码 #endif // 等价于 #if defined(标识符) #ifndef指令测试的是标识符是否没有被定义为宏：\n1 2 3 #ifndef 标识符 // 等价于 #if !defined(标识符) 14.4.4 #elif指令和#else指令 1 2 3 4 5 6 7 #if 表达式1 当表达式1非0时需要包含的代码 #elif 表达式2 当表达式1为0但表达式2非0时需要包含的代码 #else 其他情况下需要包含的代码 #endif 在#if指令和#endif指令之间可以有任意多个#elif指令，但最多只能有一个#else指令。\n14.4.5 使用条件编译 为宏提供默认定义\n1 2 3 #ifndef BUFFER_SIZE #define BUFFER_SIZE 256 #endif 临时屏蔽包含注释的代码\n1 2 3 #if 0 包含注释的代码行 #endif 14.5 其他指令 14.5.1 #error指令 #error 消息\n如果预处理器遇到#error指令，它会显示一条包含消息的出错消息。对于不同的编译器，出错消息的具体形式也可能会不一样。\n1 2 3 #if INT_MAX \u0026lt; 100000 #error int type is too small #endif 14.5.2 #line指令 14.5.3 #pragma指令 14.5.4 _Pragma运算符(c99) ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC14%E7%AB%A0-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/","summary":"14.1 预处理器的工作原理 #define指令定义了一个宏——用来代表其他东西的一个名字. 当这个宏在后面的程序中使用到时，预处理器“扩展”宏，将宏替","title":"第14章 预处理器"},{"content":"13.1 字符串字面量 字符串字面量（string literal）是用一对双引号括起来的字符序列：\n1 \u0026#34;When you come to a fork in the road, take it.\u0026#34; 13.1.1 字符串字面量中的转义序列 1 \u0026#34;Candy\\nIs dandy\\nBut liquor\\nIs quicker.\\n --Ogden Nash\\n\u0026#34; 13.1.2 延续字符串字面量 1 2 printf(\u0026#34;When you come to a fork in the road, take it. \\ --Yogi Berra\u0026#34;); 使用\\有一个缺陷：字符串字面量必须从下一行的起始位置继续。因此，这就破坏了程序的缩进结构。\n更好的方法\n1 2 printf(\u0026#34;When you come to a fork in the road, take it. \u0026#34; \u0026#34;--Yogi Berra\u0026#34;); 13.1.3 如何存储字符串字面量 C语言把字符串字面量作为字符数组来处理。 n个字符分配n+1个空间, 最后用\\0标记字符串结束 空字符串: \u0026quot;\u0026quot;(\\0) 13.1.4 字符串字面量的操作 1 2 3 4 5 char *p; p = \u0026#34;abc\u0026#34;; char ch; ch = \u0026#34;abc\u0026#34;[1]; 试图改变字符串字面量会导致未定义的行为\n1 2 char *p = \u0026#34;abc\u0026#34;; *p = \u0026#39;d\u0026#39;; /*** WRONG ***/ 13.1.5 字符串字面量与字符常量 只包含一个字符的字符串字面量不同于字符常量。字符串字面量\u0026quot;a\u0026quot;是用指针来表示的，这个指针指向存放字符\u0026quot;a\u0026quot;（后面紧跟空字符）的内存单元。字符常量 \u0026lsquo;a\u0026rsquo;是用整数（字符集的数值码）来表示的。\n13.2 字符串变量 1 2 3 #define STR_LEN 80 ... char str[STR_LEN+1]; 字符串的长度取决于空字符的位置\n13.2.1 初始化字符串变量 1 2 // 剩余空间编译器填充\\0 char date1[8] = \u0026#34;June 14\u0026#34;; C语言允许初始化式（不包括空字符）与变量有完全相同的长度：\n1 char date3[7] = \u0026#34;June 14\u0026#34;; 字符串变量的声明中可以省略它的长度。这种情况下，编译器会自动计算长度\n1 char date4[] = \u0026#34;June 14\u0026#34;; 13.2.2 字符数组与字符指针 1 2 char date[] = \u0026#34;June 14\u0026#34;; char *date = \u0026#34;June 14\u0026#34;; 在声明为数组时，就像任意数组元素一样，可以修改存储在date中的字符。在声明为指针时，date指向字符串字面量，在13.1节我们已经看到字符串字面量 是不可以修改的。 在声明为数组时，date是数组名。在声明为指针时，date是变量，这个变量可以在程序执行期间指向其他字符串。 在使用p作为字符串之前，必须把p指向字符数组\n1 2 3 4 5 6 7 8 9 10 char *p; char str[STR_LEN+1], *p; p = str; // 使用未初始化的指针变量作为字符串是非常严重的错误。 char *p; p[0] = \u0026#39;a\u0026#39;; /*** WRONG ***/ p[1] = \u0026#39;b\u0026#39;; /*** WRONG ***/ p[2] = \u0026#39;c\u0026#39;; /*** WRONG ***/ p[3] = \u0026#39;\\0\u0026#39;; /*** WRONG ***/ 13.3 字符串的读和写 13.3.1 用printf函数和puts函数写字符串 1 2 char str[] = \u0026#34;Are we having fun yet?\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, str); printf函数会逐个写字符串中的字符，直到遇到空字符才停止。\n如果空字符丢失，printf函数会越过字符串的末尾继续写，直到最终在内存的某个地方找到空字符为止。 显示字符串的一部分\n1 2 // Are we printf(\u0026#34;%.6s\\n\u0026#34;, str); 转换说明%m.ps会使字符串的前p个字符在大小为m的字段内显示。\nC函数库还提供了puts函数, puts函数总会添加一个额外的换行符\n1 puts(str); 13.3.2 用scanf函数和gets函数读字符串 调用时，scanf函数会跳过空白字符，然后读入字符并存储到str中，直到遇到空白字符为止。scanf函数始终会在字符串末尾存储一个空字符。\n1 scanf(\u0026#34;%s\u0026#34;, str); 为了一次读入一整行输入，可以使用gets函数。gets函数把读入的字符放到数组中，然后存储一个空字符。\ngets函数不会在开始读字符串之前跳过空白字符（scanf函数会跳过）。 gets函数会持续读入直到找到换行符才停止（scanf函数会在任意空白字符处停止）。 gets函数会忽略掉换行符，不会把它存储到数组中，用空字符代替换行符。 在把字符读入数组时，scanf函数和gets函数都无法检测数组何时被填满。\nscanf可以用%ns转换说明, 指定最多字符数 gets没法指定限制 fgets是更好的选择 13.3.3 逐个字符读字符串 1 2 3 4 5 6 7 8 9 int read_line(char str[], int n) { int ch, i = 0; while ((ch = getchar()) != \u0026#39;\\n\u0026#39;) if (i \u0026lt; n) str[i++] = ch; str[i] = \u0026#39;\\0\u0026#39;; /* terminates string */ return i; /* number of characters stored */ } 13.4 访问字符串中的字符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int count_spaces(const char s[]) { int count = 0, i; for (i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) if (s[i] == \u0026#39; \u0026#39;) count++; return count; } // const阻止的是改变字符, 而不阻止改变s所指向的地址 int count_spaces(const char *s) { int count = 0; for (; *s != \u0026#39;\\0\u0026#39;; s++) if (*s == \u0026#39; \u0026#39;) count++; return count; } 13.5 使用C语言的字符串库 直接复制或比较字符串会失败。\n1 2 3 4 5 6 7 8 9 10 char str1[10], str2[10]; // 利用=运算符来把字符串复制到字符数组中是不可能的 str1 = \u0026#34;abc\u0026#34;; /*** WRONG ***/ str2 = str1; /*** WRONG ***/ // 把数组名用作=的左操作数是非法的。但是，使用=初始化字符数组是合法的 // 因为在声明中=不是赋值运算符 char str1[10] = \u0026#34;abc\u0026#34;; // 使用关系运算符或判等运算符来比较字符串是合法的，但不会产生预期的结果 // 比较的是地址 if (str1 == str2) ... /*** WRONG ***/ 需要字符串操作的程序应该包含下列内容\n1 #include \u0026lt;string.h\u0026gt; 要注意那些没有声明为const的字符串形式参数。这些形式参数可能会在调用函数时发生改变，所以对应的实际参数不应该是字符串字面量。\n13.5.1 strcpy函数 1 char *strcpy(char *s1, const char *s2); 更安全的用法\n1 2 strncpy(str1, str2, sizeof(str1) - 1); str1[sizeof(str1)-1] = \u0026#39;\\0\u0026#39;; 13.5.2 strlen函数 13.5.3 strcat函数 13.5.4 strcmp函数 13.6 字符串惯用法 13.7 字符串数组 1 2 3 4 5 6 7 8 9 10 char planets[][8] = {\u0026#34;Mercury\u0026#34;, \u0026#34;Venus\u0026#34;, \u0026#34;Earth\u0026#34;, \u0026#34;Mars\u0026#34;, \u0026#34;Jupiter\u0026#34;, \u0026#34;Saturn\u0026#34;, \u0026#34;Uranus\u0026#34;, \u0026#34;Neptune\u0026#34;, \u0026#34;Pluto\u0026#34;}; // 不齐的数组 char *planets[] = {\u0026#34;Mercury\u0026#34;, \u0026#34;Venus\u0026#34;, \u0026#34;Earth\u0026#34;, \u0026#34;Mars\u0026#34;, \u0026#34;Jupiter\u0026#34;, \u0026#34;Saturn\u0026#34;, \u0026#34;Uranus\u0026#34;, \u0026#34;Neptune\u0026#34;, \u0026#34;Pluto\u0026#34;}; for (i = 0; i \u0026lt; 9; i++) if (planets[i][0] == \u0026#39;M\u0026#39;) printf(\u0026#34;%s begins with M\\n\u0026#34;, planets[i]); 命令行参数 为了能够访问这些命令行参数（C标准中称为程序参数），必须把main函数定义为含有两个参数的函数\n1 2 3 4 int main(int argc, char *argv[]) { ... } argc（“参数计数”）是命令行参数的数量（包括程序名本身），argv（“参数向量”）是指向命令行参数的指针数组，这些命令行参数以字符串的形式存储。\nargv有一个附加元素，即argv[argc]，这个元素始终是一个空指针。空指针是一种不指向任何地方的特殊指针。NULL宏\n遍历参数\n1 2 3 4 5 6 7 int i; for (i = 1; i \u0026lt; argc; i++) printf(\u0026#34;%s\\n\u0026#34;, argv[i]); char **p; for (p = \u0026amp;argv[1]; *p != NULL; p++) printf(\u0026#34;%s\\n\u0026#34;, *p); ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC13%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"13.1 字符串字面量 字符串字面量（string literal）是用一对双引号括起来的字符序列： 1 \u0026#34;When you come to a fork in the road, take it.\u0026#34; 13.1.1 字符串字面量中的转义序列 1","title":"第13章 字符串"},{"content":"12.1 指针的算术运算 1 2 3 int a[10], *p; p = \u0026amp;a[0]; *p = 5; C语言支持3种格式的指针算术运算\n指针加上整数； 指针减去整数； 两个指针相减。 12.1.1 指针加上整数 1 2 3 4 int a[10], *p, *q, i; p = \u0026amp;a[2]; q = p + 3; p += 6; 12.1.2 指针减去整数 1 2 3 p = \u0026amp;a[8]; q = p - 3; p -= 6; 12.1.3 两个指针相减 当两个指针相减时，结果为指针之间的距离\n如果p指向a[i]且q指向a[j]，那么p-q就等于i-j 1 2 3 4 5 p = \u0026amp;a[5]; q = \u0026amp;a[1]; i = p - q; /* i is 4 */ i = q - p; /* i is -4 */ 12.1.4 指针比较 比较的结果依赖于数组中两个元素的相对位置。例如，在下面的赋值后p \u0026lt;= q的值是0，而p \u0026gt;= q的值是1。\n1 2 p = \u0026amp;a[5]; q = \u0026amp;a[1]; 12.1.5 指向复合常量的指针(c99) 1 int *p = (int []){3, 0, 3, 4, 1}; 12.2 指针用于数组处理 1 2 3 4 5 6 7 #define N 10 ... int a[N], sum, *p; ... sum = 0; for (p = \u0026amp;a[0]; p \u0026lt; \u0026amp;a[N]; p++) sum += *p; *运算符和++运算符的组合 把值存入一个数组元素中，然后前进到下一个元素\n1 2 3 4 a[i++] = j; *p++ = j; // 与上面相同 *(p++) = j; 12.3 用数组名作为指针 可以用数组的名字作为指向数组第一个元素的指针。这种关系简化了指针的算术运算，而且使数组和指针更加通用。\n1 2 3 4 5 6 int a[10]; *a = 7; /* stores 7 in a[0] */ *(a+1) = 12; /* store 12 in a[1] */ for (p = a; p \u0026lt; a + N; p++) sum += *p; 不能给数组名赋新的值\n1 2 3 4 5 6 while (*a != 0) a++; /*** WRONG ***/ // 需要给新变量 p = a; while (*p != 0) p++; 12.3.1 数组型实际参数（改进版） 数组名在传递给函数时，总是被视为指针\n为了指明数组型形式参数不会被改变，可以在其声明中包含单词const：\n1 2 3 4 int find_largest(const int a[], int n) { ... } 如果需要，可以把数组型形式参数声明为指针\n1 2 3 4 int find_largest(int *a, int n) { ... } 对于形式参数而言，声明为数组跟声明为指针是一样的；但是对变量而言，声明为数组跟声明为指针是不同的。\n可以给形式参数为数组的函数传递数组的“片断”\n1 largest = find_largest(\u0026amp;b[5], 10); 12.3.2 用指针作为数组名 1 2 3 4 5 6 #define N 10 ... int a[N], i, sum = 0, *p = a; ... for (i = 0; i \u0026lt; N; i++) sum += p[i]; 12.4 指针和多维数组 12.4.1 处理多维数组的元素 1 2 3 4 5 int a[NUM_ROWS][NUM_COLS]; int *p; ... for (p = \u0026amp;a[0][0]; p \u0026lt;= \u0026amp;a[NUM_ROWS-1][NUM_COLS-1]; p++) *p = 0; 12.4.2 处理多维数组的行 对数组a的第i行清零\n1 2 3 4 int a[NUM_ROWS][NUM_COLS], *p, i; ... for (p = a[i]; p \u0026lt; a[i] + NUM_COLS; p++) *p = 0; 12.4.3 处理多维数组的列 下面的循环对数组a的第i列清零\n这里把p声明为指向长度为NUM_COLS的整型数组的指针。 *p是需要使用括号的；如果没有括号，编译器将认为p是指针数组，而不是指向数组的指针。 1 2 3 4 5 6 7 8 9 10 11 int a[NUM_ROWS][NUM_COLS], (*p)[NUM_COLS], i; ... for (p = \u0026amp;a[0]; p \u0026lt; \u0026amp;a[NUM_ROWS]; p++) (*p)[i] = 0; /* * int [] 整型数组 * int * 整型指针 * int *[] 整型指针数组 * int (*)[] 整型数组指针 * */ 12.4.4 用多维数组名作为指针 1 int a[NUM_ROWS][NUM_COLS]; a不是指向a[0][0]的指针，而是指向a[0]的指针。 用作指针时，a的类型是int (*)[NUM_COLS]（指向长度为NUM_COLS的整型数组的指针）。 把数组a的第i列清零\n1 2 3 4 5 for (p = \u0026amp;a[0]; p \u0026lt; \u0026amp;a [NUM_ROWS]; p++) (*p)[i] = 0; // 取代 for (p = a; p \u0026lt; a + NUM_ROWS; p++) (*p)[i] = 0; 另一种应用是巧妙地让函数把多维数组看成是一维数组。\n1 largest = find_largest(a[0], NUM_ROWS * NUM_COLS); 12.5 C99中的指针和变长数组 1 2 3 4 5 6 void f(int n) { int a[n], *p; p = a; ... } 如果变长数组是多维的，指针的类型取决于除第一维外每一维的长度。\n1 2 3 4 5 6 void f(int m, int n) { int a[m][n], (*p)[n]; p = a; ... } ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC12%E7%AB%A0-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84/","summary":"12.1 指针的算术运算 1 2 3 int a[10], *p; p = \u0026amp;a[0]; *p = 5; C语言支持3种格式的指针算术运算 指针加上整数； 指针减去整数； 两个指针相减。 12.1.1 指针加上整数 1 2 3 4 int a[10],","title":"第12章 指针和数组"},{"content":"11.1 指针变量 程序中的每个变量占有一个或多个字节内存，把第一个字节的地址称为是变量的地址。\n指针变量的声明 1 2 int *p; int i, j, a[10], b[20], *p, *q; C语言要求每个指针变量只能指向一种特定类型（引用类型）的对象：\n1 2 3 int *p; /* points only to integers */ double *q; /* points only to doubles */ char *r; /* points only to characters */ 指针变量甚至可以指向另一个指针\n11.2 取地址运算符和间接寻址运算符 声明指针变量是为指针留出空间，但是并没有把它指向对象：\n1 int *p; /* points nowhere in particular */ 在使用前初始化p是至关重要的。一种初始化指针变量的方法是使用\u0026amp;运算符把某个变量的地址赋给它，或者更常采用左值\n1 2 3 4 5 6 7 8 int i, *p; ... p = \u0026amp;i; int i; int *p = \u0026amp;i; int i, *p = \u0026amp;i; 11.2.2 间接寻址运算符 1 printf(\u0026#34;%d\\n\u0026#34;, *p); 如果指针变量p没有初始化，那么试图使用p的值会导致未定义的行为\n1 2 3 4 5 int *p; printf(\u0026#34;%d\u0026#34;, *p); /*** WRONG ***/ int *p; *p = 1; /*** WRONG ***/ 11.3 指针赋值 1 2 3 int i, j, *p, *q; p = \u0026amp;i; q = p; 11.4 指针作为参数 1 2 3 4 5 6 7 void decompose(double x, long *int_part, double *frac_part) { *int_part = (long) x; *fract_part = x - *int_part; } decompose(3.14159, \u0026amp;i, \u0026amp;d); 虽然scanf函数的实际参数必须是指针，但并不总是需要\u0026amp;运算符。\n1 2 3 4 5 6 int i, *p; ... p = \u0026amp;i; scanf(\u0026#34;%d\u0026#34;, p); scanf(\u0026#34;%d\u0026#34;, \u0026amp;p); /*** WRONG ***/ 用const保护参数 1 2 3 4 void f(const int *p) { *p = 0; /*** WRONG ***/ } 这一用法表明p是指向“常整数”的指针。试图改变*p是编译器会检查的一种错误。\n11.5 指针作为返回值 1 2 3 4 5 6 7 8 9 10 11 int *max(int *a, int *b) { if (*a \u0026gt; *b) return a; else return b; } int *p, i, j; ... p = max(\u0026amp;i, \u0026amp;j); 函数也可以返回指向外部变量或指向声明为static的局部变量的指针。\n永远不要返回指向自动局部变量的指针\n1 2 3 4 5 6 int *f(void) { int i; ... return \u0026amp;i; } 指针可以指向数组元素\n1 2 3 int *find_middle(int a[], int n) { return \u0026amp;a[n/2]; } ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC11%E7%AB%A0-%E6%8C%87%E9%92%88/","summary":"11.1 指针变量 程序中的每个变量占有一个或多个字节内存，把第一个字节的地址称为是变量的地址。 指针变量的声明 1 2 int *p; int i, j, a[10], b[20], *p, *q; C语言要求每个指针","title":"第11章 指针"},{"content":"10.1 局部变量 把在函数体内声明的变量称为该函数的局部变量。\n局部变量具有下列性质\n自动存储期限 块作用域, 从变量声明的点开始一直到所在函数体的末尾 C99不要求在函数一开始就进行变量声明，所以局部变量的作用域可能非常小。\n10.1.1 静态局部变量 在局部变量声明中放置单词static可以使变量具有静态存储期限而不再是自动存储期限。\n1 2 3 4 5 void f(void) { static int i; /* static local variable */ ... } 静态局部变量始终有块作用域，所以它对其他函数是不可见的。概括来说，静态变量是对其他函数隐藏数据的地方，但是它会为将来同一个函数的再调用保留这 些数据。\n10.1.2 形式参数 形式参数拥有和局部变量一样的性质，即自动存储期限和块作用域。事实上，形式参数和局部变量唯一真正的区别是，在每次函数调用时对形式参数自动进行初 始化（调用中通过赋值获得相应实际参数的值）。\n10.2 外部变量 外部变量（有时称为全局变量）的性质不同于局部变量的性质\n静态存储期限 外部变量拥有文件作用域：从变量被声明的点开始一直到所在文件的末尾。 10.2.1 示例：用外部变量实现栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;stdbool.h\u0026gt; /* C99 only */ #define STACK_SIZE 100 /* external variables */ int contents[STACK_SIZE]; int top = 0; void make_empty(void) { top = 0; } bool is_empty(void) { return top == 0; } bool is_full(void) { return top == STACK_SIZE; } void push(int i) { if (is_full()) stack_overflow(); else contents[top++] = i; } int pop(void) { if (is_empty()) stack_underflow(); else return contents [--top]; } 10.2.2 外部变量的利与弊 弊\n在程序维护期间，如果改变外部变量（比方说改变它的类型），那么将需要检查同一文件中的每个函数，以确认该变化如何对函数产生影响。 如果外部变量被赋了错误的值，可能很难确定出错的函数。 很难在其他程序中复用依赖于外部变量的函数。依赖外部变量的函数不是“独立的”。为了在另一个程序中使用该函数，必须带上此函数需要的外部变量。 使用外部变量时，要确保它们都拥有有意义的名字。\n10.3 程序块 { 多条声明 多条语句 }\n1 2 3 4 5 6 if (i \u0026gt; j) { /* swap values of i and j */ int temp = i; i = j; j = temp; } 默认情况下，声明在程序块中的变量的存储期限是自动的：进入程序块时为变量分配存储单元，退出程序块时收回分配的空间。变量具有块作用域，也就是说， 不能在程序块外引用。\nC99允许在程序块的任何地方声明变量，就像允许在函数体内的任何地方声明变量一样。\n10.4 作用域 当程序块内的声明命名一个标识符时，如果此标识符已经是可见的（因为此标识符拥有文件作用域，或者因为它已在某个程序块内声明），新的声明临时“隐藏” 了旧的声明，标识符获得了新的含义。在程序块的末尾，标识符重新获得旧的含义。\n10.5 构建C程序 下面是一种可能的编排顺序\n#include指令； #define指令； 类型定义； 外部变量的声明； 除main函数之外的函数的原型； main函数的定义； 其他函数的定义。 ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC10%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/","summary":"10.1 局部变量 把在函数体内声明的变量称为该函数的局部变量。 局部变量具有下列性质 自动存储期限 块作用域, 从变量声明的点开始一直到所在函数体的末尾 C9","title":"第10章 程序结构"},{"content":"9.1 函数的定义和调用 1 2 3 4 double average(double a, double b) { return (a + b) / 2; } void是一种没有值的类型\n1 2 3 4 void print_count(int n) { printf(\u0026#34;T minus %d and counting\\n\u0026#34;, n); } 无参函数\n1 2 3 4 void print_pun(void) { printf(\u0026#34;To C, or not to C: that is the question.\\n\u0026#34;); } 9.1.1 函数定义 1 2 3 4 5 返回类型 函数名 (形式参数) { 声明 语句 } 函数不能返回数组，但关于返回类型没有其他限制。 指定返回类型是void类型说明函数没有返回值。 如果省略返回类型，C89会假定函数返回值的类型是int类型，但在C99中这是不合法的。 C89中，变量声明必须出现在语句之前。在C99中，变量声明和语句可以混在一起，只要变量在第一次使用之前进行声明就行。 对于返回类型为void的函数，其函数体可以为空\n1 2 3 void print_pun(void) { } 9.1.2 函数调用 1 2 3 4 avg = average(x, y); if (average(x, y) \u0026gt; 0) printf(\u0026#34;Average is positive\\n\u0026#34;); printf(\u0026#34;The average is %g\\n\u0026#34;, average(x, y)); 为了清楚地表明函数返回值是被故意丢掉的，C语言允许在函数调用前加上(void)\n1 (void) printf (\u0026#34;Hi, Mom!\\n\u0026#34;); 9.2 函数声明 函数声明（function declaration）使得编译器可以先对函数进行概要浏览，而函数的完整定义以后再给出。\nC99遵循这样的规则：在调用一个函数之前，必须先对其进行声明或定义。调用函数时，如果此前编译器未见到该函数的声明或定义，会导致出错。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; double average(double a, double b); /* DECLARATION */ int main(void) { double x, y, z; printf(\u0026#34;Enter three numbers: \u0026#34;); scanf(\u0026#34;%lf%lf%lf\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); printf(\u0026#34;Average of %g and %g: %g\\n\u0026#34;, x, y, average(x, y)); printf(\u0026#34;Average of %g and %g: %g\\n\u0026#34;, y, z, average(y, z)); printf(\u0026#34;Average of %g and %g: %g\\n\u0026#34;, x, z, average(x, z)); return 0; } double average(double a, double b) /* DEFINITION */ { return (a + b) / 2; } 函数原型不需要说明函数形式参数的名字，只要显示它们的类型就可以了：\n1 double average(double, double); 9.3 实际参数 在C语言中，实际参数是通过值传递的\n9.3.1 实际参数的转换 C语言允许在实际参数的类型与形式参数的类型不匹配的情况下进行函数调用。管理如何转换实际参数的规则与编译器是否在调用前遇到函数的原型（或者函数的 完整定义）有关。\n编译器在调用前遇到原型。就像使用赋值一样，每个实际参数的值被隐式地转换成相应形式参数的类型。 编译器在调用前没有遇到原型。编译器执行默认的实际参数提升： （1）把float类型的实际参数转换成double类型 （2）执行整值提升，即把char类型和short类型的实际参数转换成int类型 9.3.2 数组型实际参数 当形式参数是一维数组时，可以（而且是通常情况下）不说明数组的长度：\n1 2 3 4 int f(int a[]) /* no length specified */ { ... } C语言没有为函数提供任何简便的方法来确定传递给它的数组的长度；如果函数需要，我们必须把长度作为额外的参数提供出来。\n虽然可以用运算符sizeof计算出数组变量的长度，但是它无法给出关于数组型形式参数的正确答案：\n1 2 3 4 5 6 int f(int a[]) { int len = sizeof(a) / sizeof(a[0]); /*** WRONG: not the number of elements in a ***/ ... } 函数可以改变数组型形式参数的元素，且改变会在相应的实际参数中体现出来。\n如果形式参数是多维数组，声明参数时只能省略第一维的长度。\n1 2 3 4 5 6 7 8 9 #define LEN 10 int sum_two_dimensional_array(int a[][LEN], int n) { int i, j, sum = 0; for (i = 0; i \u0026lt; n; i++) for (j = 0; j \u0026lt; LEN; j++) sum += a[i][j]; return sum; } 9.3.3 变长数组形式参数 C99增加了几个与数组型参数相关的特性。第一个是变长数组，这一特性允许我们用非常量表达式指定数组的长度。变长数组也可以作为参数。\n1 2 3 4 5 // 注意声明顺序 int sum_array(int n, int a[n]) { ... } 函数原型有好几种写法\n1 2 3 4 5 int sum_array(int n, int a[n]); /* Version 1 */ int sum_array(int n, int a[*]); /* Version 2a */ int sum_array(int, int [*]); /* Version 2b */ int sum_array(int n, int a[]); /* Version 3a */ int sum_array(int, int []); /* Version 3b */ 变长数组形式参数的长度可以是任意表达式, 该表达式可以使用函数外部的变量，甚至可以调用其他函数\n1 2 3 4 int concatenate(int m, int n, int a[m], int b[n], int c[m+n]) { ... } 使用变长数组形式参数，则可以推广到任意列数的情况：\n1 2 3 4 5 6 7 8 int sum_two_dimensional_array(int n, int m, int a[n][m]) { int i, j, sum = 0; for (i = 0; i \u0026lt; n; i++) for (j = 0; j \u0026lt; m; j++) sum += a[i][j]; return sum; } 这个函数的原型可以是以下几种：\n1 2 3 4 int sum_two_dimensional_array(int n, int m, int a[n][m]); int sum_two_dimensional_array(int n, int m, int a[*][*]); int sum_two_dimensional_array(int n, int m, int a[][m]); int sum_two_dimensional_array(int n, int m, int a[][*]); 9.3.4 在数组参数声明中使用static C99允许在数组参数声明中使用关键字static\n将static放在数字3之前表明数组a的长度至少可以保证是3：\n1 2 3 4 int sum_array(int a[static 3], int n) { ... } 这样使用static不会对程序的行为有任何影响。static的存在只不过是一个“提示”，C编译器可以据此生成更快的指令来访问数组。 如果数组参数是多维的，static仅可用于第一维 9.3.5 复合字面量(c99) 复合字面量是通过指定其包含的元素而创建的没有名字的数组。\n1 2 3 4 5 6 // (int[4]){1, 9, 2, 1} 也可以 total = sum_array((int []){3, 0, 3, 4, 1},5); // 可以使用指示符 (int[10]){8, 6} // 函数内部创建的复合字面量可以包含任意的表达式，不限于常量 total = sum_array((int []){2 * i, i + j, j * k}, 3); 复合字面量为左值，所以其元素的值可以改变。如果要求其值为“只读”，可以在类型前加上const，如(const int []){5, 4}。\n9.4 return语句 非void的函数必须使用return语句来指定将要返回的值。\nreturn 表达式;\n如果return语句中表达式的类型和函数的返回类型不匹配，那么系统将会把表达式的类型隐式转换成返回类型。\n如果没有给出表达式，return语句可以出现在返回类型为void的函数中：\n1 return; /* return in a void function */ 如果非void函数到达了函数体的末尾（也就是说没有执行return语句），那么如果程序试图使用函数的返回值，其行为是未定义的。\n9.5 程序终止 正常情况下，main函数的返回类型是int类型\n1 2 3 4 int main(void) { ... } 以往的C程序常常省略main的返回类型，这其实是利用了返回类型默认为int类型的传统 省略函数的返回类型在C99中是不合法的, 省略main函数参数列表中的void是合法的 main函数返回的值是状态码，在某些操作系统中程序终止时可以检测到状态码。 exit函数 此函数属于\u0026lt;stdlib.h\u0026gt;头。传递给exit函数的实际参数和main函数的返回值具有相同的含义\nreturn语句和exit函数之间的差异是：不管哪个函数调用exit函数都会导致程序终止，return语句仅当由main函数调用时才会导致程序终止。一些程序员只 使用exit函数，以便更容易定位程序中的全部退出点。\n9.6 递归 1 2 3 4 5 6 7 int fact(int n) { if (n \u0026lt;= 1) return 1; else return n * fact(n-1); } 快速排序算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* Sorts an array of integers using Quicksort algorithm */ #include \u0026lt;stdio.h\u0026gt; #define N 10 void quicksort(int a[], int low, int high); int split(int a[], int low, int high); int main(void) { int a[N], i; printf(\u0026#34;Enter %d numbers to be sorted: \u0026#34;, N); for (i = 0; i \u0026lt; N; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); quicksort(a, 0, N - 1); printf(\u0026#34;In sorted order: \u0026#34;); for (i = 0; i \u0026lt; N; i++) printf(\u0026#34;%d \u0026#34;, a[i]); printf(\u0026#34;\\n\u0026#34;); return 0; } void quicksort(int a[], int low, int high) { int middle; if (low \u0026gt;= high) return; middle = split(a, low, high); quicksort(a, low, middle - 1); quicksort(a, middle + 1, high); } int split(int a[], int low, int high) { int part_element = a[low]; for (;;) { while (low \u0026lt; high \u0026amp;\u0026amp; part_element \u0026lt;= a[high]) high--; if (low \u0026gt;= high) break; a[low++] = a[high]; while (low \u0026lt; high \u0026amp;\u0026amp; a[low] \u0026lt;= part_element) low++; if (low \u0026gt;= high) break; a[high--] = a[low]; } a[high] = part_element; return high; } ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC9%E7%AB%A0-%E5%87%BD%E6%95%B0/","summary":"9.1 函数的定义和调用 1 2 3 4 double average(double a, double b) { return (a + b) / 2; } void是一种没有值的类型 1 2 3 4 void print_count(int n) { printf(\u0026#34;T minus %d and counting\\n\u0026#34;, n); } 无参函数 1 2 3 4 void print_pun(void) { printf(\u0026#34;To C, or not to","title":"第9章 函数"},{"content":"8.1 一维数组 1 int a[10]; 因为程序以后改变时可能需要调整数组的长度，所以较好的方法是用宏来定义数组的长度：\n1 2 3 #define N 10 ... int a[N]; 8.1.1 数组下标 1 2 3 4 for (i = 0; i \u0026lt; N; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); /* reads data into a */ a[i+j*10] = 0; 8.1.2 数组初始化 1 2 3 4 5 6 7 8 9 int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int a[10] = {1, 2, 3, 4, 5, 6}; /* initial value of a is {1, 2, 3, 4, 5, 6, 0, 0, 0, 0} */ int a[10] = {0}; /* initial value of a is {0, 0, 0, 0, 0, 0, 0, 0, 0, 0} */ int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; 8.1.3 指定初始化式(c99) 1 2 3 4 5 6 7 int a[15] = {[2] = 29, [9] = 7, [14] = 48}; int a[15] = {[14] = 48 , [9] = 7, [2] = 29}; // 编译器将根据最大的指示符推断出数组的长度, 24 int b[] = {[5] = 10 , [23] = 13, [11] = 36, [15] = 29}; int c[10] = {5, 1, 9, [4] = 3, 7, 2, [8] = 6}; 8.1.4 对数组使用sizeof运算符 运算符sizeof可以确定数组的大小（字节数）\n还可以用sizeof来计算数组元素（如a[0]）的大小。用数组的大小除以数组元素的大小可以得到数组的长度\n1 2 3 4 5 6 7 8 9 sizeof(a) / sizeof(a[0]) // 遍历数组 for (i = 0; i \u0026lt; sizeof(a) / sizeof(a[0]); i++) a[i] = 0; // 可能有警告, 这里做下类型转换 for (i = 0; i \u0026lt; (int) (sizeof(a) / sizeof(a[0])); i++) a[i] = 0; 8.2 多维数组 1 int m[5][9]; 8.2.1 多维数组初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int m[5][9] = {{1, 1, 1, 1, 1, 0, 1, 1, 1}, {0, 1, 0, 1, 0, 1, 0, 1, 0}, {0, 1, 0, 1, 1, 0, 0, 1, 0}, {1, 1, 0, 1, 0, 0, 0, 1, 0}, {1, 1, 0, 1, 0, 0, 1, 1, 1}}; int m[5][9] = {{1, 1, 1, 1, 1, 0, 1, 1, 1}, {0, 1, 0, 1, 0, 1, 0, 1, 0}, {0, 1, 0, 1, 1, 0, 0, 1, 0}}; int m[5][9] = {{1, 1, 1, 1, 1, 0, 1, 1, 1}, {0, 1, 0, 1, 0, 1, 0, 1}, {0, 1, 0, 1, 1, 0, 0, 1}, {1, 1, 0, 1, 0, 0, 0, 1}, {1, 1, 0, 1, 0, 0, 1, 1, 1}}; // 省略花括号会引起某些编译器产生类似“missing braces around initializer”这样的警告消息。 int m[5][9] = {1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1}; C99的指定初始化式对多维数组也有效\n1 double ident[2][2] = {[0][0] = 1.0, [1][1] = 1.0}; 8.2.2 常量数组 1 2 3 const char hex_chars[] = {\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;F\u0026#39;}; 8.3 C99中的变长数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* Reverses a series of numbers using a variable-length array - C99 only */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int i, n; printf(\u0026#34;How many numbers do you want to reverse? \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a[n]; /* C99 only - length of array depends on n */ printf(\u0026#34;Enter %d numbers: \u0026#34;, n); for (i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); printf(\u0026#34;In reverse order:\u0026#34;); for (i = n - 1; i \u0026gt;= 0; i--) printf(\u0026#34; %d\u0026#34;, a[i]); printf(\u0026#34;\\n\u0026#34;); return 0; } 1 2 3 4 int a[3*i+5]; int b[j+k]; int c[m][n]; 变长数组的主要限制是它们没有静态存储期限 另一个限制是变长数组没有初始化式。 ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC8%E7%AB%A0-%E6%95%B0%E7%BB%84/","summary":"8.1 一维数组 1 int a[10]; 因为程序以后改变时可能需要调整数组的长度，所以较好的方法是用宏来定义数组的长度： 1 2 3 #define N 10 ... int a[N]; 8.1.1 数组下标 1 2 3 4 for (i = 0;","title":"第8章 数组"},{"content":"先看测试用例\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func main() { var a, b, c int8 = 127, 1, 0 c = a + b // -128 fmt.Println(c) var d, e, f uint8 = 255, 1, 0 f = d + e // 0 fmt.Println(f) } 无符号整数的溢出很好理解, 溢出时发生回绕. 其实有符号整数溢出时也是回绕, 但是要理解其编码方式(补码), 下图用补码的方式展示了有符号整数的编码方式\n在有符号整数当中, 符号位是参与计算的, 从上图中不难看出127+1=-128.\n参考 一文读懂原码、反码与补码 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/","summary":"先看测试用例 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func main() { var a, b, c int8 = 127, 1, 0 c = a + b // -128 fmt.Println(c) var d, e, f uint8 = 255, 1, 0 f = d + e // 0 fmt.Println(f) } 无符号整数的溢出很","title":"理解整数溢出"},{"content":"7.1 整数类型 实际上只有下列6种组合可以产生不同的类型\n说明符的顺序没什么影响 1 2 3 4 5 6 short int unsigned short int int unsigned int long int unsigned long int C语言允许通过省略单词int来缩写整数类型的名字 6种整数类型的每一种所表示的取值范围都会根据机器的不同而不同，但是有两条所有编译器都必须遵守的原则\nC标准要求short int、int和long int中的每一种类型都要覆盖一个确定的最小取值范围 标准要求int类型不能比short int类型短，long int类型不能比int类型短。但是，short int类型的取值范围有可能和int类型的范围是一样的，int类 型的取值范围也可以和long int的一样。 表7-1 16位机的整数类型\n表7-2 32位机的整数类型\n表7-3 64位机的整数类型\n表7-1、表7-2和表7-3中给出的取值范围不是C标准强制的，会随着编译器的不同而不同。对于特定的实现，确定整数类型范围的一种方法是检查\u0026lt;limits.h\u0026gt; 头。该头是标准库的一部分，其中定义了表示每种整数类型的最大值和最小值的宏。\n7.1.1 C99中的整数类型 C99提供了两个额外的标准整数类型：long long int和unsigned long long int。\n这两个long long类型要求至少64位宽 C99标准还允许在具体实现时定义扩展的整数类型（包括有符号的和无符号的）。例如，编译器可以提供有符号和无符号的128位整数类型。\n7.1.2 整数常量 在程序中以文本形式出现的数，而不是读、写或计算出来的数。\n为了强制编译器把常量作为长整数来处理，只需在后边加上一个字母L（或l）\n1 15L 0377L 0x7fffL 为了指明是无符号常量，可以在常量后边加上字母U（或u）\n1 15U 0377U 0x7fffU L和U可以结合使用，以表明常量既是长整型又是无符号的：0xffffffffUL\n字母L、U的顺序和大小写无所谓。 7.1.3 C99中的整数常量 在C99中，以LL或ll（两个字母大小写要一致）结尾的整数常量是long long int型的。如果在LL或ll的前面或后面增加字母U（或u），则该整数常量为 unsigned long long int型。\nC99确定整数常量类型的规则与C89有些不同。对于没有后辍（U、u、L、l、LL、ll）的十进制常量，其类型是int、long int或long long int中能表示该 值的“最小”类型。对于八进制或者十六进制常量，可能的类型顺序为int、unsigned int、long int、unsigned long int、long long int和 unsigned long long int。常量后面的任何后辍都会改变可能类型的列表。例如，以U（或u）结尾的常量类型一定是unsigned int、 unsigned long int和unsigned long long int中的一种，以L（或l）结尾的十进制常量类型一定是long int或long long int中的一种。如果常量的 数值过大以至不能用标准的整数类型表示，则可以使用扩展的整数类型。\n7.1.4 整数溢出 有符号整数运算中发生溢出时，程序的行为是未定义的。 无符号整数运算过程中发生溢出时，结果是有定义的 7.1.5 读/写整数 读写无符号整数\n1 2 3 4 5 6 7 unsigned int u; scanf(\u0026#34;%u\u0026#34;, \u0026amp;u); /* reads u in base 10 */ printf(\u0026#34;%u\u0026#34;, u); /* writes u in base 10 */ scanf(\u0026#34;%o\u0026#34;, \u0026amp;u); /* reads u in base 8 */ printf(\u0026#34;%o\u0026#34;, u); /* writes u in base 8 */ scanf(\u0026#34;%x\u0026#34;, \u0026amp;u); /* reads u in base 16 */ printf(\u0026#34;%x\u0026#34;, u); /* writes u in base 16 */ 读写短整数\n1 2 3 short s; scanf(\u0026#34;%hd\u0026#34;, \u0026amp;s); printf(\u0026#34;%hd\u0026#34;, s); 读写长整数\n1 2 3 long l; scanf(\u0026#34;%ld\u0026#34;, \u0026amp;l); printf(\u0026#34;%ld\u0026#34;, l); 7.2 浮点类型 C语言提供了3种浮点类型\nfloat：单精度浮点数。 double：双精度浮点数 long double：扩展精度浮点数 C标准没有说明float、double和long double类型提供的精度到底是多少，因为不同的计算机可以用不同方法存储浮点数。大多数现代计算机都遵循IEEE 754标 准（即IEC 60559）的规范\n表7-4 浮点类型的特征（IEEE标准）\n在一些机器上，float可以有和double相同的数值集合，或者double可以有和long double相同的数值集合。可以在头\u0026lt;float.h\u0026gt;中找到定义浮点类型特征的宏。\n在C99中，浮点类型分为两种：一种是实浮点类型，包括float、double和long double类型；另一种是C99新增的复数类型（27.3节，包括float _Complex、 double _Complex和long double _Complex）。\n7.2.1 浮点常量 1 57.0 57. 57.0e0 57E0 5.7e1 5.7e+1 .57e2 570.e-1 浮点常量必须包含小数点或指数；其中，指数指明了对前面的数进行缩放所需的10的幂次。如果有指数，需要在指数数值前放置字母E（或e）。可选符号+或-可以出 现在字母E（或e）的后边。\n默认情况下，浮点常量都以双精度数的形式存储。\n为了表明只需要单精度，可以在常量的末尾处加上字母F或f（如57.0F）；而为了说明常量必须以long double格式存储，可以在常量的末尾处加上字母L或l（如 57.0L）。\nC99提供了十六进制浮点常量的书写规范。\n7.2.2 读/写浮点数 读取double类型\n1 2 double d; scanf(\u0026#34;%lf\u0026#34;, \u0026amp;d); 注意：只能在scanf函数格式串中使用l，不能在printf函数格式串中使用。在printf函数格式串中，转换e、f和g可以用来写float类型或double类型的值。 （C99允许printf函数调用中使用%le、%lf和%lg，不过字母l不起作用。）\n读写long double类型\n1 2 3 long double ld; scanf(\u0026#34;%Lf\u0026#34;, \u0026amp;ld); printf(\u0026#34;%Lf\u0026#34;, ld); 7.3 字符类型 1 2 3 4 5 char ch; ch = \u0026#39;a\u0026#39;; /* lower-case a */ ch = \u0026#39;A\u0026#39;; /* upper-case A */ ch = \u0026#39;0\u0026#39;; /* zero */ ch = \u0026#39; \u0026#39;; /* space */ 7.3.1 字符操作 1 2 3 4 5 6 7 8 9 10 11 char ch; int i; i = \u0026#39;a\u0026#39;; /* i is now 97 */ ch = 65; /* ch is now \u0026#39;A\u0026#39; */ ch = ch + 1; /* ch is now \u0026#39;B\u0026#39; */ ch++; /* ch is now \u0026#39;C\u0026#39; */ if (\u0026#39;a\u0026#39; \u0026lt;= ch \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;z\u0026#39;) ch = ch - \u0026#39;a\u0026#39; + \u0026#39;A\u0026#39;; for (ch = \u0026#39;A\u0026#39;; ch \u0026lt;= \u0026#39;Z\u0026#39;; ch++)... 7.3.2 有符号字符和无符号字符 C语言标准没有说明普通char类型数据是有符号型还是无符号型\n标准C允许使用单词signed和unsigned来修饰char类型\n1 2 signed char sch; unsigned char uch; C89采用术语整值类型（integral type）来（统称）包含整数类型和字符类型。枚举类型也属于整值类型。\nC99不使用术语“整值类型”，而是扩展了整数类型的含义使其包含字符类型和枚举类型。C99中的_Bool型是无符号整数类型。\n7.3.3 算术类型 整数类型和浮点类型统称为算术类型。\nC89中的算术类型\n整值类型：\n字符数型（char）； 有符号整型（signed char、short int、int、long int）； 无符号整型（unsigned char、unsigned short int、unsigned int、unsigned long int）； 枚举类型。 浮点类型（float、double、long double）。\nC99的算术类型\n整数类型：\n字符类型（char）； 有符号整型, 包括标准的（signed char、short int、int、long int、long long int）和扩展的； 无符号整型，包括标准的（unsigned char、unsigned short int、unsigned int、unsigned long int、unsigned long long int、_Bool）和 扩展的； 枚举类型。 浮点类型：\n实数浮点类型（float、double、long double）； 复数类型（float_Complex、double_Complex、long double_Complex）。 7.3.4 转义序列 转义序列共有两种：字符转义序列（character escape）和数字转义序列（numeric escape）。\n表7-5 字符转义序列\n转义序列列表没有包含所有无法打印的ASCII字符，只包含了最常用的字符。数字转义序列可以表示任何字符\n八进制转义序列由字符\\和跟随其后的一个最多含有三位数字的八进制数组成。转义序列中的八进制数不一定要用0开头。必须为无符号 十六进制转义序列由\\x和跟随其后的一个十六进制数组成。必须为无符号, x必须小写 转义序列可能有点隐晦，所以采用#define的方式给它们命名通常是个不错的主意\n1 #define ESC \u0026#39;\\33\u0026#39; /* ASCII escape character */ 7.3.5 字符处理函数 1 2 #include \u0026lt;ctype.h\u0026gt; ch = toupper(ch); /* converts ch to upper case */ 7.3.6 用scanf和printf读/写字符 1 2 3 char ch; scanf(\u0026#34;%c\u0026#34;, \u0026amp;ch); /* reads a single character */ printf(\u0026#34;%c\u0026#34;, ch); /* writes a single character */ 在读入字符前，scanf函数不会跳过空白字符。\n为了强制scanf函数在读入字符前跳过空白字符，需要在格式串中的转换说明%c前面加上一个空格\n1 2 3 4 5 scanf(\u0026#34; %c\u0026#34;, \u0026amp;ch); /* skips white space, then reads ch */ do { scanf(\u0026#34;%c\u0026#34;, \u0026amp;ch); } while (ch != \u0026#39;\\n\u0026#39;); 7.3.7 用getchar和putchar读/写字符 1 2 putchar(ch); ch = getchar(); /* reads a character and stores it in ch */ getchar函数也不会在读取时跳过空白字符。\n执行程序时，使用getchar函数和putchar函数（胜于scanf函数和printf函数）可以节约时间。\n这两个函数比scanf函数和printf函数简单得多，因为scanf函数和printf函数是设计用来按不同的格式读/写多种不同类型数据的。 为了额外的速度提升，通常getchar函数和putchar函数是作为宏（➤14.3节）来实现的。 把getchar函数调用移到控制表达式中可以精简循环\n1 2 while (getchar() != \u0026#39;\\n\u0026#39;) /* skips rest of line */ ; 7.4 类型转换 当发生下列情况时会进行隐式转换\n当算术表达式或逻辑表达式中操作数的类型不相同时。（C语言执行所谓的常用算术转换。） 当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。 当函数调用中的实参类型与其对应的形参类型不匹配时。 当return语句中表达式的类型和函数返回值的类型不匹配时。 7.4.1 常用算术转换 常用算术转换的策略是把操作数转换成可以安全地适用于两个数值的“最狭小的”数据类型。\n任一操作数的类型是浮点类型的情况\n1 2 3 4 5 long double ↑ double ↑ float 两个操作数的类型都不是浮点类型\n1 2 3 4 5 6 7 unsigned long int ↑ long int ↑ unsigned int ↑ int 如果一个操作数的类型是long int，而另一个的类型是unsigned int，那么两个操作数都会转换成unsigned long int类型。\n7.4.2 赋值过程中的转换 把赋值运算右边的表达式转换成左边变量的类型。如果变量的类型至少和表达式类型一样“宽”，那么这种转换将没有任何障碍。\n1 2 3 4 5 6 7 char c; int i; float f; double d; i = c; /* c is converted to int */ f = i; /* i is converted to float */ d = f; /* f is converted to double */ 把浮点数赋值给整型变量会丢掉该数的小数部分\n1 2 3 int i; i = 842.97; /* i is now 842 */ i = -842.97; /* i is now -842 */ 如果该值在变量类型范围之外，那么将会得到无意义的结果\n1 2 3 c = 10000; /*** WRONG ***/ i = 1.0e20; /*** WRONG ***/ f = 1.0e100; /*** WRONG ***/ 如果浮点常量被赋值给float型变量时，一个很好的方法是在浮点常量尾部加上后辍f\n7.4.3 C99中的隐式转换 C99允许每个整数类型具有“整数转换等级”\n(1) long long int、unsigned long long int (2) long int、unsigned long int (3) int、unsigned int (4) short int、unsigned short int (5) char、signed char、unsigned char (6) _Bool C99用整数提升（integer promotion）取代了C89中的整值提升（integral promotion），可以将任何等级低于int和unsigned int的类型转换为int （只要该类型的所有值都可以用int类型表示）或unsigned int。\nC99中执行常用算术转换的规则\n任一操作数的类型是浮点类型的情况。只要两个操作数都不是复数型，规则与前面一样 两个操作数的类型都不是浮点类型的情况。首先对两个操作数进行整数提升。如果这时两个操作数的类型相同，过程结束。否则，依次尝试下面的规则，一旦 遇到可应用的规则就不再考虑别的规则： 如果两个操作数都是有符号型或者都是无符号型，将整数转换等级较低的操作数转换为等级较高的操作数的类型； 如果无符号操作数的等级高于或等于有符号操作数的等级，将有符号操作数转换为无符号操作数的类型。 如果有符号操作数类型可以表示无符号操作数类型的所有值，将无符号操作数转换为有符号操作数的类型。 否则，将两个操作数都转换为与有符号操作数的类型相对应的无符号类型。 所有算术类型都可以转换为_Bool类型。如果原始值为0则转换结果为0，否则结果为1。\n7.4.4 强制类型转换 (类型名) 表达式\n1 2 float f, frac_part; frac_part = f - (int) f; C语言把(类型名)视为一元运算符。一元运算符的优先级高于二元运算符\n7.5 类型定义 1 2 typedef int Bool; Bool flag; /* same as int flag; */ 7.5.1 类型定义的优点 类型定义使程序更加易于理解 基础类型变更更容易 1 2 typedef float Dollars; typedef double Dollars; 7.5.2 类型定义和可移植性 为了更大的可移植性，可以考虑使用typedef定义新的整数类型名。\n7.6 sizeof运算符 sizeof (类型名)\n值为无符号整数, byte 编译器本身通常就能够确定sizeof表达式的值 sizeof应用于表达式时不要求圆括号 编译器会把表达式sizeof i + j解释为(sizeof i) + j，这是因为sizeof作为一元运算符的优先级高于二元运算符+ 因为sizeof表达式的类型是size_t, 在C89中, 最好在显示前把表达式的值转换成一种已知的类型 size_t一定是无符号整型，所以最安全的方法是把sizeof表达式强制转换成unsigned long类型 然后使用转换说明符%lu显示 1 printf(\u0026#34;Size of int: %lu\\n\u0026#34;, (unsigned long) sizeof(int)); 在C99中，size_t类型可以比unsigned long更长。但C99中的printf可以直接显示出size_t类型值而不需要强制转换。 1 printf(\u0026#34;Size of int: %zu\\n\u0026#34;, sizeof(int)); /* C99 only */ ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC7%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","summary":"7.1 整数类型 实际上只有下列6种组合可以产生不同的类型 说明符的顺序没什么影响 1 2 3 4 5 6 short int unsigned short int int unsigned int long int unsigned long int C语言允许通过省略单词int来","title":"第7章 基本类型"},{"content":"6.1 while语句 while (表达式) 语句\n圆括号是强制要求的 1 2 3 4 while (i \u0026gt; 0) { printf(\u0026#34;T minus %d and counting\\n\u0026#34;, i); i--; } 无限循环 while (1)\u0026hellip;\n6.2 do语句 do 语句 while (表达式);\n控制表达式的外面也必须有圆括号 1 2 3 4 5 i = 10; do { printf(\u0026#34;T minus %d and counting\\n\u0026#34;, i); --i; } while (i \u0026gt; 0); 6.3 for语句 for (表达式1; 表达式2; 表达式3) 语句\nfor循环总可以用等价的while循环替换：\n1 2 3 4 5 表达式1; while (表达式2) { 语句 表达式3; } 6.3.1 for语句的惯用法 1 2 3 4 5 6 7 8 // 从0向上加到n-1 for ( i = 0; i \u0026lt; n; i++) ... // 从1向上加到n for ( i = 1; i \u0026lt;= n; i++) ... // 从n-1向下减到0 for ( i = n - 1; i \u0026gt;= 0; i--) ... // 从n向下减到1 for ( i = n; i \u0026gt; 0; i--) ... 6.3.2 在for语句中省略表达式 C语言允许省略任意或全部的表达式\n如果省略第二个表达式，那么它默认为真值，因此for语句不会终止\n1 for ( ; ; )... 6.3.3 C99中的for语句 for语句的第一个表达式可以替换为一个声明\n1 2 for (int i = 0; i \u0026lt; n; i++) ... 变量i不需要在该语句前进行声明。事实上，如果变量i在之前已经进行了声明，这个语句将创建一个新的i且该值仅用于循环内。 for语句声明的变量不可以在循环外访问 for语句可以声明多个变量，只要它们的类型相同 1 2 for (int i = 0, j = 0; i \u0026lt; n; i++) ... 6.3.4 逗号运算符 表达式1, 表达式2\n第一步，计算表达式1并且扔掉计算出的值。第二步，计算表达式2，把这个值作为整个表达式的值。 对表达式1的计算应该始终会有副作用；如果没有，那么表达式1就没有了存在的意义。 逗号运算符允许将两个表达式“粘贴”在一起构成一个表达式。（注意与复合语句的相似之处，后者允许我们把一组语句当作一条语句来使用。）\n1 2 for (sum = 0, i = 1; i \u0026lt;= N; i++) sum += i; 6.4 退出循环 6.4.1 break语句 1 2 3 4 5 6 7 for (d = 2; d \u0026lt; n; d++) if (n % d == 0) break; if (d \u0026lt; n) printf(\u0026#34;%d is divisible by %d\\n\u0026#34;, n, d); else printf(\u0026#34;%d is prime\\n\u0026#34;, n); break语句只能跳出一层嵌套\n6.4.2 continue语句 break语句刚好把程序控制转移到循环体末尾之后，而continue语句刚好把程序控制转移到循环体末尾之前。\ncontinue语句只能用于循环 1 2 3 4 5 6 7 8 9 10 n = 0; sum = 0; while (n \u0026lt; 10) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;i); if (i == 0) continue; sum += i; n++; /* continue jumps to here */ } 6.4.3 goto语句 goto语句则可以跳转到函数中任何有标号的语句处。\nC99增加了一条限制：goto语句不可以用于绕过变长数组的声明。 标识符 : 语句\ngoto 标识符;\n1 2 3 4 5 6 7 8 for (d = 2; d \u0026lt; n; d++) if (n % d == 0) goto done; done: if (d \u0026lt; n) printf(\u0026#34;%d is divisible by %d\\n\u0026#34;, n, d); else printf(\u0026#34;%d is prime\\n\u0026#34;, n); goto语句解决了退出多层问题\n1 2 3 4 5 6 7 8 while (...) { switch (...) { ... goto loop_done; /* break won\u0026#39;t work here */ ... } } loop_done: ... 6.5 空语句 1 i = 0; ; j = 1; ;不要放到for的同一行, 否则会混淆后面语句为循环体\n1 2 3 for (d = 2; d \u0026lt; n \u0026amp;\u0026amp; n % d != 0; d++); if (d \u0026lt; n) printf(\u0026#34;%d is divisible by %d\\n\u0026#34;, n, d); ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC6%E7%AB%A0-%E5%BE%AA%E7%8E%AF/","summary":"6.1 while语句 while (表达式) 语句 圆括号是强制要求的 1 2 3 4 while (i \u0026gt; 0) { printf(\u0026#34;T minus %d and counting\\n\u0026#34;, i); i--; } 无限循环 while (1)\u0026hellip; 6.2 do语句 do 语句 while (表达式); 控制表达式的外","title":"第6章 循环"},{"content":"5.1 逻辑表达式 在C语言中，诸如i \u0026lt; j这样的比较运算会产生整数：0（假）或1（真）。\n5.1.1 关系运算符 关系运算符可以用于比较整数和浮点数，也允许比较混合类型的操作数。\n表5-1 关系运算符\n表达式i \u0026lt; j \u0026lt; k在C语言中是合法的, 左结合\n1 2 // 表达式首先检测i是否小于j，然后用比较后产生的结果（1或0）来和k进行比较。 (i \u0026lt; j) \u0026lt; k 5.1.2 判等运算符 表5-2 判等运算符\n判等运算符也是左结合的，也是产生0（假）或1（真）作为结果。然而，判等运算符的优先级低于关系运算符。\n5.1.3 逻辑运算符 表5-3 逻辑运算符\n逻辑运算符所产生的结果是0或1。操作数的值经常是0或1，但这不是必需的。逻辑运算符将任何非零值操作数作为真值来处理，同时将任何零值操作数作为假值 来处理。\n运算符\u0026amp;\u0026amp;和运算符||都对操作数进行“短路”计算。\n5.2 if语句 if (表达式) 语句\n表达式两边的圆括号是必需的 1 2 if (line_num == MAX_LINES) line_num = 0; 5.2.1 复合语句 在if语句模板中，语句是一条语句而不是多条语句：\n1 if (表达式) 语句 如果想用if语句处理两条或更多条语句，可以引入复合语句\n{ 多条语句} 无分号 1 2 3 4 5 6 7 8 9 10 11 { line_num = 0; page_num++; } { line_num = 0; page_num++; } if (line_num == MAX_LINES) { line_num = 0; page_num++; } 5.2.2 else子句 if (表达式) 语句else语句\n1 2 3 4 if (i \u0026gt; j) max = i; else max = j; 建议在任何时候都使用花括号\n1 2 3 4 5 6 7 8 9 10 11 12 13 if (i \u0026gt; j) { if (i \u0026gt; k){ max = i; } else { max = k; } } else { if (j \u0026gt; k) { max = j; } else { max = k; } } 5.2.3 级联式if语句 1 2 3 4 5 6 7 8 9 if (表达式) 语句 else if (表达式) 语句 ... else if (表达式) 语句 else 语句 级联式if语句不是新的语句类型，它仅仅是普通的if语句，只是碰巧有另外一条if语句作为else子句（而且这条if语句又有另外一条if语句作为它自己的else 子句，依次类推）。\n5.2.4 “悬空else”的问题 1 2 3 4 5 if (y != 0) if (x != 0) result = x / y; else // 匹配最近的if printf(\u0026#34;Error: y is equal to 0\\n\u0026#34;); 5.2.5 条件表达式 表达式1 ? 表达式2 : 表达式3\n1 2 3 4 5 int i, j, k; i = 1; j = 2; k = i \u0026gt; j ? i : j; /* k is now 2 */ k = (i \u0026gt;= 0 ? i : 0) + j; /* k is now 3 */ 5.2.6 C89中的布尔值 C89标准中没有定义布尔类型, C89的程序员通常使用TRUE和FALSE这样的名字定义宏：\n1 2 3 4 5 #define BOOL int #define TRUE 1 #define FALSE 0 BOOL flag; 5.2.7 C99中的布尔值 C99提供了_Bool型\n_Bool是无符号整型 只能赋值0或1, 往_Bool变量中存储非零值会导致变量赋值为1 算术运算是合法的（不过不建议这样做） 1 _Bool flag; C99还提供了一个新的头\u0026lt;stdbool.h\u0026gt;，这使得操作布尔值更加容易 1 2 3 4 5 6 7 #include \u0026lt;stdbool.h\u0026gt; bool flag; /* same as _Bool flag; */ flag = false; ... flag = true; 5.3 switch语句 1 2 3 4 5 6 switch (表达式) { case 常量表达式 : 语句 ... case 常量表达式 : 语句 default : 语句 } 控制表达式。switch后边必须跟着由圆括号括起来的整型表达式。C语言把字符当成整数来处理，因此在switch语句中可以对字符进行判定。 分支标号。每个分支的开头都有一个标号case 常量表达式:. 分支标号中的常量表达式的值必须是整数（字符也可以） 语句。每个分支标号的后边可以跟任意数量的语句。每组语句的最后一条通常是break语句 C语言不允许有重复的分支标号，但对分支的顺序没有要求，特别是default分支不一定要放置在最后。 case后边只可以跟随一个常量表达式。但是，多个分支标号可以放置在同一组语句的前面 1 2 3 4 5 6 7 8 9 10 11 switch (grade) { case 4: case 3: case 2: case 1: printf(\u0026#34;Passing\u0026#34;); break; case 0: printf(\u0026#34;Failing\u0026#34;); break; default: printf(\u0026#34;Illegal grade\u0026#34;); break; } switch语句不要求一定有default分支。如果default不存在，而且控制表达式的值和任何一个分支标号都不匹配的话，控制会直接传给switch语句后面的语 句。\nbreak语句的作用 需要break语句是由于switch语句实际上是一种“基于计算的跳转”。\n对控制表达式求值时，控制会跳转到与switch表达式的值相匹配的分支标号处。 分支标号只是一个说明switch内部位置的标记。在执行完分支中的最后一条语句后，程序控制“向下跳转”到下一个分支的第一条语句上，而忽略下一个分支 的分支标号。 如果没有break语句（或者其他某种跳转语句），控制将会从一个分支继续到下一个分支。 故意从一个分支跳转到下一个分支的情况是非常少见的，如果没有注释，将来某人可能会通过增加多余的break语句来修正“错误”。\n虽然switch语句中的最后一个分支不需要break语句，但通常还是会放一个break语句在那里，以防止将来增加分支数目时出现“丢失break”的问题。\n","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC5%E7%AB%A0-%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5/","summary":"5.1 逻辑表达式 在C语言中，诸如i \u0026lt; j这样的比较运算会产生整数：0（假）或1（真）。 5.1.1 关系运算符 关系运算符可以用于比较整数和浮点数，也允许比较混","title":"第5章 选择语句"},{"content":"4.1 算术运算符 表4-1 算术运算符\n当把int型操作数和float型操作数混合在一起时，运算结果是float型的。 运算符%要求操作数是整数。如果两个操作数中有一个不是整数，程序将无法编译通过。 把零用作/或%的右操作数会导致未定义的行为 当运算符/和运算符%用于负操作数时，其结果难以确定。 根据C89标准，如果两个操作数中有一个为负数，那么除法的结果既可以向上取整也可以向下取整。（例如，-9/7的结果既可以是-1也可以是-2。） 在C89中，如果i或者j是负数，i%j的符号与具体实现有关。（例如，-9%7的值可能是-2或者5。） 在C99中，除法的结果总是向零截取的（因此-9/7的结果是-1），i%j的值的符号与i的相同（因此-9%7的值是-2）。 运算符的优先级和结合性 4.2 赋值运算符 4.2.1 简单赋值 1 2 3 4 5 6 7 8 i = 5; /* i is now 5 */ j = i; /* j is now 5 */ k = 10 * i + j; /* k is now 55 */ int i; float f; i = 72.99f; /* i is now 72 */ f = 136; /* f is now 136.0 */ 在许多编程语言中，赋值是语句；然而，在C语言中，赋值就像+那样是运算符。换句话说，赋值操作产生结果，这就如同两个数相加产生结果一样。\n表达式v = e的值就是v的值 =是右结合 1 2 3 4 5 6 7 8 9 10 i = j = k = 0; // 可能不是预期结果 int i; float f; f = i = 33.3f; i = 1; k = 1 + (j = i); printf(\u0026#34;%d %d %d\\n\u0026#34;, i, j, k); /* prints \u0026#34;1 1 2\u0026#34; */ 4.2.2 左值 左值表示存储在计算机内存中的对象，而不是常量或计算的结果。\n赋值运算符要求它的左操作数必须是左值 4.2.3 复合赋值 1 i += 2; /* same as i = i + 2; */ 是右结合的\n4.3 自增运算符和自减运算符 1 2 3 4 5 6 7 i = 1; printf(\u0026#34;i is %d\\n\u0026#34;, ++i); /* prints \u0026#34;i is 2\u0026#34; */ printf(\u0026#34;i is %d\\n\u0026#34;, i); /* prints \u0026#34;i is 2\u0026#34; */ i = 1; printf(\u0026#34;i is %d\\n\u0026#34;, i++); /* prints \u0026#34;i is 1\u0026#34; */ printf(\u0026#34;i is %d\\n\u0026#34;, i); /* prints \u0026#34;i is 2\u0026#34; */ 后缀++和后缀\u0026ndash;比一元的正号、负号优先级高，而且都是左结合的。前缀++和前缀\u0026ndash;与一元的正号、负号优先级相同，而且都是右结合的。\n4.4 表达式求值 表4-2 部分C语言运算符表\n子表达式的求值顺序 C语言没有定义子表达式的求值顺序（除了含有逻辑与运算符及逻辑或运算符（➤5.1节）、条件运算符（➤5.2节）以及逗号运算符（➤6.3节）的子表达式）。因 此，在表达式(a + b) * (c - d)中，无法确定子表达式(a + b)是否在子表达式(c - d)之前求值。\n不管子表达式的计算顺序如何，大多数表达式都有相同的值。但是，当子表达式改变了某个操作数的值时，产生的值就可能不一致了。\n第二条语句的执行结果是未定义的 1 2 a = 5; c = (b = a + 2) - (a = 1); 当程序中出现未定义的行为时，后果是不可预料的。\n1 2 c = (b = a + 2) - (a = 1); j = i * i++; 4.5 表达式语句 C语言有一条不同寻常的规则，那就是任何表达式都可以用作语句。\n通过在后面添加分号的方式将其转换成语句 1 2 // 没有任何作用 i * j - 1; 在使用后缀形式的++或\u0026ndash;时，何时执行自增或自减操作？\nC语言标准引入了“顺序点”的概念，并且指出“应该在前一个顺序点和下一个顺序点之间对存储的操作数的值进行更新”。在C语言中有多种不同类型的顺序点，表 达式语句的末尾是其中一种。在表达式语句的末尾，该语句中的所有自增和自减操作都必须执行完毕，否则不能执行下一条语句。\n","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC4%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"4.1 算术运算符 表4-1 算术运算符 当把int型操作数和float型操作数混合在一起时，运算结果是float型的。 运算符%要求操作数是整数。如果两","title":"第4章 表达式"},{"content":"3.1 printf函数 1 printf(格式串, 表达式1, 表达式2, ...); 调用printf函数一次可以打印的值的个数没有限制。 C语言编译器不会检测格式串中转换说明的数量是否和输出项的数量相匹配。 C语言编译器也不检测转换说明是否适合要显示项的数据类型。 3.1.1 转换说明 转换数字\n1 2 // 格式 %m.px m: 最小字段宽度 p: 精度 x: 进行哪种转换 d: 表示十进制（基数为10）形式的整数。 p指明了待显示的数字的最少个数（必要时在数前加上额外的零）；如果省略p，则默认它的值为1 e: 表示指数（科学记数法）形式的浮点数。p指明了小数点后应该出现的数字的个数（默认值为6）。如果p为0，则不显示小数点。 f: 表示“定点十进制”形式的浮点数，没有指数。p的含义与在说明符e中的一样。 g: 表示指数形式或者定点十进制形式的浮点数，形式的选择根据数的大小决定。p说明可以显示的有效数字（没有小数点后的数字）的最大数量。与转换说 明符f不同，g的转换将不显示尾随的零。此外，如果要显示的数值没有小数点后的数字，g就不会显示小数点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* Prints int and float values in various formats */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int i; float x; i = 40; x = 839.21f; printf(\u0026#34;|%d|%5d|%-5d|%5.3d|\\n\u0026#34;, i, i, i, i); printf(\u0026#34;|%10.3f|%10.3e|%-10g|\\n\u0026#34;, x, x, x); return 0; } /* 输出 |40| 40|40 | 040| | 839.210| 8.392e+02|839.21 | */ 3.1.2 转义序列 1 2 printf(\u0026#34;\\\u0026#34;Hello!\\\u0026#34;\u0026#34;); printf(\u0026#34;\\\\\u0026#34;); /* prints one \\ character */ 3.2 scanf函数 1 2 3 4 5 6 int i, j; float x, y; scanf (\u0026#34;%d%d%f%f\u0026#34;, \u0026amp;i, \u0026amp;j, \u0026amp;x, \u0026amp;y); // 输入 1 -20 .3 -4.0e3 通常把符号\u0026amp;放在scanf函数调用中每个变量的前面。符号\u0026amp;常常（但不总是）是需要的，记住使用它是程序员的责任。\n3.2.1 scanf函数的工作方法 在寻找数的起始位置时，scanf函数会忽略空白字符（white-space character，包括空格符、水平和垂直制表符、换页符和换行符）。因此，我们可以把数 字放在同一行或者分散在几行内输入。\n1 2 3 4 5 6 scanf(\u0026#34;%d%d%f%f\u0026#34;, \u0026amp;i, \u0026amp;j, \u0026amp;x, \u0026amp;y); // 输入 1 -20 .3 -4.0e3 在用于scanf函数时，转换说明%e、%f和%g是可以互换的，这3种转换说明在识别浮点数方面都遵循相同的规则。\n当scanf函数遇到一个不可能属于当前项的字符时，它会把此字符“放回原处”，以便在扫描下一个输入项或者下一次调用scanf函数时再次读入。\n3.2.2 格式串中的普通字符 空白字符。当在格式串中遇到一个或多个连续的空白字符时，scanf函数从输入中重复读空白字符直到遇到一个非空白字符（把该字符“放回原处”）为止。 格式串中空白字符的数量无关紧要，格式串中的一个空白字符可以与输入中任意数量的空白字符相匹配(包括零个)。 其他字符。当在格式串中遇到非空白字符时，scanf函数将把它与下一个输入字符进行比较。如果两个字符相匹配，那么scanf函数会放弃输入字符而继续处 理格式串。如果两个字符不匹配，那么scanf函数会把不匹配的字符放回输入中，然后异常退出，而不进一步处理格式串或者从输入中读取字符。 3.2.3 易混淆的printf函数和scanf函数 1 2 3 4 5 6 printf(\u0026#34;%d %d\\n\u0026#34;, \u0026amp;i, \u0026amp;j); /*** WRONG***/ // scanf函数首先寻找输入中的整数，把这个整数存入变量i中； // 然后，scanf函数将试图把逗号与下一个输入字符相匹配。 // 如果下一个输入的字符是空格而不是逗号，那么scanf函数将终止操作，而不再读取变量j的值。 scanf(\u0026#34;%d, %d\u0026#34;, \u0026amp;i, \u0026amp;j); printf格式串经常以\\n结尾，但是在scanf格式串末尾放置换行符通常是一个坏主意。对scanf函数来说，格式串中的换行符等价于空格，两者都会引发scanf 函数提前进入到下一个非空白字符。例如，如果格式串是\u0026quot;%d\\n\u0026quot;，那么scanf函数将跳过空白字符，读取一个整数，然后跳到下一个非空白字符处。像这样的格 式串可能会导致交互式程序一直挂起直到用户输入一个非空白字符为止。\n","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC3%E7%AB%A0-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/","summary":"3.1 printf函数 1 printf(格式串, 表达式1, 表达式2, ...); 调用printf函数一次可以打印的值的个数没有限制。 C语言编译器不会检测格式","title":"第3章 格式化输入/输出"},{"content":"2.1 编写一个简单的C程序 1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;To C, or not to C: that is the question.\\n\u0026#34;); return 0; } 2.1.1 编译和链接 对于C程序来说, 把程序转化为机器可以执行的形式通常包含下列3个步骤\n预处理。首先程序会被送交给预处理器（preprocessor）。预处理器执行以#开头的命令（通常称为指令）。预处理器有点类似于编辑器，它可以给程序添 加内容，也可以对程序进行修改。 编译。修改后的程序现在可以进入编译器（compiler）了。编译器会把程序翻译成机器指令（即目标代码）。然而，这样的程序还是不可以运行的。 链接。在最后一个步骤中，链接器（linker）把由编译器产生的目标代码和所需的其他附加代码整合在一起，这样才最终产生了完全可执行的程序。这些附加 代码包括程序中用到的库函数（如printf函数）。 预处理器通常会和编译器集成在一起, 在UNIX系统环境下，通常把C编译器命名为cc\n1 2 $ cc pun.c $ gcc -o pun pun.c 2.1.2 集成开发环境 2.2 简单程序的一般形式 指令 int main(void) { 语句 } 2.2.1 指令 1 #include \u0026lt;stdio.h\u0026gt; 2.2.2 函数 main函数是非常特殊的：在执行程序时系统会自动调用main函数。\n它会在程序终止时向操作系统返回一个状态码 1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;To C, or not to C: that is the question.\\n\u0026#34;); return 0; } main前面的int表明该函数将返回一个整数值 圆括号中的void表明main函数没有参数 1 return 0 有两个作用：\n一是使main函数终止（从而结束程序） 二是指出main函数的返回值是0。 如果main函数的末尾没有return语句，程序仍然能终止。但是，许多编译器会产生一条警告信息（因为函数应该返回一个整数却没有这么做）。\n2.2.3 语句 1 printf(\u0026#34;To C, or not to C： that is the question.\\n\u0026#34;); 以;结束 指令不用; 2.2.4 显示字符串 1 printf(\u0026#34;Brevity is the soul of wit.\\n --Shakespeare\\n\u0026#34;); 2.3 注释 1 /* This is a comment */ 建议把*/放在单独一行\n1 2 3 4 /* Name: pun.c Purpose: Prints a bad pun. Author: K. N. King */ C99提供了另一种类型的注释, 这种风格的注释会在行末自动终止。\n1 // This is a comment 2.4 变量和赋值 2.4.1 类型 进行算术运算时float型变量通常比int型变量慢 float型变量所存储的数值往往只是实际数值的一个近似值 2.4.2 声明 1 2 3 4 5 6 int height; float profit; // 声明同类型的变量 int height, length, width, volume; float profit, loss; C99之前\n1 2 3 4 5 int main(void) { 声明 // 声明在语句之前 语句 } 在C99中，声明可以不在语句之前。\n2.4.3 赋值 1 2 3 height = 8; length = 12; width = 10; 当我们把一个包含小数点的常量赋值给float型变量时，最好在该常量后面加一个字母f（代表float）：\n不加f可能会引发编译器的警告。 1 profit = 2150.48f; 混合类型赋值是可以的，但不一定安全\n1 2 3 4 height = 8; length = 12; width = 10; volume = height * length * width; /* volume is now 960 */ 2.4.4 显示变量的值 1 printf(\u0026#34;Height: %d\\n\u0026#34;, height); 2.4.5 初始化 当程序开始执行时，某些变量会被自动设置为零，而大多数变量则不会\n1 2 3 int height = 8; int height = 8, length = 12, width = 10; 2.4.6 显示表达式的值 1 printf(\u0026#34;%d\\n\u0026#34;, height * length * width); 2.5 读入输入 1 scanf(\u0026#34;%d\u0026#34;, \u0026amp;i); /* reads an integer; stores into i */ 2.6 定义常量的名字 宏定义（macro definition）当对程序进行编译时，预处理器会把每一个宏替换为其表示的值。\n1 #define INCHES_PER_POUND 166 可以利用宏来定义表达式\n1 #define RECIPROCAL_OF_PI (1.0f / 3.14159f) 2.7 标识符 在C语言中，标识符可以含有字母、数字和下划线，但是必须以字母或者下划线开头。在C99中，标识符还可以使用某些“通用字符名”\n不合法的标识符\n1 10times get-next-char C语言是区分大小写的 C对标识符的最大长度没有限制 关键字 2.8 C程序的书写规范 大多数情况下，程序中记号之间的空格数量没有严格要求。除非两个记号合并后会产生第三个记号，否则在一般情况下记号之间根本不需要留有间隔。\n事实上，添加足够的空格和空行可以使程序更便于阅读和理解。 非法的分隔\n1 2 printf(\u0026#34;To C, or not to C: that is the question.\\n\u0026#34;); /*** WRONG ***/ ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC2%E7%AB%A0-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","summary":"2.1 编写一个简单的C程序 1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;To C, or not to C: that is the question.\\n\u0026#34;); return 0; } 2.1.1 编译和链接 对于C程序来说, 把程序转化为机器可以执行的形式通常包含下列","title":"第2章 C语言基本概念"},{"content":"1.1 C语言的历史 1.1.1 起源 Unix一开始是用汇编写的 C语言基于B语言 1.1.2 标准化 经典C: The C Programming Language, K\u0026amp;R C89或C90: ANSI标准X3.159-1989, ISO/IEC 9899:1990/IEC 9899:1990 C99: /IEC 9899:1990 1.1.3 基于C的语言 C语言还值得学习吗？\n学习C有助于更好地理解C++、Java、C#、Perl以及其他基于C的语言的特性，一开始就学习其他语言的程序员往往不能很好地掌握继承自C语言的基本特性； 目前仍有许多C程序，我们需要读懂并维护这些代码； C语言仍然广泛用于新软件开发，特别是在内存或处理能力受限的情况下以及需要使用C语言简单特性的地方。 1.2 C语言的优缺点 C语言是一种底层语言. 快 C语言是一种小型语言. 有限特性 C语言是一种包容性语言. 没有强制检查 1.2.1 C语言的优点 高效 可移植 功能强大 庞大的数据类型 运算符 灵活 标准库 与UNIX系统的集成 1.2.2 C语言的缺点 C程序更容易隐藏错误 C程序可能会难以理解 C程序可能会难以修改 1.2.3 高效地使用C语言 学习如何规避C语言的缺陷 使用软件工具使程序更加可靠 lint 调试工具 利用现有的代码库 采用一套切合实际的编码规范 避免“投机取巧”和极度复杂的代码 紧贴标准 ","permalink":"https://jdxj.github.io/posts/books/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0-c%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/","summary":"1.1 C语言的历史 1.1.1 起源 Unix一开始是用汇编写的 C语言基于B语言 1.1.2 标准化 经典C: The C Programming Language, K\u0026amp;R C89或C90: ANSI标准X3.159-1989,","title":"第1章 C语言概述"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/eddycjy/pprof/","summary":"原文","title":"Go 大杀器之性能剖析 PProf（上）"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/pkg/profile/","summary":"Simple profiling support package for Go","title":"profile"},{"content":"原文\n热重启的原理 监听重启信号； 收到重启信号时fork子进程，同时需要将服务监听的socket文件描述符传递给子进程； 子进程接收并监听父进程传递的socket； 等待子进程启动成功之后，停止父进程对新连接的接收； 父进程退出，重启完成 ","permalink":"https://jdxj.github.io/posts/articles/weixin/golang%E4%B8%AD%E7%9A%84%E7%83%AD%E9%87%8D%E5%90%AF/","summary":"原文 热重启的原理 监听重启信号； 收到重启信号时fork子进程，同时需要将服务监听的socket文件描述符传递给子进程； 子进程接收并监听父进程传","title":"Golang中的热重启"},{"content":"原文\n简单来说就是封装非阻塞fd, 用户代码在调用非阻塞fd时, 由go来实现调度, 将本goroutine阻塞, 但是不阻塞该线程.\n","permalink":"https://jdxj.github.io/posts/articles/weixin/go%E5%B0%81%E8%A3%85epoll/","summary":"原文 简单来说就是封装非阻塞fd, 用户代码在调用非阻塞fd时, 由go来实现调度, 将本goroutine阻塞, 但是不阻塞该线程.","title":"在 golang 中是如何对 epoll 进行封装的？"},{"content":"原文\n比较的库 freecache bigcache fastcache offheap groupcache ristretto go-cache 实现零GC的方案 无GC：分配堆外内存(Mmap) 避免GC：map非指针优化(map[uint64]uint32)或者采用slice实现一套无指针的map。 避免GC：数据存入[]byte slice(可考虑底层采用环形队列封装循环使用空间) 实现高性能的关键 数据分片(降低锁的粒度) ","permalink":"https://jdxj.github.io/posts/articles/weixin/golang%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E9%80%89%E5%9E%8B%E5%AF%B9%E6%AF%94%E5%8F%8A%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/","summary":"原文 比较的库 freecache bigcache fastcache offheap groupcache ristretto go-cache 实现零GC的方案 无GC：分配堆外内存(Mmap) 避免GC：map非指针优化(map[uint64]uint32)或","title":"Golang本地缓存选型对比及原理总结"},{"content":"第一种方法\n1 2 $ git checkout -b foo o/main $ git pull/push 第二种方法\n1 2 3 $ git branch -u o/main foo $ git commit $ git push ","permalink":"https://jdxj.github.io/posts/cmd/git/%E8%B7%9F%E8%B8%AA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/","summary":"第一种方法 1 2 $ git checkout -b foo o/main $ git pull/push 第二种方法 1 2 3 $ git branch -u o/main foo $ git commit $ git push","title":"跟踪远程分支"},{"content":"git pull是git fetch; git merge的缩写\ngit pull --rebase是git fetch; git rebase的缩写\n","permalink":"https://jdxj.github.io/posts/cmd/git/%E8%8E%B7%E5%8F%96%E8%BF%9C%E7%A8%8B%E6%9B%B4%E6%96%B0/","summary":"git pull是git fetch; git merge的缩写 git pull --rebase是git fetch; git rebase的缩写","title":"获取远程更新"},{"content":" 1 $ git cherry-pick \u0026lt;commit-id\u0026gt;... ","permalink":"https://jdxj.github.io/posts/cmd/git/%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E6%8F%90%E4%BA%A4%E5%88%B0%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF/","summary":"1 $ git cherry-pick \u0026lt;commit-id\u0026gt;...","title":"获取指定提交到当前分支"},{"content":"reset 回退一步\nrevert 生成新commit来还原\n","permalink":"https://jdxj.github.io/posts/cmd/git/%E6%92%A4%E9%94%80%E5%8F%98%E6%9B%B4/","summary":"reset 回退一步 revert 生成新commit来还原","title":"撤销变更"},{"content":" 1 $ git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-id\u0026gt; ","permalink":"https://jdxj.github.io/posts/cmd/git/%E7%A7%BB%E5%8A%A8%E5%88%86%E6%94%AF%E5%A4%B4/","summary":"1 $ git branch -f \u0026lt;branch-name\u0026gt; \u0026lt;commit-id\u0026gt;","title":"移动分支头"},{"content":"提升对称加密算法的性能 AES 是我们的首选对称加密算法\nAES 只支持 3 种不同的密钥长度，分别是 128 位、192 位和 256 位，它们的安全性依次升高，运算时间也更长。\n在 TLS1.2 及更早的版本中，仍然允许通讯双方使用 DES 算法，这是非常不安全的行为\n这种分组后变换密钥的算法就叫做分组密码工作模式（下文简称为分组模式），它是影响 AES 性能的另一个因素。\nCBC 分组模式中，只有第 1 组明文加密完成后，才能对第 2 组加密，因为第 2 组加密时会用到第 1 组生成的密文。因此，CBC 必然无法并行计算。\n通常我们应选择可以并行计算的 GCM 分组模式，这也是当下互联网中最常见的 AES 分组算法。\n由于 AES 算法中的替换法、行移位等流程对 CPU 指令并不友好，所以 Intel 在 2008 年推出了支持AES-NI 指令集的 CPU，能够将 AES 算法的执行速度从 每字节消耗 28 个时钟周期（参见这里），降低至 3.5 个时钟周期（参见这里）。在 Linux 上你可以用下面这行命令查看 CPU 是否支持 AES-NI 指令集：\n1 2 $ sort -u /proc/crypto | grep module |grep aes module : aesni_intel 如果CPU支持AES-NI特性，那么应选择 AES 算法，否则可以选择CHACHA20 对称加密算法，它主要使用 ARX 操作（add-rotate-xor），CPU 执行起来更快。\n更快地协商出密钥 RSA 密钥协商算法的最大问题是不支持前向保密（Forward Secrecy），一旦服务器的私钥泄露，过去被攻击者截获的所有 TLS 通讯密文都会被破解。解决前向 保密的是DH（Diffie–Hellman）密钥协商算法。\nDH 算法的工作流程\n通讯双方各自独立生成随机的数字作为私钥，而后依据公开的算法计算出各自的公钥，并通过未加密的 TLS 握手发给对方。接着，根据对方的公钥和自己的私钥，双 方各自独立运算后能够获得相同的数字，这就可以作为后续对称加密时使用的密钥。即使攻击者截获到明文传递的公钥，查询到公开的 DH 计算公式后，在不知道私钥 的情况下，也是无法计算出密钥的。这样，DH 算法就可以在握手阶段生成随机的新密钥，实现前向保密。\nDH 算法的计算速度很慢，如上图所示，计算公钥以及最终的密钥时，需要做大量的乘法运算，而且为了保障安全性，这些数字的位数都很长。为了提升 DH 密钥交换 算法的性能，诞生了当下广为使用的ECDH 密钥交换算法，ECDH 在 DH 算法的基础上利用ECC 椭圆曲线特性，可以用更少的计算量计算出公钥以及最终的密钥。\n依据解析几何，椭圆曲线实际对应一个函数，而不同的曲线便有不同的函数表达式，目前不被任何已知专利覆盖的最快椭圆曲线是X25519 曲线，它的表达式是\ny^2 = x^3 + 486662x^2 + x。 提升密钥协商速度的另一个思路，是减少密钥协商的次数，主要包括以下 3 种方式\n最为简单有效的方式是在一个 TLS 会话中传输多组请求，对于 HTTP 协议而言就是使用长连接，在请求中加入 Connection: keep-alive 头部便可以做到。 客户端与服务器在首次会话结束后缓存下 session 密钥，并用唯一的 session ID 作为标识。这样，下一次握手时，客户端只要把 session ID 传给服务器， 且服务器在缓存中找到密钥后（为了提升安全性，缓存会定期失效），双方就可以加密通讯了。这种方式的问题在于，当 N 台服务器通过负载均衡提供 TLS 服务 时，客户端命中上次访问过的服务器的概率只有 1/N，所以大概率它们还得再次协商密钥。 session ticket 方案可以解决上述问题，它把服务器缓存密钥，改为由服务器把密钥加密后作为 ticket 票据发给客户端，由客户端缓存密文。其中，集群中 每台服务器对 session 加密的密钥必须相同，这样，客户端携带 ticket 密文访问任意一台服务器时，都能通过解密 ticket，获取到密钥。 使用 session 缓存或者 session ticket 既没有前向安全性，应对重放攻击也更加困难。提升 TLS 握手性能的更好方式，是把 TLS 协议升级到 1.3 版本。\n升级到 TLS1.3 TLS1.3（参见RFC8446）对性能的最大提升，在于它把 TLS 握手时间从 2 个 RTT 降为 1 个 RTT。\n在 TLS1.2 的握手中，先要通过 Client Hello 和 Server Hello 消息协商出后续使用的加密算法，再互相交换公钥并计算出最终密钥。TLS1.3 中把 Hello 消息和公钥交换合并为一步，这就减少了一半的握手时间\n那 TLS1.3 握手为什么只需要 1 个 RTT 就可以完成呢？因为 TLS1.3 支持的密钥协商算法大幅度减少了，这样，客户端尽可以把常用 DH 算法的公钥计算出来， 并与协商加密算法的 HELLO 消息一起发送给服务器，服务器也作同样处理，这样仅用 1 个 RTT 就可以协商出密钥。\n而且，TLS1.3 仅支持目前最安全的几个算法，比如 openssl 中仅支持下面 5 种安全套件：\nTLS_AES_256_GCM_SHA384 TLS_CHACHA20_POLY1305_SHA256 TLS_AES_128_GCM_SHA256 TLS_AES_128_CCM_8_SHA256 TLS_AES_128_CCM_SHA256 相较起来，TLS1.2 支持各种古老的算法，中间人可以利用降级攻击，在握手阶段把加密算法替换为不安全的算法，从而轻松地破解密文。如前文提到过的 DES 算法， 由于密钥位数只有 56 位，很容易破解。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/%E4%BC%98%E5%8C%96tls/","summary":"提升对称加密算法的性能 AES 是我们的首选对称加密算法 AES 只支持 3 种不同的密钥长度，分别是 128 位、192 位和 256 位，它们的安全性依次升高，运算时间也更长","title":"优化TLS"},{"content":"Go密码学包crypto/rand提供了密码学级别的随机数生成器实现rand.Reader，在不同平台上rand.Reader使用的数据源有所不同。在类Unix操作系统上，它使 用的是该平台上密码学应用的首选随机数源/dev/urandom\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // chapter9/sources/go-crypto/rand_generate.go package main import ( \u0026#34;crypto/rand\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { c := 32 b := make([]byte, c) _, err := rand.Read(b) if err != nil { panic(err) } fmt.Printf(\u0026#34;%x\\n\u0026#34;, b) } ","permalink":"https://jdxj.github.io/posts/articles/jdxj/go/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90/","summary":"Go密码学包crypto/rand提供了密码学级别的随机数生成器实现rand.Reader，在不同平台上rand.Reader使用的数据源有","title":"随机数生成"},{"content":"消息认证码虽然解决了消息发送者的身份认证问题，但由于采用消息认证码的通信双方共享密钥，因此对于一条通过了MAC验证的消息，通信双方依旧无法向第三方证 明这条消息就是对方发送的。同时任何一方也都没有办法防止对方否认该条消息是自己发送的。也就是说单凭消息认证码无法防止否认（non-repudiation）。\n在消息认证码中，生成MAC和验证MAC使用的是同一密钥，这是无法防止否认问题的根源。因此数字签名技术对生成签名的密钥和验证签名的密钥进行了区分，签名密 钥只能由签名一方持有，它的所有通信对端将持有用于验证签名的密钥。\n图55-10　签名与验证签名\n图55-10与公钥密码系统中的“公钥加密，私钥解密”的流程十分相似, 数字签名就是通过将公钥密码反过来用而实现的\n图55-11　公钥密码流程与数字签名流程\n在实际生产应用中，我们通常对消息的摘要进行签名。这是因为公钥密码加密算法本身很慢，如果对消息全文进行加密将非常耗时。\nRSA签名默认使用PKCS#1 v1.5方案，但该方案存在潜在伪造签名的可能。为了应对潜在伪造，RSA-PSS算法（Probabilistic Signature Scheme）被设计出 来。RSA-PSS算法通过采用对消息摘要进行签名，并在计算散列值时对消息加盐（salt）的方式来提高安全性（这样对同一条消息进行多次签名，每次得到的签名都 不同）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // chapter9/sources/go-crypto/cat rsa_pss_sign_and_verify.go func main() { // 生成公钥密码的密钥对 privateKey, err := rsa.GenerateKey(rand.Reader, 2048) if err != nil { panic(err) } publicKey := privateKey.PublicKey // 待签名消息 msg := []byte(\u0026#34;I love go programming language!!\u0026#34;) // 计算摘要 digest := sha256.Sum256(msg) // 用私钥签名 sign, err := rsa.SignPSS(rand.Reader, privateKey, crypto.SHA256, digest[:], nil) if err != nil { panic(err) } fmt.Printf(\u0026#34;签名：%s\\n\u0026#34;, fmt.Sprintf(\u0026#34;%x\u0026#34;, sign)) // 用公钥验证签名 err = rsa.VerifyPSS(\u0026amp;publicKey, crypto.SHA256, digest[:], sign, nil) if err != nil { panic(err) } fmt.Printf(\u0026#34;签名验证成功!\\n\u0026#34;) } 我们看到数字签名既可以识别篡改和伪装，还可以防止否认，这让计算机网络通信从这一技术中获益匪浅。但数字签名的正确运用有一个大前提，那就是公钥属于真正 的发送者。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/go/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/","summary":"消息认证码虽然解决了消息发送者的身份认证问题，但由于采用消息认证码的通信双方共享密钥，因此对于一条通过了MAC验证的消息，通信双方依旧无法向","title":"数字签名"},{"content":"单向散列函数虽然能辨别出数据是否被篡改，但却无法辨别出数据是不是伪装的。因此，在这样的场合下，我们还需要对消息进行认证（Authentication），即 校验消息的来源是不是我们所期望的。而用于解决这一问题的常见密码技术就是消息认证码（Message Authentication Code，MAC）。\n消息认证码技术是以通信双方共享密钥为前提的。对于任意长度的消息，我们都可以计算出一个固定长度的消息认证码数据，这个数据被称为MAC值。\n我们可以将消息认证码理解成一种与密钥相关联的单向散列函数。消息认证码有多种实现方式，包括使用单向散列函数实现、使用分组密码实现、公钥密码实现等。\n使用SHA-256单向散列函数的HMAC示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // chapter9/sources/go-crypto/hmac_generate.go func main() { // 密钥(key) 32字节 key := []byte(\u0026#34;12345678123456781234567812345678\u0026#34;) // 要传递的消息 message := []byte(\u0026#34;I love go programming language!!\u0026#34;) // 创建hmac实例（使用SHA-256单向散列函数） mac := hmac.New(sha256.New, key) mac.Write(message) // 计算mac值 m := mac.Sum(nil) ms := fmt.Sprintf(\u0026#34;%x\u0026#34;, m) // mac到string fmt.Printf(\u0026#34;mac值 = %s\\n\u0026#34;, ms) } 在实际使用中，对数据进行对称加密且携带MAC值的方式被称为“认证加密”（Authenticated Encryption with Associated Data，AEAD）。认证加密同时 满足了机密性（对称加密）、完整性（MAC中的单向散列）以及认证（MAC）的特性，在生产中有着广泛的应用。认证加密主要有以下三种方式。\n认证加密主要有以下三种方式\nEncrypt-then-MAC：先用对称密码对明文进行加密，然后计算密文的MAC值。 Encrypt-and-MAC：将明文用对称密码加密，并计算明文的MAC值。 MAC-then-Encrypt：先计算明文的MAC值，然后将明文和MAC值一起用对称密码加密。 分组密码中的GCM（Galois Counter Mode）就是一种认证加密模式，它使用CTR（计数器）分组模式和128比特分组长度的AES加密算法进行加密，并使用 Carter-Wegman MAC算法实现MAC值计算。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/go/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/","summary":"单向散列函数虽然能辨别出数据是否被篡改，但却无法辨别出数据是不是伪装的。因此，在这样的场合下，我们还需要对消息进行认证（Authentica","title":"消息认证码"},{"content":"除了输出长度固定、计算快速之外，密码学级别的单向散列函数还具有如下性质\n强抗碰撞性：要找到散列值（摘要值）相同的两条不同的消息是非常困难的。 单向性：无法通过散列值（摘要值）反算出输入的消息原文。 Go标准库密码学包提供了多种主流单向散列函数标准的实现，包括MD5、SHA-1、SHA-256、SHA-384和SHA-512等。Go语言还在扩展包 golang.org/x/crypto/sha3中提供了最新的SHA-3标准的实现。\nMD5 MD5（Message Digest）是于1991年诞生的单向散列函数，能够产生128比特（16字节）的散列值（摘要值）\n不过MD5散列函数的强抗碰撞性已经被中国科学院院士王小云教授攻破，即可以在短时间内产生具有相同散列值的两条不同消息，达到对输入信息篡改但不影响摘要值 的目的。\nSHA-1 SHA-1是由美国国家标准技术研究所（NIST）制定的单向散列函数标准，它能产生160比特（20字节）的散列值\n王小云教授团队在攻破MD5强抗碰撞性后的第二年又提出了SHA-1的强抗碰撞性快速攻击算法和范例。因此，在实际生产中，不推荐再使用MD5或SHA-1这两种单向散 列函数了。\nSHA-2 SHA-256、SHA-384和SHA-512也都是由NIST设计的单向散列函数，它们的散列值长度分别为256比特（32字节）、384比特（48字节）和512比特（64字节）。 这三个散列函数合起来统称SHA-2标准，它是目前应用最为广泛且强抗碰撞性尚未被攻破的单向散列函数标准。 SHA-256是这个标准中使用最多的单向散列函数 1 2 3 4 5 6 7 8 9 10 // chapter9/sources/go-crypto/sha256_sum.go func sum256(data []byte) string { sum := sha256.Sum256(data) return fmt.Sprintf(\u0026#34;%x\u0026#34;, sum) } func main() { s := \u0026#34;I love go programming language!!\u0026#34; fmt.Println(sum256([]byte(s))) } ","permalink":"https://jdxj.github.io/posts/articles/jdxj/go/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/","summary":"除了输出长度固定、计算快速之外，密码学级别的单向散列函数还具有如下性质 强抗碰撞性：要找到散列值（摘要值）相同的两条不同的消息是非常困难的。 单","title":"单向散列函数"},{"content":"常见的密钥配送方案有事先共享密钥（事先以安全的方式将密钥交给通信方）、密钥分配中心（每个通信方要事先与密钥分配中心共享密钥）、Diffie-Hellman密钥 交换算法、公钥密码等。\n图55-5　公钥密钥分发与加解密流程\n图55-6　RSA密钥对参与加解密的原理图\nRSA加解密默认使用PKCS#1 v1.5填充方案，但该方案在面对Chosen Ciphertext Attacks（选择密文攻击）时强度不足（虽然无法破译RSA，但攻击者可能 获取到密文对应的明文的少量信息） RSA-OAEP（Optimal Asymmetric Encryption Padding，最优非对称加密填充）则被认为是一种可信赖、满足强度要求的填充方案。 使用RAS加密 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package public_key import ( \u0026#34;crypto/rand\u0026#34; \u0026#34;crypto/rsa\u0026#34; \u0026#34;crypto/sha256\u0026#34; \u0026#34;encoding/hex\u0026#34; \u0026#34;fmt\u0026#34; ) func RSAEncrypt() { privateKey, err := rsa.GenerateKey(rand.Reader, 2048) if err != nil { panic(err) } publicKey := privateKey.PublicKey plaintext := []byte(\u0026#34;hello world\u0026#34;) // 使用公钥加密 ciphertext, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, \u0026amp;publicKey, plaintext, nil) if err != nil { panic(err) } fmt.Printf(\u0026#34;ciphertext: %s\\n\u0026#34;, hex.EncodeToString(ciphertext)) // 使用私钥解密 plaintext, err = rsa.DecryptOAEP(sha256.New(), rand.Reader, privateKey, ciphertext, nil) if err != nil { panic(err) } fmt.Printf(\u0026#34;plaintext: %s\\n\u0026#34;, plaintext) } rsa.EncryptOAEP和rsa.DecryptOAEP的第二个参数都是一个随机数生成器（这里传入rand.Reader），RSA-OAEP会通过随机数使每次生成的密文呈现不同 的排列方式，因此多次运行上述示例程序所得到的密文结果都是不同的。 这两个函数的第一个参数是hash.Hash接口实现的实例，其产生的散列值可作为随机数生成器的种子。这两个函数需要采用同一种hash.Hash接口的实现，Go标准 库文档推荐使用sha256.New()。 RSA算法对待处理的数据长度是有要求的，采用RSA-OAEP填充时，加密函数EncryptOAEP支持的最大明文长度为\nRSA密钥长度（字节数）-单向散列结果长度×2-2。 在上面的例子中，加密函数支持的最大明文长度为256-32×2-2=190（字节）。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/go/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/","summary":"常见的密钥配送方案有事先共享密钥（事先以安全的方式将密钥交给通信方）、密钥分配中心（每个通信方要事先与密钥分配中心共享密钥）、Diffie-","title":"公钥密码"},{"content":"密码算法可以分为分组密码（block cipher）和流密码（stream cipher）两种。\n分组密码是一种一次仅能处理固定长度数据块的算法。而这个数据块的固定长度（比特数量）则称为该分组密码算法的分组长度（block length）。\n图55-1　分组密码加密流程\n填充方案\nISO10126：填充字符串由一个字节序列组成，该字节序列的最后一个字节标识填充字节序列的长度，序列中的其余字节为随机数据。 PKCS#7：填充字符串由一个字节序列组成，该序列中每字节的值都是该填充字节序列的长度。该方案适合分组长度为1～255字节的情况。 PKCS#5：该填充方案和PKCS#7方案原理上没有实质区别，只是它仅适合分组长度为8字节的情况。（该方案不适合AES算法，因为该算法的分组长度至少为16字节。） 由0x80和0x00组成的填充字节序列：在这种填充方式中，填充字符串的第一个字节值是0x80，后面的每个字节值都是0x00。 迭代的方法称为分组密码算法的模式。常见的模式包括\nECB模式（电子密码本模式） CBC模式（密码分组链接模式） CFB模式（密文反馈模式） OFB模式（输出反馈模式） CTR模式（计数器模式） 图55-2　ECB模式与CBC模式对比\nCBC模式第一个明文分组由于不存在前一个密文分组，因此使用了一个被称为“初始向量”（initialization vector, IV）的随机数据。这个初始向量在解密时也 会被用到，因此加密方和解密方需事先就初始向量的生成方式达成一致。比如：一种惯用法是将初始向量字符串包含在密文的头部，长度为分组长度。\n不同分组密码迭代模式有各自的优缺点。从安全性考虑，ECB模式（电子密码本）虽然简单、快速，但不应在生产中使用，因为它对攻击的抵御能力是这些模式中最弱 的。\nGo语言实现的DES、3重DES（TDEA）和AES算法都是对称密码算法。在这三个算法中\nDES已经可以用暴力破解手段在现实时间内实现破解，因此我们不应再将DES算法应用在实际生产中； 3重DES加解密性能不高，仅在一些重视兼容性（与DES兼容）的场合有所应用； AES是标准机构NIST公开选拔的、用于取代DES的新对称密码标准，它安全快速，可以在各种平台上工作，是对称密码算法的首选 使用AES加密 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package block_cipher import ( \u0026#34;bytes\u0026#34; \u0026#34;crypto/aes\u0026#34; \u0026#34;crypto/cipher\u0026#34; \u0026#34;crypto/rand\u0026#34; ) func RandBytes(n int) ([]byte, error) { b := make([]byte, n) _, err := rand.Read(b) return b, err } func PKCS7Padding(plaintext []byte, blockSize int) []byte { paddingSize := blockSize - len(plaintext)%blockSize padding := bytes.Repeat([]byte{byte(paddingSize)}, paddingSize) return append(plaintext, padding...) } func PKCS7UnPadding(padded []byte) []byte { size := len(padded) paddingSize := int(padded[size-1]) return padded[:size-paddingSize] } func AESEncrypt(plaintext, key []byte) ([]byte, error) { block, err := aes.NewCipher(key) if err != nil { return nil, err } iv, err := RandBytes(aes.BlockSize) if err != nil { return nil, err } blockMode := cipher.NewCBCEncrypter(block, iv) plaintext = PKCS7Padding(plaintext, aes.BlockSize) // iv+ciphertext ciphertext := make([]byte, aes.BlockSize+len(plaintext)) copy(ciphertext[:aes.BlockSize], iv) blockMode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext) return ciphertext, nil } func AESDecrypt(ciphertext, key []byte) ([]byte, error) { block, err := aes.NewCipher(key) if err != nil { return nil, err } iv := ciphertext[:aes.BlockSize] blockMode := cipher.NewCBCDecrypter(block, iv) plaintext := make([]byte, len(ciphertext)-aes.BlockSize) blockMode.CryptBlocks(plaintext, ciphertext[aes.BlockSize:]) return PKCS7UnPadding(plaintext), nil } ","permalink":"https://jdxj.github.io/posts/articles/jdxj/go/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/","summary":"密码算法可以分为分组密码（block cipher）和流密码（stream cipher）两种。 分组密码是一种一次仅能处理固定长度数据块的算法。","title":"分组密码算法"},{"content":"官方crypto包\nsrc/crypto golang.org/x/crypto 分类\n分组密码 cipher 五种分组模式 ECB CBC CFB OFB CTR des 对称密码 DES TDEA aes 对称密码 AES 公钥密码 tls TLS 1.2 TLS 1.3 x509 编码格式的密钥和证书的解析 rsa RSA elliptic 标准椭圆曲线算法 dsa DSA ecdsa 数字签名算法 ed25519 椭圆曲线签名算法Ed25519 单向散列函数 (消息摘要) md5 sha1 sha256 sha512 消息认证码 hmac rand ","permalink":"https://jdxj.github.io/posts/articles/jdxj/go/go%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8C%85/","summary":"官方crypto包 src/crypto golang.org/x/crypto 分类 分组密码 cipher 五种分组模式 ECB CBC CFB OFB CTR des 对称密码 DES TDEA aes 对称密码 AES 公钥密码 tls TLS 1.2 TLS 1.3 x509 编码格式的密钥和证书的解析 rsa RSA elliptic 标准","title":"Go密码学包"},{"content":"滑动窗口是怎样影响传输速度的？ TCP 报文发出去后，并不能立刻从内存中删除，因为重发时还需要用到它。由于 TCP 是由内核实现的，所以报文存放在内核缓冲区中，这也是高并发下 buff/cache 内存增加很多的原因。\n确认报文被收到的机制非常复杂，它受制于很多因素\n网速 接收方的处理能力 RFC1323 定义了扩充窗口的方法，但 Linux 中打开这一功能，需要把 tcp_window_scaling 配置设为 1，此时窗口的最大值可以达到 1GB（2^30）\nnet.ipv4.tcp_window_scaling = 1 因为网络的传输能力是有限的，当发送方依据发送窗口，发送超过网络处理能力的报文时，路由器会直接丢弃这些报文。因此，缓冲区的内存并不是越大越好。\n带宽时延积如何确定最大传输速度？ 当最大带宽是 100MB/s、网络时延是 10ms 时，这意味着客户端到服务器间的网络一共可以存放 100MB/s * 0.01s = 1MB 的字节。这个 1MB 是带宽与时延 的乘积，所以它就叫做带宽时延积（缩写为 BDP，Bandwidth Delay Product）。这 1MB 字节存在于飞行中的 TCP 报文，它们就在网络线路、路由器等网络 设备上。如果飞行报文超过了 1MB，就一定会让网络过载，最终导致丢包。\n由于发送缓冲区决定了发送窗口的上限，而发送窗口又决定了已发送但未确认的飞行报文的上限，因此，发送缓冲区不能超过带宽时延积，因为超出的部分没有办法 用于有效的网络传输，且飞行字节大于带宽时延积还会导致丢包； 缓冲区也不能小于带宽时延积，否则无法发挥出高速网络的价值。 怎样调整缓冲区去适配滑动窗口？ 可以使用 Linux 的缓冲区动态调节功能\n发送缓冲区，它的范围通过 tcp_wmem 配置\n第 1 个数值是动态范围的下限，第 3 个数值是动态范围的上限。而中间第 2 个数值，则是初始默认值。 发送缓冲区完全根据需求自行调整。比如，一旦发送出的数据被确认，而且没有新的数据要发送，就可以把发送缓冲区的内存释放掉。 net.ipv4.tcp_wmem = 4096 16384 4194304 设置接收缓冲区范围的 tcp_rmem：\n第 1、3 个值是范围的下限和上限，第 2 个值是初始默认值 如果系统的空闲内存很多，就可以把缓冲区增大一些，这样传给对方的接收窗口也会变大，因而对方的发送速度就会通过增加飞行报文来提升。 反之，内存紧张时就会缩小缓冲区，这虽然会减慢速度，但可以保证更多的并发连接正常工作。 net.ipv4.tcp_rmem = 4096 87380 6291456 发送缓冲区的调节功能是自动开启的，而接收缓冲区则需要配置 tcp_moderate_rcvbuf 为 1 来开启调节功能：\nnet.ipv4.tcp_moderate_rcvbuf = 1 接收缓冲区调节时，怎么判断空闲内存的多少呢？这是通过 tcp_mem 配置完成的：\n当 TCP 内存小于第 1 个值时，不需要进行自动调节； 在第 1 和第 2 个值之间时，内核开始调节接收缓冲区的大小； 大于第 3 个值时，内核不再为 TCP 分配新内存，此时新连接是无法建立的。 net.ipv4.tcp_mem = 88560 118080 177120 在高并发服务器中，为了兼顾网速与大量的并发连接，我们应当保证缓冲区的动态调整上限达到带宽时延积，而下限保持默认的 4K 不变即可。而对于内存紧张的服务 而言，调低默认值是提高并发的有效手段。\n如果这是网络 IO 型服务器，那么，调大 tcp_mem 的上限可以让 TCP 连接使用更多的系统内存，这有利于提升并发能力。需要注意的是，tcp_wmem 和 tcp_rmem 的单位是字节，而 tcp_mem 的单位是页面大小。而且，千万不要在 socket 上直接设置 SO_SNDBUF 或者 SO_RCVBUF，这样会关闭缓冲区的动态 调整功能。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp%E7%BC%93%E5%86%B2%E5%8C%BA/","summary":"滑动窗口是怎样影响传输速度的？ TCP 报文发出去后，并不能立刻从内存中删除，因为重发时还需要用到它。由于 TCP 是由内核实现的，所以报文存放在内核缓冲区","title":"TCP缓冲区"},{"content":"事件是怎么产生的？ 读事件表示有到达的消息需要处理 写事件表示可以发送消息（TCP 连接的写缓冲区中有可用空间）。 tcp握手\n在建立好的 TCP 连接上收发消息时，读事件对应着接收到对方的消息 写事件则稍微复杂些 假设要发送一个 2MB 的请求, 当调用 write 函数发送时，会先把内存中的数据拷贝到写缓冲区中后，再发送到网卡上 因为在对方没有明确表示收到前，TCP 会通过定时器重发写缓冲区中的数据，保证消息能够到达对方。 写缓冲区是有大小限制的。这里假设写缓冲区只有 1MB，所以调用 write 发送 2MB 数据时，write 函数的返回值只有 1MB，表示写缓冲区已用尽。 当收到对方发来的 ACK 报文后，缓冲区中的数据才能释放，就会产生写事件通知进程发送剩余的那 1MB 数据。 如同建立连接需要双向建立一样，关闭连接也需要双方各自关闭每个方向的通道。主动关闭的一方发送 FIN 报文，到达被动方后，内核自动回复 ACK 报文，这表示 从主动方到被动方的通道已经关闭。但被动方到主动方的通道也需要关闭，所以此时被动方会产生读事件，提醒被动方调用 close 函数关闭连接。\n什么样的代码值得基于事件来做拆分呢？\n对于服务器来说，对最慢的操作做异步化改造，才能值回开发效率的损失。而服务里对资源的操作速度由快到慢，依次是 CPU、内存、磁盘和网络。CPU 和内存的执 行速度都是纳秒级的，无须考虑事件驱动，而磁盘和网络都可以采用事件驱动的异步方式处理。\n怎样处理网络事件？ epoll\n理解多路复用\n一个进程虽然任一时刻只能处理一个请求，但处理每个请求产生的事件时，若耗时控制在 1 毫秒以内，这样 1 秒钟就可以处理数千个请求，从更长的时间维度上看， 多个请求复用了一个进程，也叫做多路复用（或者叫做时分多路复用）。我们熟知的 epoll，就是内核提供给用户态的多路复用接口，进程可以通过它从内核中获取 事件。\nepoll 是如何获取网络事件的呢？最简单的方法，就是在获取事件时，把所有并发连接传给内核，再由内核返回产生了事件的连接，再处理这些连接对应的请求即可。 epoll 前的 select 等多路复用函数就是这么干的。\nepoll 为了降低性能消耗，把获取事件拆分成两步。\n第一步把需要监控的 socket 传给内核（epoll_ctl 函数），它仅在连接建立等有限的时机调用； 第二步收集事件（epoll_wait 函数）便不用传递 socket 了，这样就把 socket 的重复传递改为了一次传递，降低了性能损耗。 进程获取到产生事件的 socket 后，又该如何处理它呢？这里的核心约束是，处理任何一个事件的耗时都应该是微秒级或者毫秒级，否则就会延误其他事件的处理， 不只降低了用户的体验，而且会形成恶性循环。\n怎样保证处理一个事件的时间不会太长呢？\n第一类是计算任务，虽然内存、CPU 的速度很快，然而循环执行也可能耗时达到秒级。所以，如果一定要引入需要密集计算才能完成的请求，为了不阻碍其他事件 的处理，要么把这样的请求放在独立的线程中完成，要么把请求的处理过程拆分成多段，确保每段能够快速执行完，同时每段执行完都要均等地处理其他事件，这样 通过放慢该请求的处理时间，就保障了其他请求的及时处理。 第二类会读写磁盘，由于磁盘的写入操作使用了 PageCache 的延迟写特性，当 write 函数返回时只是复制到了内存中，所以写入操作很快。磁盘的读取操作就 比较慢了，这时，通常要把大文件的读取，拆分成许多份，每份仅有几十 KB，降低单次操作的耗时。 第三类是通过网络访问上游服务。与处理客户端请求相似，我们必须使用非阻塞 socket，用事件驱动方式处理请求。需要注意的是，许多网络服务提供的 SDK， 都是基于阻塞 socket 实现的，使用前必须先做完非阻塞改造。 // todo: 怎么用go整个非阻塞的client\n小结 网络报文到达后，内核就产生了读、写事件，而 epoll 函数使得进程可以高效地收集到这些事件。接下来，要确保在进程中处理每个事件的时间足够短，才能及时地 处理所有请求，这个过程中既要避免阻塞 socket 的使用，也要把耗时过长的操作拆成多份执行。最终，通过快速、及时、均等地执行所有事件，异步 Server 实 现了高并发。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/","summary":"事件是怎么产生的？ 读事件表示有到达的消息需要处理 写事件表示可以发送消息（TCP 连接的写缓冲区中有可用空间）。 tcp握手 在建立好的 TCP 连接上收发","title":"事件驱动"},{"content":"分布式系统的服务发现，使用人工配置既容易出错，速度也慢，而用广播就可以轻松实现自动化服务发现。\n广播是怎么实现的？ 广播要改用 UDP 协议\n网络设备天然就拥有广播能力，当它在一个网络端口上收到主机发来的报文时，可以向其他端口上的所有主机重发一遍\n根据网络分层模型，上层协议可以使用下层协议的功能，所以传输层协议拥有 IP 协议的广播能力。同时，传输层通过端口号把网络报文和进程关联在了一起\n传输层的 TCP 协议为了保证可靠性，建立了逻辑上的连接概念，由于一个连接上只能有两方，所以 TCP 无法进行一对多通讯。而传输层的 UDP 协议无需建立连接， 所以我们常用 UDP 协议发送广播。\n广播的性能高有两个原因：\n首先，交换机直接转发给接收方，要比从发送方到接收方的传输路径更短。 其次，原本需要发送方复制多份报文再逐一发送至各个接受者的工作，被交换机完成了，这既分担了发送方的负载，也充分使用了整个网络的带宽。 交换机收到消息后，怎么知道这是广播报文并转发给整个网络呢？\n以太网中的数据链路层，通过硬件的 MAC 地址来传播消息，交换机就通过报文的 MAC 地址来确定是否需要广播。当交换机收到目标 MAC 地址是 ff:ff:ff:ff:ff:ff 的报文时，便知道这是一个广播报文，才会将它转发给局域网中的所有主机，否则只会转发给 MAC 地址对应端口上的主机。 写代码时无法控制底层的 MAC 地址，只能填写目标 IP 地址 如果只是对所在子网进行广播，那么使用受限广播地址 255.255.255.255 就可以了； 如果局域网划分了多个子网，主机需要向其他子网广播，则需要正确地设置直接广播地址（路由器需要打开直接广播功能）。 如何正确地设置直接广播 IP 地址？\n主机 ID 不会出现全 0 和全 1 这两种情况，这是因为全 0 和全 1 有特殊用途，其中全 0 特指它自己（所以 0.0.0.0 可以指代本机 IP），而全 1 表示全 部主机。\n主机 ID 的比特位全部设为 1 后就是广播地址。\n比如，192.168.0.101 是 C 类地址，把主机 ID 从 101 改为 255 后，就可以用 192.168.0.255 发送广播了。 有点歧义, 这里是指目标地址改为192.168.0.255? 把每个要接收广播的主机的地址改为192.168.0.255貌似不对\nCIDR 这种新的划分方式，它通过子网掩码（或者叫 Netmask），可以在任意的位置将 IP 地址拆分为网络 ID 和主机 ID，扩展了 A、B、C 三类网络的用法。\n用更精准的组播来做服务发现 广播报文在这 3 个步骤后会被丢弃：\n第 1 步，网卡设备收到报文后，查看报文中的目标 MAC 地址是否与本机的 MAC 地址匹配，如果不匹配就会丢弃。广播 MAC 地址默认匹配，继续交由上层的 IP 协议栈处理； 第 2 步，IP 协议栈查看目标 IP 地址是否为本机 IP 地址，不匹配也会丢弃报文。上文介绍过的广播 IP 地址同样默认匹配，交由传输层协议继续处理。 第 3 步，传输层检查目标端口是否有进程在监听，如果没有则丢弃报文，反之则交付给进程处理。不属于集群的主机自然不会启动服务监听端口，在这一步才会丢 弃广播报文。 组播是一种“定向广播”，它设定了一个虚拟组，用组播 IP 来标识。这个虚拟组中可以包含多个主机的 IP，当向对应的组播 IP 发送消息时，仅在这个组内的主机 才能收到消息。\n组播ip是D类地址, 范围是从 224.0.0.0 到 239.255.255.255\n当设置好组播 IP 地址后，还要通过管理组播地址的 IGMP 协议（Internet Group Management Protocol），将主机 IP 地址添加进虚拟组中。\n组播相对于广播而言 ，除了能够更精准的管理组播范围，还能够跨越多个网络工作。当然，如果将多个网络中的 IP 加入同一虚拟组时，需要涉及到的路由器都可以 正确地处理这些 IP 地址，且都能支持 IGMP 协议。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/%E4%B8%80%E5%AF%B9%E5%A4%9A%E9%80%9A%E8%AE%AF/","summary":"分布式系统的服务发现，使用人工配置既容易出错，速度也慢，而用广播就可以轻松实现自动化服务发现。 广播是怎么实现的？ 广播要改用 UDP 协议 网络设备天然","title":"一对多通讯"},{"content":"互斥锁 当你无法判断锁住的代码会执行多久时，应该首选互斥锁\n对于 99% 的线程级互斥锁而言，阻塞都是由操作系统内核实现的\n线程获取锁失败时，增加了两次上下文切换的成本：从运行中切换为休眠，以及锁释放时从休眠状态切换为运行中。\n自旋锁 如果你能确定被锁住的代码执行时间很短，就应该用自旋锁取代互斥锁。\n自旋锁比互斥锁快得多，因为它通过 CPU 提供的 CAS 函数（全称 Compare And Swap），在用户态代码中完成加锁与解锁操作。\n第 1 步查看锁的状态，如果锁是空闲的，第 2 步将锁设置为当前线程持有。 在没有 CAS 操作前，多个线程同时执行这 2 个步骤是会出错的。 CAS 函数把这 2 个步骤合并为一条硬件级指令。 什么叫“忙等待”\n它并不意味着一直执行 CAS 函数，生产级的自旋锁在“忙等待”时，会与 CPU 紧密配合 ，它通过 CPU 提供的 PAUSE 指令，减少循环等待时的耗电量； 对于单核 CPU，忙等待并没有意义，此时它会主动把线程休眠。 读写锁 可以由互斥锁或自旋锁实现.\n如果你能够明确区分出读和写两种场景，可以选择读写锁。\n读写锁的优势在于，当写锁未被持有时，多个线程能够并发地持有读锁，这提高了共享资源的使用率。多个读锁被同时持有时，读线程并不会修改共享资源，所以它们 的并发执行不会产生数据错误。\n读写锁真正发挥优势的场景，必然是读多写少的场景，否则读锁将很难并发持有。\n读优先锁更强调效率，它期待锁能被更多的线程持有。简单看下它的工作特点：当线程 A 先持有读锁后，即使线程 B 在等待写锁，后续前来获取读锁的线程 C 仍然可以立刻加锁成功，因为这样就有 A、C 这 2 个读线程在并发持有锁，效率更高。\n写优先的读写锁。同样的情况下，线程 C 获取读锁会失败，它将被阻塞在获取锁的代码中，这样，只要线程 A 释放读锁后，线程 B 马上就可以获取到写锁。\n能否兼顾二者，避免读、写线程饿死呢？\n用队列把请求锁的线程排队，按照先来后到的顺序加锁即可，当然读线程仍然可以并发，只不过不能插队到写线程之前。 乐观锁 无论互斥锁、自旋锁还是读写锁，都属于悲观锁。\n它认为同时修改资源的概率很高，很容易出现冲突，所以访问共享资源前，先加上锁，总体效率会更优。 所谓“乐观”，就是假定冲突的概率很低，所以它采用的“加锁”方式是，先修改完共享资源，再验证这段时间内有没有发生冲突。如果没有其他线程在修改资源，那么 操作完成。如果发现其他线程已经修改了这个资源，就放弃本次操作。\n至于放弃后如何重试，则与业务场景相关，虽然重试的成本很高，但出现冲突的概率足够低的话，还是可以接受的。可见，乐观锁全程并没有加锁，所以它也叫无锁编 程。\n无锁编程中如何验证发生了冲突?\n以在线文档为例, 比较版本号来判断是否冲突\n乐观锁除了应用在 Web 分布式场景，在数据库等单机上也有广泛的应用。只是面向多线程时，最后的验证步骤是通过 CPU 提供的CAS操作完成的。\n乐观锁虽然去除了锁操作，但是一旦发生冲突，重试的成本非常高。所以，只有在冲突概率非常低，且加锁成本较高时，才考虑使用乐观锁。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/%E9%94%81/","summary":"互斥锁 当你无法判断锁住的代码会执行多久时，应该首选互斥锁 对于 99% 的线程级互斥锁而言，阻塞都是由操作系统内核实现的 线程获取锁失败时，增加了两次上","title":"锁"},{"content":"无论基于多进程还是多线程，都难以实现高并发，这由两个原因所致\n单个线程消耗的内存过多，比如，64 位的 Linux 为每个线程的栈分配了 8MB 的内存，还预分配了 64MB 的内存作为堆内存池 切换请求是内核通过切换线程实现的，什么时候会切换线程呢？不只时间片用尽，当调用阻塞方法时，内核为了让 CPU 充分工作，也会切换到其他线程执行。一次 上下文切换的成本在几十纳秒到几微秒间，当线程繁忙且数量众多时，这些切换会消耗绝大部分的 CPU 运算能力。(不能充分利用时间片) 使用异步实现高并发 多线程中使用阻塞方法读磁盘，2 个线程间的切换方式。\n怎么才能实现高并发呢？把上图中本来由内核实现的请求切换工作，交由用户态的代码来完成就可以了\n下图描述了异步 IO 的非阻塞读和异步框架结合后，是如何切换请求的。\n写异步化代码很容易出错。因为所有阻塞函数，都需要通过非阻塞的系统调用拆分成两个函数。虽然这两个函数共同完成一个功能，但调用方式却不同。第一个函数由 你显式调用，第二个函数则由多路复用机制调用。这种方式违反了软件工程的内聚性原则，函数间同步数据也更复杂。特别是条件分支众多、涉及大量系统调用时，异 步化的改造工作会非常困难。\n使用协程实现高并发 协程与异步编程相似的地方在于，它们必须使用非阻塞的系统调用与内核交互，把切换请求的权力牢牢掌握在用户态的代码中。但不同的地方在于，协程把异步化中的两段函数，封装为一个阻塞的协程函数。这个函数执行时，会使调用它的协程无感知地放弃执行权，由协程框架切换到其他就绪的协程继续执行。当这个函数的结果满足后，协程框架再选择合适的时机，切换回它所在的协程继续执行。\n用户态的代码切换协程，与内核切换线程的原理是一样的\n每个线程有独立的栈，而栈既保留了变量的值，也保留了函数的调用关系、参数和返回值，CPU 中的栈寄存器 SP 指向了当前线程的栈，而指令寄存器 IP 保存着下 一条要执行的指令地址。因此，从线程 1 切换到线程 2 时，首先要把 SP、IP 寄存器的值为线程 1 保存下来，再从内存中找出线程 2 上一次切换前保存好的寄 存器值，写入 CPU 的寄存器，这样就完成了线程切换。\n从协程 1 切换到协程 2 后的状态\n协程栈的大小通常只有几十 KB, 栈缩小后，就尽量不要使用递归函数，也不能在栈中申请过多的内存，这是实现高并发必须付出的代价。\n协程的高性能，建立在切换必须由用户态代码完成之上，这要求协程生态是完整的，要尽量覆盖常见的组件。\n协程必须重新封装所有的阻塞系统调用，否则，一旦协程触发了线程切换，会导致这个线程进入休眠状态，进而其上的所有协程都得不到执行。 面对多核系统，也需要协程与线程配合工作。因为协程的载体是线程，而一个线程同一时间只能使用一颗 CPU，所以通过开启更多的线程，将所有协程分布在这些线程 中，就能充分使用 CPU 资源。\n为了让协程获得更多的 CPU 时间，还可以设置所在线程的优先级，比如 Linux 下把线程的优先级设置到 -20，就可以每次获得更长的时间片。\n为了减少 CPU 缓存失效的比例，还可以把线程绑定到某个 CPU 上，增加协程执行时命中 CPU 缓存的机率。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/%E5%8D%8F%E7%A8%8B/","summary":"无论基于多进程还是多线程，都难以实现高并发，这由两个原因所致 单个线程消耗的内存过多，比如，64 位的 Linux 为每个线程的栈分配了 8MB 的内存，还预分配了","title":"协程"},{"content":"原文\n你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：\n1 $ ethtool -k eth0 | grep scatter-gather scatter-gather: on ","permalink":"https://jdxj.github.io/posts/articles/zhihu/dma/","summary":"原文 你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性： 1 $ ethtool -k eth0 | grep scatter-gather scatter-gather: on","title":"DMA零拷贝技术"},{"content":"// todo: 用go整一个\n在内核态和用户态之间来回切换\n要想提升传输文件的性能，需要从降低上下文切换的频率和内存拷贝次数两个方向入手。\n零拷贝如何提升文件传输性能？ 如果想减少上下文切换次数，就一定要减少系统调用的次数。解决方案就是把 read、write 两次系统调用合并成一次，在内核中完成磁盘与网卡的数据交换。 如果内核在读取文件后，直接把 PageCache中的内容拷贝到Socket 缓冲区，待到网卡发送完毕后，再通知进程，这样就只有2次上下文切换，和 3次内存拷贝。 如果网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术，还可以再去除 Socket 缓冲区的拷贝，这样一共只有 2 次内存拷贝。\n用户缓冲区为什么不与 socket 缓冲区大小一致呢？这是因为，socket 缓冲区的可用空间是动态变化的，它既用于 TCP 滑动窗口，也用于应用缓冲区，还受到 整个系统内存的影响\n零拷贝使我们不必关心 socket 缓冲区的大小。\n零拷贝还使用了 PageCache 技术，通过它，零拷贝可以进一步提升性能\nPageCache，磁盘高速缓存 为什么要把磁盘文件读到内存中?\n由于磁盘比内存的速度慢许多，所以我们应该想办法把读写磁盘替换成读写内存 读取磁盘数据时，需要先找到数据所在的位置，对于机械磁盘来说，就是旋转磁头到数据所在的扇区，再开始顺序读取数据。其中，旋转磁头耗时很长，为了降低它 的影响，PageCache 使用了预读功能。 高并发场景下，为了防止 PageCache 被大文件占满后不再对小文件产生作用，大文件不应使用 PageCache，进而也不应使用零拷贝技术处理。\n异步 IO + 直接 IO 高并发场景处理大文件时，应当使用异步 IO 和直接 IO 来替换零拷贝技术。\n// todo: go中怎么实现?\n当调用 read 方法读取文件时，实际上 read 方法会在磁盘寻址过程中阻塞等待，导致进程无法并发地处理其他任务\n异步 IO（异步 IO 既可以处理网络 IO，也可以处理磁盘 IO，这里我们只关注磁盘 IO）可以解决阻塞问题。它把读操作分为两部分\n前半部分向内核发起读请求，但不等待数据就位就立刻返回，此时进程可以并发地处理其他任务。 当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的通知，再去处理数据，这是异步 IO 的后半部分。 异步 IO 并没有拷贝到 PageCache 中，这其实是异步 IO 实现上的缺陷。经过 PageCache 的 IO 我们称为缓存 IO，它与虚拟内存系统耦合太紧，导致异步 IO 从诞生起到现在都不支持缓存 IO。\n绕过 PageCache 的 IO 是个新物种，我们把它称为直接 IO。对于磁盘，异步 IO 只支持直接 IO。\n有了直接 IO 后，异步 IO 就可以无阻塞地读取文件了。现在，大文件由异步 IO 和直接 IO 处理，小文件则交由零拷贝处理，至于判断文件大小的阈值可以灵活 配置（参见 Nginx 的 directio 指令）。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/%E9%9B%B6%E6%8B%B7%E8%B4%9D/","summary":"// todo: 用go整一个 在内核态和用户态之间来回切换 要想提升传输文件的性能，需要从降低上下文切换的频率和内存拷贝次数两个方向入手。 零拷贝如何提升文件","title":"零拷贝"},{"content":"索引有很多，哈希表、红黑树、B 树都可以在内存中使用，如果我们需要数据规模上亿后还能提供微秒级的访问速度，那么作为最快的索引，哈希表是第一选择。\n不考虑范围查询与遍历操作，在追求最快速度的条件下，哈希表是最好的选择。\n用哈希表有效地管理亿级数据 冲突 链接法虽然实现简单，还允许存放元素个数大于数组的大小（也叫装载因子大于 1），但链接法序列化数据的代价很大，因为使用了指针后，内存是不连续的。 开放寻址法确保所有对象都在数组里，就可以把数组用到的这段连续内存原地映射到文件中 如何序列化哈希表以外的数据 如果能将数据完整的放进数组，那么开放寻址法已经解决了序列化问题，所以我们应该选择开放寻址法。\n但是，有两个因素使得我们必须把数据放在哈希桶之外：\n每条数据有上百字节 哈希表中一定会有很多空桶（没有存放数据）。空桶的比例越高（装载因子越小），冲突概率也会越低，但如果每个空桶都占用上百字节，亿级规模会轻松把浪费的 内存放大许多倍。 数据的长度是固定的\n数据的长度并不固定\n降低哈希表的冲突概率 调优哈希函数 扩容 什么是好的哈希函数\n计算量不能大 尽量降低冲突概率 当哈希函数把高信息量的关键字压缩成更小的数组下标时，一定会丢失信息。我们希望只丢失一些无关紧要的信息，尽量多地保留区分度高的信息。这需要分析关键字 的特点、分布规律。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/%E7%B4%A2%E5%BC%95/","summary":"索引有很多，哈希表、红黑树、B 树都可以在内存中使用，如果我们需要数据规模上亿后还能提供微秒级的访问速度，那么作为最快的索引，哈希表是第一选择","title":"索引"},{"content":"内存申请流程\n几乎所有程序都在使用 C 库内存池分配出的内存。C 库内存池影响着系统下依赖它的所有进程。\n// todo: go 如何向系统申请内存?\n选择 Ptmalloc2 还是 TCMalloc？ Ptmalloc2 假定，如果线程 A 申请并释放了的内存，线程 B 可能也会申请类似的内存，所以它允许内存池在线程间复用以提升性能。\n分配内存时要加锁 当应用场景涉及大量的并发线程时，换成 TCMalloc 库也更有优势！ Ptmalloc2 更擅长大内存的分配。 TCMalloc 特意针对小内存做了优化,\nTCMalloc 把内存分为 3 个档次，小于等于 256KB 的称为小内存，从 256KB 到 1M 称为中等内存，大于 1MB 的叫做大内存。TCMalloc 对中等内存、大 内存的分配速度很慢 为什么从栈中分配内存会更快 由于每个线程都有独立的栈，所以分配内存时不需要加锁保护，而且栈上对象的尺寸在编译阶段就已经写入可执行文件了，执行效率更高！性能至上的 Golang 语言 就是按照这个逻辑设计的，即使你用 new 关键字分配了堆内存，但编译器如果认为在栈中分配不影响功能语义时，会自动改为在栈中分配。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","summary":"内存申请流程 几乎所有程序都在使用 C 库内存池分配出的内存。C 库内存池影响着系统下依赖它的所有进程。 // todo: go 如何向系统申请内存? 选择 Ptmalloc2 还是 TCMa","title":"内存分配"},{"content":"三级缓存要比一、二级缓存大许多倍，这是因为当下的 CPU 都是多核心的，每个核心都有自己的一、二级缓存，但三级缓存却是一颗 CPU 上所有核心共享的。\nCPU 会区别对待指令与数据, 要分开来看二者的缓存命中率\nCPU Cache Line 定义了缓存一次载入数据的大小\n1 2 3 4 # 查看缓存大小 $ cat /sys/devices/system/cpu/cpu0/cache/index0/size # 查看cache line大小 $ cat /sys/devices/system/cpu/cpu0/cache/index1/coherency_line_size 提升数据缓存命中率\n按照内存布局顺序访问将会带来很大的性能提升。 哈希表里桶的大小如 server_names_hash_bucket_size，它默认就等于 CPU Cache Line 的值, 可以尽量减少访问内存的次数 提升指令缓存的命中率\n在循环中连续走同一分支 提升多核 CPU 下的缓存命中率\n操作系统提供了将进程或者线程绑定到某一颗 CPU 上运行的能力 (避免切换到其他核心时导致的缓存不中问题) 结论 CPU 缓存分为数据缓存与指令缓存，对于数据缓存，我们应在循环体中尽量操作同一块内存上的数据，由于缓存是根据 CPU Cache Line 批量操作数据的，所以顺 序地操作连续内存数据时也有性能提升。\n对于指令缓存，有规律的条件分支能够让 CPU 的分支预测发挥作用，进一步提升执行效率。对于多核系统，如果进程的缓存命中率非常高，则可以考虑绑定 CPU 来 提升缓存命中率。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/cpu%E7%BC%93%E5%AD%98/","summary":"三级缓存要比一、二级缓存大许多倍，这是因为当下的 CPU 都是多核心的，每个核心都有自己的一、二级缓存，但三级缓存却是一颗 CPU 上所有核心共享的。 CPU 会区","title":"CPU缓存"},{"content":"原文\n聚合\n让实体和值对象协同工作的组织就是聚合, 它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。 聚合根\n如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。首先它作为实体本身，拥有实体的属性和业务行 为，实现自身的业务逻辑。其次它作为聚合的管理者，在聚合内部负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑。 ","permalink":"https://jdxj.github.io/posts/articles/cnblogs/courage129/ddd%E8%81%9A%E5%90%88/","summary":"原文 聚合 让实体和值对象协同工作的组织就是聚合, 它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。 聚合根 如果把聚合比作组织，那","title":"DDD中聚合、聚合根的含义以及作用"},{"content":"原文\n实体 实体拥有唯一标识符, 且标识符在经历过各种状态变更后仍能保持一致。对这些对象而言, 重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至 超出软件的生命周期。\n值对象 值对象本质上就是一个集合, 集合里面有什么呢？若干个用于描述目的、具有整体概念和不可修改的属性。那这个集合存在的意义又是什么？在领域建模的过程中，值 对象可以保证属性归类的清晰和概念的完整性，避免属性零碎。\n地址 ","permalink":"https://jdxj.github.io/posts/articles/cnblogs/courage129/ddd%E4%B8%AD%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%80%BC%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84/","summary":"原文 实体 实体拥有唯一标识符, 且标识符在经历过各种状态变更后仍能保持一致。对这些对象而言, 重要的不是其属性，而是其延续性和标识，对象的延续性和","title":"DDD中实体与值对象是干什么的"},{"content":"原文\n通用语言确定了项目团队内部交流的统一语言，而这个语言所在的语义环境则是由限界上下文来限定的，以确保语义的唯一性。而领域专家、架构师和开发人员的主要 工作就是通过事件风暴来划分限界上下文。限界上下文确定了微服务的设计和拆分方向，是微服务设计和拆分的主要依据。如果不考虑技术异构、团队沟通等其它外部 因素，一个限界上下文理论上就可以设计为一个微服务。\n","permalink":"https://jdxj.github.io/posts/articles/cnblogs/courage129/ddd%E4%B8%AD%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E9%80%9A%E7%94%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BD%9C%E7%94%A8/","summary":"原文 通用语言确定了项目团队内部交流的统一语言，而这个语言所在的语义环境则是由限界上下文来限定的，以确保语义的唯一性。而领域专家、架构师和开发","title":"DDD中限界上下文与通用语言的作用"},{"content":"原文\n核心域、支撑域和通用域的主要目标是：通过领域划分，区分不同子域在公司内的不同功能属性和重要性，从而公司可对不同子域采取不同的资源投入和建设策略，其 关注度也会不一样。\n","permalink":"https://jdxj.github.io/posts/articles/cnblogs/courage129/ddd%E5%88%92%E5%88%86%E9%A2%86%E5%9F%9F/","summary":"原文 核心域、支撑域和通用域的主要目标是：通过领域划分，区分不同子域在公司内的不同功能属性和重要性，从而公司可对不同子域采取不同的资源投入和建","title":"DDD划分领域、子域、核心域、支撑域的目的"},{"content":"1.1 什么是复杂系统 由大量相互作用的部分组成的系统。与整个系统比起来，这些组成部分相对简单，没有中央控制，组成部分之间也没有全局性的通信，并且组成部分的相互作用导致了 复杂行为。\nJurgen Appelo从理解能力与预测能力两个维度分析了复杂度的成因\n理解能力维度——简单的(simple)和复杂的(complicated)； 预测能力维度——有序的(ordered)、复杂的(complex)和混沌的(chaotic)。 图1-1 复杂系统的特征\n软件系统的“复杂”同时覆盖了“复杂难解”(complicated)与“复杂难测”(complex)两个层面，对标图1-1给出的案例，就是一座城市的复杂特征。\n1.2 理解能力 1.2.1 规模 系统的规模取决于\n需求的数量 需求之间的关系 软件开发的拥堵现象或许更严重\n函数存在副作用，调用时可能对函数的结果做了隐含的假设； 类的职责繁多，导致开发人员不敢轻易修改，因为不知会影响到哪些模块； 热点代码被频繁变更，职责被包裹了一层又一层，没有清晰的边界； 在系统某个角落，隐藏着伺机而动的bug，当诱发条件具备时，就会让整条调用链瘫痪； 不同的业务场景包含了不同的例外场景，每种例外场景的处理方式都各不相同； 同步处理代码与异步处理代码纠缠在一起，不可预知程序执行的顺序。 随着软件系统规模的扩张，软件复杂度以指数级增长.\n软件之所以无法躲避熵的重击，源于我们在构建软件时无法避免技术债(technical debt). 对付技术债的唯一方案就是尽量让它可见，例如通过技术债列表或者技 术债雷达等可视化形式及时呈现给团队成员，并制订计划主动地消除或降低技术债。\n在面向对象设计的软件项目里，除了代码行数，包、类、方法的数量，继承的层次以及方法的调用数，还有我们常常提及的圈复杂度，都会或多或少地影响整个软件系 统的规模。\n1.2.2 结构 结构之所以变得复杂，多数情况下还是由系统的质量属性(quality attribute)决定\n需要满足高性能、高并发的需求，就需要考虑在系统中引入缓存、并行处理、CDN、异步消息以及支持分区的可伸缩结构； 需要支持对海量数据的高效分析，就得考虑这些海量数据该如何分布存储，并如何有效地利用各个节点的内存与CPU资源执行运算。 分解的软件元素, 怎么协同，怎么通信，就成了系统分解后面临的主要问题。\n软件系统的结构繁复还会增加软件组织的复杂度。系统架构的分解促成了软件构建工作的分工，这种分工虽然使得高效的并行开发成为可能，却也可能因为沟通成本的 增加为管理带来挑战。\n康威定律(Conway’s law)就指出：“任何组织在设计一套系统（广义概念上的系统）时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。”\n这里的\u0026quot;组织\u0026quot;是指开发系统的组织, 而不是使用系统的组织 无论设计是优雅还是拙劣，系统结构都可能因为某种设计权衡而变得复杂。唯一的区别在于前者是主动地控制结构的复杂度，而后者带来的复杂度是偶发的，是错误的 滋生，是一种技术债，它会随着系统规模的增大产生一种无序设计。\n无序设计系统的几种警告信号\n代码没有显而易见的进入系统中的路径； 不存在一致性，不存在风格，也没有能够将不同的部分组织在一起的统一概念； 系统中的控制流让人觉得不舒服，无法预测； 系统中有太多的“坏味道”； 数据很少放在它被使用的地方，经常引入额外的巴洛克式缓存层，试图让数据停留在更方便的地方。 分层架构的引入原本是为了维护系统的有序性，而如果团队却不注意维护逻辑分层确定的边界，不按照架构规定的层次分配各个类的职责，就会随着职责的乱入让逻辑 分层形成的边界变得越来越模糊。\n1.3 预测能力 影响预测能力的关键要素在于变化。对变化的应对不妥，就会导致过度设计或设计不足。\n","permalink":"https://jdxj.github.io/posts/books/%E8%A7%A3%E6%9E%84%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%BC%80%E7%AF%87/%E7%AC%AC1%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%89%96%E6%9E%90/","summary":"1.1 什么是复杂系统 由大量相互作用的部分组成的系统。与整个系统比起来，这些组成部分相对简单，没有中央控制，组成部分之间也没有全局性的通信，并且组","title":"第1章 软件复杂度剖析"},{"content":"原文\n1 2 3 4 5 6 7 8 unsigned popcnt(unsigned x) { unsigned diff = x; while (x) { x \u0026gt;\u0026gt;= 1; diff -= x; } return diff; } ","permalink":"https://jdxj.github.io/posts/articles/robalni/counting-set-bits-in-an-interesting-way/","summary":"原文 1 2 3 4 5 6 7 8 unsigned popcnt(unsigned x) { unsigned diff = x; while (x) { x \u0026gt;\u0026gt;= 1; diff -= x; } return diff; }","title":"Counting Set Bits in an Interesting Way"},{"content":"原文\nTimeouts Client timeouts 1 2 3 4 5 6 7 8 9 10 c := \u0026amp;http.Client{ Timeout: 5 * time.Second, Transport: \u0026amp;http.Transport{ DialContext: (\u0026amp;net.Dialer{ // This is the TCP connect timeout in this instance. Timeout: 2500 * time.Millisecond, }).DialContext, TLSHandshakeTimeout: 2500 * time.Millisecond, }, } Server timeouts 1 2 3 4 s := \u0026amp;http.Server{ ReadTimeout: 2500 * time.Millisecond, WriteTimeout: 5 * time.Second, } HTTP Response Bodies 1 2 3 4 5 6 res, err := client.Do(req) if err != nil { return err } defer res.Body.Close() ... 1 _, err := io.Copy(ioutil.Discard, res.Body) HTTP/1.x Keep-alives 不重用连接的方式\n1 2 3 4 5 client := \u0026amp;http.Client{ \u0026amp;http.Transport{ DisableKeepAlives: true } } 1 req.Close = true 1 req.Header.Add(\u0026#34;Connection\u0026#34;, \u0026#34;close\u0026#34;) Connection Pooling 1 2 3 4 5 6 var DefaultTransport RoundTripper = \u0026amp;Transport{ MaxIdleConns: 100, IdleConnTimeout: 90 * time.Second, } ... const DefaultMaxIdleConnsPerHost = 2 ","permalink":"https://jdxj.github.io/posts/articles/baillie/gotchas-in-the-go-network-packages-defaults/","summary":"原文 Timeouts Client timeouts 1 2 3 4 5 6 7 8 9 10 c := \u0026amp;http.Client{ Timeout: 5 * time.Second, Transport: \u0026amp;http.Transport{ DialContext: (\u0026amp;net.Dialer{ // This is the TCP connect timeout in this instance. Timeout: 2500 * time.Millisecond, }).DialContext, TLSHandshakeTimeout: 2500 * time.Millisecond, }, } Server timeouts 1 2 3 4 s := \u0026amp;http.Server{ ReadTimeout: 2500 * time.Millisecond, WriteTimeout: 5 * time.Second, } HTTP Response Bodies 1 2","title":"Gotchas in the Go Network Packages Defaults"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/earthly/encrypting-data-with-ssh-keys-and-golang/","summary":"原文","title":"Encrypting Data With SSH Keys and Golang"},{"content":"原文\nWrite()为了性能使用异步方式, 操作系统同步数据到磁盘的一个时机在Close(), 如果不捕获可能造成数据丢失.\n安全的Close\n1 2 3 4 5 6 7 8 9 10 11 12 13 func helloNotes() error { f, err := os.Create(\u0026#34;/home/joeshaw/notes.txt\u0026#34;) if err != nil { return err } defer f.Close() if err = io.WriteString(f, \u0026#34;hello world\u0026#34;); err != nil { return err } return f.Sync() } ","permalink":"https://jdxj.github.io/posts/articles/joeshaw/dont-defer-close-on-writable-files/","summary":"原文 Write()为了性能使用异步方式, 操作系统同步数据到磁盘的一个时机在Close(), 如果不捕获可能造成数据丢失. 安全的Close 1 2 3","title":"Don't defer Close() on writable files"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/ip/icmp/","summary":"","title":"ICMP"},{"content":"三种工作模式\nnat工作模式 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/ip/lvs/","summary":"三种工作模式 nat工作模式","title":"LVS"},{"content":" nat napt 双向nat nat性能不好\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/ip/nat/","summary":"nat napt 双向nat nat性能不好","title":"Nat/Napt"},{"content":"检查本地缓存\n1 $ arp -nv ","permalink":"https://jdxj.github.io/posts/articles/jdxj/ip/arp/","summary":"2.5层协议","title":"ARP/RARP"},{"content":" 功能 ip寻址 选路 封装打包 分片 如何传输ip报文 直接传输 本地网络间接传输 内部选路协议 RIP OSPF 公网间接传输 外部选路协议 BGP 路由表\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/ip/ip/","summary":"功能 ip寻址 选路 封装打包 分片 如何传输ip报文 直接传输 本地网络间接传输 内部选路协议 RIP OSPF 公网间接传输 外部选路协议 BGP 路由表","title":"网络层"},{"content":" 发送心跳周期 net.ipv4.tcp_keepalive_time = 7200 7200s 没数据交互时, 启动探测 探测包发送间隔 net.ipv4.tcp_keepalive_intvl = 75 探测包重试次数 net.ipv4.tcp_keepalive_probes = 9 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-keep-alive/","summary":"发送心跳周期 net.ipv4.tcp_keepalive_time = 7200 7200s 没数据交互时, 启动探测 探测包发送间隔 net.ipv4.tcp_keepalive_intvl = 75 探测包重试次数 net.ipv4.tcp_keepalive_probes = 9","title":"TCP Keep Alive"},{"content":"net.ipv4.tcp_tw_reuse = 1\n开启后, 作为客户端时新连接可以使用仍然处于TIME-WAIT状态的端口 由于timestamp的存在, 操作系统可以拒绝迟到的报文, net.ipv4.tcp_timestamps = 1 net.ipv4.tcp_tw_recycle = 0\n开启后, 同时作为客户端和服务器都可以使用TIME-WAIT状态的端口 不安全, 无法避免报文延迟, 重复等给新连接造成混乱 net.ipv4.tcp_max_tw_buckets = 262144\ntime_wait状态连接的最大数量 超出后直接关闭连接 close 函数会让连接变为孤儿连接，shutdown 函数则允许在半关闭的连接上长时间传输数据。\n四次挥手的流程 为什么建立连接是三次握手，而关闭连接需要四次挥手呢？\nTCP 不允许连接处于半打开状态时就单向传输数据，所以在三次握手建立连接时，服务器会把 ACK 和 SYN 放在一起发给客户端 其中，ACK 用来打开客户端的发送通道，SYN 用来打开服务器的发送通道。这样，原本的四次握手就降为三次握手了。 当连接处于半关闭状态时，TCP 是允许单向传输数据的。\n主动方的优化 安全关闭连接的方式必须通过四次挥手，它由进程调用 close 或者 shutdown 函数发起，这二者都会向对方发送 FIN 报文（shutdown 参数须传入 SHUT_WR 或者 SHUT_RDWR 才会发送 FIN），区别在于 close 调用后，哪怕对方在半关闭状态下发送的数据到达主动方，进程也无法接收。(孤儿连接)\n主动方发送 FIN 报文后，连接就处于 FIN_WAIT1 状态下，该状态通常应在数十毫秒内转为 FIN_WAIT2。只有迟迟收不到对方返回的 ACK 时，才能用 netstat 命令观察到 FIN_WAIT1 状态。此时，内核会定时重发 FIN 报文，其中重发次数由 tcp_orphan_retries 参数控制（注意，orphan 虽然是孤儿的 意思，该参数却不只对孤儿连接有效，事实上，它对所有 FIN_WAIT1 状态下的连接都有效），默认值是 0，特指 8 次：\nnet.ipv4.tcp_orphan_retries = 0 如果 FIN_WAIT1 状态连接有很多，你就需要考虑降低 tcp_orphan_retries 的值。当重试次数达到 tcp_orphan_retries 时，连接就会直接关闭掉。\n对于正常情况来说，调低 tcp_orphan_retries 已经够用，但如果遇到恶意攻击，FIN 报文根本无法发送出去。这是由 TCP 的 2 个特性导致的。\n首先，TCP 必须保证报文是有序发送的，FIN 报文也不例外，当发送缓冲区还有数据没发送时，FIN 报文也不能提前发送。 其次，TCP 有流控功能，当接收方将接收窗口设为 0 时，发送方就不能再发送数据。所以，当攻击者下载大文件时，就可以通过将接收窗口设为 0，导致 FIN 报文无法发送，进而导致连接一直处于 FIN_WAIT1 状态。 tcp_max_orphans 定义了孤儿连接的最大数量。当进程调用 close 函数关闭连接后，无论该连接是在 FIN_WAIT1 状态，还是确实关闭了，这个连接都与该进 程无关了，它变成了孤儿连接。Linux 系统为防止孤儿连接过多，导致系统资源长期被占用，就提供了 tcp_max_orphans 参数。如果孤儿连接数量大于它，新增 的孤儿连接将不再走四次挥手，而是直接发送 RST 复位报文强制关闭。\n当连接收到 ACK 进入 FIN_WAIT2 状态后，就表示主动方的发送通道已经关闭，接下来将等待对方发送 FIN 报文，关闭对方的发送通道。这时，如果连接是用 shutdown 函数关闭的，连接可以一直处于 FIN_WAIT2 状态。但对于 close 函数关闭的孤儿连接，这个状态不可以持续太久，而 tcp_fin_timeout 控制了 这个状态下连接的持续时长。\nnet.ipv4.tcp_fin_timeout = 60 保留 TIME_WAIT 状态，就可以应付重发的 FIN 报文，当然，其他数据报文也有可能重发，所以 TIME_WAIT 状态还能避免数据错乱。\n为什么是 2 MSL 的时长呢？这其实是相当于至少允许报文丢失一次。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达， TIME_WAIT 状态的连接可以应对。为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这 个概率实在是太小了，忽略它比解决它更具性价比。\nTIME_WAIT 和 FIN_WAIT2 状态的最大时长都是 2 MSL，由于在 Linux 系统中，MSL 的值固定为 30 秒，所以它们都是 60 秒。\nLinux 提供了 tcp_max_tw_buckets 参数，当 TIME_WAIT 的连接数量超过该参数时，新关闭的连接就不再经历 TIME_WAIT 而直接关闭。\nnet.ipv4.tcp_max_tw_buckets = 5000 果服务器会主动向上游服务器发起连接的话，就可以把 tcp_tw_reuse 参数设置为 1，它允许作为客户端的新连接，在安全条件下使用 TIME_WAIT 状态下的端口。\nnet.ipv4.tcp_tw_reuse = 1 要想使 tcp_tw_reuse 生效，还得把 timestamps 参数设置为 1，它满足安全复用的先决条件（对方也要打开 tcp_timestamps ）：\nnet.ipv4.tcp_timestamps = 1 老版本的 Linux 还提供了 tcp_tw_recycle 参数，它并不要求 TIME_WAIT 状态存在 60 秒，很容易导致数据错乱，不建议设置为 1。\n所以在 Linux 4.12 版本后，直接取消了这一参数。 net.ipv4.tcp_tw_recycle = 0 被动方的优化 内核没有权力替代进程去关闭连接，因为若主动方是通过 shutdown 关闭连接，那么它就是想在半关闭连接上接收数据。因此，Linux 并没有限制 CLOSE_WAIT 状态的持续时间。\n由于 CLOSE_WAIT 状态下，连接已经处于半关闭状态，所以此时进程若要关闭连接，只能调用 close 函数（再调用 shutdown 关闭单向通道就没有意义了）， 内核就会发出 FIN 报文关闭发送通道，同时连接进入 LAST_ACK 状态，等待主动方返回 ACK 来确认连接关闭。\n如果被动方迅速调用 close 函数，那么被动方的 ACK 和 FIN 有可能在一个报文中发送，这样看起来，四次挥手会变成三次挥手，这只是一种特殊情况，不用在意。\n连接双方同时关闭连接 双方在等待 ACK 报文的过程中，都等来了 FIN 报文。这是一种新情况，所以连接会进入一种叫做 CLOSING 的新状态，它替代了 FIN_WAIT2 状态。此时，内核 回复 ACK 确认对方发送通道的关闭，仅己方的 FIN 报文对应的 ACK 还没有收到。所以，CLOSING 状态与 LAST_ACK 状态下的连接很相似，它会在适时重发 FIN 报文的情况下最终关闭。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp%E5%88%86%E6%89%8B%E4%BC%98%E5%8C%96/","summary":"net.ipv4.tcp_tw_reuse = 1 开启后, 作为客户端时新连接可以使用仍然处于TIME-WAIT状态的端口 由于timestamp的存在, 操作系统可以拒绝迟到的报文, net.ipv4.tcp_timestamps = 1","title":"TCP分手优化"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E4%B8%8D%E5%BB%BA%E8%AE%AE%E5%BC%80%E5%90%AFtfo/","summary":"原文","title":"不建议开启tcp fast open功能"},{"content":" 延长syn, accept队列 应用层connect超时时间 操作系统内核 服务器端syn_rcv状态 net.ipv4.tcp_max_syn_backlog: syn_rcvd状态连接的最大个数 net.ipv4.tcp_synack_retries: 被动建立连接时, 发syn/ack的重试次数 客户端syn_ent状态 net.ipv4.tcp_syn_retries = 6 主动建立连接时, 发syn的重试次数 net.ipv4.ip_local_port_range = 32768 60999 建立连接时的本地端口可用范围 accept队列设置 Fast Open降低时延 TFO\nLinux上打开TFO\nnet.ipv4.tcp_fastopen\n0: 关闭 1: 作为客户端时可以使用TFO 2: 作为服务器时可以使用TFO 3: 无论作为客户端还是服务器, 都可以使用TFO TCP_DEFER_ACCEPT 服务端收到客户端发来的数据后才唤醒阻塞在accept()的应用\n客户端的优化 三次握手建立连接的首要目的是同步序列号。只有同步了序列号才有可靠的传输，TCP 协议的许多特性都是依赖序列号实现的，比如流量控制、消息丢失后的重发等等\n客户端在等待服务器回复的 ACK 报文。正常情况下，服务器会在几毫秒内返回 ACK，但如果客户端迟迟没有收到 ACK 会怎么样呢？客户端会重发 SYN，重试的次 数由 tcp_syn_retries 参数控制，默认是 6 次：\nnet.ipv4.tcp_syn_retries = 6 第 1 次重试发生在 1 秒钟后，接着会以翻倍的方式在第 2、4、8、16、32 秒共做 6 次重试，最后一次重试会等待 64 秒，如果仍然没有返回 ACK，才会终止 三次握手。所以，总耗时是 1+2+4+8+16+32+64=127 秒，超过 2 分钟。\n如果这是一台有明确任务的服务器，你可以根据网络的稳定性和目标服务器的繁忙程度修改重试次数，调整客户端的三次握手时间上限。比如内网中通讯时，就可以适 当调低重试次数，尽快把错误暴露给应用程序。\n服务器端的优化 当服务器收到 SYN 报文后，服务器会立刻回复 SYN+ACK 报文，既确认了客户端的序列号，也把自己的序列号发给了对方。此时，服务器端出现了新连接，状态是 SYN_RCV（RCV 是 received 的缩写）。这个状态下，服务器必须建立一个 SYN 半连接队列来维护未完成的握手信息，当这个队列溢出后，服务器将无法再建立 新连接。\n获得由于队列已满而引发的失败次数\n1 2 3 # 是一个累积值 $ netstat -s | grep \u0026#34;SYNs to LISTEN\u0026#34; 1192450 SYNs to LISTEN sockets dropped 如果数值在持续增加，则应该调大 SYN 半连接队列\nnet.ipv4.tcp_max_syn_backlog = 1024 开启 syncookies 功能就可以在不使用 SYN 队列的情况下成功建立连接\n修改 tcp_syncookies\n0表示关闭该功能 2表示无条件开启功能 1则表示仅当 SYN 半连接队列放不下时，再启用它。 由于 syncookie 仅用于应对 SYN 泛洪攻击（攻击者恶意构造大量的 SYN 报文发送给服务器，造成 SYN 半连接队列溢出，导致正常客户端的连接无法建立）， 这种方式建立的连接，许多 TCP 特性都无法使用。所以，应当把tcp_syncookies设置为1，仅在队列满时再启用。\nnet.ipv4.tcp_syncookies = 1 如果服务器没有收到 ACK，就会一直重发 SYN+ACK 报文。当网络繁忙、不稳定时，报文丢失就会变严重，此时应该调大重发次数。反之则可以调小重发次数。修改 重发次数的方法是，调整 tcp_synack_retries 参数：\nnet.ipv4.tcp_synack_retries = 5 服务器收到 ACK 后连接建立成功，此时，内核会把连接从 SYN 半连接队列中移出，再移入 accept 队列，等待进程调用 accept 函数时把连接取出来。如果进 程不能及时地调用 accept 函数，就会造成accept 队列溢出，最终导致建立好的 TCP 连接被丢弃。\n丢弃连接只是 Linux 的默认行为，我们还可以选择向客户端发送 RST 复位报文，告诉客户端连接已经建立失败。打开这一功能需要将 tcp_abort_on_overflow 参数设置为 1。\nnet.ipv4.tcp_abort_on_overflow = 0 通常情况下，应当把 tcp_abort_on_overflow 设置为 0，因为这样更有利于应对突发流量。 只有你非常肯定 accept 队列会长期溢出时，才能设置为 1 以尽快通知客户端。 listen 函数的 backlog 参数就可以设置 accept 队列的大小。事实上，backlog 参数还受限于 Linux 系统级的队列长度上限，当然这个上限阈值也可以通 过 somaxconn 参数修改。\nnet.core.somaxconn = 128 TFO 技术如何绕过三次握手？ 它把通讯分为两个阶段\n第一阶段为首次建立连接，这时走正常的三次握手，但在客户端的 SYN 报文会明确地告诉服务器它想使用 TFO 功能，这样服务器会把客户端 IP 地址用只有自 己知道的密钥加密（比如 AES 加密算法），作为 Cookie 携带在返回的 SYN+ACK 报文中，客户端收到后会将 Cookie 缓存在本地。 之后，如果客户端再次向服务器建立连接，就可以在第一个 SYN 报文中携带请求数据，同时还要附带缓存的 Cookie。很显然，这种通讯方式下不能再采用经典 的“先 connect 再 write 请求”这种编程方法，而要改用 sendto 或者 sendmsg 函数才能实现。 服务器收到后，会用自己的密钥验证 Cookie 是否合法，验证通过后连接才算建立成功，再把请求交给进程处理，同时给客户端返回 SYN+ACK。虽然客户端收到后 还会返回 ACK，但服务器不等收到 ACK 就可以发送 HTTP 响应了，这就减少了握手带来的 1 个 RTT 的时间消耗。\n由于只有客户端和服务器同时支持时，TFO 功能才能使用，所以 tcp_fastopen 参数是按比特位控制的。其中，第 1 个比特位为 1 时，表示作为客户端时支持 TFO；第 2 个比特位为 1 时，表示作为服务器时支持 TFO，所以当 tcp_fastopen 的值为 3 时（比特为 0x11）就表示完全支持 TFO 功能。\nnet.ipv4.tcp_fastopen = 3 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp%E6%8F%A1%E6%89%8B%E4%BC%98%E5%8C%96/","summary":"延长syn, accept队列 应用层connect超时时间 操作系统内核 服务器端syn_rcv状态 net.ipv4.tcp_max_syn_backlog: syn_rcvd状态连接的最大个数 net.ipv4.tcp_synack_retries: 被动建立","title":"TCP握手优化"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/ibm/berkeley-packet-filters/","summary":"原文","title":"Berkeley Packet Filters"},{"content":" -D 列举所有网卡设备\n-i 选择网卡设备\n-c 抓取多少条报文\n\u0026ndash;time-stamp-precision 指定捕获时的时间精度, 默认micro, 可选nano\n-s 指定每条报文的最大字节数, 默认262144B\n-w 输出结果至文件, 有格式字符\n-C 限制输出文件的大小\n-W 指定输出文件的最大数量\n-G 指定每隔N秒就重新输出至新文件\n-r 读取一个抓包文件\n-V 将待读取的多个文件名写入一个文件中, 通过读取该文件同时读取多个文件\n-t\n-tt\n-ttt\n-tttt\n-ttttt\n-e 显示数据链路层头部\n-q 不显示网络层信息\n-v 显示网络层头部更多的信息\n-n 显示ip地址, 数字端口代替hostname等\n-S tcp信息以绝对序列号替代相对序列号\n-A 以ascii方式显示报文内容\n-x 以16进制方式显示报文内容, 不显示数据链路层\n-xx 以16进制方式显示报文内容, 显示数据链路层\nX 同时以16进制及ascii方式显示报文内容, 不显示数据链路层\nXX 同时以16进制及ascii方式显示报文内容, 显示数据链路层\n1 2 3 4 5 # -i eth0 只抓取eth0网卡，-n不解析协议名和主机名 # tcp port 80表示只抓取tcp协议并且端口号为80的网络帧 $ tcpdump -i eth0 -n tcp port 80 15:11:32.678966 IP 192.168.0.2.18238 \u0026gt; 192.168.0.30.80: Flags [S], seq 458303614, win 512, length 0 ... ","permalink":"https://jdxj.github.io/posts/cmd/tcpdump/","summary":"-D 列举所有网卡设备 -i 选择网卡设备 -c 抓取多少条报文 \u0026ndash;time-stamp-precision 指定捕获时的时间精度, 默认micro, 可选nano -s 指定每条报文的最大字节数, 默认2621","title":"tcpdump"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/udp-header/","summary":"","title":"UDP Header"},{"content":"IPv4 Header IHL 头部长度, word(4byte) TL 总长度, byte Id 分片表示 Flags 分片控制 DF = 1 不能分片 MF = 1 中间分片 FO 分片内偏移, 8byte TTL 路由器跳数生存期 Protocol 承载协议 HC 校验和 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/ip/ip-header/","summary":"IPv4 Header IHL 头部长度, word(4byte) TL 总长度, byte Id 分片表示 Flags 分片控制 DF = 1 不能分片 MF = 1 中间分片 FO 分片内偏移, 8byte TTL 路由器跳数生存期 Protocol 承载协议 HC 校验和","title":"IP Header"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-ip%E5%88%86%E5%B1%82/","summary":"","title":"TCP/IP协议层"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/it-blog-cn/","summary":"主页","title":"程序员进阶"},{"content":"原文\nlisten的地址填:0\n","permalink":"https://jdxj.github.io/posts/articles/learnku/%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E7%AB%AF%E5%8F%A3/","summary":"原文 listen的地址填:0","title":"使用随机端口"},{"content":"原文\n更新缓存的的Design Pattern有四种：\nCache aside Read through Write through Write behind caching ","permalink":"https://jdxj.github.io/posts/articles/coolshell/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%A5%97%E8%B7%AF/","summary":"原文 更新缓存的的Design Pattern有四种： Cache aside Read through Write through Write behind caching","title":"缓存更新的套路"},{"content":"Trie 树，也叫“字典树”\nhow，hi，her，hello，so，see组成的trie树\n存储结构\n1 2 3 4 class TrieNode { char data; TrieNode children[26]; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class Trie { private TrieNode root = new TrieNode(\u0026#39;/\u0026#39;); // 存储无意义字符 // 往Trie树中插入一个字符串 public void insert(char[] text) { TrieNode p = root; for (int i = 0; i \u0026lt; text.length; ++i) { int index = text[i] - \u0026#39;a\u0026#39;; if (p.children[index] == null) { TrieNode newNode = new TrieNode(text[i]); p.children[index] = newNode; } p = p.children[index]; } p.isEndingChar = true; } // 在Trie树中查找一个字符串 public boolean find(char[] pattern) { TrieNode p = root; for (int i = 0; i \u0026lt; pattern.length; ++i) { int index = pattern[i] - \u0026#39;a\u0026#39;; if (p.children[index] == null) { return false; // 不存在pattern } p = p.children[index]; } if (p.isEndingChar == false) return false; // 不能完全匹配，只是前缀 else return true; // 找到pattern } public class TrieNode { public char data; public TrieNode[] children = new TrieNode[26]; public boolean isEndingChar = false; public TrieNode(char data) { this.data = data; } } } 构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)（n 表示所有字符串的长度和）。 在其中查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度。 这种用数组存储子节点的方式有点浪费内存\n假设我们用有序数组，数组中的指针按照所指向的子节点中的字符的大小顺序排列。查询的时候，我们可以通过二分查找的方法，快速查找到某个字符应该匹配的子 节点的指针。但是，在往 Trie 树中插入一个字符串的时候，我们为了维护数组中数据的有序性，就会稍微慢了点。 实际上，Trie 树的变体有很多，都可以在一定程度上解决内存消耗的问题。比如，缩点优化，就是对只有一个子节点的节点，而且此节点不是一个串的结束节点， 可以将此节点与子节点合并。这样可以节省空间，但却增加了编码难度。 Trie的要求 字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。 要求字符串的前缀重合比较多，不然空间消耗会变大很多。 如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样 做。 通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。 ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/trie%E6%A0%91/","summary":"Trie 树，也叫“字典树” how，hi，her，hello，so，see组成的trie树 存储结构 1 2 3 4 class TrieNode { char data; TrieNode children[26]; } 1 2 3 4 5 6 7 8 9 10 11 12 13","title":"Trie树"},{"content":" 顶点的度（degree），就是跟顶点相连接的边的条数。 在有向图中，我们把度分为入度（In-degree）和出度（Out-degree）。 在带权图中，每条边都有一个权重（weight） 邻接矩阵存储方法 Adjacency Matrix\n浪费空间, 使用起来比较节省时间 邻接表存储方法 Adjacency List\n图中画的是一个有向图的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点。\n省空间，但是使用起来就比较耗时间。 可以将邻接表中链表换为平衡二叉查找树/红黑树/排序再二分查找 广度优先搜索（Breadth-First-Search） 图的广度优先搜索的代码实现。其中 s 表示起始顶点，t 表示终止顶点。我们搜索一条从 s 到 t 的路径。实际上，这样求得的路径就是从 s 到 t 的最短路径。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public void bfs(int s, int t) { if (s == t) return; boolean[] visited = new boolean[v]; visited[s]=true; Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(s); int[] prev = new int[v]; for (int i = 0; i \u0026lt; v; ++i) { prev[i] = -1; } while (queue.size() != 0) { int w = queue.poll(); for (int i = 0; i \u0026lt; adj[w].size(); ++i) { int q = adj[w].get(i); if (!visited[q]) { prev[q] = w; if (q == t) { print(prev, s, t); return; } visited[q] = true; queue.add(q); } } } } private void print(int[] prev, int s, int t) { // 递归打印s-\u0026gt;t的路径 if (prev[t] != -1 \u0026amp;\u0026amp; t != s) { print(prev, s, prev[t]); } System.out.print(t + \u0026#34; \u0026#34;); } visited 是用来记录已经被访问的顶点，用来避免顶点被重复访问。 queue 是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。 prev 用来记录搜索路径。 广度优先搜索的时间复杂度也可以简写为 O(E)。 空间复杂度是 O(V)。 深度优先搜索（Depth-First-Search） 深度优先搜索找出来的路径，并不是顶点 s 到顶点 t 的最短路径。\n变量 found: 当我们已经找到终止顶点 t 之后，我们就不再递归地继续查找了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 boolean found = false; // 全局变量或者类成员变量 public void dfs(int s, int t) { found = false; boolean[] visited = new boolean[v]; int[] prev = new int[v]; for (int i = 0; i \u0026lt; v; ++i) { prev[i] = -1; } recurDfs(s, t, visited, prev); print(prev, s, t); } private void recurDfs(int w, int t, boolean[] visited, int[] prev) { if (found == true) return; visited[w] = true; if (w == t) { found = true; return; } for (int i = 0; i \u0026lt; adj[w].size(); ++i) { int q = adj[w].get(i); if (!visited[q]) { prev[q] = w; recurDfs(q, t, visited, prev); } } } 时间复杂度是 O(E) 空间复杂度就是 O(V) ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E5%9B%BE/","summary":"Graph","title":"图"},{"content":"堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法。\n堆是一个完全二叉树； 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 用数组存储堆的例子\n往堆中插入一个元素 删除堆顶元素 如何基于堆实现排序？ 建堆 建堆的时间复杂度就是 O(n)。 排序 原地 建堆O(n), 排序O(nlogN) 不稳定 为什么快速排序要比堆排序性能好？ 对 CPU 缓存是不友好的 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序 ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E5%A0%86/","summary":"堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法。 堆是一个完全二叉树； 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 用数组","title":"堆"},{"content":"一棵斐波那契数列的递归树\n归并排序递归树\n因为每次分解都是一分为二，所以代价很低，我们把时间上的消耗记作常量 1。 我们只需要知道这棵树的高度 h，用高度 h 乘以每一层的时间消耗 n，就可以得到总的时间复杂度 O(n∗h)。 从归并排序的原理和递归树，可以看出来，归并排序递归树是一棵满二叉树。 满二叉树的高度大约是 logN，所以，归并排序递归实现的时间复杂度就是 O(nlogN)。 ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%80%92%E5%BD%92%E6%A0%91/","summary":"一棵斐波那契数列的递归树 归并排序递归树 因为每次分解都是一分为二，所以代价很低，我们把时间上的消耗记作常量 1。 我们只需要知道这棵树的高度 h，用","title":"递归树"},{"content":" 链式存储法\n基于数组的顺序存储法\n左子节点: 2*i 右子节点: 2*i+1 遍历\n前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。 前序遍历的递推公式： preOrder(r) = print r-\u0026gt;preOrder(r-\u0026gt;left)-\u0026gt;preOrder(r-\u0026gt;right) 中序遍历的递推公式： inOrder(r) = inOrder(r-\u0026gt;left)-\u0026gt;print r-\u0026gt;inOrder(r-\u0026gt;right) 后序遍历的递推公式： postOrder(r) = postOrder(r-\u0026gt;left)-\u0026gt;postOrder(r-\u0026gt;right)-\u0026gt;print r 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void preOrder(Node* root) { if (root == null) return; print root // 此处为伪代码，表示打印root节点 preOrder(root-\u0026gt;left); preOrder(root-\u0026gt;right); } void inOrder(Node* root) { if (root == null) return; inOrder(root-\u0026gt;left); print root // 此处为伪代码，表示打印root节点 inOrder(root-\u0026gt;right); } void postOrder(Node* root) { if (root == null) return; postOrder(root-\u0026gt;left); postOrder(root-\u0026gt;right); print root // 此处为伪代码，表示打印root节点 } 二叉查找树（Binary Search Tree） 也叫二叉搜索树\n二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。\n关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。\n中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n), 因此，二叉查找树也叫作二叉排序树。\n支持重复数据的二叉查找树 二叉查找树的时间复杂度分析 不平衡O(n) 平衡O(logN) 为什么还要用二叉查找树呢？ 散列表是无序的, 扩容耗时, 冲突时性能不稳定, 设计比二叉查找树复杂, 装载因子不能太大浪费空间\n平衡二叉查找树 二叉树中任意一个节点的左右子树的高度相差不能大于1。\n完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。\nAVL树完全符合平衡二叉查找树的定义 红黑树 红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树\n红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：\n根节点是黑色的； 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；(为了简化红黑树的代码实现而设置的) 任何相邻(同一路径)的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的； 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点； 在画图和讲解的时候，将黑色的、空的叶子节点都省略掉了。\n红黑树的高度近似 2logN。\n","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"链式存储法 基于数组的顺序存储法 左子节点: 2*i 右子节点: 2*i+1 遍历 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打","title":"二叉树"},{"content":"散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。\n散列函数设计的基本要求\n散列函数计算得到的散列值是一个非负整数； 如果 key1 = key2，那 hash(key1) == hash(key2)； 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。 散列冲突 开放寻址法 如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。\n线性探测（Linear Probing）, 如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直 到找到为止。 将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。 二次探测（Quadratic probing）, 跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1， hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22…… 双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的 存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。 不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表 中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。\n散列表的装载因子=填入表中的元素个数/散列表的长度 链表法 在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。\nLRU 缓存淘汰算法 hnext 指针是为了将结点串在散列表的拉链中。 ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%95%A3%E5%88%97%E8%A1%A8/","summary":"散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。 散列函数设计的基本要求 散列函数计算得到的散","title":"散列表"},{"content":"动态数据结构，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树（Red-black tree）。\n时间复杂度O(logN) 支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。 如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。 跳表索引动态更新\n通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。 ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E8%B7%B3%E8%A1%A8/","summary":"Skip List","title":"跳表"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public int bsearch(int[] a, int n, int value) { int low = 0; int high = n - 1; while (low \u0026lt;= high) { int mid = (low + high) / 2; if (a[mid] == value) { return mid; } else if (a[mid] \u0026lt; value) { low = mid + 1; } else { high = mid - 1; } } return -1; } 递归写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 二分查找的递归实现 public int bsearch(int[] a, int n, int val) { return bsearchInternally(a, 0, n - 1, val); } private int bsearchInternally(int[] a, int low, int high, int value) { if (low \u0026gt; high) return -1; int mid = low + ((high - low) \u0026gt;\u0026gt; 1); if (a[mid] == value) { return mid; } else if (a[mid] \u0026lt; value) { return bsearchInternally(a, mid+1, high, value); } else { return bsearchInternally(a, low, mid-1, value); } } 二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。 如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。 需要连续内存, 如果数据量太大, 那么无法分配内存进行排序 ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","summary":"Binary Search","title":"二分查找"},{"content":" 根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数 排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。\n","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","summary":"Radix Sort","title":"基数排序"},{"content":"计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值 都是相同的，省掉了桶内排序的时间。\n","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/","summary":"Counting Sort","title":"计数排序"},{"content":"将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。\n桶越多, 时间复杂度接近O(n) 适用外部排序 ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%A1%B6%E6%8E%92%E5%BA%8F/","summary":"Bucket Sort","title":"桶排序"},{"content":"如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之 间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。\n根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。\n递推公式： quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r) 终止条件： p \u0026gt;= r // 快速排序，A是数组，n表示数组的大小 quick_sort(A, n) { quick_sort_c(A, 0, n-1) } // 快速排序递归函数，p,r为下标 quick_sort_c(A, p, r) { if p \u0026gt;= r then return q = partition(A, p, r) // 获取分区点 quick_sort_c(A, p, q-1) quick_sort_c(A, q+1, r) } partition()需要原地\npartition(A, p, r) { pivot := A[r] i := p for j := p to r-1 do { if A[j] \u0026lt; pivot { swap A[i] with A[j] i := i+1 } } swap A[i] with A[r] return i } 并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。\n原地 不稳定 最好O(nlogn) 最坏O(n^2) ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","summary":"Quicksort","title":"快速排序"},{"content":" 递推公式： merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r)) 终止条件： p \u0026gt;= r 不用再继续分解 // 归并排序算法, A是数组，n表示数组大小 merge_sort(A, n) { merge_sort_c(A, 0, n-1) } // 递归调用函数 merge_sort_c(A, p, r) { // 递归终止条件 if p \u0026gt;= r then return // 取p到r之间的中间位置q q = (p+r) / 2 // 分治递归 merge_sort_c(A, p, q) merge_sort_c(A, q+1, r) // 将A[p...q]和A[q+1...r]合并为A[p...r] merge(A[p...r], A[p...q], A[q+1...r]) } merge(A[p...r], A[p...q], A[q+1...r]) { var i := p，j := q+1，k := 0 // 初始化变量i, j, k var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组 while i\u0026lt;=q AND j\u0026lt;=r do { if A[i] \u0026lt;= A[j] { tmp[k++] = A[i++] // i++等于i:=i+1 } else { tmp[k++] = A[j++] } } // 判断哪个子数组中有剩余的数据 var start := i，end := q if j\u0026lt;=r then start := j, end:=r // 将剩余的数据拷贝到临时数组tmp while start \u0026lt;= end do { tmp[k++] = A[start++] } // 将tmp中的数组拷贝回A[p...r] for i:=0 to r-p do { A[p+i] = tmp[i] } } 稳定 不是原地排序(致命缺点), O(n) 最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。 感觉拆分部分水分极大, 不确定实际的复杂度(与实现有关).\n","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","summary":"Merge Sort","title":"归并排序"},{"content":"Channel 的应用场景 数据交流：当作并发的 buffer 或者 queue，解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者（Producer）和消费者（Consumer）。 数据传递：一个 goroutine 将数据交给另一个 goroutine，相当于把数据的拥有权 (引用) 托付出去。 信号通知：一个 goroutine 可以将信号 (closing、closed、data ready 等) 传递给另一个或者另一组 goroutine 。 任务编排：可以让一组 goroutine 按照一定的顺序并发或者串行的执行，这就是编排的功能。 锁：利用 Channel 也可以实现互斥锁的机制。 Channel 的实现原理 ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/channel/","summary":"Channel 的应用场景 数据交流：当作并发的 buffer 或者 queue，解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者（Producer）和消费者（Consum","title":"Channel"},{"content":"对于无符号的整数和 uinptr 类型来说，怎么实现减去一个值呢？\n1 AddUint32(\u0026amp;x, ^uint32(c-1)). CAS (CompareAndSwap) 1 func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) Lock-Free queue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 package queue import ( \u0026#34;sync/atomic\u0026#34; \u0026#34;unsafe\u0026#34; ) // lock-free的queue type LKQueue struct { head unsafe.Pointer tail unsafe.Pointer } // 通过链表实现，这个数据结构代表链表中的节点 type node struct { value interface{} next unsafe.Pointer } func NewLKQueue() *LKQueue { n := unsafe.Pointer(\u0026amp;node{}) return \u0026amp;LKQueue{head: n, tail: n} } // 入队 func (q *LKQueue) Enqueue(v interface{}) { n := \u0026amp;node{value: v} for { tail := load(\u0026amp;q.tail) next := load(\u0026amp;tail.next) if tail == load(\u0026amp;q.tail) { // 尾还是尾 if next == nil { // 还没有新数据入队 if cas(\u0026amp;tail.next, next, n) { //增加到队尾 cas(\u0026amp;q.tail, tail, n) //入队成功，移动尾巴指针 return } } else { // 已有新数据加到队列后面，需要移动尾指针 cas(\u0026amp;q.tail, tail, next) } } } } // 出队，没有元素则返回nil func (q *LKQueue) Dequeue() interface{} { for { head := load(\u0026amp;q.head) tail := load(\u0026amp;q.tail) next := load(\u0026amp;head.next) if head == load(\u0026amp;q.head) { // head还是那个head if head == tail { // head和tail一样 if next == nil { // 说明是空队列 return nil } // 只是尾指针还没有调整，尝试调整它指向下一个 cas(\u0026amp;q.tail, tail, next) } else { // 读取出队的数据 v := next.value // 既然要出队了，头指针移动到下一个 if cas(\u0026amp;q.head, head, next) { return v // Dequeue is done. return } } } } } // 将unsafe.Pointer原子加载转换成node func load(p *unsafe.Pointer) (n *node) { return (*node)(atomic.LoadPointer(p)) } // 封装CAS,避免直接将*node转换成unsafe.Pointer func cas(p *unsafe.Pointer, old, new *node) (ok bool) { return atomic.CompareAndSwapPointer( p, unsafe.Pointer(old), unsafe.Pointer(new)) } ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/atomic/","summary":"对于无符号的整数和 uinptr 类型来说，怎么实现减去一个值呢？ 1 AddUint32(\u0026amp;x, ^uint32(c-1)). CAS (CompareAndSwap) 1 func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) Lock-Free queue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28","title":"Atomic"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/oschina/%E7%86%94%E6%96%AD/","summary":"原文","title":"熔断"},{"content":"在使用 Context 的时候，有一些约定俗成的规则。\n一般函数使用 Context 的时候，会把这个参数放在第一个参数的位置。 从来不把 nil 当做 Context 类型的参数值，可以使用 context.Background() 创建一个空的上下文对象，也不要使用 nil。 Context 只用来临时做函数之间的上下文透传，不能持久化 Context 或者把 Context 长久保存。把 Context 持久化到数据库、本地文件或者全局变量、 缓存中都是错误的用法。 key 的类型不应该是字符串类型或者其它内建类型，否则容易在包之间使用 Context 时候产生冲突。使用 WithValue 时，key 的类型应该是自己定义的类型。 常常使用 struct{}作为底层类型定义 key 的类型。对于 exported key 的静态类型，常常是接口或者指针。这样可以尽量减少内存分配。 WithValue 1 2 3 4 type valueCtx struct { Context key, val interface{} } WithCancel 不是只有你想中途放弃，才去调用 cancel，只要你的任务正常完成了，就需要调用 cancel\n1 2 3 4 5 6 7 8 9 10 func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { c := newCancelCtx(parent) propagateCancel(parent, \u0026amp;c)// 把c朝上传播 return \u0026amp;c, func() { c.cancel(true, Canceled) } } // newCancelCtx returns an initialized cancelCtx. func newCancelCtx(parent Context) cancelCtx { return cancelCtx{Context: parent} } propagateCancel 方法会顺着 parent 路径往上找，直到找到一个 cancelCtx，或者为 nil。如果不为空，就把自己加入到这个 cancelCtx 的 child， 以便这个 cancelCtx 被取消的时候通知自己。如果为空，会新起一个 goroutine，由它来监听 parent 的 Done 是否已关闭。\ncancel 是向下传递的，如果一个 WithCancel 生成的 Context 被 cancel 时，如果它的子 Context（也有可能是孙，或者更低，依赖子的类型）也是 cancelCtx 类型的，就会被 cancel，但是不会向上传递。parent Context 不会因为子 Context 被 cancel 而 cancel。\nWithTimeout WithTimeout 其实是和 WithDeadline 一样，只不过一个参数是超时时间，一个参数是截止时间。超时时间加上当前时间，其实就是截止时间，因此， WithTimeout 的实现是：\n1 2 3 4 func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { // 当前时间+timeout就是deadline return WithDeadline(parent, time.Now().Add(timeout)) } WithDeadline 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { // 如果parent的截止时间更早，直接返回一个cancelCtx即可 if cur, ok := parent.Deadline(); ok \u0026amp;\u0026amp; cur.Before(d) { return WithCancel(parent) } c := \u0026amp;timerCtx{ cancelCtx: newCancelCtx(parent), deadline: d, } propagateCancel(parent, c) // 同cancelCtx的处理逻辑 dur := time.Until(d) if dur \u0026lt;= 0 { //当前时间已经超过了截止时间，直接cancel c.cancel(true, DeadlineExceeded) return c, func() { c.cancel(false, Canceled) } } c.mu.Lock() defer c.mu.Unlock() if c.err == nil { // 设置一个定时器，到截止时间后取消 c.timer = time.AfterFunc(dur, func() { c.cancel(true, DeadlineExceeded) }) } return c, func() { c.cancel(true, Canceled) } } ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/context/","summary":"在使用 Context 的时候，有一些约定俗成的规则。 一般函数使用 Context 的时候，会把这个参数放在第一个参数的位置。 从来不把 nil 当做 Context 类型的参数值，可以使用 context.Background() 创建一","title":"Context"},{"content":"中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。\n参考 中介模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/","summary":"Mediator Pattern","title":"中介模式"},{"content":"它用来描述如何构建一个简单的“语言”解释器。比起命令模式，解释器模式更加小众，只在一些特定的领域会被用到，比如编译器、规则引擎、正则表达式。\n解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。\n参考 解释器模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"Interpreter Pattern","title":"解释器模式"},{"content":"设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，它类似我们之前讲过的回调。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public interface Command { void execute(); } public class GotDiamondCommand implements Command { // 省略成员变量 public GotDiamondCommand(/*数据*/) { //... } @Override public void execute() { // 执行相应的逻辑 } } //GotStartCommand/HitObstacleCommand/ArchiveCommand类省略 public class GameApplication { private static final int MAX_HANDLED_REQ_COUNT_PER_LOOP = 100; private Queue\u0026lt;Command\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); public void mainloop() { while (true) { List\u0026lt;Request\u0026gt; requests = new ArrayList\u0026lt;\u0026gt;(); //省略从epoll或者select中获取数据，并封装成Request的逻辑， //注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。 for (Request request : requests) { Event event = request.getEvent(); Command command = null; if (event.equals(Event.GOT_DIAMOND)) { command = new GotDiamondCommand(/*数据*/); } else if (event.equals(Event.GOT_STAR)) { command = new GotStartCommand(/*数据*/); } else if (event.equals(Event.HIT_OBSTACLE)) { command = new HitObstacleCommand(/*数据*/); } else if (event.equals(Event.ARCHIVE)) { command = new ArchiveCommand(/*数据*/); } // ...一堆else if... queue.add(command); } int handledCount = 0; while (handledCount \u0026lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) { if (queue.isEmpty()) { break; } Command command = queue.poll(); command.execute(); } } } } 参考 命令模式 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","summary":"Command Pattern","title":"命令模式"},{"content":"也叫快照（Snapshot）模式, 主要是用来防丢失、撤销、恢复等。\n在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 public class InputText { private StringBuilder text = new StringBuilder(); public String getText() { return text.toString(); } public void append(String input) { text.append(input); } public Snapshot createSnapshot() { return new Snapshot(text.toString()); } public void restoreSnapshot(Snapshot snapshot) { this.text.replace(0, this.text.length(), snapshot.getText()); } } public class Snapshot { private String text; public Snapshot(String text) { this.text = text; } public String getText() { return this.text; } } public class SnapshotHolder { private Stack\u0026lt;Snapshot\u0026gt; snapshots = new Stack\u0026lt;\u0026gt;(); public Snapshot popSnapshot() { return snapshots.pop(); } public void pushSnapshot(Snapshot snapshot) { snapshots.push(snapshot); } } public class ApplicationMain { public static void main(String[] args) { InputText inputText = new InputText(); SnapshotHolder snapshotsHolder = new SnapshotHolder(); Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String input = scanner.next(); if (input.equals(\u0026#34;:list\u0026#34;)) { System.out.println(inputText.toString()); } else if (input.equals(\u0026#34;:undo\u0026#34;)) { Snapshot snapshot = snapshotsHolder.popSnapshot(); inputText.restoreSnapshot(snapshot); } else { snapshotsHolder.pushSnapshot(inputText.createSnapshot()); inputText.append(input); } } } } 参考 备忘录模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","summary":"Memento Pattern","title":"备忘录模式"},{"content":"建议你不要使用访问者模式。\n允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 public abstract class ResourceFile { protected String filePath; public ResourceFile(String filePath) { this.filePath = filePath; } abstract public void accept(Visitor vistor); } public class PdfFile extends ResourceFile { public PdfFile(String filePath) { super(filePath); } @Override public void accept(Visitor visitor) { visitor.visit(this); } //... } //...PPTFile、WordFile跟PdfFile类似，这里就省略了... public interface Visitor { void visit(PdfFile pdfFile); void visit(PPTFile pdfFile); void visit(WordFile pdfFile); } public class Extractor implements Visitor { @Override public void visit(PPTFile pptFile) { //... System.out.println(\u0026#34;Extract PPT.\u0026#34;); } @Override public void visit(PdfFile pdfFile) { //... System.out.println(\u0026#34;Extract PDF.\u0026#34;); } @Override public void visit(WordFile wordFile) { //... System.out.println(\u0026#34;Extract WORD.\u0026#34;); } } public class Compressor implements Visitor { @Override public void visit(PPTFile pptFile) { //... System.out.println(\u0026#34;Compress PPT.\u0026#34;); } @Override public void visit(PdfFile pdfFile) { //... System.out.println(\u0026#34;Compress PDF.\u0026#34;); } @Override public void visit(WordFile wordFile) { //... System.out.println(\u0026#34;Compress WORD.\u0026#34;); } } public class ToolApplication { public static void main(String[] args) { Extractor extractor = new Extractor(); List\u0026lt;ResourceFile\u0026gt; resourceFiles = listAllResourceFiles(args[0]); for (ResourceFile resourceFile : resourceFiles) { resourceFile.accept(extractor); } Compressor compressor = new Compressor(); for(ResourceFile resourceFile : resourceFiles) { resourceFile.accept(compressor); } } private static List\u0026lt;ResourceFile\u0026gt; listAllResourceFiles(String resourceDirectory) { List\u0026lt;ResourceFile\u0026gt; resourceFiles = new ArrayList\u0026lt;\u0026gt;(); //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile) resourceFiles.add(new PdfFile(\u0026#34;a.pdf\u0026#34;)); resourceFiles.add(new WordFile(\u0026#34;b.word\u0026#34;)); resourceFiles.add(new PPTFile(\u0026#34;c.ppt\u0026#34;)); return resourceFiles; } } 参考 访问者模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"Visitor Pattern","title":"访问者模式"},{"content":"也叫作游标模式（Cursor Design Pattern）。\n1 2 3 4 5 6 7 8 9 10 11 12 // 接口定义方式一 public interface Iterator\u0026lt;E\u0026gt; { boolean hasNext(); void next(); E currentItem(); } // 接口定义方式二 public interface Iterator\u0026lt;E\u0026gt; { boolean hasNext(); E next(); } 迭代器实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class ArrayIterator\u0026lt;E\u0026gt; implements Iterator\u0026lt;E\u0026gt; { private int cursor; private ArrayList\u0026lt;E\u0026gt; arrayList; public ArrayIterator(ArrayList\u0026lt;E\u0026gt; arrayList) { this.cursor = 0; this.arrayList = arrayList; } @Override public boolean hasNext() { return cursor != arrayList.size(); //注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。 } @Override public void next() { cursor++; } @Override public E currentItem() { if (cursor \u0026gt;= arrayList.size()) { throw new NoSuchElementException(); } return arrayList.get(cursor); } } public class Demo { public static void main(String[] args) { ArrayList\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); names.add(\u0026#34;xzg\u0026#34;); names.add(\u0026#34;wang\u0026#34;); names.add(\u0026#34;zheng\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = new ArrayIterator(names); while (iterator.hasNext()) { System.out.println(iterator.currentItem()); iterator.next(); } } } 将创建迭代器的逻辑放到容器中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public interface List\u0026lt;E\u0026gt; { Iterator iterator(); //...省略其他接口函数... } public class ArrayList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt; { //... public Iterator iterator() { return new ArrayIterator(this); } //...省略其他代码 } public class Demo { public static void main(String[] args) { List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); names.add(\u0026#34;xzg\u0026#34;); names.add(\u0026#34;wang\u0026#34;); names.add(\u0026#34;zheng\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = names.iterator(); while (iterator.hasNext()) { System.out.println(iterator.currentItem()); iterator.next(); } } } 参考 迭代器模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"Iterator Pattern","title":"迭代器模式"},{"content":"什么是有限状态机？ 有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。 其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。\n状态机实现方式 分支逻辑法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 public class MarioStateMachine { private int score; private State currentState; public MarioStateMachine() { this.score = 0; this.currentState = State.SMALL; } public void obtainMushRoom() { if (currentState.equals(State.SMALL)) { this.currentState = State.SUPER; this.score += 100; } } public void obtainCape() { if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) { this.currentState = State.CAPE; this.score += 200; } } public void obtainFireFlower() { if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) { this.currentState = State.FIRE; this.score += 300; } } public void meetMonster() { if (currentState.equals(State.SUPER)) { this.currentState = State.SMALL; this.score -= 100; return; } if (currentState.equals(State.CAPE)) { this.currentState = State.SMALL; this.score -= 200; return; } if (currentState.equals(State.FIRE)) { this.currentState = State.SMALL; this.score -= 300; return; } } public int getScore() { return this.score; } public State getCurrentState() { return this.currentState; } } 查表法 在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 public enum Event { GOT_MUSHROOM(0), GOT_CAPE(1), GOT_FIRE(2), MET_MONSTER(3); private int value; private Event(int value) { this.value = value; } public int getValue() { return this.value; } } public class MarioStateMachine { private int score; private State currentState; private static final State[][] transitionTable = { {SUPER, CAPE, FIRE, SMALL}, {SUPER, CAPE, FIRE, SMALL}, {CAPE, CAPE, CAPE, SMALL}, {FIRE, FIRE, FIRE, SMALL} }; private static final int[][] actionTable = { {+100, +200, +300, +0}, {+0, +200, +300, -100}, {+0, +0, +0, -200}, {+0, +0, +0, -300} }; public MarioStateMachine() { this.score = 0; this.currentState = State.SMALL; } public void obtainMushRoom() { executeEvent(Event.GOT_MUSHROOM); } public void obtainCape() { executeEvent(Event.GOT_CAPE); } public void obtainFireFlower() { executeEvent(Event.GOT_FIRE); } public void meetMonster() { executeEvent(Event.MET_MONSTER); } private void executeEvent(Event event) { int stateValue = currentState.getValue(); int eventValue = event.getValue(); this.currentState = transitionTable[stateValue][eventValue]; this.score += actionTable[stateValue][eventValue]; } public int getScore() { return this.score; } public State getCurrentState() { return this.currentState; } } 状态模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 public interface IMario { State getName(); void obtainMushRoom(MarioStateMachine stateMachine); void obtainCape(MarioStateMachine stateMachine); void obtainFireFlower(MarioStateMachine stateMachine); void meetMonster(MarioStateMachine stateMachine); } public class SmallMario implements IMario { private static final SmallMario instance = new SmallMario(); private SmallMario() {} public static SmallMario getInstance() { return instance; } @Override public State getName() { return State.SMALL; } @Override public void obtainMushRoom(MarioStateMachine stateMachine) { stateMachine.setCurrentState(SuperMario.getInstance()); stateMachine.setScore(stateMachine.getScore() + 100); } @Override public void obtainCape(MarioStateMachine stateMachine) { stateMachine.setCurrentState(CapeMario.getInstance()); stateMachine.setScore(stateMachine.getScore() + 200); } @Override public void obtainFireFlower(MarioStateMachine stateMachine) { stateMachine.setCurrentState(FireMario.getInstance()); stateMachine.setScore(stateMachine.getScore() + 300); } @Override public void meetMonster(MarioStateMachine stateMachine) { // do nothing... } } // 省略SuperMario、CapeMario、FireMario类... public class MarioStateMachine { private int score; private IMario currentState; public MarioStateMachine() { this.score = 0; this.currentState = SmallMario.getInstance(); } public void obtainMushRoom() { this.currentState.obtainMushRoom(this); } public void obtainCape() { this.currentState.obtainCape(this); } public void obtainFireFlower() { this.currentState.obtainFireFlower(this); } public void meetMonster() { this.currentState.meetMonster(this); } public int getScore() { return this.score; } public State getCurrentState() { return this.currentState.getName(); } public void setScore(int score) { this.score = score; } public void setCurrentState(IMario currentState) { this.currentState = currentState; } } 像游戏这种比较复杂的状态机，包含的状态比较多，我优先推荐使用查表法，而状态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下 单这种类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。\n参考 状态模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","summary":"Stat Pattern","title":"状态模式"},{"content":"在职责链模式中，多个处理器依次处理同一个请求。\n链表实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public abstract class Handler { protected Handler successor = null; public void setSuccessor(Handler successor) { this.successor = successor; } public final void handle() { boolean handled = doHandle(); if (successor != null \u0026amp;\u0026amp; !handled) { successor.handle(); } } protected abstract boolean doHandle(); } public class HandlerA extends Handler { @Override protected boolean doHandle() { boolean handled = false; //... return handled; } } public class HandlerB extends Handler { @Override protected boolean doHandle() { boolean handled = false; //... return handled; } } public class HandlerChain { private Handler head = null; private Handler tail = null; public void addHandler(Handler handler) { handler.setSuccessor(null); if (head == null) { head = handler; tail = handler; return; } tail.setSuccessor(handler); tail = handler; } public void handle() { if (head != null) { head.handle(); } } } // 使用举例 public class Application { public static void main(String[] args) { HandlerChain chain = new HandlerChain(); chain.addHandler(new HandlerA()); chain.addHandler(new HandlerB()); chain.handle(); } } 数组实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public interface IHandler { boolean handle(); } public class HandlerA implements IHandler { @Override public boolean handle() { boolean handled = false; //... return handled; } } public class HandlerB implements IHandler { @Override public boolean handle() { boolean handled = false; //... return handled; } } public class HandlerChain { private List\u0026lt;IHandler\u0026gt; handlers = new ArrayList\u0026lt;\u0026gt;(); public void addHandler(IHandler handler) { this.handlers.add(handler); } public void handle() { for (IHandler handler : handlers) { boolean handled = handler.handle(); if (handled) { break; } } } } // 使用举例 public class Application { public static void main(String[] args) { HandlerChain chain = new HandlerChain(); chain.addHandler(new HandlerA()); chain.addHandler(new HandlerB()); chain.handle(); } } 职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。\n参考 职责链模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/","summary":"Chain of Responsibility Pattern","title":"职责链模式"},{"content":"最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。\n定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 // 定义策略 public interface Strategy { void algorithmInterface(); } public class ConcreteStrategyA implements Strategy { @Override public void algorithmInterface() { //具体的算法... } } public class ConcreteStrategyB implements Strategy { @Override public void algorithmInterface() { //具体的算法... } } // 创建策略-可重用的策略 public class StrategyFactory { private static final Map\u0026lt;String, Strategy\u0026gt; strategies = new HashMap\u0026lt;\u0026gt;(); static { strategies.put(\u0026#34;A\u0026#34;, new ConcreteStrategyA()); strategies.put(\u0026#34;B\u0026#34;, new ConcreteStrategyB()); } public static Strategy getStrategy(String type) { if (type == null || type.isEmpty()) { throw new IllegalArgumentException(\u0026#34;type should not be empty.\u0026#34;); } return strategies.get(type); } } // 创建策略-每次新创建策略对象 public class StrategyFactory { public static Strategy getStrategy(String type) { if (type == null || type.isEmpty()) { throw new IllegalArgumentException(\u0026#34;type should not be empty.\u0026#34;); } if (type.equals(\u0026#34;A\u0026#34;)) { return new ConcreteStrategyA(); } else if (type.equals(\u0026#34;B\u0026#34;)) { return new ConcreteStrategyB(); } return null; } } // 使用策略 // 策略接口：EvictionStrategy // 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy... // 策略工厂：EvictionStrategyFactory public class UserCache { private Map\u0026lt;String, User\u0026gt; cacheData = new HashMap\u0026lt;\u0026gt;(); private EvictionStrategy eviction; public UserCache(EvictionStrategy eviction) { this.eviction = eviction; } //... } // 运行时动态确定，根据配置文件的配置决定使用哪种策略 public class Application { public static void main(String[] args) throws Exception { EvictionStrategy evictionStrategy = null; Properties props = new Properties(); props.load(new FileInputStream(\u0026#34;./config.properties\u0026#34;)); String type = props.getProperty(\u0026#34;eviction_type\u0026#34;); evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type); UserCache userCache = new UserCache(evictionStrategy); //... } } // 非运行时动态确定，在代码中指定使用哪种策略 public class Application { public static void main(String[] args) { //... EvictionStrategy evictionStrategy = new LruEvictionStrategy(); UserCache userCache = new UserCache(evictionStrategy); //... } } 利用策略模式避免分支判断 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 策略的定义 public interface DiscountStrategy { double calDiscount(Order order); } // 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码... // 策略的创建 public class DiscountStrategyFactory { private static final Map\u0026lt;OrderType, DiscountStrategy\u0026gt; strategies = new HashMap\u0026lt;\u0026gt;(); static { strategies.put(OrderType.NORMAL, new NormalDiscountStrategy()); strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy()); strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy()); } public static DiscountStrategy getDiscountStrategy(OrderType type) { return strategies.get(type); } } // 策略的使用 public class OrderService { public double discount(Order order) { OrderType type = order.getType(); DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type); return discountStrategy.calDiscount(order); } } 实际上使用map来消除的\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","summary":"Strategy Pattern","title":"策略模式"},{"content":"用来解决复用和扩展两个问题\n模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步 骤。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public abstract class AbstractClass { public final void templateMethod() { //... method1(); //... method2(); //... } protected abstract void method1(); protected abstract void method2(); } public class ConcreteClass1 extends AbstractClass { @Override protected void method1() { //... } @Override protected void method2() { //... } } public class ConcreteClass2 extends AbstractClass { @Override protected void method1() { //... } @Override protected void method2() { //... } } AbstractClass demo = ConcreteClass1(); demo.templateMethod(); 参考 模板方法-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/","summary":"Template Method","title":"模板模式"},{"content":"sync.Pool 数据类型用来保存一组可独立访问的临时对象。\nsync.Pool 本身就是线程安全的 sync.Pool 不可在使用之后再复制使用 Get 方法的返回值还可能会是一个 nil（Pool.New 字段没有设置，又没有空闲元素可以返回），所以你在使用的时候，可能需要判断 如果 Put 一个 nil 值，Pool 就会忽略这个值 实现原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func poolCleanup() { // 丢弃当前victim, STW所以不用加锁 for _, p := range oldPools { p.victim = nil p.victimSize = 0 } // 将local复制给victim, 并将原local置为nil for _, p := range allPools { p.victim = p.local p.victimSize = p.localSize p.local = nil p.localSize = 0 } oldPools, allPools = allPools, nil } 请求元素时也是优先从 local 字段中查找可用的元素\n而 poolLocalInternal 也包含两个字段：private 和 shared。\nprivate，代表一个缓存的元素，而且只能由相应的一个 P 存取。因为一个 P 同时只能执行一个 goroutine，所以不会有并发的问题。 shared，可以由任意的 P 访问，但是只有本地的 P 才能 pushHead/popHead，其它 P 可以 popTail，相当于只有一个本地的 P 作为生产者（Producer），多个 P 作为消费者（Consumer），它是使用一个 local-free 的 queue 列表实现的。 Get 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func (p *Pool) Get() interface{} { // 把当前goroutine固定在当前的P上 l, pid := p.pin() x := l.private // 优先从local的private字段取，快速 l.private = nil if x == nil { // 从当前的local.shared弹出一个，注意是从head读取并移除 x, _ = l.shared.popHead() if x == nil { // 如果没有，则去偷一个 x = p.getSlow(pid) } } runtime_procUnpin() // 如果没有获取到，尝试使用New函数生成一个新的 if x == nil \u0026amp;\u0026amp; p.New != nil { x = p.New() } return x } 重点是 getSlow 方法，我们来分析下。看名字也就知道了，它的耗时可能比较长。它首先要遍历所有的 local，尝试从它们的 shared 弹出一个元素。如果还没 找到一个，那么，就开始对 victim 下手了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func (p *Pool) getSlow(pid int) interface{} { size := atomic.LoadUintptr(\u0026amp;p.localSize) locals := p.local // 从其它proc中尝试偷取一个元素 for i := 0; i \u0026lt; int(size); i++ { l := indexLocal(locals, (pid+i+1)%int(size)) if x, _ := l.shared.popTail(); x != nil { return x } } // 如果其它proc也没有可用元素，那么尝试从vintim中获取 size = atomic.LoadUintptr(\u0026amp;p.victimSize) if uintptr(pid) \u0026gt;= size { return nil } locals = p.victim l := indexLocal(locals, pid) if x := l.private; x != nil { // 同样的逻辑，先从vintim中的local private获取 l.private = nil return x } for i := 0; i \u0026lt; int(size); i++ { // 从vintim其它proc尝试偷取 l := indexLocal(locals, (pid+i)%int(size)) if x, _ := l.shared.popTail(); x != nil { return x } } // 如果victim中都没有，则把这个victim标记为空，以后的查找可以快速跳过了 atomic.StoreUintptr(\u0026amp;p.victimSize, 0) return nil } Put 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func (p *Pool) Put(x interface{}) { if x == nil { // nil值直接丢弃 return } l, _ := p.pin() if l.private == nil { // 如果本地private没有值，直接设置这个值即可 l.private = x x = nil } if x != nil { // 否则加入到本地队列中 l.shared.pushHead(x) } runtime_procUnpin() } sync.Pool 的坑 内存泄漏 将容量已经变得很大的 Buffer 再放回 Pool 中，导致内存泄漏。\n在使用 sync.Pool 回收 buffer 的时候，一定要检查回收的对象的大小。如果 buffer 太大，就不要回收了，否则就太浪费了。\n内存浪费 可以将 buffer 池分成几层。\n首先，小于 512 byte 的元素的 buffer 占一个池子； 其次，小于 1K byte 大小的元素占一个池子； 再次，小于 4K byte 大小的元素占一个池子。 这样分成几个池子以后，就可以根据需要，到所需大小的池子中获取 buffer 了。\n连接池 http.Client 实现连接池的代码是在 Transport 类型中 tcp连接池fatih/pool 标准库 sql.DB 还提供了一个通用的数据库的连接池，通过 MaxOpenConns 和 MaxIdleConns 控制最大的连接数和最大的 idle 的连接数。 Memcached Client 连接池采用 Mutex+Slice 实现 Pool Worker Pool fasthttp workerpool workerpool 参考 更加通用的多层buffer池bucketpool bytebufferpool bpool ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/pool/","summary":"sync.Pool 数据类型用来保存一组可独立访问的临时对象。 sync.Pool 本身就是线程安全的 sync.Pool 不可在使用之后再复制使用 Get 方法的返回值还可能会是一个 nil（Pool.Ne","title":"Pool"},{"content":"也被称为发布订阅模式（Publish-Subscribe Design Pattern）\n在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。\n一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。 常见的实现方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public interface Subject { void registerObserver(Observer observer); void removeObserver(Observer observer); void notifyObservers(Message message); } public interface Observer { void update(Message message); } public class ConcreteSubject implements Subject { private List\u0026lt;Observer\u0026gt; observers = new ArrayList\u0026lt;Observer\u0026gt;(); @Override public void registerObserver(Observer observer) { observers.add(observer); } @Override public void removeObserver(Observer observer) { observers.remove(observer); } @Override public void notifyObservers(Message message) { for (Observer observer : observers) { observer.update(message); } } } public class ConcreteObserverOne implements Observer { @Override public void update(Message message) { //TODO: 获取消息通知，执行自己的逻辑... System.out.println(\u0026#34;ConcreteObserverOne is notified.\u0026#34;); } } public class ConcreteObserverTwo implements Observer { @Override public void update(Message message) { //TODO: 获取消息通知，执行自己的逻辑... System.out.println(\u0026#34;ConcreteObserverTwo is notified.\u0026#34;); } } public class Demo { public static void main(String[] args) { ConcreteSubject subject = new ConcreteSubject(); subject.registerObserver(new ConcreteObserverOne()); subject.registerObserver(new ConcreteObserverTwo()); subject.notifyObservers(new Message()); } } 参考 观察者模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"Observer Pattern","title":"观察者模式"},{"content":"享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。\n池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并 不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中， 都是被所有使用者共享的，主要目的是节省空间。\n参考 享元模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","summary":"Flyweight Pattern","title":"享元模式"},{"content":"不常用, 主要是用来处理树形结构数据。\n参考 组合模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","summary":"Composite Pattern","title":"组合模式"},{"content":"外观模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。\n应用场景 解决易用性问题 解决性能问题 将多个接口调用替换为一个门面接口调用，减少网络通信成本 解决分布式事务问题 计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。 该如何组织门面接口和非门面接口？ 如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。 如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。 如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。 参考 门面模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/","summary":"Facade Pattern","title":"外观/门面模式"},{"content":"将不兼容的接口转换为可兼容的接口, 适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。\n类适配器使用继承关系来实现 对象适配器使用组合关系来实现 ITarget 表示要转化成的接口定义 Adaptee 是一组不兼容 ITarget 接口定义的接口 Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // 类适配器: 基于继承 public interface ITarget { void f1(); void f2(); void fc(); } public class Adaptee { public void fa() { //... } public void fb() { //... } public void fc() { //... } } public class Adaptor extends Adaptee implements ITarget { public void f1() { super.fa(); } public void f2() { //...重新实现f2()... } // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点 } // 对象适配器：基于组合 public interface ITarget { void f1(); void f2(); void fc(); } public class Adaptee { public void fa() { //... } public void fb() { //... } public void fc() { //... } } public class Adaptor implements ITarget { private Adaptee adaptee; public Adaptor(Adaptee adaptee) { this.adaptee = adaptee; } public void f1() { adaptee.fa(); //委托给Adaptee } public void f2() { //...重新实现f2()... } public void fc() { adaptee.fc(); } } 使用类适配器还是对象适配器?\n如果 Adaptee 接口并不多，那两种实现方式都可以。 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比 起对象适配器的实现方式，Adaptor 的代码量要少一些。(直接拿来用, 选择类适配器) 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。 (要重写, 选择对象适配器) 应用场景 封装有缺陷的接口设计 统一多个类的接口设计 替换依赖的外部系统 兼容老版本接口 适配不同格式的数据 参考 适配器模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"Adapter Pattern","title":"适配器模式"},{"content":"装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。\n组合由于继承, 避免复杂的继承关系\n装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类 1 2 3 4 InputStream in = new FileInputStream(\u0026#34;/user/wangzheng/test.txt\u0026#34;); InputStream bin = new BufferedInputStream(in); DataInputStream din = new DataInputStream(bin); int data = din.readInt(); 装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。 代理模式中，代理类附加的是跟原始类无关的功能 参考 装饰器模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"Decorator Pattern","title":"装饰器模式"},{"content":"桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public interface MsgSender { void send(String message); } public class TelephoneMsgSender implements MsgSender { private List\u0026lt;String\u0026gt; telephones; public TelephoneMsgSender(List\u0026lt;String\u0026gt; telephones) { this.telephones = telephones; } @Override public void send(String message) { //... } } public class EmailMsgSender implements MsgSender { // 与TelephoneMsgSender代码结构类似，所以省略... } public class WechatMsgSender implements MsgSender { // 与TelephoneMsgSender代码结构类似，所以省略... } public abstract class Notification { protected MsgSender msgSender; public Notification(MsgSender msgSender) { this.msgSender = msgSender; } public abstract void notify(String message); } public class SevereNotification extends Notification { public SevereNotification(MsgSender msgSender) { super(msgSender); } @Override public void notify(String message) { msgSender.send(message); } } public class UrgencyNotification extends Notification { // 与SevereNotification代码结构类似，所以省略... } public class NormalNotification extends Notification { // 与SevereNotification代码结构类似，所以省略... } public class TrivialNotification extends Notification { // 与SevereNotification代码结构类似，所以省略... } 参考 桥接模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","summary":"Bridge Pattern","title":"桥接模式"},{"content":"代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。\n代理类和业务类实现相同接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 public interface IUserController { UserVo login(String telephone, String password); UserVo register(String telephone, String password); } public class UserController implements IUserController { //...省略其他属性和方法... @Override public UserVo login(String telephone, String password) { //...省略login逻辑... //...返回UserVo数据... } @Override public UserVo register(String telephone, String password) { //...省略register逻辑... //...返回UserVo数据... } } public class UserControllerProxy implements IUserController { private MetricsCollector metricsCollector; private UserController userController; public UserControllerProxy(UserController userController) { this.userController = userController; this.metricsCollector = new MetricsCollector(); } @Override public UserVo login(String telephone, String password) { long startTimestamp = System.currentTimeMillis(); // 委托 UserVo userVo = userController.login(telephone, password); long endTimeStamp = System.currentTimeMillis(); long responseTime = endTimeStamp - startTimestamp; RequestInfo requestInfo = new RequestInfo(\u0026#34;login\u0026#34;, responseTime, startTimestamp); metricsCollector.recordRequest(requestInfo); return userVo; } @Override public UserVo register(String telephone, String password) { long startTimestamp = System.currentTimeMillis(); UserVo userVo = userController.register(telephone, password); long endTimeStamp = System.currentTimeMillis(); long responseTime = endTimeStamp - startTimestamp; RequestInfo requestInfo = new RequestInfo(\u0026#34;register\u0026#34;, responseTime, startTimestamp); metricsCollector.recordRequest(requestInfo); return userVo; } } //UserControllerProxy使用举例 //因为原始类和代理类实现相同的接口，是基于接口而非实现编程 //将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码 IUserController userController = new UserControllerProxy(new UserController()); 对于外部代码, 可以使用继承\n动态代理 Dynamic Proxy 在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class MetricsCollectorProxy { private MetricsCollector metricsCollector; public MetricsCollectorProxy() { this.metricsCollector = new MetricsCollector(); } public Object createProxy(Object proxiedObject) { Class\u0026lt;?\u0026gt;[] interfaces = proxiedObject.getClass().getInterfaces(); DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject); return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler); } private class DynamicProxyHandler implements InvocationHandler { private Object proxiedObject; public DynamicProxyHandler(Object proxiedObject) { this.proxiedObject = proxiedObject; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { long startTimestamp = System.currentTimeMillis(); Object result = method.invoke(proxiedObject, args); long endTimeStamp = System.currentTimeMillis(); long responseTime = endTimeStamp - startTimestamp; String apiName = proxiedObject.getClass().getName() + \u0026#34;:\u0026#34; + method.getName(); RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp); metricsCollector.recordRequest(requestInfo); return result; } } } //MetricsCollectorProxy使用举例 MetricsCollectorProxy proxy = new MetricsCollectorProxy(); IUserController userController = (IUserController) proxy.createProxy(new UserController()); 参考 代理模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","summary":"Proxy Pattern","title":"代理模式"},{"content":"聚合统计 集合的交, 差, 并集\nSUNIONSTORE SDIFFSTORE SINTERSTORE 这些命令复杂度较高\n排序统计 可以使用sorted set保证分页时, 元素不会串\nZRANGEBYSCORE 二值状态统计 bitmap\nSETBIT BITOP BITCOUNT 基数统计 指统计一个集合中不重复的元素个数\nset\nSADD SCARD hash\nHSET HLEN hyperLogLog\n用于统计基数的数据集合类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小。 有一定误差 PFADD PFCOUNT ","permalink":"https://jdxj.github.io/posts/articles/jdxj/redis/redis%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%BC%8F/","summary":"聚合统计 集合的交, 差, 并集 SUNIONSTORE SDIFFSTORE SINTERSTORE 这些命令复杂度较高 排序统计 可以使用sorted set保证分页时, 元素不会串 ZRANGEBYSCORE 二值状态统计 bitmap SETBIT BITOP BITCOUNT 基数统计 指统","title":"Redis中常见的四种统计模式"},{"content":"占用内存的元数据过多\n全局hash表一个项是dictEntry 封装底层编码的RedisObject 如果想节约内存, 可以考虑使用底层编码为ziplist的集合\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/redis/%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E4%BD%BF%E7%94%A8string/","summary":"占用内存的元数据过多 全局hash表一个项是dictEntry 封装底层编码的RedisObject 如果想节约内存, 可以考虑使用底层编码为zip","title":"过多的使用String键会造成内存浪费"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/segmentfault/go-generics/","summary":"原文","title":"Go 1.18 泛型全面讲解：一篇讲清泛型的全部"},{"content":"key必须是可比较的\n不可比较的类型 如果 struct 的某个字段值修改了，查询 map 时无法获取它 add 进去的值 有序的map orderedmap\n不能并发读写\n实现线程安全map 加读写锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package test import \u0026#34;sync\u0026#34; type RWMap[K comparable, V any] struct { sync.RWMutex m map[K]V } func NewRWMap[K comparable, V any](n int) *RWMap[K, V] { return \u0026amp;RWMap[K, V]{ m: make(map[K]V), } } func (m *RWMap[K, V]) Get(k K) (V, bool) { m.RLock() defer m.RUnlock() v, existed := m.m[k] return v, existed } func (m *RWMap[K, V]) Set(k K, v V) { m.Lock() defer m.Unlock() m.m[k] = v } func (m *RWMap[K, V]) Delete(k K) { m.Lock() defer m.Unlock() delete(m.m, k) } func (m *RWMap[K, V]) Len() int { m.RLock() defer m.RUnlock() return len(m.m) } func (m *RWMap[K, V]) Each(f func(k K, v V) bool) { m.RLock() defer m.RUnlock() for k, v := range m.m { if !f(k, v) { return } } } 分片加锁concurrent-map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 var SHARD_COUNT = 32 // 分成SHARD_COUNT个分片的map type ConcurrentMap []*ConcurrentMapShared // 通过RWMutex保护的线程安全的分片，包含一个map type ConcurrentMapShared struct { items map[string]interface{} sync.RWMutex // Read Write mutex, guards access to internal map. } // 创建并发map func New() ConcurrentMap { m := make(ConcurrentMap, SHARD_COUNT) for i := 0; i \u0026lt; SHARD_COUNT; i++ { m[i] = \u0026amp;ConcurrentMapShared{items: make(map[string]interface{})} } return m } // 根据key计算分片索引 func (m ConcurrentMap) GetShard(key string) *ConcurrentMapShared { return m[uint(fnv32(key))%uint(SHARD_COUNT)] } func (m ConcurrentMap) Set(key string, value interface{}) { // 根据key计算出对应的分片 shard := m.GetShard(key) shard.Lock() //对这个分片加锁，执行业务操作 shard.items[key] = value shard.Unlock() } func (m ConcurrentMap) Get(key string) (interface{}, bool) { // 根据key计算出对应的分片 shard := m.GetShard(key) shard.RLock() // 从这个分片读取key的值 val, ok := shard.items[key] shard.RUnlock() return val, ok } sync.Map sync.Map 并不是用来替换内建的 map 类型的，它只能被应用在一些特殊的场景里。\n官方的文档中指出，在以下两个场景中使用 sync.Map，会比使用 map+RWMutex 的方式，性能要好得多：\n只会增长的缓存系统中，一个 key 只写入一次而被读很多次； 多个 goroutine 为不相交的键集读、写和重写键值对。 这两个场景说得都比较笼统，而且，这些场景中还包含了一些特殊的情况。所以，官方建议你针对自己的场景做性能评测，如果确实能够显著提高性能，再使用 sync.Map。\n","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/map/","summary":"key必须是可比较的 不可比较的类型 如果 struct 的某个字段值修改了，查询 map 时无法获取它 add 进去的值 有序的map orderedmap 不能并发读写 实现线程安全map 加读写锁","title":"map"},{"content":"选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。\n原地排序 不稳定 最好O(n^2) 最坏O(n^2) 平均O(n^2) 参考 选择排序-go ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","summary":"Selection Sort","title":"选择排序"},{"content":"插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 插入排序，a表示数组，n表示数组大小 public void insertionSort(int[] a, int n) { if (n \u0026lt;= 1) return; for (int i = 1; i \u0026lt; n; ++i) { int value = a[i]; int j = i - 1; // 查找插入的位置 for (; j \u0026gt;= 0; --j) { if (a[j] \u0026gt; value) { a[j+1] = a[j]; // 数据移动 } else { break; } } a[j+1] = value; // 插入数据 } } 原地排序 稳定 最好O(n) 最坏O(n^2) 平均O(n^2) 参考 插入排序-go ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","summary":"Insertion Sort","title":"插入排序"},{"content":"一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。\n第一次 后续 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 冒泡排序，a表示数组，n表示数组大小 public void bubbleSort(int[] a, int n) { if (n \u0026lt;= 1) return; for (int i = 0; i \u0026lt; n; ++i) { // 提前退出冒泡循环的标志位 boolean flag = false; for (int j = 0; j \u0026lt; n - i - 1; ++j) { if (a[j] \u0026gt; a[j+1]) { // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true; // 表示有数据交换 } } if (!flag) break; // 没有数据交换，提前退出 } } 原地排序 稳定 最好O(n) 最坏O(n^2) 平均O(n^2) 参考 冒泡排序-go ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","summary":"Bubble Sort","title":"冒泡排序"},{"content":"排序算法的执行效率 最好情况、最坏情况、平均情况时间复杂度 时间复杂度的系数、常数 、低阶 比较次数和交换（或移动）次数 排序算法的内存消耗 原地排序 排序算法的稳定性 ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","summary":"排序算法的执行效率 最好情况、最坏情况、平均情况时间复杂度 时间复杂度的系数、常数 、低阶 比较次数和交换（或移动）次数 排序算法的内存消耗 原地排序 排","title":"如何分析排序算法"},{"content":"如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝） 的方式来创建新对象，以达到节省创建时间的目的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class Demo { private HashMap\u0026lt;String, SearchWord\u0026gt; currentKeywords=new HashMap\u0026lt;\u0026gt;(); private long lastUpdateTime = -1; public void refresh() { // 原型模式就这么简单，拷贝已有对象的数据，更新少量差值 HashMap\u0026lt;String, SearchWord\u0026gt; newKeywords = (HashMap\u0026lt;String, SearchWord\u0026gt;) currentKeywords.clone(); // 浅拷贝 // 从数据库中取出更新时间\u0026gt;lastUpdateTime的数据，放入到newKeywords中 List\u0026lt;SearchWord\u0026gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime); long maxNewUpdatedTime = lastUpdateTime; for (SearchWord searchWord : toBeUpdatedSearchWords) { if (searchWord.getLastUpdateTime() \u0026gt; maxNewUpdatedTime) { maxNewUpdatedTime = searchWord.getLastUpdateTime(); } if (newKeywords.containsKey(searchWord.getKeyword())) { SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword()); oldSearchWord.setCount(searchWord.getCount()); oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime()); } else { newKeywords.put(searchWord.getKeyword(), searchWord); } } lastUpdateTime = maxNewUpdatedTime; currentKeywords = newKeywords; } private List\u0026lt;SearchWord\u0026gt; getSearchWords(long lastUpdateTime) { // TODO: 从数据库中取出更新时间\u0026gt;lastUpdateTime的数据 return null; } } 深拷贝和浅拷贝 浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。\n深拷贝\n方法一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class Demo { private HashMap\u0026lt;String, SearchWord\u0026gt; currentKeywords=new HashMap\u0026lt;\u0026gt;(); private long lastUpdateTime = -1; public void refresh() { // Deep copy HashMap\u0026lt;String, SearchWord\u0026gt; newKeywords = new HashMap\u0026lt;\u0026gt;(); for (HashMap.Entry\u0026lt;String, SearchWord\u0026gt; e : currentKeywords.entrySet()) { SearchWord searchWord = e.getValue(); SearchWord newSearchWord = new SearchWord( searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime()); newKeywords.put(e.getKey(), newSearchWord); } // 从数据库中取出更新时间\u0026gt;lastUpdateTime的数据，放入到newKeywords中 List\u0026lt;SearchWord\u0026gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime); long maxNewUpdatedTime = lastUpdateTime; for (SearchWord searchWord : toBeUpdatedSearchWords) { if (searchWord.getLastUpdateTime() \u0026gt; maxNewUpdatedTime) { maxNewUpdatedTime = searchWord.getLastUpdateTime(); } if (newKeywords.containsKey(searchWord.getKeyword())) { SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword()); oldSearchWord.setCount(searchWord.getCount()); oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime()); } else { newKeywords.put(searchWord.getKeyword(), searchWord); } } lastUpdateTime = maxNewUpdatedTime; currentKeywords = newKeywords; } private List\u0026lt;SearchWord\u0026gt; getSearchWords(long lastUpdateTime) { // TODO: 从数据库中取出更新时间\u0026gt;lastUpdateTime的数据 return null; } } 方法二 1 2 3 4 5 6 7 8 9 10 public Object deepCopy(Object object) { ByteArrayOutputStream bo = new ByteArrayOutputStream(); ObjectOutputStream oo = new ObjectOutputStream(bo); oo.writeObject(object); ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray()); ObjectInputStream oi = new ObjectInputStream(bi); return oi.readObject(); } 深浅结合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Demo { private HashMap\u0026lt;String, SearchWord\u0026gt; currentKeywords=new HashMap\u0026lt;\u0026gt;(); private long lastUpdateTime = -1; public void refresh() { // Shallow copy HashMap\u0026lt;String, SearchWord\u0026gt; newKeywords = (HashMap\u0026lt;String, SearchWord\u0026gt;) currentKeywords.clone(); // 从数据库中取出更新时间\u0026gt;lastUpdateTime的数据，放入到newKeywords中 List\u0026lt;SearchWord\u0026gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime); long maxNewUpdatedTime = lastUpdateTime; for (SearchWord searchWord : toBeUpdatedSearchWords) { if (searchWord.getLastUpdateTime() \u0026gt; maxNewUpdatedTime) { maxNewUpdatedTime = searchWord.getLastUpdateTime(); } if (newKeywords.containsKey(searchWord.getKeyword())) { newKeywords.remove(searchWord.getKeyword()); } newKeywords.put(searchWord.getKeyword(), searchWord); } lastUpdateTime = maxNewUpdatedTime; currentKeywords = newKeywords; } private List\u0026lt;SearchWord\u0026gt; getSearchWords(long lastUpdateTime) { // TODO: 从数据库中取出更新时间\u0026gt;lastUpdateTime的数据 return null; } } 参考 原型模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","summary":"Prototype Pattern","title":"原型模式"},{"content":"把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校 验通过之后才会创建对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 public class ResourcePoolConfig { private String name; private int maxTotal; private int maxIdle; private int minIdle; private ResourcePoolConfig(Builder builder) { this.name = builder.name; this.maxTotal = builder.maxTotal; this.maxIdle = builder.maxIdle; this.minIdle = builder.minIdle; } //...省略getter方法... //我们将Builder类设计成了ResourcePoolConfig的内部类。 //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。 public static class Builder { private static final int DEFAULT_MAX_TOTAL = 8; private static final int DEFAULT_MAX_IDLE = 8; private static final int DEFAULT_MIN_IDLE = 0; private String name; private int maxTotal = DEFAULT_MAX_TOTAL; private int maxIdle = DEFAULT_MAX_IDLE; private int minIdle = DEFAULT_MIN_IDLE; public ResourcePoolConfig build() { // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等 if (StringUtils.isBlank(name)) { throw new IllegalArgumentException(\u0026#34;...\u0026#34;); } if (maxIdle \u0026gt; maxTotal) { throw new IllegalArgumentException(\u0026#34;...\u0026#34;); } if (minIdle \u0026gt; maxTotal || minIdle \u0026gt; maxIdle) { throw new IllegalArgumentException(\u0026#34;...\u0026#34;); } return new ResourcePoolConfig(this); } public Builder setName(String name) { if (StringUtils.isBlank(name)) { throw new IllegalArgumentException(\u0026#34;...\u0026#34;); } this.name = name; return this; } public Builder setMaxTotal(int maxTotal) { if (maxTotal \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;...\u0026#34;); } this.maxTotal = maxTotal; return this; } public Builder setMaxIdle(int maxIdle) { if (maxIdle \u0026lt; 0) { throw new IllegalArgumentException(\u0026#34;...\u0026#34;); } this.maxIdle = maxIdle; return this; } public Builder setMinIdle(int minIdle) { if (minIdle \u0026lt; 0) { throw new IllegalArgumentException(\u0026#34;...\u0026#34;); } this.minIdle = minIdle; return this; } } } // 这段代码会抛出IllegalArgumentException，因为minIdle\u0026gt;maxIdle ResourcePoolConfig config = new ResourcePoolConfig.Builder() .setName(\u0026#34;dbconnectionpool\u0026#34;) .setMaxTotal(16) .setMaxIdle(10) .setMinIdle(12) .build(); 与工厂模式有何区别？ 工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复 杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。\n参考 建造者模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"Builder Pattern","title":"建造者模式"},{"content":"简单工厂 Simple Factory 根据key返回符合某一接口的实现\n方式一\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class RuleConfigSource { public RuleConfig load(String ruleConfigFilePath) { String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension); if (parser == null) { throw new InvalidRuleConfigException( \u0026#34;Rule config file format is not supported: \u0026#34; + ruleConfigFilePath); } String configText = \u0026#34;\u0026#34;; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; } private String getFileExtension(String filePath) { //...解析文件名获取扩展名，比如rule.json，返回json return \u0026#34;json\u0026#34;; } } public class RuleConfigParserFactory { public static IRuleConfigParser createParser(String configFormat) { IRuleConfigParser parser = null; if (\u0026#34;json\u0026#34;.equalsIgnoreCase(configFormat)) { parser = new JsonRuleConfigParser(); } else if (\u0026#34;xml\u0026#34;.equalsIgnoreCase(configFormat)) { parser = new XmlRuleConfigParser(); } else if (\u0026#34;yaml\u0026#34;.equalsIgnoreCase(configFormat)) { parser = new YamlRuleConfigParser(); } else if (\u0026#34;properties\u0026#34;.equalsIgnoreCase(configFormat)) { parser = new PropertiesRuleConfigParser(); } return parser; } } 方式二\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class RuleConfigParserFactory { private static final Map\u0026lt;String, RuleConfigParser\u0026gt; cachedParsers = new HashMap\u0026lt;\u0026gt;(); static { cachedParsers.put(\u0026#34;json\u0026#34;, new JsonRuleConfigParser()); cachedParsers.put(\u0026#34;xml\u0026#34;, new XmlRuleConfigParser()); cachedParsers.put(\u0026#34;yaml\u0026#34;, new YamlRuleConfigParser()); cachedParsers.put(\u0026#34;properties\u0026#34;, new PropertiesRuleConfigParser()); } public static IRuleConfigParser createParser(String configFormat) { if (configFormat == null || configFormat.isEmpty()) { return null;//返回null还是IllegalArgumentException全凭你自己说了算 } IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase()); return parser; } } 尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加 parser，也没有太多的 parser）是没有问题的。\n工厂方法 Factory Method 为了把创建对象的函数放到map\u0026lt;string, Factory\u0026gt;中, 所以又把工厂给抽象成接口了.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public interface IRuleConfigParserFactory { IRuleConfigParser createParser(); } public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new JsonRuleConfigParser(); } } public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new XmlRuleConfigParser(); } } public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new YamlRuleConfigParser(); } } public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new PropertiesRuleConfigParser(); } } public class RuleConfigSource { public RuleConfig load(String ruleConfigFilePath) { String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension); if (parserFactory == null) { throw new InvalidRuleConfigException(\u0026#34;Rule config file format is not supported: \u0026#34; + ruleConfigFilePath); } IRuleConfigParser parser = parserFactory.createParser(); String configText = \u0026#34;\u0026#34;; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; } private String getFileExtension(String filePath) { //...解析文件名获取扩展名，比如rule.json，返回json return \u0026#34;json\u0026#34;; } } //因为工厂类只包含方法，不包含成员变量，完全可以复用， //不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。 public class RuleConfigParserFactoryMap { //工厂的工厂 private static final Map\u0026lt;String, IRuleConfigParserFactory\u0026gt; cachedFactories = new HashMap\u0026lt;\u0026gt;(); static { cachedFactories.put(\u0026#34;json\u0026#34;, new JsonRuleConfigParserFactory()); cachedFactories.put(\u0026#34;xml\u0026#34;, new XmlRuleConfigParserFactory()); cachedFactories.put(\u0026#34;yaml\u0026#34;, new YamlRuleConfigParserFactory()); cachedFactories.put(\u0026#34;properties\u0026#34;, new PropertiesRuleConfigParserFactory()); } public static IRuleConfigParserFactory getParserFactory(String type) { if (type == null || type.isEmpty()) { return null; } IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase()); return parserFactory; } } 基本上符合开闭原则\n抽象工厂 Abstract Factory 应用场景比较特殊，没有前两种常用\nFactory接口中包含更多种类的create()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public interface IConfigParserFactory { IRuleConfigParser createRuleParser(); ISystemConfigParser createSystemParser(); //此处可以扩展新的parser类型，比如IBizConfigParser } public class JsonConfigParserFactory implements IConfigParserFactory { @Override public IRuleConfigParser createRuleParser() { return new JsonRuleConfigParser(); } @Override public ISystemConfigParser createSystemParser() { return new JsonSystemConfigParser(); } } public class XmlConfigParserFactory implements IConfigParserFactory { @Override public IRuleConfigParser createRuleParser() { return new XmlRuleConfigParser(); } @Override public ISystemConfigParser createSystemParser() { return new XmlSystemConfigParser(); } } // 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码 参考 简单工厂-go 工厂方法-go 抽象工厂-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","summary":"Factory Pattern","title":"工厂模式"},{"content":"Once 的使用场景 1 func (o *Once) Do(f func()) Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源。\n如何实现一个 Once？ 很多人认为实现一个 Once 一样的并发原语很简单\n1 2 3 4 5 6 7 8 9 10 type Once struct { done uint32 } func (o *Once) Do(f func()) { if !atomic.CompareAndSwapUint32(\u0026amp;o.done, 0, 1) { return } f() } 就是如果参数 f 执行很慢的话，后续调用 Do 方法的 goroutine 虽然看到 done 已经设置为执行过了，但是获取某些初始化资源的时候可能会得到空的资源\n一个正确的 Once 实现要\n使用一个互斥锁保证只有一个 goroutine 进行初始化 利用双检查的机制（double-checking），再次判断 o.done 是否为 0，如果为 0，则是第一次执行，执行完毕后，就将 o.done 设置为 1，然后释放锁。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type Once struct { done uint32 m Mutex } func (o *Once) Do(f func()) { if atomic.LoadUint32(\u0026amp;o.done) == 0 { o.doSlow(f) } } func (o *Once) doSlow(f func()) { o.m.Lock() defer o.m.Unlock() // 双检查 if o.done == 0 { defer atomic.StoreUint32(\u0026amp;o.done, 1) f() } } ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/once/","summary":"Once 的使用场景 1 func (o *Once) Do(f func()) Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源。 如何实现一个 On","title":"Once"},{"content":"Go 标准库提供 Cond 原语的目的是，为等待/通知场景下的并发问题提供支持。\nCond 的基本用法 1 2 3 4 5 type Cond func NeWCond(l Locker) *Cond func (c *Cond) Broadcast() func (c *Cond) Signal() func (c *Cond) Wait() Cond 关联的 Locker 实例可以通过 c.L 访问，它内部维护着一个先入先出的等待队列。 Signal 方法，允许调用者 Caller 唤醒一个等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等待队 列中有一个或者多个等待的 goroutine，则需要从等待队列中移除第一个 goroutine 并把它唤醒。 调用 Signal 方法时，不强求你一定要持有 c.L 的锁。 Broadcast 方法，允许调用者 Caller 唤醒所有等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等 待队列中有一个或者多个等待的 goroutine，则清空所有等待的 goroutine，并全部唤醒。 调用 Broadcast 方法时，也不强求你一定持有 c.L 的锁。 Wait 方法，会把调用者 Caller 放入 Cond 的等待队列中并阻塞，直到被 Signal 或者 Broadcast 的方法从等待队列中移除并唤醒。 调用 Wait 方法时必须要持有 c.L 的锁。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func main() { c := sync.NewCond(\u0026amp;sync.Mutex{}) var ready int for i := 0; i \u0026lt; 10; i++ { go func(i int) { time.Sleep(time.Duration(rand.Int63n(10)) * time.Second) // 加锁更改等待条件 c.L.Lock() ready++ c.L.Unlock() log.Printf(\u0026#34;运动员#%d 已准备就绪\\n\u0026#34;, i) // 广播唤醒所有的等待者 c.Broadcast() }(i) } c.L.Lock() for ready != 10 { c.Wait() log.Println(\u0026#34;裁判员被唤醒一次\u0026#34;) } c.L.Unlock() //所有的运动员是否就绪 log.Println(\u0026#34;所有运动员都准备就绪。比赛开始，3，2，1, ......\u0026#34;) } Cond 的使用其实没那么简单。它的复杂在于：\n这段代码有时候需要加锁，有时候可以不加； Wait 唤醒后需要检查条件； 条件变量的更改，其实是需要原子操作或者互斥锁保护的。 Cond 的实现原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 type Cond struct { noCopy noCopy // 当观察或者修改等待条件的时候需要加锁 L Locker // 等待队列 notify notifyList checker copyChecker } func NewCond(l Locker) *Cond { return \u0026amp;Cond{L: l} } func (c *Cond) Wait() { c.checker.check() // 增加到等待队列中 t := runtime_notifyListAdd(\u0026amp;c.notify) c.L.Unlock() // 阻塞休眠直到被唤醒 runtime_notifyListWait(\u0026amp;c.notify, t) c.L.Lock() } func (c *Cond) Signal() { c.checker.check() runtime_notifyListNotifyOne(\u0026amp;c.notify) } func (c *Cond) Broadcast() { c.checker.check() runtime_notifyListNotifyAll(\u0026amp;c.notify) } runtime_notifyListXXX 是运行时实现的方法，实现了一个等待 / 通知的队列。 copyChecker 是一个辅助结构，可以在运行时检查 Cond 是否被复制使用。 Signal 和 Broadcast 只涉及到 notifyList 数据结构，不涉及到锁。 Wait 把调用者加入到等待队列时会释放锁，在被唤醒之后还会请求锁。在阻塞休眠期间，调用者是不持有锁的，这样能让其他 goroutine 有机会检查或者更新 等待变量。 Cond为什么不能被Channel替代 Cond 和一个 Locker 关联，可以利用这个 Locker 对相关的依赖条件更改提供保护。 Cond 可以同时支持 Signal 和 Broadcast 方法，而 Channel 只能同时支持其中一种。 Cond 的 Broadcast 方法可以被重复调用。等待条件再次变成不满足的状态后，我们又可以调用 Broadcast 再次唤醒等待的 goroutine。这也是 Channel 不能支持的，Channel 被 close 掉了之后不支持再 open。 有限容量队列实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;sync\u0026#34; ) type Queue struct { cond *sync.Cond data []interface{} capc int logs []string } func NewQueue(capacity int) *Queue { return \u0026amp;Queue{cond: \u0026amp;sync.Cond{L: \u0026amp;sync.Mutex{}}, data: make([]interface{}, 0), capc: capacity, logs: make([]string, 0)} } func (q *Queue) Enqueue(d interface{}) { q.cond.L.Lock() defer q.cond.L.Unlock() for len(q.data) == q.capc { q.cond.Wait() } // FIFO入队 q.data = append(q.data, d) // 记录操作日志 q.logs = append(q.logs, fmt.Sprintf(\u0026#34;En %v\\n\u0026#34;, d)) // 通知其他waiter进行Dequeue或Enqueue操作 q.cond.Broadcast() } func (q *Queue) Dequeue() (d interface{}) { q.cond.L.Lock() defer q.cond.L.Unlock() for len(q.data) == 0 { q.cond.Wait() } // FIFO出队 d = q.data[0] q.data = q.data[1:] // 记录操作日志 q.logs = append(q.logs, fmt.Sprintf(\u0026#34;De %v\\n\u0026#34;, d)) // 通知其他waiter进行Dequeue或Enqueue操作 q.cond.Broadcast() return } func (q *Queue) Len() int { q.cond.L.Lock() defer q.cond.L.Unlock() return len(q.data) } func (q *Queue) String() string { var b strings.Builder for _, log := range q.logs { // fmt.Fprint(\u0026amp;b, log) b.WriteString(log) } return b.String() } ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/cond/","summary":"Go 标准库提供 Cond 原语的目的是，为等待/通知场景下的并发问题提供支持。 Cond 的基本用法 1 2 3 4 5 type Cond func NeWCond(l Locker) *Cond func (c *Cond) Broadcast() func (c *Cond) Signal() func (c *Cond) Wait() Cond 关联的 Locker 实例可","title":"Cond 条件变量"},{"content":"递归需要满足的三个条件 一个问题的解可以分解为几个子问题的解 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 注意 递归代码要警惕堆栈溢出 递归代码要警惕重复计算 在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。 在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销 ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%80%92%E5%BD%92/","summary":"递归需要满足的三个条件 一个问题的解可以分解为几个子问题的解 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 注意","title":"递归"},{"content":"一个类只允许创建一个对象（或者实例）\n为什么要使用单例？ 处理资源访问冲突 表示全局唯一类 实现一个单例 私有构造方法 线程安全的创建实例 是否延迟加载 getInstance()性能是否高 饿汉式 立即初始化 如果有外部依赖时, 可能会初始化失败 1 2 3 4 5 6 7 8 9 10 11 public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static final IdGenerator instance = new IdGenerator(); private IdGenerator() {} public static IdGenerator getInstance() { return instance; } public long getId() { return id.incrementAndGet(); } } 懒汉式 延迟加载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static IdGenerator instance; private IdGenerator() {} public static synchronized IdGenerator getInstance() { if (instance == null) { instance = new IdGenerator(); } return instance; } public long getId() { return id.incrementAndGet(); } } 双重检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static IdGenerator instance; private IdGenerator() {} public static IdGenerator getInstance() { if (instance == null) { synchronized(IdGenerator.class) { // 此处为类级别的锁 if (instance == null) { instance = new IdGenerator(); } } } return instance; } public long getId() { return id.incrementAndGet(); } } 实际上，上述实现方式存在问题：CPU 指令重排序可能导致在 IdGenerator 类的对象被关键字 new 创建并赋值给 instance 之后，还没来得及初始化（执行 构造函数中的代码逻辑），就被另一个线程使用了。这样，另一个线程就使用了一个没有完整初始化的 IdGenerator 类的对象。要解决这个问题，我们只需要给 instance 成员变量添加 volatile 关键字来禁止指令重排序即可。\n静态内部类 一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。 instance 的唯一性、创建过程的线程安全 性，都由 JVM 来保证。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class IdGenerator { private AtomicLong id = new AtomicLong(0); private IdGenerator() {} private static class SingletonHolder{ private static final IdGenerator instance = new IdGenerator(); } public static IdGenerator getInstance() { return SingletonHolder.instance; } public long getId() { return id.incrementAndGet(); } } 枚举 这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。\n1 2 3 4 5 6 7 8 public enum IdGenerator { INSTANCE; private AtomicLong id = new AtomicLong(0); public long getId() { return id.incrementAndGet(); } } 参考 单例模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","summary":"Singleton Pattern","title":"单例模式"},{"content":"WaitGroup 的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type WaitGroup struct { // 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则 noCopy noCopy // 64bit(8bytes)的值分成两段，高32bit是计数值，低32bit是waiter的计数 // 另外32bit是用作信号量的 // 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样，具体处理看下面的方法 // 总之，会找到对齐的那64bit作为state，其余的32bit做信号量 state1 [3]uint32 } // 得到state的地址和信号量的地址 func (wg *WaitGroup) state() (statep *uint64, semap *uint32) { if uintptr(unsafe.Pointer(\u0026amp;wg.state1))%8 == 0 { // 如果地址是64bit对齐的，数组前两个元素做state，后一个元素做信号量 return (*uint64)(unsafe.Pointer(\u0026amp;wg.state1)), \u0026amp;wg.state1[2] } else { // 如果地址是32bit对齐的，数组后两个元素用来做state，它可以用来做64bit的原子操作，第一个元素32bit用来做信号量 return (*uint64)(unsafe.Pointer(\u0026amp;wg.state1[1])), \u0026amp;wg.state1[0] } } 在 64 位环境下，state1 的第一个元素是 waiter 数，第二个元素是 WaitGroup 的计数值，第三个元素是信号量。\n在 32 位环境下，如果 state1 不是 64 位对齐的地址，那么 state1 的第一个元素是信号量，后两个元素分别是 waiter 数和计数值。\nAdd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func (wg *WaitGroup) Add(delta int) { statep, semap := wg.state() // 高32bit是计数值v，所以把delta左移32，增加到计数上 state := atomic.AddUint64(statep, uint64(delta)\u0026lt;\u0026lt;32) v := int32(state \u0026gt;\u0026gt; 32) // 当前计数值 w := uint32(state) // waiter count if v \u0026gt; 0 || w == 0 { return } // 如果计数值v为0并且waiter的数量w不为0，那么state的值就是waiter的数量 // 将waiter的数量设置为0，因为计数值v也是0,所以它们俩的组合*statep直接设置为0即可。此时需要并唤醒所有的waiter *statep = 0 for ; w != 0; w-- { runtime_Semrelease(semap, false, 0) } } // Done方法实际就是计数器减1 func (wg *WaitGroup) Done() { wg.Add(-1) } Wait Wait 方法的实现逻辑是：不断检查 state 的值。如果其中的计数值变为了 0，那么说明所有的任务已完成，调用者不必再等待，直接返回。如果计数值大于 0， 说明此时还有任务没完成，那么调用者就变成了等待者，需要加入 waiter 队列，并且阻塞住自己。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func (wg *WaitGroup) Wait() { statep, semap := wg.state() for { state := atomic.LoadUint64(statep) v := int32(state \u0026gt;\u0026gt; 32) // 当前计数值 w := uint32(state) // waiter的数量 if v == 0 { // 如果计数值为0, 调用这个方法的goroutine不必再等待，继续执行它后面的逻辑即可 return } // 否则把waiter数量加1。期间可能有并发调用Wait的情况，所以最外层使用了一个for循环 if atomic.CompareAndSwapUint64(statep, state, state+1) { // 阻塞休眠等待 runtime_Semacquire(semap) // 被唤醒，不再阻塞，返回 return } } } 使用 WaitGroup 的正确姿势是，预先确定好 WaitGroup 的计数值，然后调用相同次数的 Done 完成相应的任务。\n总结 ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/waitgroup/","summary":"WaitGroup 的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type WaitGroup struct { // 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则 noCopy noCopy // 64bit(8","title":"WaitGroup"},{"content":"先进者先出，这就是典型的“队列”。\n循环队列 要想写出没有 bug 的循环队列的实现代码最关键的是，确定好队空和队满的判定条件。\n队空 head == tail 队满 head == (tail+1)%n 阻塞队列 就是在队列为空的时候，从队头取数据会被阻塞 果队列已经满了，那么插入数据的操作就会被阻塞 并发队列 线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存 或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。\n","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%98%9F%E5%88%97/","summary":"先进者先出，这就是典型的“队列”。 循环队列 要想写出没有 bug 的循环队列的实现代码最关键的是，确定好队空和队满的判定条件。 队空 head == tail 队满 head == (tail+1)%n 阻塞","title":"队列"},{"content":"栈是一种“操作受限”的线性表\n","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%A0%88/","summary":"栈是一种“操作受限”的线性表","title":"栈"},{"content":"命名 命名长度 作用域大的长点 作用域小的短点 利用上下文简化命令 属性名可以不加user 1 2 3 4 5 6 public class User { private String userName; private String userPassword; private String userAvatarUrl; //... } 函数参数 1 2 3 public void uploadUserAvatarImageToAliyun(String userAvatarImageUri); //利用上下文简化为： public void uploadUserAvatarImageToAliyun(String imageUri); 命名要可读、可搜索 大概能读出个音就行 大家都用“selectXXX”表示查询，你就不要用“queryXXX”；大家都用“insertXXX”表示插入一条数据，你就要不用“addXXX” 命名接口和抽象类 接口 实现 IUserService UserService UserService UserServiceImpl 对于抽象类, 比如AbstractConfiguration可以不加Abstract\n注释 写什么 做什么 为什么 怎么做 注释是不是越多越好？ 类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的 可读性。 代码风格 类、函数多大才合适？ 对于函数代码行数的最大限制，网上有一种说法，那就是不要超过一个显示屏的垂直高度。 对于类的代码行数的最大限制, 当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功 能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数过多了。 一行代码多长最合适？ 一行代码最长不能超过 IDE 显示的宽度。需要滚动鼠标才能查看一行的全部代码，显然不利于代码的阅读。 善用空行分割单元块 四格缩进还是两格缩进？ go中没有这个问题 不要用tab 大括号是否要另起一行？ go中没有这个问题 类中成员的排列顺序 go中字段顺序影响内存占用(内存对齐) 技巧 把大块代码分割成更小的单元块 避免函数参数过多 勿用函数参数来控制逻辑 不要使用bool参数 不要使用参数是否为null 函数设计要职责单一 移除过深的嵌套层次 学会使用解释性变量 常量取代魔法数字 1 2 3 4 5 6 7 8 9 public double CalculateCircularArea(double radius) { return (3.1415) * radius * radius; } // 常量替代魔法数字 public static final Double PI = 3.1415; public double CalculateCircularArea(double radius) { return PI * radius * radius; } 使用解释性变量来解释复杂表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 if (date.after(SUMMER_START) \u0026amp;\u0026amp; date.before(SUMMER_END)) { // ... } else { // ... } // 引入解释性变量后逻辑更加清晰 boolean isSummer = date.after(SUMMER_START)\u0026amp;\u0026amp;date.before(SUMMER_END); if (isSummer) { // ... } else { // ... } 代码质量checklist 常规checklist\n目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？ 是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？ 设计模式是否应用得当？是否有过度设计？ 代码是否容易扩展？如果要添加新功能，是否容易实现？ 代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？ 代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？ 代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？ 业务需求checklist\n代码是否实现了预期的业务需求？ 逻辑是否正确？是否处理了各种异常情况？ 日志打印是否得当？是否方便 debug 排查问题？ 接口是否易用？是否支持幂等、事务等？ 代码是否存在并发问题？是否线程安全？ 性能是否有优化空间，比如，SQL、算法是否可以优化？ 是否有安全漏洞？比如输入输出校验是否全面？ ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%A7%84%E8%8C%83/","summary":"命名 命名长度 作用域大的长点 作用域小的短点 利用上下文简化命令 属性名可以不加user 1 2 3 4 5 6 public class User { private String userName; private String userPassword; private String userAvatarUrl; //... } 函数参数 1 2 3 public void","title":"规范"},{"content":"为什么要重构（why）？ 保证代码质量 对工程师本身技术成长有意义 到底重构什么（what）？ 大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这 类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入 bug 的风 险也会相对比较大。\n小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。小型重构更多 的是利用我们能后面要讲到的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入 bug 的风险相对来说也会比较小。\n什么时候重构（when）？ 持续重构\n平时没有事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合 编码规范、不好的设计重构一下。总之，就像把单元测试、Code Review 作为开发的一部分\n如何重构（how）？ 在进行大型重构的时候，我们要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后， 再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，我们都要控制好重构影响到的代码范围，考虑好如何兼容老的代码 逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，我们才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新的功能开发相冲突。\n大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。而小规模低层次的重构，因为影响范围小，改动耗时短，所 以，只要你愿意并且有时间，随时都可以去做。实际上，除了人工去发现低层次的质量问题，我们还可以借助很多成熟的静态代码分析工具（比如 CheckStyle、 FindBugs、PMD），来自动发现代码中的问题，然后针对性地进行重构优化。\n对于重构这件事情，资深的工程师、项目 leader 要负起责任来，没事就重构一下代码，时刻保证代码质量处在一个良好的状态。否则，一旦出现“破窗效应”，一个 人往里堆了一些烂代码，之后就会有更多的人往里堆更烂的代码。毕竟往项目里堆砌烂代码的成本太低了。不过，保持代码质量最好的方法还是打造一种好的技术氛围， 以此来驱动大家主动去关注代码质量，持续重构代码。\n保证重构不出错的手段 单元测试 mock 重构手段 解耦 封装与抽象 中间层 模块化 单一职责原则 基于接口而非实现编程 依赖注入 多用组合少用继承 迪米特法则 观察者模式 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%87%8D%E6%9E%84/","summary":"为什么要重构（why）？ 保证代码质量 对工程师本身技术成长有意义 到底重构什么（what）？ 大型重构指的是对顶层代码设计的重构，包括：系统、模块","title":"重构"},{"content":"Law of Demeter, 迪米特法则\n另外一个更加达意的名字: 最小知识原则, The Least Knowledge Principle\n每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。 或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。 用接口隔离\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/lod/","summary":"Law of Demeter, 迪米特法则 另外一个更加达意的名字: 最小知识原则, The Least Knowledge Principle 每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “clo","title":"LOD"},{"content":"Don’t Repeat Yourself。\n考虑几方面\n实现逻辑重复 功能语义重复 代码执行重复 怎么提高代码复用性？\n减少代码耦合 满足单一职责原则 模块化 业务与非业务逻辑分离 通用代码下沉 继承、多态、抽象、封装 应用模板等设计模式 泛型 复用意识 Rule of Three 第一次编写代码的时候，我们不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/dry/","summary":"Don’t Repeat Yourself。 考虑几方面 实现逻辑重复 功能语义重复 代码执行重复 怎么提高代码复用性？ 减少代码耦合 满足单一职责原则 模块化 业务与非业","title":"DRY"},{"content":"You Ain’t Gonna Need It。你不会需要它.\n不要做过度设计。 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/yagni/","summary":"You Ain’t Gonna Need It。你不会需要它. 不要做过度设计。","title":"YAGNI"},{"content":" Keep It Simple and Stupid. Keep It Short and Simple. Keep It Simple and Straightforward. 如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/kiss/","summary":"Keep It Simple and Stupid. Keep It Short and Simple. Keep It Simple and Straightforward. 如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”","title":"KISS"},{"content":"Single Responsibility Principle, 单一职责原则\n一个类或者模块只负责完成一个职责（或者功能）。\n如何判断类的职责是否足够单一？\n并没有一个非常明确的、可以量化的标准 下面这几条判断原则，比起很主观地去思考类是否职责单一，要更有指导意义、更具有可执行性：\n类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分； 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分； 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性； 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰； 类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应 的方法拆分出来。 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/solid/srp/","summary":"Single Responsibility Principle 单一职责原则","title":"SRP"},{"content":"Open Closed Principle, 开闭原则\n软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。\n在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、 职责链、状态等）。\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/solid/ocp/","summary":"Open Closed Principle 开闭原则","title":"OCP"},{"content":"Liskov Substitution Principle, 里式替换原则\n子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证 原来程序的逻辑行为（behavior）不变及正确性不被破坏。\nLSP与多态的区别\n里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。 替换前后的行为一模一样\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/solid/lsp/","summary":"Liskov Substitution Principle 里式替换原则","title":"LSP"},{"content":"Interface Segregation Principle, 接口隔离原则\n客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/solid/isp/","summary":"Interface Segregation Principle 接口隔离原则","title":"ISP"},{"content":"IOC Inversion Of Control, 控制反转\n流程的控制权从程序员“反转”到了框架。 控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。 DI Dependency Injection, 依赖注入\n一种具体的编码技巧 不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。 优点\n提高了代码的扩展性，我们可以灵活地替换依赖的类。 DIP Dependency Inversion Principle, 依赖反转原则/依赖倒置原则\n高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象 （abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。\n调用者属于高层，被调用者属于低层 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/solid/dip/","summary":"Dependency Inversion Principle 依赖反转原则/依赖倒置原则","title":"DIP"},{"content":"贫血模型(Anemic Domain Model)将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。\n充血模型(Rich Domain Model)，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。\n基于贫血模型的开发模式, 不夸张地讲，我们平时的开发，大部分都是 SQL 驱动（SQL-Driven）的开发模式。我们接到一个后端接口的开发需求的时候，就去 看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写 SQL 语句来获取数据。之后就是定义 Entity、BO、VO，然后模板式地往对应 的 Repository、Service、Controller 类中添加代码。业务逻辑包裹在一个大的 SQL 语句中，而 Service 层可以做的事情很少。SQL 都是针对特定的 业务功能编写的，复用性差。当我要开发另一个业务功能的时候，只能重新写个满足新需求的 SQL 语句，这就可能导致各种长得差不多、区别很小的 SQL 语句满 天飞。所以，在这个过程中，很少有人会应用领域模型、OOP 的概念，也很少有代码复用意识。 基于充血模型的 DDD 的开发模式，需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都 基于之前定义好的这些领域模型来完成。 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B/","summary":"贫血模型(Anemic Domain Model)将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。 充血模型(Rich Domain Mode","title":"贫血模型与充血模型"},{"content":"抽象类的特性 (代码复用, 多态特性)\n不允许实例化, 只能被继承 可以包含属性和方法 子类继承抽象类, 必须实现抽象方法 接口的特性 (代码复用, 解耦)\n不能包含属性 只能声明方法 类必须实现接口所有方法 如何决定该用抽象类还是接口？\n从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。 而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"抽象类的特性 (代码复用, 多态特性) 不允许实例化, 只能被继承 可以包含属性和方法 子类继承抽象类, 必须实现抽象方法 接口的特性 (代码复用, 解耦) 不能","title":"接口与抽象类的区别"},{"content":" 滥用getter, setter违反封装特性 是否公开了不应该公开的 滥用全局变量和全局方法违反封装特性 是否有必要放到全局 定义数据和方法分离的类 MVC ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81%E7%9C%8B%E4%BC%BC%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%AE%9E%E9%99%85%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/","summary":"滥用getter, setter违反封装特性 是否公开了不应该公开的 滥用全局变量和全局方法违反封装特性 是否有必要放到全局 定义数据和方法分离的类 MVC","title":"哪些代码看似是面向对象 实际是面向过程"},{"content":"一、股票组合搭建步骤 每个月或每个季度定期调整组合，在选股时要综合考虑几点因素 宏观环境和经济周期导向，如货币政策宽松时可适当多配成长风格类个股，通货膨胀严重时重点精选周期类个股（但同样要避免行业过度集中的问题）； 个股业绩导向，即近期财报表现不佳的个股少配或不配，多选择业绩较好或有向好预期的个股； 消息面导向，当股票池中某行业有政策催化因素（如2020年中新能源政策利好不断），或个股有“消息引火索”（如新冠疫情利好智飞生物、英科医疗等抗疫题 材股）时，都可以在当月或当季组合中做一定配置。 在“海选”出个股后，每只股票视估值情况赋予8%～15%的仓位占比，原则上估值偏高的低配，估值偏低的高配。再看好的股票，仓位占比也不建议超过资金的 20%。 分析每只股票的行业特性。分清楚目标个股是属于强周期行业（如能源、钢铁），还是抗周期行业（如消费、医药）甚至逆周期行业（低端消费行业、部分科技企 业）。同一级行业个股持仓占比不建议超过30%，尽量做到行业分散周期对冲，避免出现组合由于行业过分集中暴涨暴跌的情况，而且充分分散行业能够获得更稳 健的收益。 二、组合成份股的调整 如个股出现重大风险事件股价暴跌时，要果断移出。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E7%B2%BE%E9%80%89%E4%B8%AA%E8%82%A1%E5%81%9A%E7%BB%84%E5%90%88/","summary":"一、股票组合搭建步骤 每个月或每个季度定期调整组合，在选股时要综合考虑几点因素 宏观环境和经济周期导向，如货币政策宽松时可适当多配成长风格类个股","title":"第二节 精选个股做组合"},{"content":"一、构建股票池的意义 A股近4000只股票，多数股票仅适合短线投机，只有少部分好股才有长期持有价值。经过层层筛选的股票基本面可靠程度较高，踩雷的概率会降低许多。\n在框定股票池后，就不会被海量的个股乱花渐欲迷人眼。只需要和自己最熟悉的股票打交道，跟踪公司的业绩表现和新闻动态，当基本面、技术面或消息面出现交易信 号时，能迅速做出反应。买卖动作都有逻辑，就不会在机会来临时行动滞后，风险加大时还浑然不觉。\n二、如何打造股票池 股票池应由小扩大，研究明白一个纳入一个\n造股票池的建议如下\n股票数量：不宜过多，以30～100只为宜。道理很简单，机构有强大的研究资源支持，可以同时覆盖三五百只股票。而个人能力和精力都有限，贪多求全反而适得其 反。 覆盖行业：要足够分散。市场风格是轮动的，除个别能够保持长期强势的行业外，多数行业容易在各领风骚数个月后归入沉寂。股票池中涵盖多个行业和题材，会方 便我们在政策性、趋势性投资机会出现时选配个股。 选股因子, 营收增速、净利润增速、自由现金流、净资产收益率、毛利率和分红率，这类指标对选股非常重要。 表9-1　2021年版“潴100股票池”\n新人基本面分析功底弱？没关系，还有一种偷懒的方法——抄机构作业。\n天天基金网、私募排排网 三、股票池的管理 成分股出现由盈转亏、涉及诉讼或被他国制裁一类的坏消息不打紧，只要不是会导致基本面重大变化的利空都可以不急于移出股票池。但如果有财务造假、实控人或管 理团队道德品质败坏等原则性问题，应该第一时间进行调整。\n股价走势和估值变动也需要定期跟踪，但其变化并不是调入或调出股票池的主要原因。\n打造股票池的核心目标在于缩小研究范围，在去粗取精精耕细作精益求精后，最终将为选定投资组合保驾护航。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E8%82%A1%E7%A5%A8%E6%B1%A0/","summary":"一、构建股票池的意义 A股近4000只股票，多数股票仅适合短线投机，只有少部分好股才有长期持有价值。经过层层筛选的股票基本面可靠程度较高，踩雷","title":"第一节 打造个人专属股票池"},{"content":"再融资是指上市公司通过配股、增发和发债等方式，在证券市场上进行直接融资。\n一、公开增发／定向增发 IPO是上市公司首次公开发行股票向市场募资，增发则是已上市企业出于某种目的再融资而再次发行股票的行为，主要分为公开增发和定向增发两种。无论哪种形式均 需满足组织机构健全、管理层勤勉尽职、财务状况和盈利能力不存在明显瑕疵等条件，故能获准增发的企业基本面一般不会太糟糕。\n公开增发因条件苛刻近年少见, 原股东持有的股票并不增加，但总股本增加后一般会导致同期每股账面权益（净资产值）增加，同期每股收益会被摊薄，因此公开增 发通常被视为利空。 定向增发较为常见. 公开增发稀释原股东权益的影响同样存在，且为顺利完成再融资，发行价一般会在当前股价基础上有一定比例折让，锁定期满后解禁还存在抛售 隐忧（公开增发无锁定期），即便参与方不减持，也可能因避险情绪引发股价短线下挫。 二、配股 配股原理与增发类似，区别在于未引进新股东，而是向原股东们按持股比例配售一定数量的新发行股票。配股价会较市价有所折让，总股本增加同样存在稀释每股权益 的问题，因此一般被视为利空。\n持股者如无意参与配股，一定要在缴款起始日前卖出（一般上市公司会在这天开始停牌），否则会因除权承受亏损。\n三、发债／发可转债 普通债券发行属于中性消息，当然如果负债成本过高，发债后负债率过高，或融资用途仅仅是借新还旧，也会引起市场对其基本面的质疑。\n可转债是持有人既可以持有到期获取本息，又可以在满足一定条件的情况下将债券转换为股票的，兼具债性和股性的特殊债券。对上市公司而言，可转债融资成本 （利率）比普通公司债低，如果可转债持有人最终选择转股更几乎是没有成本。但对原股东而言，若转股在理论上存在类似增发或配股稀释权益的负面影响。因此，可转债发行时也会给原股东优选认购权。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%B6%88%E6%81%AF/%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%86%8D%E8%9E%8D%E8%B5%84%E5%AF%B9%E4%B8%AA%E8%82%A1%E7%9A%84%E5%BD%B1%E5%93%8D/","summary":"再融资是指上市公司通过配股、增发和发债等方式，在证券市场上进行直接融资。 一、公开增发／定向增发 IPO是上市公司首次公开发行股票向市场募资，增","title":"第三节 再融资对个股的影响"},{"content":"一、业绩报告 季报、半年报和年报等定期财报公开披露，是对短线股价影响最明显的一大消息类型。一季报的集中披露期在4月，半年报在7—8月，三季报在10月，年报则必须在次 年的4月前完成对外披露。财报披露前后股价容易鸡飞狗跳，这也是4、7、10月等财报月个股分化程度和市场波动一般较其他月份大的原因。\n判断业绩好坏不能只单纯看营业收入和净利润等数字大小，除了要比较扣除非经常性损益后的净利润情况，并考虑同／环比增速、对照期基数是否正常和股价相对位置 高低外, 还有一个极重要的参考因素——业绩是否“超预期”，“业绩超预期”或“不及预期”才是很多老手和机构买入或卖出股票的经典策略。\n二、业绩预告和快报 业绩预告和快报同样有预期引领功能。\n按规定，深交所主板上市公司年报、半年报和三季报如出现净利润为负或扭亏为盈，或与上年同期相比上升或下降50%以上等情况须进行业绩预告，一季报预告不做强 制披露要求。 上交所主板、科创板和深交所创业板，仅对符合上述条件（创业板还多一条：期末净资产为负）的企业有年报预告要求，一季报、半年报和三季报均无要求。 业绩快报现在也属于企业自愿披露事项，盈利情况较好、有市值管理需求的企业可能会用这种方式“剧透”业绩。 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%B6%88%E6%81%AF/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E4%B8%9A%E7%BB%A9%E6%8A%AB%E9%9C%B2%E5%AF%B9%E4%B8%AA%E8%82%A1%E7%9A%84%E5%BD%B1%E5%93%8D/","summary":"一、业绩报告 季报、半年报和年报等定期财报公开披露，是对短线股价影响最明显的一大消息类型。一季报的集中披露期在4月，半年报在7—8月，三季报在","title":"第二节 业绩披露对个股的影响"},{"content":"一、真消息与假消息 对消息真假的判断要结合来源是否权威、内容是否符合逻辑、市场有无异动等因素综合考虑。\n一般真消息曝出前后综合指数、行业指数或个股多少会有异动，市场波澜不惊则多半属于假消息。如若市场因假消息异动，在利好证伪后要迅速撤离避免损失扩大，利 空证伪后可考虑补回被谣言制造者骗取的筹码。\n二、公开消息与内幕消息 等你自以为拿到绝密消息如获至宝地追高买入，多半就是去接盘啦！\n证券市场有严格的信息披露制度，投资者完全可以通过合法合规的手段收集关于目标企业的相关信息（本章第三节会展开介绍）。多看正规媒体新闻报道，多读财报研 报跟踪企业基本面消息面变化，少听信微博大V、亲朋好友或张三李四的“八手消息”，才是一个成熟投资者应有的“消息观”。\n三、有实质影响的消息和无效消息 需要思考的是，这种消息对企业的业绩改善有任何实质性作用吗？\n四、宏观消息、行业消息与个股消息 宏观经济和行业、个股基本面的变化，及各类突发事件，共同组成了消息面。\n宏观面的消息包括GDP、PMI、社融等经济数据公布，存款准备金、存贷款利率和印花税等货币财政政策调整，长远经济规划（如“一带一路”“十四五”），重大会议 （如“两会”、中央经济工作会议）和区域建设规划（如雄安新区、海南自贸区建设）以及国际地缘政治经济事件等，其影响往往较全面、重大和深远。\n行业性消息影响不了全局，但足够让某个板块内的一众个股鸡飞狗跳。行业性利好自然是你好我好大家好，行业性黑天鹅的影响则需要辩证看待。\n一般而言，对行业进行整改整顿或提出某些约束性措施的监管政策，从长远看对行业龙头较有利。 要擅于捕捉行业黑天鹅带来的逆势抄底机会，而不是一见所谓利空就躲得老远，不敢再碰。 个股的消息更多更杂，既包括引发基本面（估值）变化的事项，如业绩提升或下降、并购重组、定向增发、回购（注销）、分红、高送转、签订重大合同等，又包括会 激起股价巨震的突发事件，如实控人死亡或犯罪、管理团队变动、企业违规或犯罪被罚、财务造假被曝光、安全生产事故等。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%B6%88%E6%81%AF/%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%B6%88%E6%81%AF%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E5%BD%B1%E5%93%8D/","summary":"一、真消息与假消息 对消息真假的判断要结合来源是否权威、内容是否符合逻辑、市场有无异动等因素综合考虑。 一般真消息曝出前后综合指数、行业指数或个","title":"第一节 消息的分类及其对市场的影响"},{"content":"一、K线的基本原理 图7-8　标准K线的结构\n以日K线为例讲解K线基本原理\n当日收盘价高于开盘价时收阳线，低于开盘价时收阴线。\n对阳线而言，最高价高于收盘价的差值部分用上影线体现，最低价低于开盘价的差值部分用下影线体现。\n对阴线来说，最高价高于开盘价的差值部分用上影线体现，最低价低于收盘价的差值部分用下影线体现\n如果当日开盘价较前一交易日高开较多，即便收盘价低于开盘价收阴线，但还是高于前一日收盘价。这样的阴线其实还是收涨的，所以被称为“假阴线”。\n反之，如果当日开盘价较前一交易日低开较多，即便收盘价高于开盘价收阳线，但还是低于前一日收盘价，这样的阳线被称为“假阳线”。\n假阳线和假阴线在震荡行情中意义不大，但如果在趋势性上涨或下跌一段时间后出现，则有可能是行情扭转的信号。\n二、12种K线形状 图7-9　12种基本K线形状\n2^3 * 2 - 4 = 12\n表7-1　各K线名称及意义\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8A%80%E6%9C%AF/%E7%AC%AC%E5%9B%9B%E8%8A%82-k%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%A4%BA%E4%BE%8B/","summary":"一、K线的基本原理 图7-8 标准K线的结构 以日K线为例讲解K线基本原理 当日收盘价高于开盘价时收阳线，低于开盘价时收阴线。 对阳线而言，最高价高于","title":"第四节 K线技术简介及示例(上)"},{"content":"看懂分时图的含义是解读市场和个股行情，展开各类技术分析的必经之路。很多超短线高手仅靠盘口数据和分时图形就能观察多空交战情况，判断主力动向，进而对后 市走向做出预判。分时图分为指数分时图和个股分时图，二者基本要素类似，只是细节上略有差别。\n一、大盘分时图示例 图7-4　上证指数分时图\n图形的左边是指数点位，右侧是涨跌幅度。横轴以每分钟为单位向前推进，成交量在图形底部以红绿白色等柱子的形式展示。正常交易日全天共4个小时，一共会出 240(4*60)根柱子。 当某一分钟收涨时买方占优显示红柱，反之出绿柱。 全天开盘和收盘两个时间段因为集合竞价前后成交都会更密集，成交量柱都会较其他时间更长。 零轴附近的柱子则是反映即时所有股票的买盘与卖盘在数量上的比率，红柱线的增长减短表示上涨买盘力量的增减，绿柱线的增长缩短表示下跌卖盘力度的强弱。 关注度更高的是粗的那根白线，它体现的是加权平均法下的上证指数。即既考虑个股股价，也考虑个股的股本，大盘股股本越大所占权重越大，故而对指数影响力也 就越大。而黄线代表的“领先指标”，则是运用算术平均法，不考虑股本差别，通过将所有股票的价格简单相加后平均计算得出。 二、个股分时图示例 图7-5　山西汾酒分时图\n多了一根分时均价线 以盘口总成交额除以总成交量的运算方式计算每一股即时的平均成交价，能精确统计当前所有参与者的持仓成本。 靠股价走势线和分时均价线关系分辨当日个股强弱的规律：\n当股价持续在均价线上方运行时，表明市场预期较好，买盘踊跃，当天介入的大部分资金都能赚钱，这是盘口强势特征； 当股价持续在均价线下方运行时，表明市场预期较差，卖盘踊跃，当天介入的大部分资金都亏钱，属弱势特征； 当均价线从低位持续上扬时，表明市场预期提高，投资者纷纷入场推动股价上涨，综合持仓成本不断抬高，对股价形成支撑； 当均价线从高位持续下挫时，表明市场预期较差，投资者纷纷离场迫使股价下跌，综合持仓成本不断下降，对股价形成压制。 三、其他分时技术分析术语 图7-7　陕西煤业分时盘口信息\n买卖五档 在每天买卖的委托单中，这是多空各方交易意图的直接体现。\n委比和委差 相比看买卖五档，委比是以数值比例的方式，更直观体现某一时段买卖盘相对强度的指标。\n其计算公式是委比=（委买手数－委卖手数）/（委买手数+委卖手数）×100%，取值范围为±100%。 当委比为正值时说明买方占优，数值越大买方实力越强，委比为负值说明卖方占优。 当委比值为+100%时个股涨停，反之个股则惨遭跌停。 委差是用大盘或个股的买单总量减去卖单总量，反映买卖双方力道对比。正数为买方占优，负数为卖方更强。\n换手率 换手率是指在单位时间内，某只个股的累计成交量与其流通股本之间的比率，反映的是单个股票的筹码流通情况，一般讨论较多的是每日换手率。\n量比 量比是衡量相对成交量的指标，是指股市开市后平均每分钟的成交量与过去5个交易日平均每分钟成交量之比。通常认为量比为0.8～1.5属于正常状态，而如果低于或 高于这一阈值则是出现了缩量或放量，特别是量比数值低于0.5倍或高于2.5倍时要重点留意股价走势。\n内盘和外盘 所谓内盘，是指按照买方已经挂好的价格成交的主动性卖盘，越大表示主动性抛盘越多。而外盘则刚好相反，是指按卖方已经挂好的价格成交的主动性买盘，越大表示 主动买入的资金越多。二者加起来就是总成交量。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%88%86%E6%97%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%A4%BA%E4%BE%8B/","summary":"看懂分时图的含义是解读市场和个股行情，展开各类技术分析的必经之路。很多超短线高手仅靠盘口数据和分时图形就能观察多空交战情况，判断主力动向，进","title":"第三节 分时技术简介及示例"},{"content":"一、K线流 K线流旨在用图形的方式记录指数和个股价格在每个时间段的变化，注重研究K线及其组合形态的规律，借以判断市场中多空力量的对比，并凭此预测后市运行态势。\n图7-2　K线图灵感来源于蜡烛\n二、切线流 切线流的逻辑基础是前文讲述的技术分析三大假设中的“价格以趋势方式演变”，其核心玩法是按一定原则和方法在价格图中画出直线，并据此预判指数或个股价格的未 来趋势。这些直线或平或斜，对价格起着支撑或压力的作用，被统称为“切线”。\n寻找和绘制对后市价格走向有影响的切线的方法有很多，典型的包括趋势线法、通道线法、黄金分割线法、百分比线法、扇形线法、甘氏线法等。如今专业一点的炒股 软件都会自带绘制各类切线的功能，使用比较简单\n严格意义上的切线特指直线，因此均线、布林线等同样旨在寻找支撑和压力的技术理论不能归为其中，这是很多人容易混淆的地方。但这类“找线”或“找点”的方法本质 原理是相近的，配合起来使用，效果会更好。\n三、形态流 形态流信徒们立足点更为宏大，注重观察较长一段时间价格走势的变化。他们笃信“历史会重演”：当指数或股价以某种典型波动轨迹出现时，复现其历史上有过的走势 的概率较大。\n从大的类型上看，形态可以分为持续整理和反转突破两种。持续整理形态是价格尽管有或上或下的变化，但总体是沿原来的运行趋势行进。反转突破形态则是多空双方 打破了原有的“默契”，运行趋势出现根本性变化，出现这类形态的苗头时，要提防变盘。\n四、指标流 指标流中理科生云集，尤其受到有数学或计算机背景的股民追捧。和偏直观感受的K线、切线和形态流不同，他们专注于研究各类记录股市运行特征的参数和技术指标， 通过数据强弱的变化判断价格趋势的涨跌，并运用于指导买入卖出实战。这种方法相对更重视数据的客观性，尽量少掺杂个人的主观判断。因此有相当多的指标流技术 派在计算机编程技术的帮助下，完成了向量化派的转变。\n技术指标如弱水三千，可只取三瓢饮。选定学习和熟悉三个技术指标足以应对市场上的各类变化，个人建议必须掌握的是MA和MACD两个趋势指标，并辅之以另一个震 荡指标即可。\nMA（移动平均线）、MACD（指数平滑异同移动平均线） 五、波浪流 波浪理论的开创者是美国人拉尔夫·纳尔逊·艾略特，他认为股票价格的运动遵循自然界波浪起伏的规律，将股价上升期分为五浪，其中又可以细分1/3/5三个奇数上升浪和2/4两个偶数调整浪；股价下跌期分为A/B/C三浪，其中A和C是下跌浪，B是反弹浪\n大浪套中浪，中浪套小浪，一浪之后还有一浪。千人千浪，每一个数浪大师都能把浪花拨弄得天花乱坠。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E7%9A%84%E4%BA%94%E5%A4%A7%E6%B5%81%E6%B4%BE/","summary":"一、K线流 K线流旨在用图形的方式记录指数和个股价格在每个时间段的变化，注重研究K线及其组合形态的规律，借以判断市场中多空力量的对比，并凭此预","title":"第二节 技术分析方法的五大流派"},{"content":"如果因为个人能力问题无法驾驭好一匹马，怎么能对马破口大骂，而不反躬自省？\n一、技术分析及量价时空 技术分析是以K线、均线、切线和波浪等图形为主要工具，判断股票、债券和期货等金融交易品种在量、价、时、空等四方面的变化趋势，并以结论指导下一步交易动 作的研究方法。\n量即成交量，价即价格。\n分析大盘指数时用到的是全市场的成交量和指数点位 具体到个股时是单只股票的成交量和成交价格。 市场参与主体有机构、游资、散户等等，但最终落实到交易本身只分买方和卖方，成交量就是买卖双方就指数或个股价格达成共识时产生的交易额。\n在各级别技术走势图中，时间表现为横轴，表征空间的纵轴体现的则是价格波动的幅度\n图7-1　量价时空示意\n当你熟悉技术分析后，会发现所有的方法都只是在努力解释和辨清量价时空四要素之间的关系，只是不同技术流派侧重点各有不同。如K线和均线分析法重点研究价格 趋势，布林线分析法研究价格和空间，波浪理论则重在研究时空关系。而那些所谓的技术分析高手，不过是比一般人对这四个字的理解程度更深一些，对各门学问间的 融会贯通做得较好些罢了。\n二、技术分析的三大假设 第一条：市场行为包容消化一切。在纯粹的技术派看来，任何影响市场的政治、经济、心理因素，以及它们的一切变化，都将完全被指数或股价的波动所反映。 第二条：价格以趋势方式演变。技术派相信趋势一旦形成，价格会朝阻力最小的方向运动，如果没有外力干预，将按惯性继续沿已形成的趋势前进。只有当某种外力 打破现有平衡时，才会出现具有操作指导意义的拐点信号。 第三条：历史会重演, 但绝不是细节上简单复现。 三、如何正确理解技术分析的价值 技术分析能较好地帮助散户抓住盈利机会，并避免深陷雷区 技术分析水平到一定程度后，能通过对量价时空的判断把握大盘整体走向和个股的买入、卖出机会。\n技术分析只是交易方法体系中的一环而远非全部 不同方法应对不同风格的市场也各有长短\n技术分析的结果必须用“概率思维”对待 分析结论只是提供预判，最后结果正确与否必须交给市场印证。而一旦出错，必须采取措施果断纠偏。\n技术分析应用于预判指数比预测个股准确率更高。技术分析某种程度上可视为集体心理的自我实现\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E5%AF%B9%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E7%9A%84%E6%84%8F%E4%B9%89/","summary":"如果因为个人能力问题无法驾驭好一匹马，怎么能对马破口大骂，而不反躬自省？ 一、技术分析及量价时空 技术分析是以K线、均线、切线和波浪等图形为主要","title":"第一节 技术分析对股票投资的意义"},{"content":"一、绝对估值法的逻辑基础 上市公司的内在价值，是将预期未来现金流，按照反映其风险的折现率，进行折现后的现值加总。\n对估值法的分支有很多，其中使用率较高且便于初学者掌握的，主要是现金股利折现模型（Dividend Discount Model，简称DDM）和自由现金流折现模型 （Free Cash Flow for the Firm，简称FCFF）两种。它们都属于广义的现金流折现法（Discounted Cash Flow，简称DCF），分别通过测算上市公司未来 的现金股利或自由现金流，实现估算公司股票内在价值的目的。但无论何种方法，理解什么是“折现”都是展开学习的前提。\n二、折现与折现率 折现，也叫贴现，是指将未来现金流折算成等价现值的过程。\n折现率，本质是资产未来预计取得的收益率水平，未来可以是一年、三年或者更长。\n根据公式定义，未来收益的现值=未来收益绝对值/（1+折现率）^n，n为与折现率匹配的折现期数（如以年收益率作为折现率，则n=需要折现的年数）； 如未来有多笔收益，则现值为每一笔收益折现到当前时点的数值之和。 三、折现率的应用 不同现金流的选择 现在有A、B两笔现金流，哪一笔更好呢？\nA：一年后得到10 000元，两年后再得到10 000元； B：一年后无所得，两年后一次性得到20 500元。 假设预期收益率是4%，即以4%作为折现率。\nA现金流：一年后得到10 000元，两年后再得到10 000元，相当于当前时点马上得到约18 861元\n图6-7　A现金流计算步骤\nB现金流：一年后无收入，两年后得到2.05万元，相当于当前时点马上得到约18 953元\n图6-8　B现金流计算步骤\n由于B现金流的18 953元现值大于A现金流的18 861元现值，因此B现金流要优于A现金流。\n此处的18 861元和18 953元有一个专门的名称——净现值（Net Present Value，NPV），是指未来资金流入的现值与未来资金流出的现值之间的差额。\n不同投资项目的选择 C：初始投入2万元，一年后追加投入8万元，两年后退出项目获得11万元，项目结束； D：初始一次性投入10万元，一年后部分退出获得5万元，两年后全部退出获得6万元，项目结束。 以4%的折现率为例\nC项目的净现值为0.48万元 图6-9　C项目净现值计算步骤\n同理可计算出D项目的净现值约为0.36万元，因此在4%折现率之下，项目C优于项目D。 影响净现值的核心因素主要包括以下三点：\n未来现金流的大小。未来现金流净流入越大，折现到当前的NPV就越高。 折现率的高低。折现率越低，折现到当前的NPV就越高。 折现周期的长短。折现期数越短，现金流折现到当前的NPV就越高。 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BC%B0%E5%80%BC/%E7%AC%AC%E4%B8%83%E8%8A%82-%E7%BB%9D%E5%AF%B9%E4%BC%B0%E5%80%BC%E6%B3%95%E4%BB%8B%E7%BB%8D/","summary":"一、绝对估值法的逻辑基础 上市公司的内在价值，是将预期未来现金流，按照反映其风险的折现率，进行折现后的现值加总。 对估值法的分支有很多，其中使用","title":"第七节 绝对估值法介绍"},{"content":"很多人喜欢用指数点位来判断当前时点是否存在泡沫、是否值得出手投资。客观讲，这种思路可能并不适用于所有个股的买卖择时。\n将指数分位值理解为对某一市场或某一行业所有成份股的“集体估值”并知道如何使用即可。\n一、指数分位怎么用 指数估值\n根据当前估值处于历史估值的位置来判断性价比 二、指数分位估值法使用要点 理论上分位值越小，风险越低。但分位值体现的只是历史，并不能用于预测未来。 不要把指数点位与个股时机的判断混为一谈。指数分位值高，可能也有性价比很高的个股机会；指数分位值再低，也不能代表所有的个股都有投资价值。 部分指数成立时间晚，历史年限短，分位值参考价值较低 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BC%B0%E5%80%BC/%E7%AC%AC%E5%85%AD%E8%8A%82-%E6%8C%87%E6%95%B0%E5%88%86%E4%BD%8D%E4%BC%B0%E5%80%BC%E6%B3%95%E4%BB%8B%E7%BB%8D/","summary":"很多人喜欢用指数点位来判断当前时点是否存在泡沫、是否值得出手投资。客观讲，这种思路可能并不适用于所有个股的买卖择时。 将指数分位值理解为对某一","title":"第六节 指数分位估值法介绍"},{"content":"一、市销率是什么 公司总市值=每股股价×公司总股本 公司营业收入=每股营业收入×公司总股本 市销率=公司总市值／公司营业收入 市销率=公司总市值／公司营业收入=每股股价／每股营业收入\n二、市销率用在哪儿 亏损的企业\n三、市销率估值法使用要点 企业收入的构成中也存在着与主业相关性较低的收入成分。因此在计算市销率过程中，营业收入通常选用“主营业务收入”。\n市销率以收入作为评价的主要依据，因此收入的质量就尤为关键。\n当企业存在应收账款账期较长、坏账率较高、应收票据占比较大等情况时，会对市销率的使用效果起到负面影响。 在使用市销率的时候，务必要关注企业利润表各项的结构及其合理性，客观分析企业尚未盈利的真实原因。\n表6-9　三种估值方法对比\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BC%B0%E5%80%BC/%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%B8%82%E9%94%80%E7%8E%87%E4%BC%B0%E5%80%BC%E6%B3%95%E4%BB%8B%E7%BB%8D/","summary":"处于亏损阶段的企业，市盈率基本不适用, 应使用市销率","title":"第五节 市销率估值法介绍"},{"content":" 公司总市值=每股股价×公司总股本 公司净利润=每股净利润×公司总股本 市盈率=公司总市值/公司净利润 市盈率=公司总市值/公司净利润=每股股价/每股净利润\n市盈率的本质就是静态投资回报周期\n前提，公司的现金分红率必须为100%（现金分红率=现金分红额／可分配净利润总额） 一、常见的几种市盈率 静态市盈率：公司当前总市值／公司前一会计年度净利润（上市公司须以年报公告为准）\n静态市盈率的主要缺点在于，上市公司T年的年报一般会在T+1年的3—4月才会公告 动态市盈率：公司当前总市值／公司未来会计年度净利润，比如现在是2021年上半年，动态市盈率一般表达为PE（21E）、PE（22E），分别代表公司当前总市值与 2021年预测全年净利润、2022年预测全年净利润的比率。\n动态市盈率的主要缺点在于，未来年度净利润全部为预测值。如果预测结果过于乐观，会造成分母过大，有动态市盈率计算结果被低估的风险。 滚动市盈率：公司当前总市值／公司最近四个季度的净利润之和（上市公司须以公告为准）. 一般以PE（TTM）表示\n滚动市盈率较前两者都更加精确，也是最为广泛使用的市盈率口径。 假设A公司的总市值是50亿，目前2020年年报尚未公布\n表6-7　A公司净利润假设\n静态市盈率\nPE=50/3.67=13.64（等到2020年年报公告后，分母换成2020年全年净利润） 动态市盈率\nPE（21E）=50/5.28=9.47 PE（22E）=50/6.34=7.89 滚动市盈率\nPE（TTM）=50/（1+0.8+1.5+0.9）=11.9 40倍市盈率（无特别说明的情况下，均指滚动市盈率）的股票，和4%收益率（相当于25倍市盈率）的理财，选择前者的原因主要有两个：\n判断公司未来净利润会保持增长，将市盈率逐步摊薄至25倍以下； 或判断理财未来收益率会下降，理财产品对应的市盈率逐步提高至40倍以上（第一点的影响一般会更大）。 二、市盈率相对盈利增长比率（PEG） PEG指标中的PE即PE（TTM），G指的是未来（一般不少于3年）净利润平均增速（Growth），PEG=PE/（G×100）。\n假设B公司2020年PE（TTM）为25倍\n表6-8　B公司净利润及增速假设\n粗略计算未来三年业绩的平均增速约为20%，根据公式可得出，PEG=25/（20%×100）=1.25。\n对于PEG指标，通常认为当PEG\u0026gt;1时的价格偏高，PEG\u0026lt;1时的价格偏低。当然不同行业的参照值也存在差异\n夕阳行业可以将PEG与0.8对比，朝阳行业可以将PEG与1.2对比 大多数情况下，同一行业内PEG低的企业相对安全一些；同一企业的不同时点，PEG低的时候相对安全一些 三、市盈率估值法使用要点 在某些情况下，净利润的增长并不能带来每股净利润的提高。比如上市公司定向增发 建议使用“扣除非经常性损益后的净利润”作为分母另行计算，更能体现出企业主营业务真实利润情况对应的估值水平。 在大多数软件中，无论何种口径的市盈率，基本都是选用全口径净利润作为分母。 全口径包含投资收益、资产处置、政府补贴等不规律因素的影响（一般统称为“非经常性损益”）。 谨防估值陷阱, 市净率看资产质量，市盈率看业绩成长。 只有一种情况下市盈率为负，那就是标的公司处于亏损状态（市值或股价最低为零，不会为负）。 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BC%B0%E5%80%BC/%E7%AC%AC%E5%9B%9B%E8%8A%82-%E5%B8%82%E7%9B%88%E7%8E%87%E4%BC%B0%E5%80%BC%E6%B3%95%E4%BB%8B%E7%BB%8D/","summary":"公司总市值=每股股价×公司总股本 公司净利润=每股净利润×公司总股本 市盈率=公司总市值/公司净利润 市盈率=公司总市值/公司净利润=每股股价/每","title":"第四节 市盈率估值法介绍"},{"content":"一、市净率是什么 公司总市值=每股股价×公司总股本 公司净资产=每股净资产×公司总股本 市净率=公司总市值/公司净资产 市净率=公司总市值/公司净资产=每股股价/每股净资产\n二、市净率运用要点 市净率估值方法对于标的公司资产质量的敏感度较高, 资产越重的企业，资产质量就越为关键\n市净率估值法多用于如钢铁、煤炭等资产规模较大的重资产行业，以及如银行、地产等净资产规模较大的资金密集型行业。 使用市净率估值方法，以下几个问题尤为重要。\n如何判断重资产公司的资产质量？ 市净率越低代表风险越小吗？ 在市净率维度下，如何设定安全边际？ 三、康美药业案例：关于企业资产质量的判断 有钱也不还 公司每年宁可支付越来越高的财务费用，也不肯用几百亿元的货币资金去偿还几十亿元的短期借款（短期借款一般为一年期借款，不存在无法提前偿还的问题）。\n表6-1　康美药业历年货币资金、短期借款和财务费用统计\n不用也不还 长年均未出现大额资金缺口，且没有过高的投资需求，为什么不肯偿还几十亿元的有息负债？\n表6-2　康美药业历年经营活动和投资活动现金流净额统计\n还了继续借 一家公司资金充足，却每年都要玩筹资活动的现金流游戏\n表6-3　康美药业历年债务相关现金收付情况统计\n四、模拟案例：市净率低并不等于风险小（同行业横向对比） 表6-4　A、B公司简化资产负债表\n假设目前市场给予两家公司的估值均为1亿元，通过计算可以得出，A公司对应的市净率约为4.35倍（1亿元/0.23亿元），B公司对应的市净率约为1.82倍 （1亿元/0.55亿元）。如果仅从市净率的角度看，能否直接得出结论：B公司比A公司便宜呢？\n答案是不能。两家公司的资产质量不同，直接以市净率的比较判断贵或便宜，也是不科学的。\nB公司仍然存在以下问题：\n应收票据如为商业承兑汇票，存在无法足额兑付的风险； 应收账款虽已计提坏账准备，但由于余额较大，存在计提坏账准备金仍不足额的风险； 存货同样可能存在虽然计提了跌价准备金但仍不足额的风险，尤其对于周期类原材料存货，价格剧烈波动是经常发生的； 目前的会计准则下，商誉不涉及摊销，如果商誉是由于收购其他标的形成，且收购标的实际业绩明显未达收购时点的业绩预期，就有可能存在大额减值风险，将直接 削减净资产余额； 短期借款余额较大，货币资金余额无法偿还到期本息的风险。 假设通过对B公司的深度研究，确实发现存在上述风险。为了留出足够的安全边际，对B公司的资产负债表进行调整\n表6-5　A、B公司简化资产负债表（调整后）\n调整后，B公司对应1亿元估值的市净率约为7.14倍。相较于A公司，B公司在市净率维度已不存在价格优势。\n当然，如果通过深度研究排除上述潜在风险，那么B公司仍然具备价格优势。但不论最终的结论如何，都是以对公司的深度研究为基础和前提。 五、招商银行与民生银行对比案例：市净率低并不等于风险小 对于银行来说，影响净资产质量众多因素中，有两个极为关键：不良贷款率和拨备覆盖率。前者是金融机构不良贷款占总贷款余额的比重，越低越好；后者是实际上银 行贷款可能发生的呆、坏账准备金的使用比率，用来衡量银行贷款损失准备金计提是否充足，越高越好。\n表6-6　招商、民生银行历年不良贷款率和拨备覆盖率对比\n图6-1　招商、民生银行PB估值中枢对比\nPB绝对值的高低未必代表股票真正“贵”或“便宜”。请牢记，资产质量才是PB角度下最关键的因素。\n六、招商银行案例：通过自身历史维度（纵向）分析市净率 图6-3　招商银行市净率估值中枢\n在纵向维度上，也要先对上市公司做好充分的研究。如果公司的资产质量在历史长期保持健康稳定并且在未来也无明显恶化风险，PB低等于风险小；如果公司的资产质 量稳定性较差，或者在未来存在恶化风险，则PB低不等于风险小。\n同行业不同公司之间的选择：\n资产质量接近的，选市净率低的； 市净率接近的，选资产质量好的 同一公司不同时点的选择\n资产质量健康稳定以及呈现向好趋势的，在市净率接近历史底部附近时出手买入或加仓 资产质量不稳定甚至有恶化风险的，市净率处于底部也不能盲目操作 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BC%B0%E5%80%BC/%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%B8%82%E5%87%80%E7%8E%87%E4%BC%B0%E5%80%BC%E6%B3%95%E4%BB%8B%E7%BB%8D/","summary":"一、市净率是什么 公司总市值=每股股价×公司总股本 公司净资产=每股净资产×公司总股本 市净率=公司总市值/公司净资产 市净率=公司总市值/公司净资","title":"第三节 市净率估值法介绍"},{"content":"没有任何一种估值工具是完美的、能在所有环境下都完全生效的。\n灵活运用多种估值方法，不要固守某一种方法。 绝对估值法是指，在上市公司基本面分析，以及上市公司未来业绩、财务等因素预测的基础上对其价值进行判断，常见的方法包括现金股利折现和自由现金流折现模型 等。\n相对估值法是在上市公司核心比率、价值指标等基础上，通过寻找同行业、同类型、同周期等各方面最接近的对标企业及相似交易案例，并与其对比分析，从而对上市 公司的价值进行判断，常见的方法包括PE（市盈率）、PB（市净率）和PS（市销率）等。\n需要注意的是，现实投资中两种估值方法的结论并不始终一致，很多情况下二者结论差异极大，甚至会出现结论完全相反的情况。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BC%B0%E5%80%BC/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E4%BC%B0%E5%80%BC%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB/","summary":"没有任何一种估值工具是完美的、能在所有环境下都完全生效的。 灵活运用多种估值方法，不要固守某一种方法。 绝对估值法是指，在上市公司基本面分析，以","title":"第二节 估值方法的分类"},{"content":"脱离价值谈论价格是没有意义的。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BC%B0%E5%80%BC/%E7%AC%AC%E4%B8%80%E8%8A%82-%E4%BC%B0%E5%80%BC%E5%AF%B9%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E7%9A%84%E6%84%8F%E4%B9%89/","summary":"脱离价值谈论价格是没有意义的。","title":"第一节 估值对股票投资的意义"},{"content":"一、三张表之间的关系 总的来说，这三张报表是站在两个不同的视角来看待企业：一是风险视角，通过现金流量表可审视企业能否继续存活；二是收益视角，资产负债表和利润表勾勒出企业 持续经营的模样——有多少家底，经营成绩又究竟如何。\n资产负债表是一个时点报表，其中各科目期初和期末数值的变化，都能通过利润表和现金流量表这两张期间报表反映出来。\n图5-3　三张表勾稽关系示意图\n期末资产=期末负债+期初所有者权益+本期净利润－本年度实际分红\n二、财务指标综合分析 盈利能力指标 盈利能力可分两个维度：一是从销售角度看收入盈利能力，二是从投入角度看资产盈利能力。\n收入盈利能力指标常见的有毛利率、营业利润率、净利率等\n毛利率=（营业收入－营业成本）÷营业收入 营业利润率=（营业收入－营业成本－三大费用）÷营业收入 净利率=净利润÷营业收入 常见的资产盈利能力指标有净资产收益率（ROE）和总资产收益率（ROA）。ROE和ROA是更能够体现企业盈利能力的指标，它不仅考虑了收益的大小，还考虑了收益的 效率问题。其中ROA代表了企业全部资产的获利能力，ROE代表了企业股东的获利能力。\n净资产收益率=净利润÷平均净资产 总资产收益率=净利润÷平均总资产 其中平均净资产和平均总资产可以简单用期初值加上期末值除以2得到。\n偿债能力指标 偿债能力同样分两部分，分别是短期偿债能力和长期偿债能力。\n短期偿债能力的核心思路是流动资产越多，短期偿债能力越强，主要指标是流动比率和速动比率。速动的意思是能够快速变现的流动资产，而存货有时是很难快速变现 的\n动比率=流动资产÷流动负债 速动比率=（流动资产－存货）÷流动负债 对于非重资产企业，流动比率通常在2左右，速动比率通常在1左右，这两个比率不需要过高。\n长期偿债能力是指企业偿还一年以上债务的能力，通常用资产负债率来计算，不过只要企业能够长期盈利，长期偿债能力一般都不存在太大问题。\n资产负债率=负债总额÷资产总额 对企业而言，适当的负债有助于发展，所以这个比率并不是越低越好，通常45%～60%是比较合适的区间。\n判断企业的偿债能力还有一个快速方法，就是看现金及现金等价物能否覆盖所有的有息负债，如果能够覆盖或者相差不大，偿债能力就较强。\n现金流指标 收现率 = 销售商品、提供劳务收到的现金/主营业务收入 现比 = 经营活动现金流量净额/净利润 对于收现率约等于“1+增值税税率”的企业，通常认为其收入的大部分都作为现金收回。而净现比主要体现净利润的质量，大于1时，说明企业每实现1元净利润，实际 可以收到大于1元的现金。需要注意的是，发展期企业净现比通常较小，另外行业差异也会带来较大的净现比差异。\n增长率指标 营业收入增长率=（本期营业收入－上期营业收入）÷上期营业收入 营业利润增长率=（本期营业利润－上期营业利润）÷上期营业利润 净资产增长率=（本期净资产－上期净资产）÷上期净资产 总资产增长率=（本期总资产－上期总资产）÷上期总资产 营运能力指标 企业的回报取决于效益和效率，效益可以用利润率、毛利率表示，效率则可以用各种资产的周转率表示，其公式为\n某类资产周转率=营业收入÷某类资产平均余额 资产的平均余额可以简单地用期初和期末余额之和除以2来计算，不同的资产对应不同的周转率。如存货就是存货周转率，固定资产就是固定资产周转率，应收账款就 是应收账款周转率，总资产就是总资产周转率\n应收账款周转率越高，代表应收账款在本会计年度内转化为现金的次数越多，每次应收账款的回款速度越快。 存货周转率反映公司的存货利用情况。一般来说，存货周转率越高，存货占用的资金越少。但存货周转率太高，会让企业出现供不应求的状态，从而影响企业的收入。 固定资产周转率是衡量厂房和机器设备等固定资产使用效率的比率。这个周转率越大越好，越大就证明固定资产很好，可以带来较多收入。需要注意的是，重资产和 轻资产经营的公司，该项周转率的差异会比较大。 总资产周转率是综合评价企业全部资产经营质量和利用效率的重要指标。总资产周转率越大，证明同样数量的资产产生更多的销售收入，或者同样的销售收入占用更 少的资源。其他各项指标接近的情况下，总资产周转率越大，还可反映企业管理层的资产运用能力越强。 三、最关键的财务指标——ROE ROE是代表企业股东权益的投资报酬率，是评价股东权益财务状况的重要指标。\n净资产收益率=净利润÷净资产=（净利润÷营业收入）×（营业收入÷平均总资产）×（平均总资产÷净资产）=净利润率×总资产周转率×杠杆系数\n高净利润率模式的代表就是贵州茅台 高资产周转率模式的在商超等零售行业中比较普遍 高杠杆模式的典型行业就是金融业 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%A2%E6%8A%A5/%E7%AC%AC%E4%B8%83%E8%8A%82-%E8%B4%A2%E5%8A%A1%E6%8C%87%E6%A0%87%E7%9A%84%E7%BB%BC%E5%90%88%E5%88%86%E6%9E%90/","summary":"一、三张表之间的关系 总的来说，这三张报表是站在两个不同的视角来看待企业：一是风险视角，通过现金流量表可审视企业能否继续存活；二是收益视角，资","title":"第七节 财务指标的综合分析"},{"content":"现金流量表是反映在一定时间内企业经营、投资和筹资活动对其现金及现金等价物流入和流出所产生影响的财务报表。它区别于利润表和资产负债表的一个重要特征， 就是现金流量表采用的是收付实现制，而另两张表都是权责发生制。\n资产负债表和利润表在权责发生制下的很多信息都会被美化，资产可能会被提前确认，利润也会被提前装进去。而现金流量表会更真实地反映当期的现金流动情况，可 以让你看清楚企业的经营情况究竟如何。\n现金和现金等价物与资产负债表中货币资金科目的区别。\n现金和现金等价物有一个非常鲜明的特征，就是在三个月内随时能够为企业所调用。 货币资金科目下的其他货币资金（受限制的钱）和定期存款，前者显然不可能随时被调用；后者存期通常都在一年以上，两者属于货币资金，但不能归为现金等价物。 银行承兑商业汇票能无条件地把现金给持有人，对企业来说基本可以当作现金使用，所以它属于现金及现金等价物的范畴。\n一、现金流量表的要素和结构 表5-8　现金流量表基本格式\n现金流量表主要包含经营、投资、筹资三大部分，分别对应经营活动产生的现金流、投资活动产生的现金流和筹资活动产生的现金流。每一类现金流又分流入和流出两 个方向：每类现金流净额=现金流入总额－现金流出总额。\n现金及现金等价物净增加额 = 经营活动产生的现金流量净额 + 投资活动产生的现金流量净额 + 筹资活动产生的现金流量净额 ± 汇率变动对现金的影响 期末现金及现金等价物余额 = 期初现金及现金等价物余额 + 现金及现金等价物净增加额 二、经营活动现金流 经营活动是指除投资和筹资活动之外的，与企业日常经营相关的所有交易和事项。不同公司业务经营范围不同，所列的各类与现金收付相关的项目也不尽相同\n表5-9　经营活动现金流部分\n需要重点关注的科目是“销售商品、提供劳务收到的现金”。\n通常用该科目金额和营业收入作对比，如果远远小于营业收入，企业可能有大量应收账款被拖欠。这种现象的出现，或者是由于缺乏竞争力，造成账期上的话语权较 弱，或者是企业虚增了收入，无论何种原因都不是好事。 还有一个“支付给职工以及为职工支付的现金”科目值得一提\n这指的是付给职工的工资和奖金，但要注意某些企业该科目的金额并不完全等于企业员工的实际薪酬。因为股权激励作为员工薪酬重要的组成部分，并不会在这里体 现。例如像腾讯、阿里这类互联网企业或某些尚处成长期的公司，会用大量的股权激励来缓解正常形式的工资带来的现金流压力。 优秀企业的经营活动现金流净额不仅大于0，往往还大于净利润。两者接近可说明企业的净利润大多都变成了实实在在的现金，而如果经营活动现金流净额远大于净利 润，则说明企业的应付账款或预收账款比较高，通常是因为产品竞争力突出，或是占据较强的市场地位。\n三、投资活动现金流 投资活动是指企业长期资产的购建和不包括在现金等价物内的投资及其处置活动，包括实物资产投资和金融资产投资两块。\n投资活动现金流的流出项主要包括购买固定资产、无形资产等扩大企业资产规模所支付的现金，以及购买债券、股票或者其他企业股权等支出。流入项主要包括投资本 金的回流，以及相应收益的获取。\n表5-10　投资活动现金流部分\n可以通过投资现金流情况来判断企业当前的发展趋势，净额为正可能预示着扩张速度变慢或者正处于收缩状态。\n对企业投资要重点关注两点：一是投资项目是否在其能力控制范围之内，相当一部分上市公司的跨界投资都算不上成功，毕竟隔行如隔山；二是关注投资收益情况，回 报率至少要大于社会平均回报水平，否则这投资就比较失败，还不如买点理财产品合适。\n四、筹资活动现金流 筹资活动是指导致企业资本及债务规模和构成发生变化的活动，如再次发行股票、向银行贷款、向社会发行债券等。\n筹资活动现金流的流入项目主要包括企业从外部获取资金的进账，现金流流出主要包括企业归还外部资金和相关成本。这部分钱可能是借的（债务性筹资），可能是通 过发股票（权益性筹资）募集而来，对应的成本分别是贷款利息、现金红利等。\n表5-11　筹资活动现金流部分\n投资者需重点观察债务性筹资，如果融资利率较低，说明企业信用评级较好，反之则说明企业可能存在某些瑕疵，令资金融出方提高溢价来覆盖风险。\n五、自由现金流 自由现金流就是在企业通过经营活动赚来的钱中，扣除维持企业正常运转和保持企业竞争力等必要投入后剩余的部分。\n只要企业还要持续发展就必须进行再投资，只有在扣除这些投资之后才能向股东分红。我们常说的只有为股东持续创造价值的上市公司才值得长期持有，指的就是那 些拥有充沛自由现金流的企业。 自由现金流=税后净营业利润+折旧和摊销-资本性支出-营运资金支出\n资本性支出为企业对新增固定资产、无形资产的支出，属于投资活动现金流。 营运资金就是维持企业正常生产经营所需要的资金，其支出=期末－期初。营运资金=（流动资产－货币资金）-（流动负债－短期借款－应付短期债券－一年内到期 的长期借款－一年内到期的应付债券） 单看一年的自由现金流并不全面，投资者同样需要进行企业自身历史纵向和同业横向的对比。根据近几年自由现金流的变化趋势，分析增加或减少的原因。\n六、上市公司的现金流画像 企业的现金流被经营、投资和筹资三种活动分成三类，每类又有净流入（+）、净流出（-）两种状态，排列组合后便得到了八种不同的现金流画像结构\n表5-12　上市公司现金流画像\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%A2%E6%8A%A5/%E7%AC%AC%E5%85%AD%E8%8A%82-%E7%8E%B0%E9%87%91%E6%B5%81%E9%87%8F%E8%A1%A8/","summary":"现金流量表是反映在一定时间内企业经营、投资和筹资活动对其现金及现金等价物流入和流出所产生影响的财务报表。它区别于利润表和资产负债表的一个重要","title":"第六节 上市公司的供血站——现金流量表"},{"content":"9.1 服务器中的数据库 redis.h/redisServer\n1 2 3 4 5 6 7 8 9 struct redisServer { // ... //一个数组，保存着服务器中的所有数据库 redisDb *db; // ... //服务器的数据库数量 int dbnum; // ... }; dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16\n图9-1 服务器数据库示例\n9.2 切换数据库 1 2 3 4 5 6 7 8 9 10 11 12 redis\u0026gt; SET msg \u0026#34;hello world\u0026#34; OK redis\u0026gt; GET msg \u0026#34;hello world\u0026#34; redis\u0026gt; SELECT 2 OK redis[2]\u0026gt; GET msg (nil) redis[2]\u0026gt; SET msg\u0026#34;another world\u0026#34; OK redis[2]\u0026gt; GET msg \u0026#34;another world\u0026#34; 在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库\n1 2 3 4 5 6 typedef struct redisClient { // ... //记录客户端当前正在使用的数据库 redisDb *db; // ... } redisClient; redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。\n图9-2 客户端的目标数据库为1号数据库\n建议显式地切换到指定的数据库，然后才执行命令\n9.3 数据库键空间 redis.h/redisDb\n1 2 3 4 5 6 7 typedef struct redisDb { // ... // 数据库键空间，保存着数据库中的所有键值对 dict *dict; // ... } redisDb; 每个键都是一个字符串对象 每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象 图9-4 数据库键空间例子\n9.3.6 读写键空间时的维护操作 在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个 值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。 在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。 如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作 如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改 过 如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知 9.4 设置键的生存时间或过期时间 通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL）\n客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。\nTTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间\n9.4.1 设置过期时间 实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的\nEXPIRE命令可以转换成PEXPIRE命令 PEXPIRE命令又可以转换成PEXPIREAT命令 EXPIREAT命令也可以转换成PEXPIREAT命令 图9-11 设置生存时间和设置过期时间的命令之间的转换\n9.4.2 保存过期时间 redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：\n过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。 过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。 1 2 3 4 5 6 typedef struct redisDb { // ... //过期字典，保存着键的过期时间 dict *expires; // ... } redisDb; 图9-12 带有过期字典的数据库例子\n为了展示方便，图9-12的键空间和过期字典中重复出现了两次alphabet键对象和book键对象。在实际中，键空间的键和过期字典的键都指向同一个键对象，所以不 会出现任何重复对象，也不会浪费任何空间。\n9.4.3 移除过期时间 PERSIST命令可以移除一个键的过期时间：\n1 2 3 4 5 6 7 8 redis\u0026gt; PEXPIREAT message 1391234400000 (integer) 1 redis\u0026gt; TTL message (integer) 13893281 redis\u0026gt; PERSIST message (integer) 1 redis\u0026gt; TTL message (integer) -1 9.4.4 计算并返回剩余生存时间 TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间：\n1 2 3 4 5 6 redis\u0026gt; PEXPIREAT alphabet 1385877600000 (integer) 1 redis\u0026gt; TTL alphabet (integer) 8549007 redis\u0026gt; PTTL alphabet (integer) 8549001011 TTL和PTTL两个命令都是通过计算键的过期时间和当前时间之间的差来实现的\n9.4.5 过期键的判定 通过过期字典，程序可以用以下步骤检查一个给定键是否过期：\n检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。 检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。 9.5 过期键删除策略 定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。 9.5.1 定时删除 使用定时器\n优点\n尽快删除过期键, 释放内存 缺点\ncpu不友好, 有大量过期键时可能影响响应时间和吞吐量 时间事件使用无序链表, 查找事件事件复杂度O(N), 效率不高 9.5.2 惰性删除 程序只会在取出键时才对键进行过期检查\n优点\ncpu友好 缺点\n内存不友好, 过期了只要不访问就不删除(视为内存泄漏) 9.5.3 定期删除 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。 除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。 定期删除策略的难点是确定删除操作执行的时长和频率：\n9.6 Redis的过期键删除策略 Redis服务器实际使用的是惰性删除和定期删除两种策略\n9.6.1 惰性删除策略的实现 过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查\n图9-15 命令调用expireIfNeeded来删除过期键\n9.6.2 定期删除策略的实现 过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle 函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。\n9.7 AOF、RDB和复制功能对过期键的处理 在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。\n9.7.2 载入RDB文件 在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：\n如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略 如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的 时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。 9.7.3 AOF文件写入 当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。\n当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。\n9.7.4 AOF重写 在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。\n","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC9%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"9.1 服务器中的数据库 redis.h/redisServer 1 2 3 4 5 6 7 8 9 struct redisServer { // ... //一个数组，保存着服务器中的所有数据库 redisDb *db; // ... //服务器的数据库数量 int dbnum; // ... }; dbnum属","title":"第9章 数据库"},{"content":"Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和 有序集合对象这五种类型的对象\n8.1 对象的类型与编码 Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另 一个对象用作键值对的值（值对象）。\nRedis中的每个对象都由一个redisObject结构表示\n1 2 3 4 5 6 7 8 9 typedef struct redisObject { //类型 unsigned type:4; //编码 unsigned encoding:4; //指向底层实现数据结构的指针 void *ptr; // ... } robj; 8.1.1 类型 对象的type属性记录了对象的类型\n表8-1 对象的类型\n对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种\nTYPE命令用于查看值对象的类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #键为字符串对象，值为字符串对象 redis\u0026gt; SET msg \u0026#34;hello world\u0026#34; OK redis\u0026gt; TYPE msg string #键为字符串对象，值为列表对象 redis\u0026gt; RPUSH numbers 1 3 5 (integer) 6 redis\u0026gt; TYPE numbers list #键为字符串对象，值为哈希对象 redis\u0026gt; HMSET profile name Tom age 25 career Programmer OK redis\u0026gt; TYPE profile hash #键为字符串对象，值为集合对象 redis\u0026gt; SADD fruits apple banana cherry (integer) 3 redis\u0026gt; TYPE fruits set #键为字符串对象，值为有序集合对象 redis\u0026gt; ZADD price 8.5 apple 5.0 banana 6.0 cherry (integer) 3 redis\u0026gt; TYPE price zset 8.1.2 编码和底层实现 表8-3 对象的编码\n表8-4 不同类型和编码的对象\n8.2 字符串对象 编码\nint raw embstr 如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成 long），并将字符串对象的编码设置为int。\n图8-1 int编码的字符串对象\n如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的 编码设置为raw。\n图8-2 raw编码的字符串对象\n如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值\n图8-3 embstr编码创建的内存块结构\n图8-4 embstr编码的字符串对象\n如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。\n8.2.1 编码的转换 对于int编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw。\n1 2 3 4 5 6 7 8 9 10 redis\u0026gt; SET number 10086 OK redis\u0026gt; OBJECT ENCODING number \u0026#34;int\u0026#34; redis\u0026gt; APPEND number \u0026#34; is a good number!\u0026#34; (integer) 23 redis\u0026gt; GET number \u0026#34;10086 is a good number!\u0026#34; redis\u0026gt; OBJECT ENCODING number \u0026#34;raw\u0026#34; 因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序, 所以embstr编码的字符串对象实际上是只读的。当我们对embstr编码的字符串对象执行任何 修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。\n1 2 3 4 5 6 7 8 redis\u0026gt; SET msg \u0026#34;hello world\u0026#34; OK redis\u0026gt; OBJECT ENCODING msg \u0026#34;embstr\u0026#34; redis\u0026gt; APPEND msg \u0026#34; again!\u0026#34; (integer) 18 redis\u0026gt; OBJECT ENCODING msg \u0026#34;raw\u0026#34; 8.2.2 字符串命令的实现 表8-7 字符串命令的实现\n8.3 列表对象 编码\nziplist linkedlist 图8-5 ziplist编码的numbers列表对象\n图8-6 linkedlist编码的numbers列表对象\n8.3.1 编码转换 当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：\n列表对象保存的所有字符串元素的长度都小于64字节； 列表对象保存的元素数量小于512个； 不能满足这两个条件的任意一个时, 列表对象需要使用linkedlist编码。\n以上两个条件的上限值是可以修改的，具体请看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 所有元素的长度都小于64 字节 redis\u0026gt; RPUSH blah \u0026#34;hello\u0026#34; \u0026#34;world\u0026#34; \u0026#34;again\u0026#34; (integer)3 redis\u0026gt; OBJECT ENCODING blah \u0026#34;ziplist\u0026#34; #将一个65字节长的元素推入列表对象中 redis\u0026gt; RPUSH blah \u0026#34;wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\u0026#34; (integer) 4 #编码已改变 redis\u0026gt; OBJECT ENCODING blah \u0026#34;linkedlist\u0026#34; 8.3.2 列表命令的实现 表8-8 列表命令的实现\n8.4 哈希对象 编码\nziplist hashtable ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保 存了值的压缩列表节点推入到压缩列表表尾\n图8-9 ziplist编码的profile哈希对象\n图8-10 profile哈希对象的压缩列表底层实现\nhashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：\n字典的每个键都是一个字符串对象，对象中保存了键值对的键； 字典的每个值都是一个字符串对象，对象中保存了键值对的值。 图8-11 hashtable编码的profile哈希对象\n8.4.1 编码转换 当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：\n哈希对象保存的所有键值对的键和值的字符串长度都小于64字节； 哈希对象保存的键值对数量小于512个； 不能满足这两个条件的任意一个时, 哈希对象需要使用hashtable编码。\n这两个条件的上限值是可以修改的，具体请看配置文件中关于hash-max-ziplist-value选项和hash-max-ziplist-entries选项的说明。\n1 2 3 4 5 6 7 8 9 10 11 #哈希对象只包含一个键和值都不超过64个字节的键值对 redis\u0026gt; HSET book name \u0026#34;Mastering C++ in 21 days\u0026#34; (integer) 1 redis\u0026gt; OBJECT ENCODING book \u0026#34;ziplist\u0026#34; #向哈希对象添加一个新的键值对，键的长度为66字节 redis\u0026gt; HSET book long_long_long_long_long_long_long_long_long_long_long_description \u0026#34;content\u0026#34; (integer) 1 #编码已改变 redis\u0026gt; OBJECT ENCODING book \u0026#34;hashtable\u0026#34; 8.4.2 哈希命令的实现 表8-9 哈希命令的实现\n8.5 集合对象 编码\nintset hashtable intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。\n图8-12 intset编码的numbers集合对象\nhashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。\n图8-13 hashtable编码的fruits集合对象\n8.5.1 编码的转换 当集合对象可以同时满足以下两个条件时，对象使用intset编码：\n集合对象保存的所有元素都是整数值； 集合对象保存的元素数量不超过512个。 不能满足这两个条件的任意一个时, 集合对象需要使用hashtable编码。\n第二个条件的上限值是可以修改的，具体请看配置文件中关于set-max-intset-entries选项的说明。\n1 2 3 4 5 6 7 8 redis\u0026gt; SADD numbers 1 3 5 (integer) 3 redis\u0026gt; OBJECT ENCODING numbers \u0026#34;intset\u0026#34; redis\u0026gt; SADD numbers \u0026#34;seven\u0026#34; (integer) 1 redis\u0026gt; OBJECT ENCODING numbers \u0026#34;hashtable\u0026#34; 8.5.2 集合命令的实现 表8-10 集合命令的实现方法\n8.6 有序集合对象 编码\nziplist skiplist ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第 二个元素则保存元素的分值（score）。\n压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。 图8-14 ziplist编码的有序集合对象\n图8-15 有序集合元素在压缩列表中按分值从小到大排列\nskiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：\n1 2 3 4 typedef struct zset { zskiplist *zsl; dict *dict; } zset; zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素： 跳跃表节点的object属性保存了元素的成员 跳跃表节点的score属性则保存了元素的分值。 通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK、ZRANGE等命令就是基于跳跃表API来实现的。 zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员 字典的值则保存了元素的分值。 通过这个字典，程序可以用O(1)复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的 有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。值得一提的是，虽然zset结构同时使用跳跃表和字典来保存有序集 合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分值\n为什么有序集合需要同时使用跳跃表和字典来实现？\n有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现, 但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低 如果我们只使用字典来实现有序集合，那么虽然以O(1)复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行 范围型操作——比如ZRANK、ZRANGE等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少O(NlogN)时间复杂度，以及额外的O(N)内存 空间（因为要创建一个数组来保存排序后的元素）。 如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1) 上升为O(logN)。 图8-16 skiplist编码的有序集合对象\n图8-17 有序集合元素同时被保存在字典和跳跃表中\n为了展示方便，图8-17在字典和跳跃表中重复展示了各个元素的成员和分值，但在实际中，字典和跳跃表会共享元素的成员和分值，所以并不会造成任何数据重复，也 不会因此而浪费任何内存。\n8.6.1 编码的转换 当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：\n有序集合保存的元素数量小于128个； 有序集合保存的所有元素成员的长度都小于64字节； 不能满足以上两个条件的任意一个时, 有序集合对象将使用skiplist编码。\n以上两个条件的上限值是可以修改的，具体请看配置文件中关于zset-max-ziplist-entries选项和zset-max-ziplist-value选项的说明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #对象包含了128个元素 redis\u0026gt; EVAL \u0026#34;for i=1, 128 do redis.call(\u0026#39;ZADD\u0026#39;, KEYS[1], i, i) end\u0026#34; 1 numbers (nil) redis\u0026gt; ZCARD numbers (integer) 128 redis\u0026gt; OBJECT ENCODING numbers \u0026#34;ziplist\u0026#34; #再添加一个新元素 redis\u0026gt; ZADD numbers 3.14 pi (integer) 1 #对象包含的元素数量变为129个 redis\u0026gt; ZCARD numbers (integer) 129 #编码已改变 redis\u0026gt; OBJECT ENCODING numbers \u0026#34;skiplist\u0026#34; 8.6.2 有序集合命令的实现 表8-11 有序集合命令的实现方法\n8.7 类型检查与命令多态 8.7.1 类型检查的实现 类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的\n8.7.2 多态命令的实现 Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。\n8.8 内存回收 因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制， 程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。\n每个对象的引用计数信息由redisObject结构的refcount属性记录：\n1 2 3 4 5 6 typedef struct redisObject { // ... //引用计数 int refcount; // ... } robj; 对象的引用计数信息会随着对象的使用状态而不断变化：\n在创建一个新对象时，引用计数的值会被初始化为1； 当对象被一个新程序使用时，它的引用计数值会被增一； 当对象不再被一个程序使用时，它的引用计数值会被减一； 当对象的引用计数值变为0时，对象所占用的内存会被释放。 表8-12 修改对象引用计数的API\n对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。\n8.9 对象共享 在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：\n将数据库键的值指针指向一个现有的值对象； 将被共享的值对象的引用计数增一。 图8-20 未被共享的字符串对象\n图8-21 被共享的字符串对象\nRedis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值\n创建共享字符串对象的数量可以通过修改redis.h/REDIS_SHARED_INTEGERS常量来修改。\n如果我们创建一个值为100的键A，并使用OBJECT REFCOUNT命令查看键A的值对象的引用计数，我们会发现值对象的引用计数为2：\n1 2 3 4 redis\u0026gt; SET A 100 OK redis\u0026gt; OBJECT REFCOUNT A (integer) 2 引用这个值对象的两个程序分别是持有这个值对象的服务器程序\n图8-22 引用数为2的共享对象\n那些在数据结构中嵌套了字符串对象的对象（linkedlist编码的列表对象、hashtable编码的哈希对象、hashtable编码的集合对象，以及zset编码的有序集合 对象）都可以使用这些共享对象。\n为什么Redis不共享包含字符串的对象？\n只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂 度就会越高，消耗的CPU时间也会越多：\n如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为O(1)； 如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)； 如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N^2)。 8.10 对象的空转时长 redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：\n1 2 3 4 5 typedef struct redisObject { // ... unsigned lru:22; // ... } robj; OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 redis\u0026gt; SET msg \u0026#34;hello world\u0026#34; OK #等待一小段时间 redis\u0026gt; OBJECT IDLETIME msg (integer) 20 #等待一阵子 redis\u0026gt; OBJECT IDLETIME msg (integer) 180 #访问msg键的值 redis\u0026gt; GET msg \u0026#34;hello world\u0026#34; #键处于活跃状态，空转时长为0 redis\u0026gt; OBJECT IDLETIME msg (integer) 0 OBJECT IDLETIME命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性。\n如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设 置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。\n配置文件的maxmemory选项和maxmemory-policy选项的说明介绍了关于这方面的更多信息。\n8.11 重点回顾 Redis数据库中的每个键值对的键和值都是一个对象。 Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象 的使用效率。 服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。 Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。 Redis会共享值为0到9999的字符串对象。 对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。 ","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC8%E7%AB%A0-%E5%AF%B9%E8%B1%A1/","summary":"Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、","title":"第8章 对象"},{"content":"一、利润表的要素和结构 净利润=收入－成本－费用±其他\n基本表现形式主要有多步式和单步式两种，按照企业会计制度的规定，我国利润表主要采用多步式结构，描述收入一步一步变成利润的过程：\n第一步，以主营业务收入为基础，减去主营业务成本、主营业务税金及附加，计算出主营业务利润； 第二步，以主营业务利润为基础，加上其他业务利润减去营业费用、管理费用、财务费用，计算出营业利润； 第三步，以营业利润为基础，加上投资收益、补贴收入、营业外收入，减去营业外支出，计算出利润总额； 第四步，以利润总额为基础，减去所得税，计算出净利润（或亏损）。 表5-6　利润表基本格式\n续表\n因为人们容易在瞄一眼利润表数据后，就简单得出业绩好坏的结论, 利润表成了“三张表”中最容易财务造假的重灾区\n在权责发生制这一会计核算准则下，收入和费用天然存在较大操作空间。\n权责发生制，又称“应收应付制”。它是以本期发生的费用和收入来确定本期损益的会计制度。凡在本期发生的收入和费用，不论本期是否已收到或付出现金，均应作为 本期的收入和费用做处理。某些不良企业会利用这种制度，将尚不确定的收入和费用提前确认，从而达到调整利润或掩盖亏损等目的。\n二、利润表的阅读逻辑 从营业收入到毛利润 营业收入－营业成本=毛利润\n毛利率 = 毛利润/营业收入\n一家企业的毛利率是否正常需要在同业维度下作比较\n毛利率提升的原因，要么是成本下降，要么是售价上升。当企业的毛利率发生变动，首先分析是成本端还是销售端的原因，然后再思考这种变化是否合理。\n从毛利润到营业利润 “毛”主要包括税金及附加、期间费用、资产减值损失以及其他收益等，拔过毛的利润就是企业的营业利润。\n税金及附加是指企业在营业中应负担的相关税费，包括消费税、增值税、城市维护建设税、资源税、房产税、城镇土地使用税、车船税和印花税等。\n期间费用指的是营业费用、管理费用以及财务费用这三大费用。\n营业费用又叫销售费用，主要是企业在销售产品和提供服务等日常经营过程中产生的各项费用。销售费用通常会与销售收入同向变动，且变动比例不会太大。 管理费用 管理费用是指在企业管理环节产生的各项费用，包含管理者工资福利、工会经费、职工教育经费、行政开支、董事会经费、中介机构费用、无形资产摊销以及管理机 构资产折旧、业务招待费、计提的各类准备等。这个科目是个大杂烩，各种名目的支出，各种费用调节，甚至有些找不到科目归属的费用，都会丢到管理费用中。 管理费用还包含一个经常被忽视的重要内容——诉讼费。被忽视是因为该科目的金额一般不会很大，十几万元甚至几万元的也常见。而一旦出现这个科目，说明企业可 能处于法律纠纷或仲裁中，账面十几万元费用的背后可能是天文数字的赔偿金额。在终审判决之前，审计师通常无法将其确认为负债，只能列为前一节介绍过的 “或有负债”，在表外进行披露，故须引起重视。 财务费用主要包括自有资金的利息收入、债务的利息支出、外汇结算的汇兑损益以及在银行等金融机构办理业务时产生的各项手续费。因为此费用有收入项也有支出 项，所以可正可负。它主要用来和货币资金以及有息负债进行对比，看是否合理以及会否对企业带来过重财务负担。 资产减值损失指的是资产的可回收金额低于账面价值所造成的损失，前一节提到的固定资产、无形资产、商誉和存货等资产都有可能出现这一问题。需要重点关注的是 存货、应收账款以及持有到期投资这几项的减值损失，因为这些计提转出后，如果发现提错了还可以再转回来。\n这一特点的存在，让这个科目成了上市公司调节利润最常耍手段的地方之一。 其他收益包括投资收益和公允价值变动收益。投资收益指的是企业对外投资取得的利润、股利、利息等收入减去投资损失后的净收益。公允价值变动收益指的是金融资 产和投资性房地产公允价值变动带来的收益或损失。看报表时要留意这块占营业利润的比例，占比较大可能说明企业的主营业务发展得并不好。\n营业利润率 = 营业利润/营业收入\n它直接反映企业的运营效率高不高，数值越高代表运营效率越高。在竞争比较充分的行业中，各企业毛利率差别不会很大，但净利润却相差悬殊，此种差异主要就是 由运营效率不同造成的 从营业利润到净利润 净利润 = 营业利润 + 营业外收入 - 营业外支出 - 所得税\n营业外收入就是与主营业务无关的偶然性收入。\n营业外支出出自营业外收入相对应的科目，因被罚款或者火灾、地震造成的损失就算作营业外支出。\n计算净利润前的最后一项是企业所得税，这是根据企业最终的盈余来征收的。利润总额如果为负数，亏损的这一部分还能用来抵扣将来需缴纳的企业所得税，这在税法 里叫作弥补亏损。\n有净利润并不等于就挣到了钱，还要将其和现金流量表中的“经营现金流净额”对照起来看。如果净利润总是小于经营现金流净额就需要提高警惕——这类上市公司或者是 有大量应收或预付款项，或者是存在虚增营业利润的可能。而无论哪一种情况，投资者都尽量远离。\n三、利润表的重点关注对象 首先是营业收入。选股时应优选营业收入持续增长的企业，这说明其在不断扩张市场。另外，对比同行的营业收入增长率，能看出该企业在行业中的地位强弱，龙头公 司的该项数据一般会高于其他企业。另外，再强的龙头公司也很难保持永远高速增长\n其次是毛利率。毛利率高的企业在产品或服务的价格方面往往有着较强的竞争优势。但是，在选择时为防止刻意做高毛利润，还要看一下高毛利率的原因是什么，如缺 少合理解释也不能排除财务造假的可能。\n再次是费用率。有运营就必然会产生费用，研究财报要谨慎对待费用率高或剧烈波动的公司。销售费用高的公司往往是因为产品竞争力有限，需要庞大的销售团队铺开 渠道，这样会造成企业的扩张成本较高，降低利润空间。\n再次是营业利润率。营业利润率越大说明企业的盈利能力越强，但在求大的同时也要做历史纵向比较和同业横向比较，看看高营业利润率是否合理，是否能够持续。\n最后还要比对净利润和现金流量表，确保全部或至少大部分的净利润能以真正的现金流形式流入企业。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%A2%E6%8A%A5/%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%88%A9%E6%B6%A6%E8%A1%A8/","summary":"一、利润表的要素和结构 净利润=收入－成本－费用±其他 基本表现形式主要有多步式和单步式两种，按照企业会计制度的规定，我国利润表主要采用多步式结","title":"第五节 上市公司的成绩单——利润表"},{"content":"一、审计报告 审计类型共有五种，分别表达了会计师的五种态度\n表5-1　会计师出具意见与真实意图对照\n二、资产负债表的要素和结构 资产负债表主要是用来反映企业有多少家当，家底厚不厚。此表中的内容直接决定了企业资产质量和持续获取稳定利益的能力。\n资产=负债+所有者权益\n资产表明企业的钱以何种形式存在，通常按变现的便捷程度进行排序，容易变现的货币及其等价物放在最上面，难以变现的资产放在后面。负债及所有者权益表明企业 的钱从哪里来，负债就是企业借了或欠了外面多少钱，所有者权益就是企业有多少钱是股东的（也可以理解为一种永久负债，只要没破产清算就不用还）。此处排序同 样有讲究，一般按还钱的紧急程度进行排序，距离还钱期限越短的越往上排。\n表5-3　资产负债表基本格式\n三、资产及主要会计科目 资产的分类方法有多种，如按可变现能力可将一年内能变现或者运用的资产归为流动资产，一年以上的称为非流动资产；按是否具备实物形态可分为有形资产和无形资 产；按资产的来源可分为自有资产和租入资产等。对投资者而言，将资产分为货币资产、经营相关资产、生产相关资产以及投资相关资产更具实际意义。\n货币资产主要指货币资金； 经营相关资产主要包括应收账款、预付账款和存货； 生产相关资产主要包括固定资产、在建工程、无形资产、商誉等； 投资相关资产，主要指的是投资性房地产、交易性金融资产、可供出售金融资产等。 关注经常性资产, 重点关注资产变动情况\n经常性资产主要包括货币资金、存货、应收票据及应收账款、预付账款、固定资产和在建工程等。对于这类资产的分析，主要是通过与历年数据对比，看是否存在异 常变动，如有，则需要努力寻找其变动的原因。 “重点关注”资产主要包括投资性房地产、交易性金融资产、可供出售金融资产、无形资产、商誉、长期待摊费用和其他应收款等。对这类资产，除需要和往年对比外， 还要重点观察其绝对金额，科目余额较大时必须深究其原因。 货币资金 这是最容易出现财务造假的科目。资产负债表之中该科目只有期初值和期末值，因此需要借助财报的附注部分的“合并财务报表项目注释”科目来进行详细分析。重点是 要关注现金、银行存款、其他货币资金和其他流动资产的构成以及金额是否符合常理。\n投资者可以把企业的货币资金和短期债务及实际经营情况进行对比。与短期债务匹配，代表企业的偿债能力强；与经营情况匹配，代表资金使用效率高。\n货币资金占总资产的比例同样也值得关注，这一数据在不同行业之间差异较大。\n通过对比一家企业年平均货币资金（用货币资金期初值加上期末余额后再除以2）和利息收入的关系，可以判断财报上的数字是不是临时“借”来的或者存在资金占用的 问题。\n企业购买的银行理财产品会体现在“其他流动资产”这个科目里，当投资者需要考察货币资金状况时，需把这部分资金计算进去。\n存货 存货是指企业在日常活动中持有以备出售的生产成品或商品、处在生产过程中的在产品、在生产过程或提供劳务过程中耗用的材料或物料等。此处同样是财务造假的重 灾区，通过它进行财务造假的方式主要有三种。\n调整存货减值计提 主要产品具备上下游价格波动大、新鲜程度要求高（如牛奶等农副产品）或迭代速度快（如手机、芯片等）等特征的企业，容易存在通过存货减值计提来对利润进行调 整甚至财务造假的风险。\n通过虚构交易来虚增利润 某些上市公司为虚增利润，先是通过购买价值不易评估的产品和服务，使资金流出企业，再通过虚假出售上述产品虚构收入和利润。这类造假的破绽在于，存货的增幅 远大于同期营业成本增幅，且存货与产品销售速度也显著高于同行。因此，在进行同业对比时如果出现上述现象就要多加警惕。\n通过加大生产，降低单位成本，提升毛利率，虚增本期利润 这种造假方式常见于固定成本比较高、边际成本比较低的企业。\n这么做的上市公司不但投资价值没有提升，反而由于存货增加、各种税费增加令经营负担加重，时间拉长只会越来越差。\n应收票据、应收账款和预付账款 应收票据和账款通俗地说就是销售完商品或服务，但目前还没收到的钱。预付账款则是已经付了钱，但是暂时还没收到的商品或服务。\n这三个科目能够体现出企业在产业链上的地位，余额占比越高说明其在产业链上的话语权越低。\n账龄反映了应收账款的质量，也是坏账准备金计提标准之一。如果某家上市公司大多数应收账款都在一年以上，那就有点危险：账龄越长，收回的可能性越低，成为坏 账的可能性越大。\n应收账目还有个指标叫应收账款周转天数\n应收账款周转率=营业收入／平均应收账款 平均应收账款=（期初应收账款+期末应收账款）/2 应收账款周转天数=360/应收账款周转率 应收账款周转天数主要表示当产品卖出后，要多久才能把钱收回来。这个指标通常用来和同行进行对比，应收账款周转天数较低的企业通常在行业中处于优势地位，一 般多为行业龙头。\n应收账款周转率也是一个检验财务是否造假的好工具，企业应收账款周转率低的同时应收账款却很高，就存在财务造假的可能。\n固定资产、在建工程 这两个科目通常连在一起去看：“在建工程”通过消耗“工程物资”转化成“固定资产”，如果迟迟无法转化，那这个“在建工程”可能就是造假的结果。\n固定资产最重要的特点就是需要计提折旧和减值准备。所谓计提折旧，就是把固定资产折损按照一定的方法提取出来，计提部分要作为企业当期经营的成本费用从利润 表中进行扣除。计提减值准备，就是对损坏的、跌价的或长期不用的资产做减值准备，这部分也要从利润表中扣除。\n固定资产的增长速度也是值得观察的指标，太快或者太慢都不好。增长太快，利润跟不上，一旦折旧就会让报表很难看；增长太慢，则有可能是陷入发展瓶颈，没有空 间或必要扩张规模、提高产能了。\n投资性房地产、交易性金融资产、可供出售金融资产 这部分资产主要指的是企业进行投资的资产。绝对金额或总资产占比大并不见得就是好事，优秀的公司应该专注主业，如果和主业经营无关的资产占比过高，利润增长 点主要靠各类资产投资创造，即便业绩可能因此好看，却是在侧面提醒我们该企业可能正在经历某种瓶颈。\n无形资产、长期待摊费用 无形资产主要指企业研发费用的资本化部分或直接外购的无形资产，主要包括专利权、专利技术、版权、商标权和土地使用权等。对于无形资产过大的企业一定要谨慎， 因为无形资产难以清点，估值或多或少都存在一些争议。如果一家企业无形资产太多，很有人为做大资产总量的嫌疑。\n长期待摊费用指的是装修费、预付租金、预付广告费等预计受益期超过一年的费用。这类费用在支付时已经一次性全额支出，而且几乎没有任何变现价值。这块同样是 一个容易财务造假的点，有的企业会把并不需要长期分摊的费用做成长期待摊费用，从而对企业的利润进行调整。\n商誉 商誉是指企业在兼并收购外部公司时所支付的溢价，这可以说是企业各项资产中“水分”最足的地方，除了长期趴在资产负债表或者通过减值进入利润表之外，它几乎不 会为企业带来任何新的经济利益流入。\n其他应收款 其他应收款是指与正常经营关系之外的第三方之间的款项往来，如提供商品或服务后暂留给对方的质保金、房屋租赁提供给业主的押金、股东借款等\n该科目可以说是资产负债表中的藏污纳垢之处，有的大股东用它转移资金，占用企业资金；有的用它来隐藏利润或费用，调节报表。\n在负债中与其对应的是“其他应付款”，包含内容和风险程度与其较为相似。优秀企业的这两个科目金额一般都不会太大，当发现数字较大时一定要提高警惕。\n四、负债及主要会计科目 负债反映在企业的家底中，有多少钱是借来的（金融负债），或目前尚欠的外债有多少（经营负债）。借贷是现代企业的正常商业行为，上市公司有负债并不是坏事， 只要控制在合理范围内就是健康的。\n或有负债不算负债，不计入资产负债表中，一般只在资产负债表的附注中披露。\n在会计上，负债同样以一年为分界点分为流动负债和非流动负债。但站在投资者的角度上，通常按照负债性质分为经营性负债、融资性负债以及分配性负债。\n对于负债下的各科目，需要重点关注两点：一是财务风险，二是有息负债占总资产的比例。具体来说，就是看上市公司的现金及现金等价物能否覆盖有息负债，这样在 极端情况下还可以断臂求生，用现金及现金等价物偿还有息负债。至于有息负债占总资产比例，主要是和同行作对比，如果和同行相差较远，就需要提高重视程度。\n负债中吸收存款以及同业存款、向中央银行借款这几个科目也是比较特殊的负债科目。这些科目只会出现在银行、非银金融机构财报中，是这类企业的特权。\n五、所有者权益 所有者权益中的“所有者”指的是股东，所以又叫股东权益。它是指企业资产中属于股东的那部分，由企业总资产减去总负债得出。投资者通常说的 “净资产”就是所有者权益中的“归属于母公司所有者权益合计”的部分，可以由“所有者权益”减去“少数股东权益”得到。\n所有者权益主要由四部分，即实收资本、资本公积、盈余公积和未分配利润构成。\n实收资本 实收资本又叫“股本”，就是企业营业执照上的注册资金。它等于上市公司发行的股份总额乘以股票面值，由于绝大多数股票面值为1元，所以实收资本也可以理解为上 市公司一共发行了多少股的股票。\n资本公积 股票的发行价往往高于股票的面值，多出来的部分就是资本溢价（又叫股本溢价），这部分会进入资本公积。\n资本公积转增股票不用交税，这是因为资本公积是股东投入的，而不是通过利润得来的。在企业存续期间，非交易产生的所得都会被归入资本公积。\n盈余公积和未分配利润 企业赚钱后，利润分配不是随便分，而是有顺序要求的。\n首先要用来弥补以前的年度亏损； 其次，要按照当年母公司利润表的税后利润的10%计提法定盈余公积； 再次，由股东自行决定是否继续提取额外的盈余公积（具体数额股东商定）； 最后，才决定是否向股东分配。 盈余公积是从利润里留下继续投入扩大再生产的钱。其中法定盈余公积是强制股东留下的，累积到注册资本的50%以后可不再提取。企业可以利用盈余公积或未分配利 润送红股，用盈余公积送股的，需保证送股后盈余公积不得低于注册资本的25%。\n四看\n首先看各科目的总资产占比，并对比比率是否合理； 其次看资产质量是否有水分，有的话会对企业有什么影响； 再次看企业有息负债和货币资金的匹配关系，是否有潜在的财务风险； 最后看各资产的运转效率（用营业收入除以各资产的平均余额，具体参考应收账款周转率）。 分析时还要纵向对比各年份数据，判断其数值变动是否处于合理范围；同时横向对比同业，正常情况和行业的平均水平不会相差太多，如果偏差异常就要提高警惕。\n最后，理解公司的行业特征、商业模式和业务流程是读懂资产负债表的前提，不同行业上市公司的资产负债表差异会很大\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%A2%E6%8A%A5/%E7%AC%AC%E5%9B%9B%E8%8A%82-%E8%B5%84%E4%BA%A7%E8%B4%9F%E5%80%BA%E8%A1%A8/","summary":"一、审计报告 审计类型共有五种，分别表达了会计师的五种态度 表5-1 会计师出具意见与真实意图对照 二、资产负债表的要素和结构 资产负债表主要是用来反","title":"第四节 上市公司的家底——资产负债表"},{"content":"一、公司业务概要 这一部分将对公司主营业务、经营模式、业务发展情况及目标，乃至企业核心竞争力等内容进行全方位的阐述。\n年报每年都在更新，通过对比这一部分内容的变化，有时还能窥见公司对行业和自身发展的观点，据此研判其在业务、技术和客户等方面是否有重大突破。\n二、经营情况讨论与分析 仔细阅读和分析这一节内容，可获取比前一部分更多的重要信息。一是从管理层的角度解释公司过去一年的业绩是如何形成的；二是经营业绩会有大量更细节的数据， 有的数据是在财务报表及附注中也没有的；三是会对企业的未来进行展望；四是可以体现管理层的能力与眼光。\n概述及主营业务分析 这一节通过对业务发展的定性描述，解读了财务数据背后的逻辑。\n库存量, 实物销售表会显示企业各类产品的库存量，有些企业会通过这部分来对营业收入进行调整 研发投入, 对于创新型企业的这部分尤需重点关注 前5名客户及前5名供应商资料，可以从总额占比看出上市公司对上下游某单一企业的依赖程度 非主营业务情况和资产及负债状况分析 非主营业务情况主要阐述企业非主营业务所带来的收入，以及这类收入是否能够持续。\n资产及负债状况分析主要罗列资产负债表的主要科目、敏感科目（应收应付类科目）以及变化较大的科目。\n投资状况分析 此处要重点关注的是“募集资金使用情况”，上市公司IPO时许下的承诺、愿景，到底是讲故事还是真正兑现了，在这里能够展现出来。这一项下还有一个分项叫做 “募集资金变更项目情况”，阅读后可推断公司是准备赖账，还是在各种主客观原因下应时而变。\n公司未来发展的展望 这部分是站在企业管理者的角度分析上市公司在市场、行业中的优劣势，及未来的发展前景。尤其是“公司未来经营计划”，有可能会在此处给出下一年的业绩预期。投 资者平常所说的“不及预期”有两种，一种是不及研究机构分析师的预期，另一种就是指不及董事会上一年的预期。\n从这部分还可看出管理层的能力、诚信和战略眼光。一方面可以去翻阅往年财报，看业务规划是否实现、行业趋势判断是否正确、许下的承诺有无兑现。\n另一方面还可横向比对同行业公司的管理层，对企业竞争力和行业发展趋势的总结。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%A2%E6%8A%A5/%E7%AC%AC%E4%B8%89%E8%8A%82-%E4%B8%8D%E5%8F%AF%E8%BD%BB%E8%A7%86%E7%9A%84%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/","summary":"一、公司业务概要 这一部分将对公司主营业务、经营模式、业务发展情况及目标，乃至企业核心竞争力等内容进行全方位的阐述。 年报每年都在更新，通过对比","title":"第三节 不可轻视的定性分析"},{"content":"一、财报的获取渠道 上海证券交易所和深圳证券交易所官网 巨潮资讯网 第三方软件和网站 二、财报的公布时间 从披露时间上来说，一季报、三季报是要求在季度结束后的一个月内进行披露；半年报是在上半年结束后的两个月内进行披露（即每年8月31日前）；年报是在年度结 束后的4个月内进行披露（即每年4月30日前）。由于时间上的差异，年报信息最为详细和完整，半年报次之，一季报、三季报只有一些基本数据。同时，和其他报告比， 年报必须经过会计师事务所审计，所以通常被认为更有研究和分析价值。\n三、财报的主要结构 图5-1　爱美客公司2020年年报目录\n需要细读的重要内容\n经营情况讨论与分析（也有的报告以“董事会报告”一类作为标题） 重要事项 财务报告 适当关注的内容\n第一节的重要提示部分 第六节的股份变动及股东情况 第九节的董事、监事、高级管理人员和员工情况。 企业情况的基本信息\n第一节的释义部分以及第二、第三节 对于首次关注的企业可以浏览掌握基本情况 四、财报各部分要点 重要提示、目录和释 重要提示通常在首节首页，这一节之所以重要，是因为它通常会把涉及股东权益变动，如分红、送股、转增一类的重大事项放在此处，有的还会把审计报告的结果写在 这里。\n公司简介和主要财务指标 展示了公司的主要财务数据，需要快速了解财务情况的投资者，只须蜻蜓点水般浏览此部分简表即可。\n看完营业收入、净利润以及和上年同期数据的对比，再确认一下非经常性损益项目与净利润的比例，可以得到一个该公司财务基本面的大致印象。\n公司业务概要 是对上市公司进行定性分析的捷径之一\n经营情况讨论与分析 由董事会自己书写的企业分析报告，内容可靠性和准确性一般会高于各机构研究报告。\n重要事项 如果真正想全面掌握一家企业的基本面概况，其中仍有很多内容值得留意，如重大合同及履约情况、涉诉情况、股权激励、员工持股计划等，都可能是影响未来业绩表 现及股价的潜在因素。\n“聘任、解聘会计师事务所情况”一项中如出现换所的情况，也需要多加留意。一般情况下上市公司不会轻易更换会计师事务所，一旦为之，有可能是其财报出现某种状 况\n股份变动及股东情况 这里重点关注的，是股东人数和前十大股东的变化。\n股东人数的变化通常会有两个数字，一个是报告期末股东人数，另一个是披露日前上一月末普通股股东总数。\n优先股相关情况 可转换公司债券相关情况 董事、监事、高级管理人员和员工情况 通过这部分可了解高管的履历和薪酬情况，最重要的是还可以了解员工人数及结构。从员工的人数变化可看出公司业务现阶段是处于扩张还是收缩阶段，员工结构年轻 化、高学历化能侧面说明公司景气度高，研发人员占比高代表着公司重视科研创新，未来产品或服务更新换代的效率会更快。\n公司治理 公司治理包括公司的组织机构上，是否建立健全的内部管理和控制制度体系，是否提升公司经营管理水平和风险防范能力。\n公司债券相关情况 财务报告 资产负债表、利润表和现金流量表\n备查文件目录 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%A2%E6%8A%A5/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E8%B4%A2%E5%8A%A1%E6%8A%A5%E5%91%8A%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/","summary":"一、财报的获取渠道 上海证券交易所和深圳证券交易所官网 巨潮资讯网 第三方软件和网站 二、财报的公布时间 从披露时间上来说，一季报、三季报是要求在季度","title":"第二节 财务报告的基本结构"},{"content":"一、个股基本面的两个方向 主要分为定性研究和定量研究两个方向, 对应要解决的两个核心问题，分别是上市公司质地是否健康以及赚钱能力究竟是强还是弱。\n定性分析需要全面了解公司的业务开展情况：从产品到渠道，从价格到促销、营销管理，从研发到供应链的完整运营链路，等等。再结合行业的基本格局和竞争态势来 理解企业的发展战略，辅助判断公司是否具有可持续的竞争优势和投资价值。\n定量分析主要是对企业的经营业绩进行数字化分析，测算关键财务指标，判断企业的盈利能力、财务状况和运营效率，并通过对比自身历史数据进行趋势分析以及与国 内外同行横向对比等手段，来确定公司的业绩是否优秀。\n专业投资机构使用全球通用的商业分析模型, 主要包括波特五力、SWOT、ECIRM、SCP等。\n财报是普通投资者收集企业“情报”的重要工具。\n二、财报分析的意义 财报是部《致富经》，能帮我们增强持股信心 通过研读目标公司的历年财报（也包括上市时的招股说明书），了解企业主的创富故事，洞悉企业的前世今生，能帮我们更好地理解企业的价值观，判断未来的走向； 透过各种量化指标了解公司的战略、运营、风险和绩效，掌握其在行业内的竞争优势和不足。只有财富积累过程正当，与我们的价值观和方法论吻合，瑕不掩瑜或暂时 的缺点最终能克服的企业，才能让我们更确信其能从优秀走向卓越，强化持股信心。\n财报是本《相亲指南》，能帮我们找到适合自己的对象 读财报也是如此：要带着企业“过去发生了什么”，去判断企业未来“会产生怎样的变化”。在分析方法上，主要是用财务比率和同业、企业自身历史进行对比。财务比率， 就是各种财务指标的比率，诸如毛利率、净利率、净资产收益率、资产负债率等。当企业的财务比率和同业相差较大或者较过去有较大的波动，就要去深挖这种情况出 现的原因，然后再考虑这种原因是否合理。\n财报是份《体检报告》，能帮我们避免投资“踩雷” 并不是好的财务数据造就了好的企业，而是好的企业产出了好的财务数据。因此，看财报要像看《体检报告》一样，不能只看好的地方，而要多关注不好的指标，发现 企业潜在的问题。\n财报分析只是个股基本面分析的工具之一，既是工具就有其适用范围，它并不能涵盖全部的企业信息，而且各家上市公司财务报告的含金量参差不齐。我们的目标，是 通过财报信息结合各方资讯，尽可能地掌握目标企业更多的真实情况，努力提高下注的准确率。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%A2%E6%8A%A5/%E7%AC%AC%E4%B8%80%E8%8A%82-%E8%B4%A2%E6%8A%A5%E5%88%86%E6%9E%90%E7%9A%84%E6%84%8F%E4%B9%89/","summary":"一、个股基本面的两个方向 主要分为定性研究和定量研究两个方向, 对应要解决的两个核心问题，分别是上市公司质地是否健康以及赚钱能力究竟是强还是弱。","title":"第一节 财报分析的意义"},{"content":"一、行业龙头的优势 行业龙头由于自身实力或其他原因（如行政垄断），往往在其行业中有举足轻重的地位。 行业龙头更容易享受到政策红利，很多时候在行业政策的制定阶段，就会邀请龙头企业参与，并参考这些企业的建议，对政策进行调整 龙头在行业发展进入整合和成熟期后最为受益 随着注册制改革的推进，市场容量在快速增加的同时退市制度也得到强化，A股将会呈现出类似美股和港股的二八分化现象。选择那些抗风险能力强，持续盈利能力 靠谱的龙头企业更安全 二、如何挑选龙头 对于多数行业来说，最大的企业一般也是竞争力最强的企业\n企业的综合竞争力强通常有两方面体现：一是有着较深的护城河，二是当行业开始衰退时能够展现较强的抗性。\n垄断、品牌、技术、市场占有率以及管理能力。 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%8C%E4%B8%9A/%E7%AC%AC%E4%B8%83%E8%8A%82-%E9%87%8D%E8%A7%86%E8%A1%8C%E4%B8%9A%E4%B8%AD%E7%9A%84%E9%BE%99%E5%A4%B4/","summary":"一、行业龙头的优势 行业龙头由于自身实力或其他原因（如行政垄断），往往在其行业中有举足轻重的地位。 行业龙头更容易享受到政策红利，很多时候在行业","title":"第七节 重视行业中的龙头"},{"content":"迈瑞医疗、药明康德、恒瑞医药和爱尔眼科\n医疗行业是一个强政策主导的行业。对它的研究离不开对政策的了解，需要密切关注国家医保局、国家药品监督管理局和卫健委这三个部门的政策动向。现阶段三部门 各司其职，医保局负责医保，药监局负责医药，卫健委负责医疗。\n医疗行业对投资专业度的要求甚至比科技行业还要高。因为大板块下细分赛道极多，包括原料药、化学制剂、医疗器械、医事服务、医药流通等。各条赛道还可以继续 往下分，如化学制剂又可分为仿制药和创新药。\n不同赛道的投资逻辑迥异\n对于原料药的研究可采用周期行业的投资逻辑 创新药有必要借用科技行业分析框架进行研究 连锁药房则与零售商超存在一定相似性。 一、原料药赛道 原料药分为大宗和特色两个领域\n所谓大宗原料药就是指市场需求相对稳定、应用普遍和规模较大的传统药品原料药，如抗生素、维生素、氨基酸、激素等。这类产品毛利率较低，价格波动就是主导股 价变动的核心，产品价格会受到供给、产能、原材料价格的影响而周期性地波动。\n特色原料药通常指尚处于专利保护期，或专利保护期结束后药品的原料药。这类原料药种类众多规模偏小，价格受到下游产品影响较大。对这类企业的研究要重点去分 析下游药品的需求量和与各下游药企合作关系的稳定性。\n总体而言，无论是大宗还是特色，原料药整体是受价格影响较大的行业，呈现出较强的周期品特征。\n美诺华 二、化学制剂赛道 无论是仿制药还是创新药，管线（pipeline）都是化学制剂行业投资必须要了解的重要术语，它是指还未上市的、处于临床阶段或者临床前阶段的药品，其数量体现 了药企后续产品布局线的丰富程度，亦即业绩增长的潜力。\n对于创新药行业，通常用管线估值法进行研究。\n对于创新药企尤其是其中的中小公司，其现金流状况也需要重点关注。\n三、生物制药赛道 疫苗比较类似创新药，可以采用创新药的方法去研究。需要注意的是由于疫苗在产品稳定性和安全性上要求更高，所以对于政策也更会敏感一些。\n血制品无论是自身还是其“来源”——血浆，天生行业壁垒较高，呈现典型的寡头市场特征。对于血制品企业的研究也要采用类似资源周期品行业的方法，重点了解其浆站 数量、采浆量、投浆量的情况。\n四、医疗器械赛道 医疗器械也是一个值得关注的赛道，一来行业尚处蓝海发展空间巨大，二来国产替代是未来发展的趋势。对于医疗器械的研究方法可参照化学制剂的思路，需要多注意 的就是观察目标公司的销售能力和创新壁垒。\n五、医事服务赛道 如眼科、口腔、体检和医美等都属于其下的细分赛道。与其他医药行业比，医事服务受政策影响较小，但对可复制性和品牌效应要求更高。\n六、CXO（医药外包服务）赛道 广义的医事服务下，还包括一个近年来最为亮眼的黄金赛道，被称为CXO，是对为制药企业提供各类外包服务的“铲子型”机构的统称。其中间的字母X相当于汉语中的 某，在细分不同的服务类型时可将具体单词的首字母代入。\nCRO CMO CDMO CSO 对于该赛道的研究重点要关注企业的客户结构、生产能效以及订单量这几个关键点\n总而言之，医药行业对于专业知识和精力投入的要求较高，很多保守投资者会基于敬畏而回避这一行业。但考虑到天花板仍远未触及，医药行业尤其是创新药和CXO等 重点赛道，对收益率有进取心的投资者来说绝不能轻易绕过！\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%8C%E4%B8%9A/%E7%AC%AC%E5%85%AD%E8%8A%82-%E5%8C%BB%E7%96%97%E8%A1%8C%E4%B8%9A%E5%8F%8A%E7%BB%86%E5%88%86%E8%B5%9B%E9%81%93/","summary":"迈瑞医疗、药明康德、恒瑞医药和爱尔眼科 医疗行业是一个强政策主导的行业。对它的研究离不开对政策的了解，需要密切关注国家医保局、国家药品监督管理","title":"第六节 医疗行业及细分赛道"},{"content":"一、科技行业的特性 科技行业具备成长性、周期性和易泡沫化三大典型特征，这让它相对于稳定性和确定性都更高的消费行业，投资难度要大不少。\n成长性, 做得最好的那一家或者那几家公司往往会占据整个行业中绝大部分的市场份额 周期性主要体现在一长一短两个周期上，长周期指的是研发周期长. 短周期指的是产品的迭代周期相对较短 科技行业的弊端\n经常出现题材炒作 经常都处于一个相对高估的状态 对于普通投资者而言，投资科技行业要更加理性、谨慎和细致。\n二、科技行业的研究方法 首先，投资科技企业要以5～10年的维度去看。(回报周期较长) 其次，对企业的业务、产品和技术路线等基本面要有更深入地了解，并在同行业或同类型的公司中进行对比，这样在投资时才会更有底，也能把真正做产业的和只是 做主题性炒作的公司区分开，避免踩坑。 再次，无论牛熊市，科技行业的高波动在所难免。故而在投资时需要做一些仓位控制，不能把全部仓位都放在波动大的科技上。 最后，对科技股难以用传统的市盈率或现金流折现等估值法进行估值。可以根据互联网、电子商务、半导体等赛道不同的特性，用市销率、分部估值或研发费用估值 等方法，并从行业景气度的角度把握投资节奏，或许是更好的选择。 科技是典型的朝阳行业，但其特性决定了投资要以年为单位。因此一方面是要学会守拙，坚持对这一行业的信仰；另一方面就是要挑选其中未来景气度最高的几个赛道， 如消费电子、半导体材料和设备、软件服务、新能源产业链以及互联网科技等。\n三、消费电子赛道 消费电子赛道是科技行业中确定性相对较强的，逻辑也是比较清晰的，从它的发展历程来看，其属于典型的技术迭代型周期行业（2014年开始4G基站大规模铺设， 2014—2016年4G手机销量大幅提升，2019—2020年开始大规模铺设5G基站，同期5G手机销量大幅提升），因此对于该赛道主要看终端销量增长。简单来说就是企业 垄断能力越强，就越值得关注。\n除了终端销量，技术升级带来的零部件使用量以及产品附加值的提升等也是该赛道需关注的重点。\n四、半导体赛道 无论从需求端还是从供给端看，半导体材料和设备都是一个值得长期关注的赛道。\n芯片行业通常被划分为设计、制造和封测三个主要环节。我国在封测环节的实力最强，设计次之，制造环节的实力最弱。芯片封测中长电科技排名全球第三，另外还有 通富微电和天水华天这两家公司也能跻身前十，三家公司的全球市场份额合计大概占20%。\n五、软件服务（SaaS, Software-as-a-Service）赛道 诸如金蝶国际、广联达、金山办公、金山软件、微软和谷歌等企业都是软件服务赛道的代表企业。伴随全球企业云化、数字化进程持续推进，SaaS将会是未来科技领域 值得关注的赛道。从美股市场来看，其IGV（北美软件服务）指数连续四年跑赢标普500指数，全球SaaS产业处于快速演进和变化过程中，新的市场机会不断孕育。\n对于软件服务赛道，可以从其产品的渗透率来判断景气程度。\n在市场渗透率达到20%之前，市场扩张处于一个相对缓慢的过程。 但是一旦到了20%就会进入一个高速增长的阶段 之后到50%～60%就再次进入了一个缓慢增长的阶段。 投资的时候我们可以在企业渗透率达到20%～30%的时候介入，享受其业绩高速增长带来的红利，然后在过了50%后，如果还没有新产品迭代的话就可以提前离场。\n六、新能源赛道 在“碳中和”成为时代进步超强音的背景下，新能源技术是未来科技发展重要的方向之一。\n新能源产业链覆盖面极广，从传统能源到新型能源，从材料研发到系统芯片，新能源赛道几乎覆盖了所有和科技沾边的行业。\n七、互联网赛道 互联网赛道有一个特点，就是其往往喜欢涉足多个领域。相对于其他不重要的枝节，对于这些企业的研究更建议从最核心的“护城河”入手。如腾讯的社交和游戏、阿里 的电商和支付、美团的本地生活和点评系统等。当其“护城河”受到影响或挑战的时候，企业也就会出现较大的波动。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%8C%E4%B8%9A/%E7%AC%AC%E4%BA%94%E8%8A%82-%E7%A7%91%E6%8A%80%E8%A1%8C%E4%B8%9A%E5%8F%8A%E7%BB%86%E5%88%86%E8%B5%9B%E9%81%93/","summary":"一、科技行业的特性 科技行业具备成长性、周期性和易泡沫化三大典型特征，这让它相对于稳定性和确定性都更高的消费行业，投资难度要大不少。 成长性, 做","title":"第五节 科技行业及细分赛道"},{"content":"赛道通常是指行业里面的某个细分行业或领域\n一、牛股辈出的消费行业 这一行业最大的特征就是需求稳定，背后的底层逻辑就是人口——只要社会仍在发展、人口仍在增长，消费的整体需求就是不断向上、稳定增长的，所以从需求的角度看， 这几乎堪称“永动机”行业。\n消费行业的分析方法 消费需求端的演变 需求的演进变化指的是由于地域、收入等多种因素带来的消费理念的变化，也就是通常说的消费分级——一、二线城市消费者更关注品牌背后的附加内容，愿意为品牌支 付超额溢价；而三、四线城市则对消费品的价格更加敏感，降价打折的消费品通常更受欢迎。\n对于消费品的需求演变，通常又得观察稳定性和延展性这两个特性。\n稳定性 观察目标企业的需求端能否在未来一段时间内保持稳定：需求越稳定，投资的可行性和确定性就越高。 关注业绩能否保持较稳定的增速 延展性 消费品市场扩张的延展性. 比如一、二线城市的消费理念比较超前，消费者更多注重个性化、多样化和体验式的消费；三、四线城市更多是温饱型消费，得到满 足之后开始转向享受型消费；县域、乡镇或农村的消费者个性化意识并没有完全觉醒，更注重的是消费品的性价比。 消费升级，是指随着经济的发展，消费者需求的逐渐多样化和个性化. 在研究消费公司时还要看其产品是否因消费升级而被替代，以及应对消费升级的进阶战略 是否足够清晰。 消费供给端的变化 消费品需求端的演进主要围绕稳定性、扩张性和升级性变化，而企业供给端的变化，则主要是渠道、产品和品牌的变迁。\n过去网购没有兴起，交通也没那么发达。那时候哪家消费企业的销售渠道广，哪家的竞争优势就更大。但随着物流业的发达，产品的渠道差异越来越弱化，此时市场占 有率的决定性因素更加回归到产品本身。\n随着行业发展，产品差异不断缩小后，消费品对于消费者心智的占领变得更加重要，这个阶段消费品牌拼的就是品牌力，具有品牌优势的龙头企业会占据更多的市场份 额。\n消费行业还需要关注的，是民族品牌和国货的崛起。\n在分析消费赛道时要注重渠道、产品和品牌这三个要点，看其能否与这三者的变迁保持同步甚至领先。具体来说，白酒、调味品和乳制品等食品饮料，家电、旅游出行 和“Z世代”新消费等都是值得关注的好赛道。\n二、白酒赛道 具有令其他赛道艳羡的极宽护城河\n一是保质期极长，不但无需考虑存货贬值的问题，某些“越陈越香”的老酒甚至还会逐年升值； 二是毛利率极高，普遍在70%以上； 三是品牌效应强、复购率高，具备一定的社交属性； 四是酿造技术变化不大，无须像科技企业那样必须投入高昂的研发费用。 对于白酒赛道的投资重点应放在高端和次高端酒上，关注目标企业的销量、提价速度以及是否具备“收藏属性”。对于在消费升级中获得更多市场份额的企业，可以投入 更多的关注。\n三、调味品赛道 据统计，当前只有30%的调味品消费发生在家庭厨房，20%是食品加工，剩下的大头是餐饮服务业在埋单。这种终端消费者构成，让调味料具备了较强的现代工业化属 性。\n那些建立了一定品牌效应，并且能够实现标准化生产的企业是值得青睐的。 调味品的另一个趋势就是功能性和高附加值带来的高端化 功能性主要体现在调味品的结构调整升级，过去一瓶酱油如今分成了生抽、老抽、耗油、海鲜酱油等 高附加值主要体现在品牌、健康化等特色上 还有一点更重要的是，与调味品庞大市场相对应的是其“大行业小公司”的赛道特征。也就是说调味品企业的赛道空间还很大，未来谁可以占据更大的市场份额，谁就会 有更好的发展。可以重点关注品牌效应好、市场扩张快的企业。\n四、乳制品赛道 乳制品是一个很有潜力的消费赛道。据统计，国内一线城市液态奶渗透率已达90%，但二、三线城市，大部分中小城市及农村地区渗透率仅分别为70%、50%、20%。随 着低线城市及农村地区人均可支配收入的提升及消费渠道的覆盖普及，未来乳制品市场渗透率将向二、三线城市靠拢，这将给乳制品带来巨大渗透空间。\n另外，乳制品还有一个现象：如今超市中单价较高的脱脂奶、低温奶、益生菌的占比越来越多，高单价也就意味着更高的毛利率和净利率，也就意味着企业利润有望进 一步提升。\n投资者应该将重点放在那些自控奶源充足、市场占有率高的企业上。\n五、家电赛道 未来大家电市场将更多地依靠技术进步来促进销量，因此要重点关注那些在智能化、场景化、套系化上做得更好的企业。\n另外，还可以着重挖掘电磁炉、扫地机器人、智能马桶和投影等小家电企业。一方面随着居民可支配收入的增加和消费升级，小家电的需求将迎来提升；另一方面，从 2020年开始，小家电的出口和海外渗透率都在明显加快。\n六、“Z世代”新消费赛道 随着“90后”“00后”成为新一代消费人群主力，诸如潮玩、宠物、美妆、医美、新式茶饮等新消费成了当下消费行业中颇具潜力的黄金赛道。\n对于新消费赛道的研究，要重点围绕着“90后”和“00后”的人群特性——这批人群有着较强的消费欲望和一定消费能力，注重品质与服务，同时对新事物有较高的接受度， 追求个性化、多样化以及体验式消费，更热衷于消费升级。\n此外，对于该赛道的研究还要比传统消费更重视品牌效应和产品质量。产品质量不错，品牌口碑更好的新兴企业往往有着更好的发展空间，反而传统消费行业中占有绝 对地位的价格因素没那么重要。可以更多关注铁杆客群庞大、提价能力超强的新兴消费企业。\n随着中国经济的发展，会有越来越多优秀的消费企业成长起来。在各行业中，消费有望继续保持牛股摇篮“C位”。另外，消费行业的产品和普通大众的日常生活息息相 关，一般人理解起来难度不算大。更重要的是，消费企业的财报也相对简单，不需要太多的财务知识也能看懂。\n消费完全有理由成为初学者投资组合中的必配行业。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%8C%E4%B8%9A/%E7%AC%AC%E5%9B%9B%E8%8A%82-%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A%E5%8F%8A%E7%BB%86%E5%88%86%E8%B5%9B%E9%81%93/","summary":"赛道通常是指行业里面的某个细分行业或领域 一、牛股辈出的消费行业 这一行业最大的特征就是需求稳定，背后的底层逻辑就是人口——只要社会仍在发展、人","title":"第四节 消费行业及细分赛道"},{"content":"投资圈使用较多的是申银万国、中信和万得等机构编制的行业分类标准。最常用的申万行业分类分为三级，一级分类有28个行业，二级分类有104个行业，三级分类有 227个行业。\n一、农林牧渔 农林牧渔主要包括种植业、渔业、林业、饲料、农产品加工、农业综合、畜禽养殖和动物保健等子行业。\n周期性极强 市场庞大 风险较高 由于需求量大，价格稍微变动都会对利润造成巨大的影响 盈率这一指标往往在农林牧渔上容易失真 由于农产品的生物特性，生产资料、动植物产品、存货天然不容易清点，交易结算方式现金交易占较多等因素，使得农林牧渔行业容易沦为财务造假重灾区 由于多年来中央“一号文件”均聚焦农业，每年年末和年初该板块都会出现一定投资机会。 二、采掘、钢铁和有色金属 采掘（主要是石油和煤炭）、钢铁和有色金属行业周期性极强，其股价也经常会跟随大宗商品的价格潮涨潮落。\n行业高峰期急速扩张后，会导致供给需求关系的恶化。加之近年来环保等政策压力剧增，牛转熊后的蛰伏期也会很长。所以除个别优质龙头外，多数采掘、钢铁和有色 类个股只适合抓波段，并不太适合长期持有。\n这类行情同样来得快去得也快，所以对于采掘、钢铁和有色这三个强周期行业还是建议只阶段性地参与。\n三、化工 化工包含的细分领域很多, 分析它时主要围绕四个要点：\n一是要根据其上下游产业链，判断供给和需求特点； 二是要关注其产品价格的变化趋势并和历史进行对比； 三是要关注更细分领域的竞争； 最后也是最重要的一点，需要密切关注企业的库存和开工率。 由于大多数化工行业或多或少都需要进口一些原材料，所以其上游原材料的价格也会对它造成不小的影响，因此也就容易受到国际市场美元和原油等大宗商品价格的影 响。\n四、传媒、电子、计算机及通信 通常所说的TMT（Technology, Media, Telecom）就是这四个行业的统称。\n高成长性 一定周期性 成长性、周期性和易泡沫化这三者凑到一起，就决定了TMT是一个高波动的领域。因此，投资TMT需要紧跟时代潮流，跟踪行业景气趋势，并重点关注能够保持持续创 新劲头的优质公司。这是潜在“十倍股”聚集区，但伴随的是投资风险较大，更适合积极进取、能接受股价较大回撤的激进投资者。\n五、食品饮料和家用电器 食品饮料和家用电器是消费板块的主力，也是必选和可选消费这两大消费分支的代表。必选消费就是对于人们来说刚需的消费品，比如乳业、调味品等，而部分消费品 人们收入达到一定水平后才会产生需求，如高端白酒和智能电视等，被归类为可选消费。\n消费板块牛股频出，和以下几个特征有关\n需求稳定, 以食品饮料为主的必选消费一般价格不太高，无论经济环境如何，人们的需求并不会有太大差异。随着生活水平的提高还会出现消费升级，又进一步延 展到对可选消费的需求。 易形成品牌效应。消费品往往在竞争到寡头局面后就容易形成品牌效应，进而实现规模效应 现金流充裕。大多数消费品都是一手交钱，一手交货，甚至先钱后货。所以读消费行业公司的财报经常会发现应收账款很少，反而预收账款较高。 投资者在研究该行业时应围绕业绩稳定性、现金流充裕度、市占率变化等因素进行分析。\n六、休闲服务、纺织服装和商业贸易 休闲服务就是通常说的餐饮服务、休闲旅游等，它和纺织服装和商业贸易都属于消费行业的一个分支，但在行业特征上有具备了很多服务业的特点。对于这三大行业的 分析，要重点围绕“人、货、场”这零售三要素进行。\n人，即创造业绩的主体。一方面指广大的消费者这一需求方，另一方面也指为需求方提供服务的服务方。对前者要看市占率以及市场扩张模式，后者的优势主要体现 在企业的管理上。 对于企业来说，货品是决定销售业绩最关键的因素。成本更低也好，奇货可居也好，货品优质也好，总之能让自己的“货”在某方面有优势就能构成企业快速发展的强 动力。 场，顾名思义就是场地，即门店卖场。这三个行业的门槛都不算高，同业竞争较大，如若能开辟更多的“场”，并让“场”的效率提升，在业绩增长上就会赢得巨大优势。 七、医疗 随着全民健康意识的觉醒和老龄化时代的渐行渐近，这一行业在国民经济中的地位也愈发重要。\n医疗行业主要包括制药、生物科技及医疗保健三大板块。由于覆盖面广、行业构成相对复杂，针对不同的细分行业，采用的研究方法也不尽相同。如对于高成长、周期 性的创新药要从科技的视角去看；对于定价权强的制药行业要用消费行业的分析逻辑去研究\n该行业还容易受政策影响 八、制造业 制造业是国民经济中占比较大的行业，涵盖电气设备、国防军工、机械设备、轻工制造、汽车等子行业，其发展对国计民生影响深远。从改革开放到21世纪初，中国一 直扮演着全世界制造工厂的角色。但随着东南亚国家在中低端制造业上开始发力，我国劳动密集型制造业的优势逐渐消退，制造业开始面临结构调整实现产业升级的重 要考验。\n所以对制造业的投资，要围绕产业升级、自主知识产权和新“智造”等关键词进行。\n具体可关注芯片、精密机床、航空航天、新能源、新材料和精密制造等方向。另外，传统制造业中研发能力和国际竞争力强的细分行业，如轨交设备、锂电池制造设备、 航空航天设备、工业激光设备等，也具备一定投资价值。\n九、金融业 对银行业的研究，重点在于内生性增长和收入来源。\n所谓内生性增长，是指不依赖于外部股权融资的情况下能够持续经营，并且保持银行对股东的回报持续增长。 收入来源方面，银行主要靠净利息收入和非利息收入。 其中，净利息收入的决定因素是吸收存款的规模和净息差。就增厚净息差而言，一种是提升资产收益率，另一种思路就是控制核心负债的成本。能在这两点上保持 领先的银行，就能在日趋残酷的市场竞争中占得先机。 非利息收入方面，想要增收，除保持必要的零售客户规模外，必须保持和客户的黏性。一般客户黏性越强，使用银行服务的种类就越多，频率就越高。所以一家银 行要想在收入上得到大的提升，就必须在零售业务、小微企业贷款、财富管理等新兴业务上取得优势 对保险行业的研究有两个要点需要关注：一是保险公司特有的研究指标EV（内含价值）。\n证券是一个和市场高度关联的行业，牛市期间，由于市场热情较高，证券公司的盈利也就大幅提高，这也是牛市的开始和结束时券商通常会大涨的原因。前者出于预期， 后者则是由实际业绩增长带来的。\n十、房地产、建筑材料和建筑装饰 在过去，房地产业的金融属性较强，但随着“房住不炒”的理念逐渐深入人心，房地产业开始逐渐回归其“住”的定位。而建筑材料和建筑装饰作为房地产的上下游，行业 发展会在很大程度上受到房地产业的影响。\n周期波动大 现金压力大 对于房地产行业的研究还要看两个“三角形”。\n一个是以周转率、利润率和杠杆为主的进攻三角形。 另一个是包括成本、融资和配套产品的防御三角形。 建筑材料和装饰行业则要重点关注产品质量和品牌口碑。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%8C%E4%B8%9A/%E7%AC%AC%E4%B8%89%E8%8A%82-%E4%B8%BB%E8%A6%81%E8%A1%8C%E4%B8%9A%E5%8F%8A%E5%85%B6%E6%8A%95%E8%B5%84%E8%A6%81%E7%82%B9/","summary":"投资圈使用较多的是申银万国、中信和万得等机构编制的行业分类标准。最常用的申万行业分类分为三级，一级分类有28个行业，二级分类有104个行业，","title":"第三节 主要行业及其投资要点"},{"content":"一、把握宏观环境与行业发展趋势的关系 一看行业与经济环境的相关性，二看行业未来发展趋势。\n在选行业时结合总体经济形势，把握行业政策、发展趋势和发展空间三方面，能帮助我们判断哪些行业更具增长前景，哪些可能遭遇发展瓶颈。\n行业政策对于行业的影响是致命的。积极的行业政策能够助推行业的发展，甚至逆市上涨；偏空的行业政策不仅会阻碍行业的发展，甚至可能给企业带来灭顶之灾。多 了解时政要闻，多读机构行业研报，或亲自登录中央及各地方政府官网了解当前和未来2～3年的行业政策，总归是个好习惯。\n行业空间是行业分析时必不可少的一环，它通常包含两个方面：一个是行业的品牌集中空间，另一个是行业的增量空间。前者相对来说好判断一些，毕竟在品牌集中的 过程中，龙头企业会有较大的竞争优势而且会滚雪球般快速积累，并在这个过程中形成行业壁垒、品牌护城河。而对行业的增量空间的判断则相对复杂，首先要搞懂 “行业的真正产品是什么”。\n二、把握行业结构和产业结构的关系 行业本身的结构主要指的是行业由哪些企业构成，以及各细分行业正处于生命周期的哪一个阶段。\n企业构成指包含的企业都有哪些？每个企业擅长的细分领域是哪个？哪些企业是龙头？龙头的市场占有率又是多少？这些研究能加深投资者对拟介入行业的了解。 对于细分行业的生命周期，主要是了解各细分行业当前正处于行业生命周期的哪一个阶段，是初创期、成长期、消退期、成熟期或是衰退期？了解这一块能让投资者 在选择行业时更容易乘上发展的“东风”。 对于产业结构方面，主要是需要了解行业所处的产业链位置以及行业替代品风险。行业所处产业链位置就是通常说的上游、中游和下游。上游行业通常是原材料供应端， 中游行业则主要是中间环节的制造加工端，至于下游，一般是直接面向市场或者客户的设计端或者销售端。在通常情况下，上游和下游的溢价和议价空间都会比较大， 中游行业则相对弱势。\n三、把握本行业的特有属性 有些行业天生就是好生意。比如白酒\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%8C%E4%B8%9A/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90%E7%9A%84%E6%96%B9%E6%B3%95/","summary":"一、把握宏观环境与行业发展趋势的关系 一看行业与经济环境的相关性，二看行业未来发展趋势。 在选行业时结合总体经济形势，把握行业政策、发展趋势和发","title":"第二节 行业分析的方法"},{"content":"一、行业分析的定义 投资中的行业分析则是对行业的发展历史、现状与格局等进行分析，从而找出行业的特征和结构，来对行业的市场容量、发展趋势等进行预测，进而找出最适宜投资的 行业。\n二、行业分析的意义 寻找具有投资潜力的行业 行业天花板指的是行业的产品（或服务）趋于饱和、达到或接近供大于求的状态。行业的天花板有三种：\n一种是已经达到天花板的行业，如钢铁，这类行业要重点关注市场份额和定价权； 第二是随着产业升级，旧天花板被解构，新天花板尚未或正在形成的行业，如随新能源发展出现变革的汽车制造业，要分析在达成新的行业平衡前行业的扩张速度； 最后是那些天花板尚不明确的行业，这些行业多处在新兴领域，对于该类企业要重点挖掘那些细分行业里具备领军地位的优秀企业。 根据各经济周期下行业分化表现顺势而为 除少数能够穿越经济周期的行业，大多数行业都是随着经济周期的盛衰而涨落。通过研究行业的特点来选择在合适的经济周期介入能更好地把握投资时机。\n在经济复苏初期考虑利润快速增长的家电、汽车等可选消费 在经济衰落时投资利润受经济影响小的食品饮料、调味品等必选消费 纵向分析行业生命周期确定投资策略 行业也有自己的生命周期，按照不同的阶段可分为初创期、成长期、成熟期以及衰退期。\n初创期：这个阶段的行业容量相对较小，消费者对产品缺乏认知，行业内企业的产品和技术发展方向不明晰，研发和市场开拓成本较大，亏损的可能性较大。但由于 整个行业发展水平都很低，竞争不是很激烈，行业进入壁垒也不高。此时要重点关注现金流较稳定，能够活下去的企业。 成长期：行业产品逐渐被消费者认可，市场需求和增长率都较高。随着行业内企业销售规模的增大，行业整体容量在快速扩大。该阶段行业利润率较高，行业内各企 业有竞争但并不强烈。此时要重点关注市场占用率提升迅速的企业。 成熟期：整个行业的需求已经接近或达到饱和，产品和技术已经完全形成，企业间竞争激烈。行业平均利润逐渐走低，开始出现企业淘汰和兼并重组，行业集中度逐 渐走高。此时那些技术壁垒高、市场占有率高的企业更值得关注。 衰退期：行业内产品和技术逐渐开始老化，新产品和新技术开始出现，原有产品的市场份额逐渐萎缩。此时拥有稳定市场份额、具备较强创新技术的行业更值得青睐。 横向对比同行业内各企业找准最优目标 可以横向对比毛利率、营收、增速、估值、市占率等财务指标，分析与同行相比存在哪些优势，还有哪些弱点和不足（指标明显低于行业平均不投，异常优秀的还需考 虑是否存在财务造假），在所处行业中的地位是否稳固等。同行对比，优中选优是买入个股前必做的功课，持有过程中也需要紧密关注行业动态。\n利用板块协同效应迅速响应市场 熟悉各行业板块的另一大作用就是，能充分利用股市中的板块协同效应。当某一行业政策出台或热点事件发生后迅速反应有哪些上市公司会受利好或利空影响，进行短 线逐利或及时避险，同时也可以分析是否存在错杀带来的投资机会。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%8C%E4%B8%9A/%E7%AC%AC%E4%B8%80%E8%8A%82-%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90%E5%AF%B9%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E7%9A%84%E6%84%8F%E4%B9%89/","summary":"一、行业分析的定义 投资中的行业分析则是对行业的发展历史、现状与格局等进行分析，从而找出行业的特征和结构，来对行业的市场容量、发展趋势等进行预","title":"第一节 行业分析对股票投资的意义"},{"content":"一、四大周期理论 基钦周期 整个周期的时间大约是5年，且往往是企业的存货（可简单理解为卖剩的东西）发生变化、起伏所导致的，所以又叫存货周期或库存周期。具体来说，就是在大规模的 机器设备、技术生产线没有办法改变的情况下，企业家依据经济形势的变化，调整存货而导致的经济波动。\n朱格拉周期 又称设备更新周期，周期时长通常为10年。朱格拉周期指向的是生产所用的机器设备的更新换代，因而比存货周期持续时间会更长，对整个经济的影响更大。\n库兹涅茨周期 又称房地产周期，周期时长大概是15～20年。\n康德拉季耶夫周期 又称技术革新周期，周期时长大概是50年左右。比如从最早的蒸汽技术到电力技术，再到互联网技术，从最早的马车到汽车、火车等，这种涉及基础设施领域的重大技 术突破所带来的经济周期波动。\n二、经济周期与股市的关系 股指本身就是经济的先行指标，市场往往会先于经济周期发生变动\n经济处于底部开始复苏前，股市已经开始上涨，经济露出衰退迹象时，股市已经悄悄下跌了一段时间。 经济在走向高峰之前股指已经提前见顶，经济还没有正式出现底部拐点，股市却可能先一步反弹 所以衰退期要以保本为主，此时多持有现金和短期存款等货币类资产形式，避免投资随经济衰退出现亏损，等经济复苏时再进入股市；而到经济繁荣期，当各种不懂投 资盲目跟进的人都开始在股市赚钱时，则考虑逐步收缩战线保护投资收益。\n三、经济周期与行业的关系 经济周期对不同行业的影响：有的行业在经济复苏期就有优异的表现，如能源、设备（机械、电子）等；而有的则是在衰退期发挥出较强的抗跌能力，如公用事业、必 选（日用）消费等。总之，投资者还应该考虑各行业本身的特性，在不同的市况下做出具体选择。\n图3-19　不同经济周期各行业股价表现示意\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E5%85%AB%E8%8A%82-%E7%BB%8F%E6%B5%8E%E5%91%A8%E6%9C%9F%E4%B8%8E%E8%82%A1%E5%B8%82-%E8%A1%8C%E4%B8%9A%E7%9A%84%E5%85%B3%E7%B3%BB/","summary":"一、四大周期理论 基钦周期 整个周期的时间大约是5年，且往往是企业的存货（可简单理解为卖剩的东西）发生变化、起伏所导致的，所以又叫存货周期或库存","title":"第八节 经济周期与股市、行业的关系"},{"content":"一、基础货币与货币乘数 货币政策是货币管理当局为实现其特定的经济目标而采用的各种调节和控制货币供应量的方针、政策和措施的总称。\n基础货币是由央行发行的那部分“原始的钱”，通过商业银行存贷款业务能够实现成倍地扩张或收缩，具备创生其他货币的功能，因而也有“高能货币”之称。基础货币是 货币发行量和商业银行法定存款准备金及超额存款准备金的总和，这在央行每个月公布的资产负债表上都有体现\n币发行完成后会通过各类政策工具投放到市场，过程很复杂，但最终会转化为商业银行的库存现金及企业和居民手中持有的现金，也就是上一节讲过的M0。\n表3-2　2020年8月央行资产负债表\n货币乘数正是通过商业银行体系的信用创造功能最终形成的货币供应总量与最初央行基础货币的比值。\n可以将货币乘数近似地视为法定准备金率的倒数 实际上各商业银行一般不会将杠杆放到最大，而是会根据实际流动性和自身经营规划，在法定存款准备金之外再多留一部分自行保管或缴存央行以备不时之需，即所 谓超额准备金率。 或缴存央行以备不时之需，即所谓超额准备金率。另外，现实中人们在获得资金后，也会基于各种原因留下部分现金。这些钱很可能再也回不到银行体系的信用创造 大循环中，即所谓的“现金损漏”。 二、几个重要的货币政策工具 央行想通过货币政策实现宏观调控目标，无非就是在法定存款准备金率和基础货币这两方面做文章。因此，旨在调控二者的再贴现、存款准备金率和公开市场操作被合 誉为一般性货币政策工具中的“三大法宝”。\n调控基础货币有量和价两个方向，也就是规模和利率。再贴现是央行通过买进商业银行持有的已贴现但尚未到期的商业汇票，向商业银行提供融资支持的行为，其本质 就是央行作为家长一样给各商业银行“发钱”。通过降低或提高再贴现利率，扩大或缩小再贴现额度，便可以达到释放或回笼流动性的目的。\n降低或提高存款准备率是股民更加熟悉的操作\n货币政策的四大目标分别是稳定物价、充分就业、经济增长及国际收支平衡，可从不包括“刺激股市”。请勿简单地将降准等同于必然大涨，从历次降准后的市场表现 看都是有涨有跌，特别是如果此前市场对降准消息已经有高度预期，指数已经累积一定涨幅，一旦利好落地反而得严防冲高后大幅回落。 公开市场操作是Open Market Operation的中文译名，简称OMO。它是由央行直接在金融市场上买卖政府债券、央行票据和外汇，用以吞吐基础货币的一种政策性 工具。2013年以前每年外汇占款规模较大，有多少外汇流入需要投放对应人民币兑换方可流通，当时央行主要用正回购和央票来回笼过剩的流动性。而此后外汇占款逐 步降低，主要矛盾开始转向需要用新的工具补充金融市场间歇性的流动性不足。\n短期流动性调节工具（SLO）、常备借贷便利（SLF）、中期借贷便利（MLF）等。目标定位为缓解流动性不足的它们每次出现都令股民倍感欣慰——只要规模扩大， 利率降低就简单粗暴地认为是股市利好，并亲切地冠以“酸辣圈”“酸辣粉”“麻辣粉”等昵称。 这几个品种本质区别不大，都是由央行以招标的方式，对符合条件的商业银行或政策性银行要求提供国债、央票、政策性金融债等优质债券为质押，满足条件即可获 得定额定价，期限长短不一的流动性支持，期满后还款赎回票据。 三、降息及其与降准的区别 银行从央行处获得资金的价格，包括SLF、MLF、再贷款、再贴现等利率调整，自然会传导到货币市场、债券市场和信贷市场。它们的下调和存贷款基准利率下降一起， 才构成财经媒体口中广义的“降息”。\n贷款市场报价利率（LPR）是在公开市场操作利率（主要就是MLF）基础上加点形成，各家银行再在LPR基础上自主定价 存款利率因和老百姓（尤其是中低收入人群）生活更为密切，为保民生，央行很少对存款基准利率“动刀子” 常见诸报端的“降息”通常是指MLF和LPR利率下降，真正的存贷款利率双降的“全面降息”较为罕见。 降息与降准的区别在于\n降准是释放新的流动性，为市场提供增量资金； 降息则并没有增加市场资金，只是改变资金投向，鼓励人们更多地去消费和投资。 降准是“量”的工具，主要影响金融机构，传导到实体经济和百姓生活尚需时日； 而人们对降息这种“价”的工具更敏感，降息比降准对国计民生的影响更大，央行对此慎之又慎。而正因为谨慎使用，一旦祭出这种“核武器”，市场会视为更强烈的 政策信号，对股市的影响也会比降准更大些。 降息到底是“重大利好”还是“利好落地”，都必须结合当时市场环境和指数所处位置综合判断\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E4%B8%83%E8%8A%82-%E8%B4%A7%E5%B8%81%E6%94%BF%E7%AD%96%E7%9B%B8%E5%85%B3%E6%8C%87%E6%A0%87/","summary":"一、基础货币与货币乘数 货币政策是货币管理当局为实现其特定的经济目标而采用的各种调节和控制货币供应量的方针、政策和措施的总称。 基础货币是由央行","title":"第七节 与货币政策相关的指标与概念（下）"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/eastmoney/","summary":"主页","title":"东方财富 数据中心"},{"content":"生成数字序列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 生成1～5的数字序列 $ seq 1 5 1 2 3 4 5 # 指定使用空格为分隔符 $ seq -s\u0026#39; \u0026#39; 1 5 1 2 3 4 5 # 指定步长为2，输出偶数 $ seq 2 2 10 2 4 6 8 10 # 不指定起始位置时，则默认起始位置为1 $ seq -s\u0026#39; \u0026#39; 8 1 2 3 4 5 6 7 8 # 支持调用变量 $ i=5 $ j=10 $ seq -s\u0026#39; \u0026#39; $i $j 5 6 7 8 9 10 ","permalink":"https://jdxj.github.io/posts/cmd/seq/","summary":"生成数字序列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 生成1～5的数字序列 $ seq 1 5 1 2 3 4 5 # 指定使用空格为分隔符 $ seq -s\u0026#39; \u0026#39; 1 5 1 2","title":"seq"},{"content":" 1 2 3 4 5 # 注意不同版本的free输出可能会有所不同 $ free total used free shared buff/cache available Mem: 8169348 263524 6875352 668 1030472 7611064 Swap: 0 0 0 total 是总内存大小 used 是已使用内存的大小，包含了共享内存 free 是未使用内存的大小 shared 是共享内存的大小 buff/cache 是缓存和缓冲区的大小 available 是新进程可用内存的大小 available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。\n","permalink":"https://jdxj.github.io/posts/cmd/free/","summary":"1 2 3 4 5 # 注意不同版本的free输出可能会有所不同 $ free total used free shared buff/cache available Mem: 8169348 263524 6875352 668 1030472 7611064 Swap: 0 0 0 total 是总内存大小 used 是已使用内存的大小，包含了共享内存","title":"free"},{"content":"“通货”一词的本义正是“流通中的货币”\n一、货币分层与M0/M1/M2 作为金融学名词，流动性是指某一资产或金融工具在不影响到其价格的情况下，在市场上快速成交转变为现金的能力。如股票交易方便容易出手而流动性好，而房子、 汽车和古董等不好变现故流动性较差。\n具体到货币上，流动性则特指其作为流通手段和支付手段的便利程度：流动性越高，在流通和交易中越容易被人接受，因此购买力也更强；流动性越差，周转不方便， 购买力也就更弱。\n以流动性作为统计口径，将货币分为M0、M1和M2等多个层次（M是英文money的首字母大写）。\n图3-13　我国货币分层体系\nM0是央行印发的，肉眼可见、可以直接拿来花的“钞票”，故而流动性最强，也和普通人生活消费最相关。 M1即所谓狭义货币，是在M0的基础上，再加上各企事业单位在银行的活期存款和居民个人手中的信用卡余额。这部分钱都是企业和个人随时准备好要用的，故而流 动性较高，可以体现当前的实际购买力。 广义货币M2涵盖内容更多，除M1之外，还要加上企事业单位定期存款、居民定活期存款、信托类存款、券商客户保证金和其他存款等。这部分钱流动性较差，只能 代表未来的潜在购买力，因此也被称为“准货币”。 二、M1和M2之间的关系及影响 多数年份两者都呈现同涨同跌的正相关关系，但在某些特殊的时期，也会出现“剪刀差”的情况\n图3-14　2001—2020年M1、M2同比增速\nM1增速高于M2，表征消费、生产领域需求和物价增高，持续6个月以上可判定为通胀的信号。一般M1增速快一点是好事，但如果剪刀差过大或持续时间过长，短期内资 金都往股市和房市涌入的话，也会推升资产泡沫而引来调控或打压。\nM1增速低于M2（即所谓“负剪刀差”）的时间过长，表明市场对经济悲观，实体经济中投资机会减少，人们更愿意把钱存起来而不是花出去，地产企业房产销售资金回 笼后也不再投入新的开发项目，或资金存留在金融系统内空转，管理层其实更担忧这种通缩的风险。\n三、社会融资规模 社会融资规模（简称“社融”）。它是指一定时期内（每月、每季或每年）实体经济从金融体系获得的资金总额，由金融机构表内业务（人民币和外币各项贷款）、金融 机构表外业务、直接融资（非金融企业境内股票筹资和企业债券融资）和其他项目四大类构成。\n图3-16 2020年存量社融各分项结构占比\n图3-17　社融与M2关系示意图\n社融是GDP、CPI和进出口等重要经济数据的先行指标（先行1～3个季度），且相关系数甚至比M2更高。它反映的是金融系统对实体经济的支持程度，而M2反映的是金 融系统向社会提供的流动性，体现全社会的购买力水平。\n四、实战举例 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E5%85%AD%E8%8A%82-%E8%B4%A7%E5%B8%81%E6%94%BF%E7%AD%96%E7%9B%B8%E5%85%B3%E6%8C%87%E6%A0%87/","summary":"“通货”一词的本义正是“流通中的货币” 一、货币分层与M0/M1/M2 作为金融学名词，流动性是指某一资产或金融工具在不影响到其价格的情况下，在","title":"第六节 与货币政策相关的指标与概念（上）"},{"content":"一、CPI和PPI的概念 CPI全称Consumer Price Index，中文译为消费者价格指数，是用以反映与居民生活有关的消费品及服务价格水平变动情况的经济指标。它不光与普通消费者的生 活息息相关，更是管理层经济决策的重要参考。其高低走向会影响国家宏观调控措施的出台与力度（如是否调息、是否调整存款准备金率等），因而也会波及各资本市 场。一般可以将CPI大于3%视为即将通货膨胀的信号，连续多月在3%以上居高不下可以判断通胀已经发生，如果发生CPI持续在5%之上的情况，可以视为严重的通货膨 胀。\n图3-9 1980—2020年中国CPI统计\nPPI，全称Producer Price Index，中文是生产者价格指数。它是从生产者角度观察的物价指数，用以测量制造业厂商在初级市场（非零售市场）上首次购进或卖 出某种货物价格的变动情况，因此又可以分为生产者购进价格指数和生产者出厂价格指数。两者分别代表了投入和产出，差值刚好可以反映工业生产的利润水平。 财经新闻和研报点评中常见的一般是狭义PPI，即生产者出厂价格指数。\n二、CPI和PPI的统计方法 CPI和PPI用百分数表示，均由国家统计局和地方统计部门负责统计，近年来月度数据基本在次月9日前后公布。\nCPI的统计方法\n第一步是确定纳入CPI核算的商品和服务项目。 第二步需要根据居民消费支出的比重，为8大类及262个子类分别赋予不同权重。 图3-10 CPI统计构成\n第三步是抽选约500个市县，确定采集价格的调查点，包括食杂店、百货店、超市、便利店、专业市场、购物中心、农贸市场等共6.3万个。按照“定人、定点、 定时”的方式，派近4000名调查员到各个调查点现场采集价格。价格采集频率因商品而异 最后，根据审核后的原始价格资料，按消费水平不同给各地区定权重，逐级统计汇总出各省市和全国的CPI。 PPI的统计编制原理和CPI类似，但因统计对象是制造厂商购买或生产的产品价格，可以不用派调查员四处出击，只要抽选有代表性的工业企业要求定期填报即可\n图3-11 工业生产者出厂价格调查问卷样式\n和CPI上下波动很大程度由猪肉蔬果决定类似，PPI主要受“三黑一色”，即石油、煤炭、钢铁和有色等生产资料价格的影响，此外，化工化纤行业亦有所贡献。\n三、CPI和PPI之间的关系 理论上同时期CPI和PPI应该呈涨跌方向一致的趋势，学界一般也将PPI视为CPI的先行指标。\n但在现实经济运行中，由于国际环境（如金融危机、国际原油暴涨暴跌等），各行业供需关系和国内宏观调控等方面的变化，CPI和PPI原本和谐共进退的关系也会走 向背离。\n四、CPI和PPI对股市的影响 PPI中细项又和A股部分板块关联度较高。如有色、钢铁、煤炭、水泥和玻璃等价格指数的暴涨暴跌，容易激发相关产业链中周期股的跟随性涨跌。当然，CPI中重要分 项猪肉价格的走势和A股中的“猪股”（生猪养殖、屠宰、饲料和动物疫苗等）也有“共进退”的现象。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E4%BA%94%E8%8A%82-cpi-ppi/","summary":"一、CPI和PPI的概念 CPI全称Consumer Price Index，中文译为消费者价格指数，是用以反映与居民生活有关的消费品及服务价格水平变动情","title":"第五节 最重要的通货膨胀观察指标——CPI和PPI"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/pmiii/","summary":"主页","title":"中采咨询"},{"content":"一、PMI的概念 Purchasing Manager\u0026rsquo;s Index，中文译为采购经理指数, 通过对企业采购经理的月度调查结果统计编制而成的综合指数。它涵盖制造业和非制造企业的采购、 生产和流通各环节，是国际通用的监测宏观经济走向的先行指标，具有较强的预测和预警作用。\n指标体系已包括新订单、积压订单、新出口订单、产量、雇员、供应商配送、库存和价格等多项商业活动指标。除制造业和服务业PMI外，有的国家还建立起了建筑 业甚至更多行业的PMI数据体系。 各国一般以50为荣枯分界线：PMI高于50意味着经济在扩张，数值越高扩张速度越快；低于50则意味着经济开始收缩，数值越低收缩得越厉害。 图3-6 2005—2020年美国PMI走势\n二、PMI的统计方法 PMI由5个分项指数加权计算而成，分别是\n反映需求端强弱情况的新订单指数，权重为30%； 反映生产端强弱情况的生产指数，权重为25%； 反映就业状况和企业招工意愿的从业人员指数，权重为20%； 反映交货时间快慢的供应商配送时间指数，权重为15%，需要指出的是，这一分项是一个逆指数，也就是数值越大交货时间越慢，表明经济越不活跃，因此在综合成 PMI指数时需要进行反向处理； 此外还有权重为10%的原材料库存指数，它反映库存状况和企业信心，企业补充原材料库存趋于增加，说明企业要加快生产，这个指标越大，表明未来经济保持平稳 增长的概率越大。 在每个月的22—25日，统计方以问卷调查的形式询问样本企业的采购经理或者主管企业运行的负责人对本企业的生产、订单、库存、雇员、配送时间等情况的看法\n图3-7 制造业采购经理调查问卷样式\n选项一般只有三个：比上月增加、持平和减少。然后对作出每一种回答的企业个数的占比赋予不同的权重（100%、50%、0），计算得出分项的指数，再按各分项权重 进行加总得到总体的PMI指数。\n假设有300家制造业企业参与调查，其中100家认为本月的生产比上个月上升（占比1/3），150家企业认为本月的生产与上个月持平（占比1/2），50家企业认为本月 的生产比上个月是下降的（占比1/6）。根据上述三项的权重，所得数据如下：\n本月生产指数=33.3×100%+50×50%+16.7×0=58.3 以此类推计算出其他四项分项指数之后，再按公式（PMI指数=新订单指数×30%+生产指数×25%+从业人员指数×20%+供应商配送时间指数×15%+原材料库存指数×10%） 加总计算即可。\n由上述可以得出两个结论：\n一是PMI是一个典型的“月对月”环比指标； 二是由于统计时间是每个月的22—25日，所以当月公布的PMI实际反映的是上月26日到当月25日样本企业的生产经营情况，并非完全是当月的经济情况。 PMI也会存在前文提及的“季节性调整”的问题。\n三、官方PMI与财新PMI 我国主流的PMI指数有两个。\n官方PMI由国家统计局和中国物流与采购联合会联合发布（也称“中采PMI”）。 财新PMI也称“民间PMI”，由英国研究公司Markit集团编制，目前由财新传媒冠名发布 两者的区别主要有以下几点。\n第一，发布时间不同。官方是统计当月最后一天发布，财新是次月第一天。 第二，统计口径不同。官方PMI统计口径更广泛多元，样本企业包括分布全国各地的超3000家大、中、小型企业；财新PMI以东部地区中小企业为采集对象，数量也 就400余家。官方PMI一般趋势性更强，反映大型经济主体景气状况，财新PMI波动性更大，反映中小企业生产经营情况为主。由此，某些时点两者会发生所谓数据 背离（即变化不一致的情况），但这反而能更全面地展示经济图景，辅助管理层和各类投资者做出更具针对性的决策。 第三，具体指标有所差异。官方公布的是制造业和非制造业PMI，财新PMI包括制造业和服务业两大分项。由于产业层级和GDP占比权重等原因，非制造业或服务业 PMI和股市相关性偏低，一般重点关注制造业PMI即可。 四、PMI与股市的关系 图3-8 2005—2020年PMI和上证综指走势\n单纯读取PMI数据并不能预判后市涨跌\nPMI统计只是基于受访者的主管定性判断，并不基于完整严谨的定量分析。先导性决定了它会提前3～6个月反映经济走势，会和同样为领先指标的股指存在时差。且 务必记住PMI是一个环比指标，如上一统计期基数低，会造成隔月数据反升较快的情况。 PMI冲得太快或高位滞涨时会引来管理层为经济降温，严重垮塌时会有量化宽松、降准降息等货币政策或减税降费等财政政策积极护盘 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E5%9B%9B%E8%8A%82-pmi/","summary":"一、PMI的概念 Purchasing Manager\u0026rsquo;s Index，中文译为采购经理指数, 通过对企业采购经理的月度调查结果统计编制而成的综合指数。它涵盖制造业和非制造企业的采购","title":"第四节 最受市场关注的先行指标——PMI"},{"content":"一、GDP的概念 GDP(Gross Domestic Product)国内生产总值, 指一个国家或地区所有常住单位在一定时期内（一般考察一个季度或一年）生产经营活动产出的全部产品和劳 务成果 GNP(Gross National Product)国民生产总值 一个在中国常驻的美国企业，所生产的产品计入中国而不是美国的GDP，只能计入美国的GNP。\n二、GDP的统计方法 GDP有价值、产品和收入三种表现形态，分别对应三种统计方法，即生产法、支出法和收入法，它们从不同视角衡量经济总量及构成，拥有各自的指标体系\n表3-1　我国GDP主要统计方法\n支出法的基本逻辑是，既然任何一种国民产出最终都会以某种方式被购买，那只要把花费在最终产品或劳务上的所有支出相加，总额就应该等于国民产出的总价值。其 下有一个著名的宏观经济学恒等式——GDP=C+I+G+（EX-IM）。\nC是家庭消费，G是政府采购商品和劳务的支出，两者和而构成“最终消费”； I是各类企业为维持经营所进行的生产性资产的投资； EX-IM即出口额减进口额所得出的净出口总值 三驾马车\n消费 投资 净出口 理论上，无论用何种方法统计，最终结果应该都能吻合。但在实践中由于各种方法的资料来源不同，数据加工换算方式不同等原因，三种结果会出现一定差异。西方国 家一般以支出法的结果为准，我国由于全面核算的基础相对较弱，部门的产值核算基础较好，以生产法统计为主。\n三、GDP增速高不一定意味着股市牛 GDP还有“名义GDP”和“实际GDP”之分。名义GDP很好理解，是用生产物品和劳务的当年价格计算的全部最终产品的市场价值，而实际GDP用从前某一年作为基准年 （这个年份经常变动，如2018年实际GDP统计以2010年为基准年，2019年则转而以2015年为基准年）的价格计算出当年全部最终产品的市场价值。\n二者通常不等，名义GDP增长率等于实际国内生产总值增长率与通货膨胀率之和，由通货膨胀引发的价格变动，即使产量一直没有变动，名义GDP仍然会上升。统计局 先根据统计数字得出名义GDP，然后再综合CPI、PPI、出口价格指数和进口价格指数等数据计算GDP平减指数，最后由名义GDP和平减指数得出实际增长率。GDP之外 的其他数据也存在类似问题，人们应关心的是剔除过物价上涨因素后的实际增长率，因为这才能更真实地反映经济增长情况。\n即便经济真的增长质量很高，股市就能蒸蒸日上吗？不好意思，答案还是不一定。\n解读数据务必综合存量（基数）、增量和增速考虑，很多GDP增速快的国家可能只是基数低，且增长质量不一定上佳。而对同一国而言，由于股市本身是领先指标， GDP反而是同步指标甚至有点滞后，经济增长同样不一定和股市呈正相关关系。\n四、GDP总量健康发展才是股市成长的关键 图3-4　中国GDP增速与A股走势\n图3-5　中国GDP与A股走势\nGDP应当用于看大势，其总量和增长质量好坏是决定“做或者不做”的关键，尽管增速可能非常缓慢，但国际资本更热衷于在GDP总量稳健向上的发达国家投资，而不会 在GDP动辄上天入地的新兴国家资本市场下重注。\n随着我国经济的发展和管理层对资本市场投融资功能的愈加重视，A股总市值占GDP比值不断提高，指数增长与GDP增速也有望往正相关回归，A股未来依然大有可为。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E4%B8%89%E8%8A%82-gdp/","summary":"一、GDP的概念 GDP(Gross Domestic Product)国内生产总值, 指一个国家或地区所有常住单位在一定时期内（一般考察一个季度或一年）生产经营活动产出的全部产","title":"第三节 最核心的宏观经济指标——GDP"},{"content":"注意事项\n解读数据要同时关注存量（基数）、增量和增速。以GDP为例，2007年后我国整体经济增速明显放缓，这是由于改革开放后经济高速发展，GDP基数不断提升，但不 能由此武断得出经济不景气的结论。 不能看数字直接下结论，要注意“同比”和“环比”的问题。同比的意思是本期数据与历史同时期比较，一般是与上一年度同一月份或同一季度比较，环比则是本期与 相邻最近的一段时期的数据对比，如本月比上月，本季度与上一季度对比。看到异常好或者特别差的数据时，要注意是否由去年同期数据或上月、上季度数据基数异 常造成。 季调数据. 自然气候、生产生活消费习惯、节假日等因素，两个相邻季度在季节上容易存在较大差距，若直接比对会放大季节性因素造成的短期波动。因此世界 各国在统计季度环比指标时，会采用各种季节性调整方法优化数据。 春节 各数据之间有千丝万缕的相互影响关系，还要学会整体、辩证甚至是逆向去解读宏观数据对股市的影响。 宏观数据还有先行指标、同步指标和滞后指标之分 先行指标又称领先指标或超前指标，是指在总体经济活动达到高峰或低谷之前，先行出现高峰或低谷的指标。常用的先行指标有采购经理指数（Purchasing Managers\u0026rsquo;Index, PMI）、货币供应量、十年期国债收益率等，它们往往能在总体经济发生变化前半年达到顶峰或低谷，是经济景气分析的有力工具。 同步指标又称一致指标，是指达到高峰或低谷的时间与总体经济出现高峰或低谷的时间大致相同的指标。同步指标可描述总体经济的运行轨迹，确定总体经济运行 的高峰或低谷位置。 滞后指标又称落后指标，是指其高峰或低谷出现的时间晚于总体经济出现高峰或低谷的时间的指标。它有助于分析前一经济循环是否已结束，下一循环将会如何变 化。 各类指标均有用途和优缺点，全面分析和预判经济形势走向需要密切跟踪各类数据的波动和勾稽关系，而一般投资者只需对此有所了解即可。但请注意股票操作要避免 受滞后指标干扰，因为股市指数本身也是一个先行指标，会提前6～9个月反映实体经济的变化\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%A7%A3%E8%AF%BB%E5%AE%8F%E8%A7%82%E6%8C%87%E6%A0%87/","summary":"注意事项 解读数据要同时关注存量（基数）、增量和增速。以GDP为例，2007年后我国整体经济增速明显放缓，这是由于改革开放后经济高速发展，GD","title":"第二节 如何正确解读宏观指标"},{"content":"图3-1　宏观经济研究的范围和对象\n一、对宏观分析的傲慢与偏见 连高善文自己也曾戏谑式地创作过一副对联，上联是“解释过去头头是道，似乎有理”，下联是“预测未来躲躲闪闪，误差惊人”，横批：经济分析。\n，对任何人、事和物过度的拔高和诋毁可能都是有失偏颇的。经济发展的宏观整体由无数个微观切面共同组成，同时各行各业的微观经济活动又需要在良好的宏观经济 状况保障下才能得以稳定运行。个体和社会的关系如鱼和水，良性互动方能水清鱼活。\n二、宏观分析的真正价值 研判政经大势有助于决定能否买股票 一旦把时间轴拉长，我们会发现股市长期表现与经济大势基本趋同，股指能在长期经济增长线上获得支撑。\n图3-2　1973—2019年纽交所指数与美国GDP走势\n明白经济周期有助于决定配置多少股票，以及买哪一大类股票 在确定某一国的股票市场值得参与后，还可以通过经济周期判断，在繁荣、滞胀、衰退和复苏等各个阶段，决定在各大类资产中配置多少比例的股票。\n读懂政策和重大事件能避免“听风就是雨” 宏观经济学浩如烟海，让普通投资者搞宏观研究并不现实，亦无必要。但了解基本的宏观常识对看明白财经新闻和读懂券商研报大有助益\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%88%86%E6%9E%90%E5%AF%B9%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E7%9A%84%E6%84%8F%E4%B9%89/","summary":"图3-1 宏观经济研究的范围和对象 一、对宏观分析的傲慢与偏见 连高善文自己也曾戏谑式地创作过一副对联，上联是“解释过去头头是道，似乎有理”，下联","title":"第一节 宏观经济分析对股票投资的意义"},{"content":" 上证综指 深证成指 创业板指 上证50指数 沪深300指数 中证500指数 中证1000指数 道琼斯工业指数 标准普尔指数 纳斯达克指数 恒生指数 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AD%E8%8A%82-%E9%87%8D%E8%A6%81%E8%82%A1%E5%B8%82%E6%8C%87%E6%95%B0%E4%BB%8B%E7%BB%8D/","summary":"上证综指 深证成指 创业板指 上证50指数 沪深300指数 中证500指数 中证1000指数 道琼斯工业指数 标准普尔指数 纳斯达克指数 恒生指数","title":"第六节 重要股市指数介绍"},{"content":"维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。\n如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。 如果此数据没有在缓存链表中，又可以分为两种情况： 如果此时缓存未满，则将此结点直接插入到链表的头部； 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。 ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0lru/","summary":"维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。 如果此数据之前已经被缓存在","title":"链表实现LRU"},{"content":"单向链表 插入, 删除操作时间复杂度为O(1)\n链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。\n循环链表 双向链表 双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。\n双向循环链表 链表 VS 数组性能大比拼 数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。\n数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足 （out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。\n链表本身没有大小的限制，天然地支持动态扩容\n如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。 而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片\n","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%93%BE%E8%A1%A8/","summary":"单向链表 插入, 删除操作时间复杂度为O(1) 链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。 循环链表 双向链表 双向链表可以支持 O(1) 时间复杂度的情","title":"链表"},{"content":"7.1 压缩列表的构成 图7-1 压缩列表的各个组成部分\n表7-1 压缩列表各个组成部分的详细说明\n图7-2 包含三个节点的压缩列表\n7.2 压缩列表节点的构成 个压缩列表节点可以保存一个字节数组或者一个整数值\n字节数组可以是以下三种长度的其中一种：\n长度小于等于63（2^6–1）字节的字节数组； 长度小于等于16383（2^14–1）字节的字节数组； 长度小于等于4294967295（2^32–1）字节的字节数组； 整数值则可以是以下六种长度的其中一种：\n4位长，介于0至12之间的无符号整数； 1字节长的有符号整数； 3字节长的有符号整数； int16_t类型整数； int32_t类型整数； int64_t类型整数。 图7-4 压缩列表节点的各个组成部分\n7.2.1 previous_entry_length previous_entry_length属性的长度可以是1字节或者5字节：\n如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。 如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值254），而之后的 四个字节则用于保存前一节点的长度。 图7-5 当前节点的前一节点的长度为5字节\n图7-6 当前节点的前一节点的长度为10086字节\n图7-7 通过指针运算计算出前一个节点的地址\n7.2.2 encoding 节点的encoding属性记录了节点的content属性所保存数据的类型以及长度：\n一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两 位之后的其他位记录； 一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录； 表格中的下划线“_”表示留空，而b、x等变量则代表实际的二进制数据，为了方便阅读，多个字节之间用空格隔开。\n表7-2 字节数组编码\n表7-3 整数编码\n7.2.3 content 图7-9 保存着节数组\u0026quot;hello world\u0026quot;的节点\n图7-10 保存着整数值10086的节点\n7.3 连锁更新 图7-13 连锁更新过程\n因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)。\n尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：\n首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见； 其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的； 因为以上原因，ziplistPush等命令的平均复杂度仅为O(N)\n7.4 压缩列表API 表7-4 压缩列表API\n7.5 重点回顾 压缩列表是一种为节约内存而开发的顺序型数据结构。 压缩列表被用作列表键和哈希键的底层实现之一。 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。 ","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC7%E7%AB%A0-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/","summary":"7.1 压缩列表的构成 图7-1 压缩列表的各个组成部分 表7-1 压缩列表各个组成部分的详细说明 图7-2 包含三个节点的压缩列表 7.2 压缩列表节点的构成 个压缩","title":"第7章 压缩列表"},{"content":"linux环境变量, 保存0~32767之间的随机整数\n1 2 3 $ echo $RANDOM $ echo $[RANDOM%10+1] 9 ","permalink":"https://jdxj.github.io/posts/cmd/random/","summary":"linux环境变量, 保存0~32767之间的随机整数 1 2 3 $ echo $RANDOM $ echo $[RANDOM%10+1] 9","title":"RANDOM"},{"content":" 面向对象与面向过程不是对立的\nOOP 更加能够应对大规模复杂程序的开发\n面向过程是线性的思维方式, 思考大规模程序的网状结构会吃力 面向对象先建模为类, 再按照流程将类组织起来 OOP 风格的代码更易复用、易扩展、易维护\n封装, 易维护 抽象, 易扩展 函数本身是一种抽象, 面向对象和面向过程都支持 面向对象支持基于接口的抽象 继承, 易复用 多态, 易扩展, 易复用 OOP 语言更加人性化、更加高级、更加智能\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9B%B8%E6%AF%94%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF/","summary":"面向对象与面向过程不是对立的 OOP 更加能够应对大规模复杂程序的开发 面向过程是线性的思维方式, 思考大规模程序的网状结构会吃力 面向对象先建模为类, 再","title":"面向对象编程相比面向过程编程有哪些优势"},{"content":"面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分 离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B/","summary":"面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方","title":"什么是面向过程编程"},{"content":"面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","summary":"面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。","title":"什么是面向对象编程"},{"content":"一、有关参与者的行话 多头（多方）：对股市未来行情乐观，预计股价还会继续节节攀升的人。 空头（空方）：对股市前景悲观，预计股价会下跌的人。 大户：资金实力雄厚、投资金额巨大、大批量买卖股票，甚至能够影响某只个股涨跌的投资者。 庄家：庄家必然是大户，但大户不一定是庄家。庄家是通过刻意买入大量股票，在一段时间内操纵股价涨跌，以达到某种特定目的的资金大户。 散户：这是与大户、庄家对应的概念, 但散户和“韭菜”不能画等号，在“七亏二平一赚”的A股中，还是有小部分散户能够脱颖而出，有的甚至能成长为“牛散”。 韭菜: 在金融圈，“韭菜”特指长期被各类“砖家”忽悠，不经过学习和思考就无脑买入股票、基金和理财等金融产品，次次赔钱甚至赔本，但偏偏屡教不改、不长记 性的人。 夹头：这是对价值投资者简称的谐音调侃。切忌在长期投资和短线投机之间摇摆不定，骑墙派会被市场教训得体无完肤，那才是真的“夹头”。 白衣骑士：当成为他人的并购目标后（一般为恶意收购），上市公司的控股方或管理层会寻找友好人士或其他企业的帮助，达到驱逐恶意收购者的目的。这提供资金 或其他资源，帮忙解救危难的第三方，便是财经报道中经常出现的“白衣骑士”。 二、有关市场的行话 牛市：也称多头市场，当多头占绝对优势时，牛市行情波澜壮阔，个股交易活跃，股价和指数屡创新高。2006年11月—2007年10月，上证指数从1833点一路高歌 猛进到6124点。2014年9月—2015年6月，上证指数从2401点启动，一直飙涨到5178点见顶。 熊市：也称空头市场，当多头散去，转由空头主导局面时，行情会变得萎靡不振，股价和指数开始一路下跌。熊市中管理层出台利好政策，甚至直接出手救市时，也 无人敢于出手做多。2007年11月—2008年10月，上证指数从6005点飞流直下到1664点。2015年6月开始的股灾，从5178点一路跌到2016年2月的2638点方才见 底反弹。 猴市和羊市：典型的牛市和熊市之间，更多时候是涨跌互相交织的震荡市。当震荡幅度较大，指数和股价动辄上蹿下跳时，被人们称为“猴市”；而指数窄幅波动， 股价温和整理的市场，则被称为“羊市”。 结构性牛市：猴市和羊市中，也会存在某些特定行业、板块走得比其他行业板块明显更强的情况，或某一风格主导市场. 结构性牛市也可以和“结构性熊市”同在。 技术性牛市：在各国央行大手笔货币宽松和财政放水后，多个市场都进入了“技术性牛市”。但严格意义上这并不是真牛市，站在技术分析的角度，从大盘指数最低点 算起涨幅超过20%时，才可以称之为技术性牛市。也有人将大盘稳定站上60日均线并且拐头向上定性为技术性牛市，还有更稳健的则将大盘站上120日均线定性为技 术性牛市。 回档和反弹：在指数上升至一定阶段和一段较长时间后，有可能面临短期下跌。也许是为了回避“跌”字，人们美其名曰“回档”；反之，跌跌不休的熊市也可能会迎 来一段回暖行情，江湖人称“反弹”。千金难买牛回头，牛市中的回档是不可错过的上车机会；而熊市中的反弹只是回光返照，重仓套牢者能抓住这难得的机会逃离也 算是一桩幸事。 反转: 反转由回档和反弹发展而来，当回档和反弹达到一定强度，甚至足以扭转当前趋势时，可以称之为“反转”。反转分为向上反转和向下反转，前者是熊市向牛市 的转换，后者则意味着牛市开始转熊。 盘整：在多数时候，指数会在某一段区间内上下波动，并无明显趋势性行情，这被称为盘整（或曰“横盘”）。盘整期间，投资者应静观其变，短线操作意义有限。 突破：突破也就是盘面开始发生变化，当指数上涨涨破前高，或下跌跌破前低时，即是盘整行情发生变化的信号（变盘）。前者为向上突破，后者为向下突破。突破 信号此后的技术图形如果确认有效，即是反转时刻的到来。 三、交易术语 吸货和出货：“货”即股票，吸货和出货就是买入和卖出股票的意思。 和“仓”有关的术语：货物储存的地方，就是仓库。交易账户中储存股票的地方，被人们形象地称为“仓”。 开始有计划地买入股票的过程是“建仓” 建仓后持有股票的状态，被称作“持仓” 持仓三成以内是“轻仓”，五成时是“半仓”，超过七成是“重仓” 现金全部买入，仓库里堆满股票后，就是传说中的“满仓” 有计划地抛售股票的过程，叫“减仓” 因某种原因被迫把账户内的股票全部卖出，叫“平仓” 主动把剩余全部股票一次性卖出的行为叫“清仓” 如果是赔本卖出的，也可以称为“斩仓” 整体仓位不变，但调换股票的行为，被称为“调仓” 出现浮亏，为降低持仓成本再次买入股票的行为叫“补仓” 本有浮盈，因看好某只股票选择再次买入的行为叫“加仓” 踏空：投资者本来持仓成本不高，但因为看空某只股票的后市表现选择卖出，结果此后股价一路上扬，只能眼巴巴看着别人赚钱，自己却守着一堆现金吃活期利息， 被江湖侠客们戏称为“踏空”。 套牢：意思刚好和踏空相反，指投资者看好某只股票的后市表现选择买入，结果此后股价一路下跌，又不舍得及时认亏卖出股票（俗称“割肉”，好听点叫“止损”）， 最后深度亏损的状态。 解套：深度亏损的股票股价回升，从而使套牢者可以以不赔本的价格卖出股票。 做T：是指通过先低买再高卖或先高卖再低买的交易手法，以达到赚取买卖价差、降低持仓成本等目的，过去老股民也俗称“抢帽子”。根据做T的顺序不同，可以分 为“正T”和“倒T”（也称“负T”）。上涨趋势中的个股可以在分时低点先买入，然后在后面的分时高点卖出，这是做正T；反之，下降趋势中的个股可以在分时高点先 卖出，待股价下跌后再在分时低点接回，是为倒T。当然能否真正达到降低成本的效果，依赖于准确判断分时高低点 对倒：游资、庄家开立多个账户自买自卖，让股票成交量和换手率升高，显得股性活跃，以达到吸引散户注意入场参与买卖股票的行为。 坐轿子和抬轿子：庄家通常会选择在某些小众低位股，将其股价抬升至高位后卖出盈利。普通投资者通过某些内幕信息，或技术图形预判股价会涨，在拉升之前提前 买入股票，这样的行为就是“坐轿子”。股价拉高后，庄家为了更好地出货，会通过刻意构造走势较好的技术图形，或在出货前散布利好消息，吸引投资者跟风买入。 如果投资者不幸中招，很可能面临亏损，沦为“抬轿子”的轿夫。 戴帽子和摘帽子：因财务或其他状况出现异常（如连续两年亏损）的上市公司股票交易，会被交易所进行特别处理（Special Treatment），具体的措施包括股 价涨跌幅限制为5%，股票名称前加“ST”，以及上市公司的中期报告必须经过审计等。被冠以ST“荣誉称号”的动作，就叫“戴帽子”。如果业绩持续无法改善，ST股 还会被再戴一个“*型帽子”（所以也叫“戴星”），*ST股风险更大，投资者务必谨慎参与，新手应该回避这类绩差股的炒作。 考察期内业绩改善，经营状况回归正常后，ST股和*ST股也有去除股票名前加冠的字母符号的机会，这个动作被称为“摘帽子”或“摘星”。一旦提前有摘帽子的消 息发布，股价很可能迎来一波上涨行情。 打板和翘板：在我国，除新股上市当天外，普通单日交易都有10%或20%的涨跌幅限制。所谓“打板”，是指股价异动，快速拉升至接近涨停时突击买入的交易行为。 专门从事类似短线交易的股民，也称为“打板族”。当股票跌停后抄底买入，豪赌股价当日回升的行为，则为“翘板”。围绕打板和翘板，也衍生出众多操作技法和专 有名词，如“天地板”，即指股价从涨停直接打到跌停；反之则为“地天板”。 在头一天股票涨停封板后，第二天继续涨停，就是打板族常说的“1进2”，如果第二天继续涨停，即是“2进3”。这种连续涨停板的赚钱效应很强，但盲目追高打板 也可能在高位接盘，遭遇各种“割韭菜大法”清洗。近几年流行的新名词“核按钮”，即是指在盘前盘中以跌停价格挂卖单，保证持股者以最快速度抛出筹码以换取 现金。 四、盘口术语 “盘口”是在股市交易过程中，观察大盘或个股交易动向的统称。在长期的股市实践中，习惯看图（分时图、日周月线图等）说话的技术分析派发明了大量的概念和指标， 共享着一整套分析盘面信息的概念和术语。\n洗盘：为减轻后续拉升股价顺利出货的压力，主力或庄家有时会通过“洗盘”有意制造恐慌，迫使低价买入却又意志不坚定的散户卖出股票。洗盘之后往往还会有拉升， 但究竟是洗盘还是真跌出货，就要看投资者自己的判断了。 崩盘：由于政治经济因素（次贷危机）或突发某种利空（战争、疫情），导致市场指数和绝大多数股票无限度暴跌，包括机构、主力和散户在内的所有参与者都在恐 慌情绪下集体抛售股票. 华尔街对崩盘有一个量化标准，通常被定义为单日或数日累计跌幅超过20%。 护盘：与崩盘对应的概念为“护盘”，股指持续下跌，人心惶惶之时，管理层甚至会动用国家力量直接参与救市。而个股股价大崩时，产业资本或机构、主力也会开始 发力护盘，即购入股票维持股价不再下跌，以防止造成更严重的连锁反应。 高开：指数或个股开盘价超过上一交易日收盘价，但未超过最高价的现象。如果买入力道过强，甚至超过前一日最高价，则为“跳空高开”。 低开: 指数或个股开盘价低于上一交易日收盘价，但未低于最低价的现象。如果卖出力道过强，甚至低于前一日最低价，则为“跳空低开”。 缺口：跳空高开或低开会在K线图中留下痕迹，即相邻两根K线之间的一段空白。通常情况下，如果缺口不被迅速回补，表明行情有延续的可能，如果缺口被回补， 表明行情有反转的可能。 平开：指数或个股开盘价与前一交易日收盘价持平 盘档: 指当天股价变动幅度很小，最高价与最低价之间差价不超过2%。对市场指数而言，行情进入盘整期后，指数上下波动幅度不大的情况 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%88%9D%E5%85%A5%E6%B1%9F%E6%B9%96%E9%9C%80%E4%BA%86%E8%A7%A3%E7%9A%84%E8%82%A1%E5%B8%82%E8%A1%8C%E8%AF%9D/","summary":"一、有关参与者的行话 多头（多方）：对股市未来行情乐观，预计股价还会继续节节攀升的人。 空头（空方）：对股市前景悲观，预计股价会下跌的人。 大户：","title":"第五节 初入江湖需了解的股市行话"},{"content":"一、技术分析派 根据所持“武器”的不同，技术分析派内部可细分为K线流、切线流、形态流、指标流和波浪流等，在我国还异化出了以“缠论”为代表的一批颇具个人特色的神奇学说， 被信徒们广泛用于股市、期市、汇市等投资领域。\n技术分析这一江湖名门下的各分支都笃信所有的宏观政策、市场讯息、企业的基本面变化、资金和情绪面的种种变化，最终都将体现在技术图形和各类技术指标的波动 当中。他们看重的是结果，而不是像基本面分析者一样去追寻原因。且各支流间一般没有太大分歧，各种技术理论的背后都是“量、价、时（间）、空（间）”这核心四 字在体现功效，各类指标和图形也能得到互相验证。因此，很多人会选择几种技术分析工具进行综合分析\n二、价值投资派 价值投资派的信仰是基于财务报表的基本面分析\n格雷厄姆一派致力于价值发现并长期持有 巴菲特在受费雪《怎样选择成长股》一书以及亲密挚友芒格的影响后，开创了价值投资派中新的一流——价值成长流 在承袭其师格雷厄姆关于企业的内在价值和安全边际理论后，巴芒一派还提出了独创的“能力圈”理论。 林奇不拘泥于持股时长和投资企业的行业属性，更看重股票背后公司在行业中的竞争地位和成长性。 其本人更是号称“不论什么股票他都喜欢”，持股数和换手率都比正统价投派更像个“投机者”。所以从某种意义上，也可以称该流派为“价值投机”。 三、组合投资派 哈里·马科维茨1952年发表的《资产选择》一文标志着现代投资组合理论（portfolio theory）的开端。他利用均值－方差模型分析，得出通过投资组合可以有效 降低风险的结论\n组合投资派信奉的基础教义其实只有最朴素的三条：\n第一，不要把所有的鸡蛋都放在一个篮子里面，否则“倾巢之下，难有完卵”； 第二，组合的风险与组合中资产的收益之间的关系有关； 第三，随着组合中资产种数增加，组合的风险下降，但是组合管理的成本提高，当组合中资产的种数达到一定数量后，风险无法继续下降。 四、量化交易派 量化交易派和组合投资派相比，对金融、数学、计算机等学科能力的要求更高，其中的高频交易流、对冲流对投资资金、交易系统的要求也相当苛刻，因此普通散户并 不容易学习和模仿。西方发达国家的量化交易派已经渐有称霸江湖之势，但国内量化交易派才刚起步，多由具有海外留学背景、金融工程或高等数学专业出身的高智商 “侠客”组成。\n图2-10　国内外量化基金发展历程\n对中小散户而言，直接运用量化交易模型的难度较大，但可以关注擅长于量化交易的公／私募基金（如华泰柏瑞、幻方、锐天等）推出的产品，作为个人资产配置组合 中的一环。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%9B%9B%E8%8A%82-%E8%82%A1%E5%B8%82%E6%B1%9F%E6%B9%96%E5%90%84%E5%A4%A7%E6%8A%95%E8%B5%84%E9%97%A8%E6%B4%BE%E7%AE%80%E4%BB%8B/","summary":"一、技术分析派 根据所持“武器”的不同，技术分析派内部可细分为K线流、切线流、形态流、指标流和波浪流等，在我国还异化出了以“缠论”为代表的一批","title":"第四节 股市江湖各大投资门派简介"},{"content":"一、各路资金齐聚A股 龙虎榜\n通常只有日内股票价格涨跌幅7%以上、股票价格日内换手率超过20%、股票价格日内上行振幅15%以上，或者连续三日内涨跌幅偏离值超过20%，数据处于前三的股 票才有资格上榜。 通过龙虎榜可以关注主力资金参与的交易，对证券营业部、机构、游资、基金或是大股东的交易进行观察参考。 虽然每天的龙虎榜都是在收盘之后才会公布，但是主力资金大概率不会一次性出货（除游资外）。所以投资者可以关注主力资金买入或者卖出股票的情况，进行投资 参考。 二、庄家、游资、主力一定能赚钱吗？ 各个炒股软件对机构、主力、散户，以及大单、中单、小单等概念的定义均不相同，这就导致每个公司同一天的市场统计、对同一只个股的资金流向记录各不相同。 庄家不一定赚钱 三、A股投资者结构 各主流机构的分类方法各有不同，如国金证券研究所采用个人投资者、一般法人（即所谓产业资本）、境内机构和境外机构的“四分法”\n图2-6　A股投资者结构分类之一\n申万宏源则将财政部、汇金、证金等政府机构纳入，增加了一类“政府持股”，也就是我们平时津津乐道的“国家队”\n图2-7　A股投资者结构分类之二\n图2-8　A股各类投资者持股占比\n四、各类参与者风格差异 占比最大的产业资本是不会轻易增减持的，其特点是对自家公司的经营现状和发展前景有较外界更为清楚的认识\n当市场极度悲观时（如2017—2018年），会趁股价便宜时制定并执行增持、回购计划，反之也会大手笔减持。 很多不明就里的散户对减持很反感，认为是“割韭菜”。但对减持必须视具体情况区分对待——底部减持多半是前景确实不乐观或重要股东缺钱，而高位减持更可以理 解为股价飙涨后，估值连管理者自己都认为高了，将心比心地说，这种情况下减持无可厚非，散户何必还去苦苦追高呢？ 政府投资股市，则更多是以支持产业发展（如国家集成电路产业投资基金，俗称“大基金”）或为完成某种特定目的而来（如股灾中救市）。\n我们可以在大方向上参考“国家队”入场和退场的节奏，当管理层对市场的急跌程度不能忍受，都已经出手救市时，深跌的个股就要考虑是否还需要在踩踏中割肉； 当“大基金”已经明确减仓甚至清仓某只热门牛股（如2020年的汇顶科技和闻泰科技等）时，就没有再傻乎乎地冲进去接盘的必要啦！ 内资专业机构中，公募基金占比最大。它的特点是崇尚价值投资\n散户在选股时可以选择优质基金“抄作业”，但当“抱团股”估值明显偏离常识，已经无法靠业绩增长支撑时，也不能犯盲从和盲目追高的错误。 和公募基金的一团和睦不同，私募基金良莠不齐的特点明显。私募基金中各种投资流派都有，有崇尚价值投资并知行合一的高瓴资本、高毅资产，也有量化大拿幻方、 明汯和锐天等，还有做超短的投机派。\n私募基金并不乐于在耳熟能详的大白马股中抱团，更多强调“价值发现”，做一些尚在底部的冷门小众股，且没有对外公开持仓的义务，偶尔透露出来的重仓股，也有 可能是故意放消息出来忽悠别人接盘，所以并不建议抄他们的作业 在挑选私募时，尽量买市场公认好公司的优质基金，规避买小众产品的踩雷风险 险资和社保基金性质类似，目标不在于多高的超额收益，保值是第一要务，其次才是追求稳健增值。因此这一类型的资金更愿意配置蓝筹权重，青睐有更高安全边际以 及低估值、高分红的银行股、地产股。长线或资金体量较大的散户可以适当借鉴，但热衷于短线投机的玩家没有研究它们持仓和操作风格的必要。\n近几年外资投资A股的热情居高不下，呈逐年稳步流入的特点。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%89%E8%8A%82-%E8%82%A1%E5%B8%82%E5%8D%9A%E5%BC%88%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8F%82%E4%B8%8E%E5%8A%9B%E9%87%8F/","summary":"一、各路资金齐聚A股 龙虎榜 通常只有日内股票价格涨跌幅7%以上、股票价格日内换手率超过20%、股票价格日内上行振幅15%以上，或者连续三日内涨","title":"第三节 股市博弈的主要参与力量"},{"content":"查看底层编码\n1 2 3 4 redis\u0026gt; SADD numbers 1 3 5 7 9 (integer) 5 redis\u0026gt; OBJECT ENCODING numbers \u0026#34;intset\u0026#34; 6.1 整数集合的实现 intset.h/intset\n1 2 3 4 5 6 7 8 typedef struct intset { //编码方式 uint32_t encoding; //集合包含的元素数量 uint32_t length; //保存元素的数组(可以视为[]byte) int8_t contents[]; } intset; contents数组按从小到大的顺序保存元素\ncontents数组并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值\n如果encoding属性的值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里的每个项都是一个int16_t类型的整数值（最小值为 -32768，最大值为32767）。 如果encoding属性的值为INTSET_ENC_INT32，那么contents就是一个int32_t类型的数组，数组里的每个项都是一个int32_t类型的整数值（最小值为 -2147483648，最大值为2147483647）。 如果encoding属性的值为INTSET_ENC_INT64，那么contents就是一个int64_t类型的数组，数组里的每个项都是一个int64_t类型的整数值（最小值为 -9223372036854775808，最大值为9223372036854775807）。 图6-1 一个包含五个int16_t类型整数值的整数集合\n6.2 升级 每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元 素添加到整数集合里面。\n根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性 质不变。 将新元素添加到底层数组里面。 向整数集合添加新元素的时间复杂度为O(N)。\n扩容复杂度?\n6.3 升级的好处 6.3.1 提升灵活性 避免类型错误\n6.3.2 节约内存 只在有更大的数据需要保存时才升级\n6.4 降级 不支持降级操作\n6.5 整数集合API 表6-1 整数集合API\n6.6 重点回顾 整数集合是集合键的底层实现之一。 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。 整数集合只支持升级操作，不支持降级操作。 ","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC6%E7%AB%A0-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/","summary":"查看底层编码 1 2 3 4 redis\u0026gt; SADD numbers 1 3 5 7 9 (integer) 5 redis\u0026gt; OBJECT ENCODING numbers \u0026#34;intset\u0026#34; 6.1 整数集合的实现 intset.h/intset 1 2 3 4 5 6 7 8 typedef struct intset { //编码方式 uint32_t encoding; //集合包含的元素数量 uint32_t length; //保","title":"第6章 整数集合"},{"content":"","permalink":"https://jdxj.github.io/posts/cmd/df/","summary":"","title":"df"},{"content":" 1 2 3 4 $ ps aux | grep /app root 4009 0.0 0.0 4376 1008 pts/0 Ss+ 05:51 0:00 /app root 4287 0.6 0.4 37280 33660 pts/0 D+ 05:54 0:00 /app root 4288 0.6 0.4 37280 33668 pts/0 D+ 05:54 0:00 /app s 表示这个进程是一个会话的领导进程，而 + 表示前台进程组\n进程组表示一组相互关联的进程，比如每个子进程都是父进程所在组的成员； 会话是指共享同一个控制终端的一个或多个进程组。 比如，我们通过 SSH 登录服务器，就会打开一个控制终端（TTY），这个控制终端就对应一个会话。而我们在终端中运行的命令以及它们的子进程，就构成了一 个个的进程组，其中，在后台运行的命令，构成后台进程组；在前台运行的命令，构成前台进程组。\n1 2 3 # 根据线程id(tid)找进程id $ ps -efT | grep 514 root 12280 514 14626 33 14:47 pts/0 00:00:05 /usr/local/bin/python /app.py 参考 其他进程状态参考不可中断进程和僵尸进程 ","permalink":"https://jdxj.github.io/posts/cmd/ps/","summary":"1 2 3 4 $ ps aux | grep /app root 4009 0.0 0.0 4376 1008 pts/0 Ss+ 05:51 0:00 /app root 4287 0.6 0.4 37280 33660 pts/0 D+ 05:54 0:00 /app root 4288 0.6 0.4 37280 33668 pts/0 D+ 05:54 0:00 /app s 表示这个进程是一个会话的领导进程，而 + 表示前台进程组","title":"ps"},{"content":" 1 2 3 4 5 6 7 # 查看中断情况 # -d 参数表示高亮显示变化的区域 $ watch -d cat /proc/interrupts CPU0 CPU1 ... RES: 2450431 5279697 Rescheduling interrupts ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ cat /proc/zoneinfo ... Node 0, zone Normal pages free 227894 min 14896 low 18620 high 22344 ... nr_free_pages 227894 nr_zone_inactive_anon 11082 nr_zone_active_anon 14024 nr_zone_inactive_file 539024 nr_zone_active_file 923986 ... ","permalink":"https://jdxj.github.io/posts/cmd/cat/","summary":"1 2 3 4 5 6 7 # 查看中断情况 # -d 参数表示高亮显示变化的区域 $ watch -d cat /proc/interrupts CPU0 CPU1 ... RES: 2450431 5279697 Rescheduling interrupts ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ cat /proc/zoneinfo ... Node 0, zone Normal pages free 227894 min 14896","title":"cat"},{"content":"Linux系统中的文件链接分为软链接和硬链接两种。\n软链接创建后，如果源文件被删除，则软链接将无法继续使用，可以跨分区和磁盘创建软链接。 硬链接创建后，如果源文件被删除，则硬链接依然可以正常使用、正常读写数据，但硬链接不可以跨分区或磁盘创建。 硬链接与源文件使用的是相同的设备、相同的inode编号。使用ls -l命令查看硬链接文件的属性时，文件属性与普通文件是一样的，而软链接的文件属性则可以看 到被l标记，表示该文件为软链接。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/linux/%E8%BD%AF%E9%93%BE%E6%8E%A5-%E7%A1%AC%E9%93%BE%E6%8E%A5/","summary":"Linux系统中的文件链接分为软链接和硬链接两种。 软链接创建后，如果源文件被删除，则软链接将无法继续使用，可以跨分区和磁盘创建软链接。 硬链接","title":"软链接 硬链接"},{"content":"为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：\n上半部用来快速处理中断(硬中断)，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。 下半部用来延迟处理上半部未完成的工作(软中断)，通常以内核线程的方式运行。 上半部会打断 CPU 正在执行的任务，然后立即执行中断处理程序。而下半部以内核线程的方式执行，并且每个 CPU 都对应一个软中断内核线程，名字为 “ksoftirqd/CPU 编号”，比如说， 0 号 CPU 对应的软中断内核线程的名字就是 ksoftirqd/0。\n软中断不只包括了刚刚所讲的硬件设备中断处理程序的下半部，一些内核自定义的事件也属于软中断，比如内核调度和 RCU 锁（Read-Copy Update 的缩写，RCU 是 Linux 内核中最常用的锁之一）等。\n查看中断 /proc/softirqs 提供了软中断的运行情况； /proc/interrupts 提供了硬中断的运行情况。 1 2 3 4 5 6 7 8 9 10 11 12 13 # 各种软中断的次数 $ cat /proc/softirqs CPU0 CPU1 HI: 0 0 TIMER: 811613 1972736 NET_TX: 49 7 NET_RX: 1136736 1506885 BLOCK: 0 0 IRQ_POLL: 0 0 TASKLET: 304787 3691 SCHED: 689718 1897539 HRTIMER: 0 0 RCU: 1330771 1354737 查看软中断内核线程\n1 2 3 $ ps aux | grep softirq root 7 0.0 0.0 0 0 ? S Oct10 0:01 [ksoftirqd/0] root 16 0.0 0.0 0 0 ? S Oct10 0:01 [ksoftirqd/1] ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/cpu/%E4%B8%AD%E6%96%AD/","summary":"为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部： 上半部用来快速处理中断(硬中断)","title":"中断"},{"content":"RWMutex 一般都是基于互斥锁、条件变量（condition variables）或者信号量（semaphores）等并发原语来实现。Go 标准库中的 RWMutex 是基于 Mutex 实现的。\n读写锁的设计策略\nRead-preferring: 只有所有的读都释放了锁之后，写才可能获取到锁, 会导致写饥饿 Write-preferring: 会导致读饥饿 如果已经有一个 writer 在等待请求锁的话，它会阻止新来的请求锁的 reader 获取到锁 如果有一些 reader 已经请求了锁的话，新请求的 writer 也会等待已经存在的 reader 都释放锁之后才能获取 不指定优先级: 某些场景下这种不指定优先级的设计反而更有效 Go 标准库中的 RWMutex 设计是 Write-preferring 方案。一个正在阻塞的 Lock 调用会排除新的 reader 请求到锁。\n1 2 3 4 5 6 7 8 9 type RWMutex struct { w Mutex // 互斥锁解决多个writer的竞争 writerSem uint32 // writer信号量 readerSem uint32 // reader信号量 readerCount int32 // reader的数量 readerWait int32 // writer等待完成的reader的数量 } const rwmutexMaxReaders = 1 \u0026lt;\u0026lt; 30 // 最大的 reader 数量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func (rw *RWMutex) RLock() { if atomic.AddInt32(\u0026amp;rw.readerCount, 1) \u0026lt; 0 { // rw.readerCount是负值的时候，意味着此时有writer等待请求锁，因为writer优先级高，所以把后来的reader阻塞休眠 runtime_SemacquireMutex(\u0026amp;rw.readerSem, false, 0) } } func (rw *RWMutex) RUnlock() { if r := atomic.AddInt32(\u0026amp;rw.readerCount, -1); r \u0026lt; 0 { rw.rUnlockSlow(r) // 有等待的writer } } func (rw *RWMutex) rUnlockSlow(r int32) { if atomic.AddInt32(\u0026amp;rw.readerWait, -1) == 0 { // 最后一个reader了，writer终于有机会获得锁了 runtime_Semrelease(\u0026amp;rw.writerSem, false, 1) } } 一旦一个 writer 获得了内部的互斥锁，就会反转 readerCount 字段，把它从原来的正整数 readerCount(\u0026gt;=0) 修改为负数（readerCount-rwmutexMaxReaders），让这个字段保持两个含义（既保存了 reader 的数量，又表示当前有 writer）。\n1 2 3 4 5 6 7 8 9 10 func (rw *RWMutex) Lock() { // 首先解决其他writer竞争问题 rw.w.Lock() // 反转readerCount，告诉reader有writer竞争锁 r := atomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders // 如果当前有reader持有锁，那么需要等待 if r != 0 \u0026amp;\u0026amp; atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0 { runtime_SemacquireMutex(\u0026amp;rw.writerSem, false, 0) } } 1 2 3 4 5 6 7 8 9 10 11 func (rw *RWMutex) Unlock() { // 告诉reader没有活跃的writer了 r := atomic.AddInt32(\u0026amp;rw.readerCount, rwmutexMaxReaders) // 唤醒阻塞的reader们 for i := 0; i \u0026lt; int(r); i++ { runtime_Semrelease(\u0026amp;rw.readerSem, false, 0) } // 释放内部的互斥锁 rw.w.Unlock() } 注意死锁\n重入 RLock中调用Lock writer 依赖活跃的 reader -\u0026gt; 活跃的 reader 依赖新来的 reader -\u0026gt; 新来的 reader 依赖 writer ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/rwmutex/","summary":"RWMutex 一般都是基于互斥锁、条件变量（condition variables）或者信号量（semaphores）等并发原语来实现。Go 标准库中的 RWMutex 是","title":"rwMutex"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 # 列出listen/非listen套接字 $ netstat -a # 列出tcp套接字 $ netstat -at # 展示端口号 $ netstat -ltn # 展示进程 $ netstat -ltnp # 显示 8080 端口所有处于 ESTABLISHED 状态的连接 $ netstat -atnp | grep \u0026#34;:8080\u0026#34; | grep ESTABLISHED ","permalink":"https://jdxj.github.io/posts/cmd/netstat/","summary":"1 2 3 4 5 6 7 8 9 10 11 # 列出listen/非listen套接字 $ netstat -a # 列出tcp套接字 $ netstat -at # 展示端口号 $ netstat -ltn # 展示进程 $ netstat -ltnp # 显示 8080 端口所","title":"netstat"},{"content":" 1 2 3 4 5 6 7 8 # 并发10个请求测试Nginx性能，总共测试100个请求 $ ab -c 10 -n 100 http://192.168.0.10:10000/ This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1706008 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, ... Requests per second: 11.63 [#/sec] (mean) Time per request: 859.942 [ms] (mean) ... 1 2 # 测试的并发请求数改成 5，同时把请求时长设置为 10 分钟 $ ab -c 5 -t 600 http://192.168.0.10:10000/ ","permalink":"https://jdxj.github.io/posts/cmd/ab/","summary":"apache bench是一个常用的 HTTP 服务性能测试工具","title":"ab"},{"content":"实时显示占用 CPU 时钟最多的函数或者指令\n1 2 3 4 5 6 7 8 $ perf top Samples: 833 of event \u0026#39;cpu-clock\u0026#39;, Event count (approx.): 97742399 Overhead Shared Object Symbol 7.28% perf [.] 0x00000000001f78a4 4.72% [kernel] [k] vsnprintf 4.32% [kernel] [k] module_get_kallsym 3.65% [kernel] [k] _raw_spin_unlock_irqrestore ... 第一行包含三个数据，分别是采样数（Samples）、事件类型（event）和事件总数量（Event count）。\n再往下看是一个表格式样的数据，每一行包含四列\n第一列 Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示。 第二列 Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等。 第三列 Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。 最后一列 Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。 perf top虽然实时展示了系统的性能信息，但它的缺点是并不保存数据，也就无法用于离线或者后续的分析。而perf record则提供了保存数据的功能，保存 后的数据，需要你用 perf report 解析展示。\n1 2 3 4 5 $ perf record # 按Ctrl+C终止采样 [ perf record: Woken up 1 times to write data ] [ perf record: Captured and wrote 0.452 MB perf.data (6093 samples) ] $ perf report # 展示类似于perf top的报告 1 2 # -g开启调用关系分析，-p指定进程号21515 $ perf top -g -p 21515 1 2 # 记录性能事件 $ perf record -g ","permalink":"https://jdxj.github.io/posts/cmd/perf/","summary":"是Linux2.6.31以后内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。","title":"perf"},{"content":"CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比\n查看cpu节拍数 单位是USER_HZ(10ms, 100HZ)\n1 $ cat /proc/stat | grep ^cpu 也可以用每一个场景的 CPU 时间，除以总的 CPU 时间，计算出每个场景的 CPU 使用率。\n直接用 /proc/stat 的数据直接算出来的，是开机以来的平均 CPU 使用率，一般没啥参考价值。为了计算 CPU 使用率，性能工具一般都会取间隔一段时间 （比如3秒）的两次值，作差后，再计算出这段时间内的平均 CPU 使用率\ncat /proc/stat | grep ^cpu各列含义\nuser（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。 nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。 system（通常缩写为 sys），代表内核态 CPU 时间。 idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。 iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。 irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。 softirq（通常缩写为 si），代表处理软中断的 CPU 时间。 steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。 guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。 guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。 Linux 也给每个进程提供了运行情况的统计信息，也就是 /proc/[pid]/stat\n查看cpu使用率 性能分析工具给出的都是间隔一段时间的平均CPU使用率，所以要注意间隔时间的设置，特别是用多个工具对比分析时，一定要保证它们用的是相同的间隔时间。\ntop 1 2 3 4 5 6 7 8 9 10 11 12 13 # 默认每3秒刷新一次 $ top top - 11:58:59 up 9 days, 22:47, 1 user, load average: 0.03, 0.02, 0.00 Tasks: 123 total, 1 running, 72 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.3 us, 0.3 sy, 0.0 ni, 99.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 8169348 total, 5606884 free, 334640 used, 2227824 buff/cache KiB Swap: 0 total, 0 free, 0 used. 7497908 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 78088 9288 6696 S 0.0 0.1 0:16.83 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.05 kthreadd 4 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 kworker/0:0H ... %CPU表示进程的 CPU 使用率。它是用户态和内核态 CPU 使用率的总和，包括进程用户空间使用的 CPU、通过系统调用执行的内核空间 CPU 、以及在就绪队列等 待运行的 CPU。在虚拟化环境中，它还包括了运行虚拟机占用的 CPU。\npidstat 1 2 3 4 5 6 7 8 9 # 每隔1秒输出一组数据，共输出5组 $ pidstat 1 5 15:56:02 UID PID %usr %system %guest %wait %CPU CPU Command 15:56:03 0 15006 0.00 0.99 0.00 0.00 0.99 1 dockerd ... Average: UID PID %usr %system %guest %wait %CPU CPU Command Average: 0 15006 0.00 0.99 0.00 0.00 0.99 - dockerd 用户态 CPU 使用率 （%usr）； 内核态 CPU 使用率（%system）； 运行虚拟机 CPU 使用率（%guest）； 等待 CPU 使用率（%wait）； 总的 CPU 使用率（%CPU）。 小结 CPU 使用率是最直观和最常用的系统性能指标，更是我们在排查性能问题时，通常会关注的第一个指标。所以我们更要熟悉它的含义，尤其要弄清楚用户（%user）、 Nice（%nice）、系统（%system） 、等待 I/O（%iowait） 、中断（%irq）以及软中断（%softirq）这几种不同 CPU 的使用率。\n用户 CPU 和 Nice CPU 高，说明用户态进程占用了较多的 CPU，所以应该着重排查进程的性能问题。 系统 CPU 高，说明内核态占用了较多的 CPU，所以应该着重排查内核线程或者系统调用的性能问题。 I/O 等待 CPU 高，说明等待 I/O 的时间比较长，所以应该着重排查系统存储是不是出现了 I/O 问题。 软中断和硬中断高，说明软中断或硬中断的处理程序占用了较多的 CPU，所以应该着重排查内核中的中断服务程序。 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/cpu/cpu%E4%BD%BF%E7%94%A8%E7%8E%87/","summary":"CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比 查看cpu节拍数 单位是USER_HZ(10ms, 100HZ) 1 $ cat /proc/stat | grep ^cpu 也可以用每一个场景的","title":"CPU使用率"},{"content":" 查看某key的内部编码\n1 2 3 4 redis\u0026gt; RPUSH lst 1 3 5 10086 \u0026#34;hello\u0026#34; \u0026#34;world\u0026#34; (integer)6 redis\u0026gt; OBJECT ENCODING lst \u0026#34;ziplist\u0026#34; raw embstr hashtable linkedlist ziplist intset skiplist ","permalink":"https://jdxj.github.io/posts/articles/jdxj/redis%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81/","summary":"查看某key的内部编码 1 2 3 4 redis\u0026gt; RPUSH lst 1 3 5 10086 \u0026#34;hello\u0026#34; \u0026#34;world\u0026#34; (integer)6 redis\u0026gt; OBJECT ENCODING lst \u0026#34;ziplist\u0026#34; raw embstr hashtable linkedlist ziplist intset skiplist","title":"Redis内部编码"},{"content":"5.1 跳跃表的实现 图5-1 一个跳跃表\n图片最左边的是zskiplist结构\nheader：指向跳跃表的表头节点 tail：指向跳跃表的表尾节点 level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内） length：记录跳跃表的长度，跳跃表目前包含节点的数量（表头节点不计算在内） 位于zskiplist结构右方的是四个zskiplistNode结构\n层（level）：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。 每个层都带有两个属性：前进指针和跨度。 前进指针用于访问位于表尾方向的其他节点， 跨度则记录了前进指针所指向节点和当前节点的距离。 在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。 当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。 后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用 分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列 成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象 注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表 头节点的各个层。\n5.1.1 跳跃表节点 redis.h/zskiplistNode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 typedef struct zskiplistNode { //层 struct zskiplistLevel { //前进指针 struct zskiplistNode *forward; //跨度 unsigned int span; } level[]; //后退指针 struct zskiplistNode *backward; //分值 double score; //成员对象 robj *obj; } zskiplistNode; 层 一般来说，层的数量越多，访问其他节点的速度就越快 每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这 个大小就是层的“高度” 图5-2 带有不同层高的节点\n前进指针 level[i].forward, 用于从表头向表尾方向访问节点\n图5-3 遍历整个跳跃表\n注意虚线标识的访问路径, 可以在不同层之间前进 跨度 level[i].span用于记录两个节点之间的距离\n两个节点之间的跨度越大，它们相距得就越远 指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点 跨度实际上是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。 图5-4 计算节点的排位\n图5-5 另一个计算节点排位的例子\n后退指针 backward每次只能后退至前一个节点。\n图5-6 从表尾向表头方向遍历跳跃表\n分值和成员 score是double类型的浮点数, 跳跃表中的所有节点都按分值从小到大来排序 obj指向一个字符串对象，而字符串对象则保存着一个SDS值 分值相同的节点将按照成员对象在字典序中的大小来进行排序 图5-7 三个带有相同分值的跳跃表节点\n5.1.2 跳跃表 redis.h/zskiplist\n1 2 3 4 5 6 7 8 typedef struct zskiplist { //表头节点和表尾节点 structz skiplistNode *header, *tail; //表中节点的数量 unsigned long length; //表中层数最大的节点的层数 int level; } zskiplist; 图5-8 由多个跳跃节点组成的跳跃表\n图5-9 带有zskiplist结构的跳跃表\nheader和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为O(1)。 通过使用length属性来记录节点的数量，程序可以在O(1)复杂度内返回跳跃表的长度。 level属性则用于在O(1)复杂度内获取跳跃表中层高最大的那个节点的层数量，注意表头节点的层高并不计算在内。 5.2 跳跃表API 表5-1 跳跃表API\n5.3 重点回顾 跳跃表是有序集合的底层实现之一。 Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而 zskiplistNode则用于表示跳跃表节点。 每个跳跃表节点的层高都是1至32之间的随机数。 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。 ","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC5%E7%AB%A0-%E8%B7%B3%E8%B7%83%E8%A1%A8/","summary":"5.1 跳跃表的实现 图5-1 一个跳跃表 图片最左边的是zskiplist结构 header：指向跳跃表的表头节点 tail：指向跳跃表的表尾节点 leve","title":"第5章 跳跃表"},{"content":"4.1 字典的实现 4.1.1 哈希表 dict.h/dictht\n1 2 3 4 5 6 7 8 9 10 11 typedef struct dictht { //哈希表数组 dictEntry **table; //哈希表大小 unsigned long size; //哈希表大小掩码，用于计算索引值 //总是等于size-1 unsigned long sizemask; //该哈希表已有节点的数量 unsigned long used; } dictht; 图4-1 一个空的哈希表\n4.1.2 哈希表节点 dict.h/dictEntry\n1 2 3 4 5 6 7 8 9 10 11 12 typedef struct dictEntry { //键 void *key; //值 union{ void *val; uint64_tu64; int64_ts64; } v; //指向下个哈希表节点，形成链表 struct dictEntry *next; } dictEntry; next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。\n图4-2 连接在一起的键K1和键K0\n4.1.3 字典 dict.h/dict\n1 2 3 4 5 6 7 8 9 10 11 typedef struct dict { //类型特定函数 dictType *type; //私有数据 void *privdata; //哈希表 dictht ht[2]; // rehash索引 //当rehash不在进行时，值为-1 int rehashidx; /* rehashing not in progress if rehashidx == -1 */ } dict; type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。 privdata属性则保存了需要传给那些类型特定函数的可选参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 typedef struct dictType { //计算哈希值的函数 unsigned int (*hashFunction)(const void *key); //复制键的函数 void *(*keyDup)(void *privdata, const void *key); //复制值的函数 void *(*valDup)(void *privdata, const void *obj); //对比键的函数 int (*keyCompare)(void *privdata, const void *key1, const void *key2); //销毁键的函数 void (*keyDestructor)(void *privdata, void *key); //销毁值的函数 void (*valDestructor)(void *privdata, void *obj); } dictType; ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行 rehash时使用。 图4-3 普通状态下的字典\n4.2 哈希算法 Redis计算哈希值和索引值的方法\n1 2 3 4 5 #使用字典设置的哈希函数，计算键key的哈希值 hash = dict-＞type-＞hashFunction(key); #使用哈希表的sizemask属性和哈希值，计算出索引值 #根据情况不同，ht[x]可以是ht[0]或者ht[1] index = hash \u0026amp; dict-＞ht[x].sizemask; 图4-4 空字典\n图4-5 添加键值对K0和v0之后的字典\n当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。\n这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。 4.3 解决键冲突 Redis的哈希表使用链地址法（separate chaining）来解决键冲突\n图4-6 一个包含两个键值对的哈希表\n因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置（复杂度为O（1）），排在其他已有节 点的前面。\n图4-7 使用链表解决k2和k1的冲突\n4.4 rehash Redis对字典的哈希表执行rehash的步骤\n为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值） 如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n； 如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n。 将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。 当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次 rehash做准备。 图4-8 执行rehash之前的字典\nht[0].used当前的值为4，4*2=8，而8（2^3）恰好是第一个大于等于4的2的n次方，所以程序会将ht[1]哈希表的大小设置为8。\n图4-9 为字典的ht[1]哈希表分配空间\n将ht[0]包含的四个键值对都rehash到ht[1]\n图4-10 ht[0]的所有键值对都已经被迁移到ht[1]\n释放ht[0]，并将ht[1]设置为ht[0]，然后为ht[1]分配一个空白哈希表\n图4-11 完成rehash之后的字典\n当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作\n服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5 哈希表的负载因子\n1 2 #负载因子=哈希表已保存节点数量/哈希表大小 load_factor = ht[0].used / ht[0].size 根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中， Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，所以在子进程存在期间，服务器会 提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。\n当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。\n4.5 渐进式rehash 扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但是，这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。\n为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键 值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完 成。 图4-12 准备开始rehash\n图4-13 rehash索引0上的键值对\n图4-14 rehash索引1上的键值对\n图4-15 rehash索引2上的键值对\n图4-16 rehash索引3上的键值对\n图4-17 rehash执行完毕\n因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、 更新（update）等操作会在两个哈希表上进行。例如，要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht[1]里面进 行查找，诸如此类。\n在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减 不增，并随着rehash操作的执行而最终变成空表。\n4.6 字典API 表4-1 字典的主要操作API\n4.7 重点回顾 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。 Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。 哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进 式地完成的。 ","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC4%E7%AB%A0-%E5%AD%97%E5%85%B8/","summary":"4.1 字典的实现 4.1.1 哈希表 dict.h/dictht 1 2 3 4 5 6 7 8 9 10 11 typedef struct dictht { //哈希表数组 dictEntry **table; //哈希表大小 unsigned long size; //哈希表大小掩码，用于计算索引值 //总是等于si","title":"第4章 字典"},{"content":"两个或两个以上的进程（或线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下去，此时，我们 称系统处于死锁状态或系统产生了死锁。\n死锁产生的必要条件\n互斥： 至少一个资源是被排他性独享的，其他线程必须处于等待状态，直到资源被释放。 持有和等待：goroutine 持有一个资源，并且还在请求其它 goroutine 持有的资源，也就是咱们常说的“吃着碗里，看着锅里”的意思。 不可剥夺：资源只能由持有它的 goroutine 来释放。 环路等待：一般来说，存在一组等待进程，P={P1，P2，…，PN}，P1 等待 P2 持有的资源，P2 等待 P3 持有的资源，依此类推，最后是 PN 等待 P1 持有的资源，这就形成了一个环路等待的死结。 ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/%E6%AD%BB%E9%94%81/","summary":"两个或两个以上的进程（或线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下","title":"死锁"},{"content":"演化过程 初版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // CAS操作，当时还没有抽象出atomic包 func cas(val *int32, old, new int32) bool func semacquire(*int32) func semrelease(*int32) // 互斥锁的结构，包含两个字段 type Mutex struct { key int32 // 锁是否被持有的标识 sema int32 // 信号量专用，用以阻塞/唤醒goroutine } // 保证成功在val上增加delta的值 func xadd(val *int32, delta int32) (new int32) { for { v := *val if cas(val, v, v+delta) { return v + delta } } panic(\u0026#34;unreached\u0026#34;) } // 请求锁 func (m *Mutex) Lock() { if xadd(\u0026amp;m.key, 1) == 1 { //标识加1，如果等于1，成功获取到锁 return } semacquire(\u0026amp;m.sema) // 否则阻塞等待 } func (m *Mutex) Unlock() { if xadd(\u0026amp;m.key, -1) == 0 { // 将标识减去1，如果等于0，则没有其它等待者 return } semrelease(\u0026amp;m.sema) // 唤醒其它阻塞的goroutine } Unlock 方法可以被任意的 goroutine 调用释放锁，即使是没持有这个互斥锁的 goroutine，也可以进行这个操作。这是因为，Mutex 本身并没有包含持有这把锁的 goroutine 的信息，所以，Unlock 也不会对此进行检查。Mutex 的这个设计一直保持至今。\n给新人机会 1 2 3 4 5 6 7 8 9 10 type Mutex struct { state int32 sema uint32 } const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // mutex is locked mutexWoken // 是否存在被唤醒的goroutine mutexWaiterShift = iota ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func (m *Mutex) Lock() { // Fast path: 幸运case，能够直接获取到锁 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } awoke := false for { old := m.state new := old | mutexLocked // 新状态加锁 if old\u0026amp;mutexLocked != 0 { // 锁未释放 new = old + 1\u0026lt;\u0026lt;mutexWaiterShift //等待者数量加一 } if awoke { // goroutine是被唤醒的， // 新状态清除唤醒标志 new \u0026amp;^= mutexWoken } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) {//设置新状态 if old\u0026amp;mutexLocked == 0 { // 锁原状态未加锁 break } runtime.Semacquire(\u0026amp;m.sema) // 请求信号量 awoke = true } } } \u0026amp;^含义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func (m *Mutex) Unlock() { // Fast path: drop lock bit. new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) //去掉锁标志 if (new+mutexLocked)\u0026amp;mutexLocked == 0 { //本来就没有加锁 panic(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } old := new for { if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken) != 0 { // 没有等待者，或者有唤醒的waiter，或者锁原来已加锁 return } new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken // 新状态，准备唤醒goroutine，并设置唤醒标志 if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { runtime.Semrelease(\u0026amp;m.sema) return } old = m.state } } 多给些机会 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func (m *Mutex) Lock() { // Fast path: 幸运之路，正好获取到锁 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } awoke := false iter := 0 for { // 不管是新来的请求锁的goroutine, 还是被唤醒的goroutine，都不断尝试请求锁 old := m.state // 先保存当前锁的状态 new := old | mutexLocked // 新状态设置加锁标志 if old\u0026amp;mutexLocked != 0 { // 锁还没被释放 if runtime_canSpin(iter) { // 还可以自旋 if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() iter++ continue // 自旋，再次尝试请求锁 } new = old + 1\u0026lt;\u0026lt;mutexWaiterShift } if awoke { // 唤醒状态 if new\u0026amp;mutexWoken == 0 { panic(\u0026#34;sync: inconsistent mutex state\u0026#34;) } new \u0026amp;^= mutexWoken // 新状态清除唤醒标记 } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { if old\u0026amp;mutexLocked == 0 { // 旧状态锁已释放，新状态成功持有了锁，直接返回 break } runtime_Semacquire(\u0026amp;m.sema) // 阻塞等待 awoke = true // 被唤醒 iter = 0 } } } 解决饥饿 在极端情况下，等待中的 goroutine 可能会一直获取不到锁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 type Mutex struct { state int32 sema uint32 } const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // mutex is locked mutexWoken mutexStarving // 从state字段中分出一个饥饿标记 mutexWaiterShift = iota starvationThresholdNs = 1e6 ) func (m *Mutex) Lock() { // Fast path: 幸运之路，一下就获取到了锁 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } // Slow path：缓慢之路，尝试自旋竞争或饥饿状态下饥饿goroutine竞争 m.lockSlow() } func (m *Mutex) lockSlow() { var waitStartTime int64 starving := false // 此goroutine的饥饿标记 awoke := false // 唤醒标记 iter := 0 // 自旋次数 old := m.state // 当前的锁的状态 for { // 锁是非饥饿状态，锁还没被释放，尝试自旋 if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) { if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() iter++ old = m.state // 再次获取锁的状态，之后会检查是否锁被释放了 continue } new := old if old\u0026amp;mutexStarving == 0 { new |= mutexLocked // 非饥饿状态，加锁 } if old\u0026amp;(mutexLocked|mutexStarving) != 0 { new += 1 \u0026lt;\u0026lt; mutexWaiterShift // waiter数量加1 } if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 { new |= mutexStarving // 设置饥饿状态 } if awoke { if new\u0026amp;mutexWoken == 0 { throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } new \u0026amp;^= mutexWoken // 新状态清除唤醒标记 } // 成功设置新状态 if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // 原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回 if old\u0026amp;(mutexLocked|mutexStarving) == 0 { break // locked the mutex with CAS } // 处理饥饿状态 // 如果以前就在队列里面，加入到队列头 queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } // 阻塞等待 runtime_SemacquireMutex(\u0026amp;m.sema, queueLifo, 1) // 唤醒之后检查锁是否应该处于饥饿状态 starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs old = m.state // 如果锁已经处于饥饿状态，直接抢到锁，返回 if old\u0026amp;mutexStarving != 0 { if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } // 有点绕，加锁并且将waiter数减1 delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift) if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { delta -= mutexStarving // 最后一个waiter或者已经不饥饿了，清除饥饿标记 } atomic.AddInt32(\u0026amp;m.state, delta) break } awoke = true iter = 0 } else { old = m.state } } } func (m *Mutex) Unlock() { // Fast path: drop lock bit. new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) if new != 0 { m.unlockSlow(new) } } func (m *Mutex) unlockSlow(new int32) { if (new+mutexLocked)\u0026amp;mutexLocked == 0 { throw(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } if new\u0026amp;mutexStarving == 0 { old := new for { if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken|mutexStarving) != 0 { return } new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { runtime_Semrelease(\u0026amp;m.sema, false, 1) return } old = m.state } } else { runtime_Semrelease(\u0026amp;m.sema, true, 1) } } vet发现Mutex复制原理 检查是通过copylock分析器静态分析实现的。 这个分析器会分析函数调用、range 遍历、复制、声明、函数返回值等位置，有没有锁的值 copy 的情景，以此来判断有没有问题。可以说，只要是实现了 Locker 接口，就会被分析。\n","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/mutex/","summary":"演化过程 初版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // CAS操作，当时还没有抽象出atomic包 func cas(val *int32, old, new int32) bool","title":"mutex"},{"content":"一、股票的概念 股票是有价证券的一种，是股份公司在筹集资本时公开或不公开向出资人发行的，用以证明出资人股东身份和权利，并根据股东所持股份数享有权利和承担义务的可转 让的书面凭证。\n二、股票的特点 图2-2　上海飞乐音响股票\n永久且不可偿还 上市公司通过发行股票融资，投资者认购股票后成为其股东，股票所载明的权责义务的有效性是无限期的。公司在，股票就在，你购买股票后就已经成为公司管理层的 一分子，中小股东和大股东是“同事”关系，不存在售后又后悔要求退股的“好事”，投资要慎重哦！\n可转让可流通 如果有幸参与了新股的一级市场发行，经过锁定期后股票达到目标价位，你又不想继续持有，当然可以选择转让给市场上的其他参与者；二级交易市场上，只要不是停 牌或涨跌停，如果股价涨超或跌破心理预期，或者发现公司质地欠佳，都可以选择卖给别人。\n参与人数较少、流动性欠佳、不方便随时变现的新三板股票，普通散户也尽量少参与\n收益与风险并存 收益既包括股价上扬部分，也包括每年从公司取得的股息、分红。 即便几十年间被誉为“只挤奶，不吃草”的优质公司，也会因为宏观经济环境、业绩变化和突发事件等影响出现股价大幅波动，如果基本面持续无法改观，中长期投资 逻辑也会发生变化。 其他不可忽视的权利 中小投资者往往容易忽视身为股东，还享有出席公司股东大会、参与制定影响公司未来走向的重大决策、选举公司董事会等权利。 当上市公司因信息披露不规范、虚假陈述、恶意隐瞒导致股价波动的消息等行为被监管处罚后，持股投资者可以依法发起诉讼索赔； 当企业经营不善破产清算时，中小股东同样拥有对公司在清偿债务和支付雇员报酬后剩余资产的分配权。 三、股票的分类 根据持有者享有权利的不同，可分为优先股和普通股 优先股的“优先”二字，主要体现在利润分红和公司剩余财产分配权上优于普通股。\n优先股股东每年收取固定的股息率，不参与上市公司管理，没有选举和被选举权，对公司重大经营事项无投票权，在某些特定的关系到优先股股东相关事项上有受严 格限制的投票权； 而普通股股东有着正常公司股东所应有的一切权利。但在公司经营不善的情况下，普通股股东的分红权利要次于优先股，破产清算时对剩余财产的分配上，优先股股 东优先于普通股股东。 一般情况下，中小散户在二级市场买卖的股票基本都是普通股，优先股在极特殊情况下才能够进入二级市场流通\n根据购买主体的不同，可分为国有股、法人股和社会公众股 国有股指有权代表同家投资的部门或机构以国有资产向公司投资形成的股份，包括以公司现有国有资产折算成的股份。 法人股指企业法人或具有法人资格的事业单位和社会团体以其依法可经营的资产向公司非上市流通股权部分投资所形成的股份。 社会公众股是指我国境内个人和机构，以其合法财产向公司可上市流通股权部分投资所形成的股份。对于大多数股民来说，在股票市场买卖的股票都是社会公众股。 根据上市地点的不同，可分为A/B、H、S、N、T、L股等 A股、B股都在中国内地注册并上市，A股以人民币认购和交易，参与者为内资机构和个人；B股以人民币标明面值，只能以外币认购和交易，参与者主要为港澳台居民及 外国人。\nB股日渐式微，走向边缘化。不建议散户尤其是新手参与该板块。 H、S、N、T、L股分别代表的是内地注册，在香港（Hong Kong）、新加坡（Singapore）、纽约（New York）、东京（Tokyo）和伦敦（London）上市的外资 股。\n有重点关注价值的是H股和N股，即港股和美股。这两个市场都比A股更成熟，整体估值也更为合理。很多大型金融和能源企业在内地、 香港两地上市（也称“红筹股”），但A股较H股溢价较多，从长期持有的角度看港股更为合适。 根据上市板块的不同，可分为主板、中小板、创业板、科创板和新三板股票 表2-1　A股各板块概况\n图2-3　中国资本市场体系分层\n其他分类 根据行业不同可分为金融股、消费股、医药股、科技股、有色股、化工股等； 根据市值大小可分为大盘股（蓝筹股）和中小盘股； 根据业绩优秀还是纯炒概念，可分为白马股和题材股； 根据企业风格又能分成价值股和成长股； 根据行业周期或特性还可分为周期股、防御股和进攻股等。 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%A6%82%E5%BF%B5-%E7%89%B9%E7%82%B9%E5%8F%8A%E5%88%86%E7%B1%BB/","summary":"一、股票的概念 股票是有价证券的一种，是股份公司在筹集资本时公开或不公开向出资人发行的，用以证明出资人股东身份和权利，并根据股东所持股份数享有","title":"第二节 股票的概念, 特点及分类"},{"content":"一、金融市场的分类 根据金融交易的期限\n一年以内的短期市场为货币市场，满足买卖双方短线资金流动性需求； 一年以上的长期市场就是我们经常在财经新闻中听到的高频词——资本市场，它存在的意义在于满足中央、地方政府弥补财政赤字和拟上市、拟发债企业的中长期投融 资需求。 根据金融交易交割期限的不同分为\n现货市场 期货市场 根据交易标的品种的不同分为\n股票市场 债券市场 贵金属市场 外汇市场等 几组分类并不完全周延，会存在交织重叠的情况。广义的资本市场概念之下又包括银行中长期存贷款市场和证券市场。人们常挂在嘴边的资本市场，一般约定俗成指的 就是证券市场。\n二、何谓证券市场 所谓证券，是指代表持有者某种所有权、收益权，或债权的法律凭证。现在常见，还在经济生活中发挥重要作用的有股票、债券、国库券、支票、汇票等，而已经退出 或正在逐渐退出历史舞台的粮票、邮票等，也都是广义证券的一种。\n证券市场即是股票、债券等有价证券发行和交易的场所，参与者包括\n发行人（融资方，包括政府、拟上市公司等） 投资者（包括金融机构和非金融机构、企事业单位、个人等） 中介机构（券商、资信评级机构、证券投顾公司等） 自律性组织（如证券交易所）等。 中国证券监督管理委员会，也就是证监会。 基金，包括证券投资基金、私募股权基金、上市公司并购基金、政府产业基金（如被大伙亲切称为“大基金”的国家集成电路产业投资基金）、创业投资基金等多种类型。 其中的证券投资基金可以在场内或场外买卖，同样属于证券概念范畴。\n所谓的“场”特指证券交易所，封闭式基金可以像股票一样在上交所或深交所买卖，而开放式基金可以在基金公司以及各个代销机构（如券商，银行，蚂蚁金服、天天 基金等互联网第三方平台）进行申购（买入）和赎回（卖出）。 无论场内、场外均属于证券市场统辖范围，证券交易所只是证券市场的组成部分之一，这是容易混淆需要厘清的地方。 二、中国证券市场的萌芽 三、中国证券市场的发展 四、中国证券市场终将走向成熟 图2-1　2019年全球资本市场竞争力指数排名\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E8%8A%82-%E4%B8%AD%E5%9B%BD%E8%AF%81%E5%88%B8%E5%B8%82%E5%9C%BA%E6%A6%82%E5%86%B5/","summary":"一、金融市场的分类 根据金融交易的期限 一年以内的短期市场为货币市场，满足买卖双方短线资金流动性需求； 一年以上的长期市场就是我们经常在财经新闻中","title":"第一节 中国证券市场概况"},{"content":"2.1 智能化脚本的基础之测试 条件判断的方式\n[[ expr ]] [ expr ] test expr 不管使用哪种方式进行条件判断，系统默认都不会有任何输出结果，可以通过echo $?命令，查看上一条命令的退出状态码，或者使用\u0026amp;\u0026amp;和||操作符结合其他命令进 行结果的输出操作。\n表达式两边要有空格 操作符两边要有空格 使用[[]]和test进行排序比较时，使用的比较符号不同 在test或[]中不能直接使用\u0026lt;或\u0026gt;符号进行排序比较(因为是输入输出重定向符号) 在一行中执行多个命令\n; 按顺序执行命令, 退出码以最后一个命令为准 \u0026amp;\u0026amp; 前一条命令成功后才会执行之后的命令, 都成功执行后退出码为0 || 前一条命令失败后才会执行之后的命令, 存在成功执行退出码为0 2.2 字符串的判断与比较 1 2 $ test a == b; echo $? $ [ a == b ]; echo $? -z测试字符串是否为空\n1 $ [ -z $TEST ] -n测试字符串是否非空\n1 $ [ -n $TEST ] 使用-n时最好使用\u0026quot;\u0026ldquo;将变量扩起来, 否则会测试随后空格, 返回值永为真 1 2 3 4 5 6 $ [ -n ] \u0026amp;\u0026amp; echo Y || echo N Y $ [ -n $Jacob ] \u0026amp;\u0026amp; echo Y || echo N Y $ [ -n \u0026#34;$Jacob\u0026#34; ] \u0026amp;\u0026amp; echo Y || echo N N 2.3 整数的判断与比较 表2-1 整数的比较运算符\n1 $ test 3 -eq 3 \u0026amp;\u0026amp; echo Y || echo N 2.4 文件属性的判断与比较 更多文件属性操作符可以参考命令帮助手册（man test）\n表2-2 文件属性操作符\n1 2 $ [ ! -e docs ] \u0026amp;\u0026amp; echo 对 || echo 错 错 在测试权限时需要注意，超级管理员root在没有rw权限的情况下，也是可以读写文件的，rw权限对超级管理员是无效的。但是如果文件没有x权限，哪怕是root也不 可以执行该文件。\n2.5 探究[[]]和[]的区别 多数情况下[]和[[]]是可以通用的，两者的主要差异是：test或[]是符合POSIX标准的测试语句，兼容性更强，几乎可以运行在所有Shell解释器中，相比较而言 [[]]仅可运行在特定的几个Shell解释器中（如Bash、Zsh等）。事实上，目前支持使用[[]]进行条件测试的解释器已经足够多了。使用[[]]进行测试判断时甚至 可以使用正则表达式。\n在[[]]中使用\u0026lt;和\u0026gt;符号时，系统进行的是排序操作，而且支持在测试表达式内使用\u0026amp;\u0026amp;和||符号。在test或[]测试语句中不可以使用\u0026amp;\u0026amp;和||符号。\n[[]]中的表达式如果使用\u0026lt;或\u0026gt;进行排序比较，使用的是本地的locale语言顺序。可以使用LANG=C设置在排序时使用标准的ASCII码顺序。 1 2 $ LANG=C $ [[ b \u0026gt; A ]] \u0026amp;\u0026amp; echo Y || echo N 虽然[]也支持同时进行多个条件的逻辑测试，但是在[]中需要使用-a和-o进行逻辑与和逻辑或的比较操作，而[[]]中可以直接使用\u0026amp;\u0026amp;和||进行逻辑比较操作，更直 观，可读性更好。\n1 2 $ [ yes == y -a no == no ] \u0026amp;\u0026amp; echo Y || echo N $ [[ yes == y \u0026amp;\u0026amp; no == no ]] \u0026amp;\u0026amp; echo Y || echo N 在[[]]中==是模式匹配，模式匹配允许使用通配符。例如，Bash常用的通配符有*、? 、[…]等。而==在test语句中仅代表字符串的精确比较，判断字符串是否一模 一样。\n1 2 3 4 5 $ name=Jacob $ [[ $name == J* ]] \u0026amp;\u0026amp; echo Y || echo N Y $ [[ $name == J?cob ]] \u0026amp;\u0026amp; echo Y || echo N Y 在[[]]中还支持使用=～进行正则匹配，而在[]中则完全不支持正则匹配\n1 2 3 $ name=\u0026#34;welcome to beijing\u0026#34; $ [[ $name =~ w ]] \u0026amp;\u0026amp; echo Y || echo N Y [[]]支持分组测试()(类似数学计算中的括号), 仅部分shell的[]支持()\n1 2 $ [[ a == a \u0026amp;\u0026amp; (b == b || c == d) ]] \u0026amp;\u0026amp; echo Y || echo N Y 表2-3 [[]]和[]的对比\n2.6 实战案例：系统性能监控脚本 2.7 实战案例：单分支if语句 1 2 3 4 5 6 7 8 if cond then cmd fi if cond; then cmd fi 任何有退出码的命令都可以写在if后面\n1 2 3 if grep -q AMD /proc/cpuinfo; then echo \u0026#34;AMD CPU\u0026#34; fi 2.8 实战案例：双分支if语句 1 2 3 4 5 if cond; then cmd else cmd fi 2.9 实战案例：如何监控HTTP服务状态 2.10 实战案例：多分支if语句 1 2 3 4 5 6 7 if cond; then cmd elif cond; then cmd else cmd fi 2.11 实战案例：简单、高效的case语句 1 2 3 4 5 6 7 8 9 case word in 模式1） 命令序列1; ; 模式2） 命令序列2; ; ...... ＊） 命令序列n; ; esac 1 2 3 4 5 6 7 8 9 case word in 模式1|模式2|模式3） 命令序列1; ; 模式4|模式5|模式6） 命令序列2; ; ... ... *） 命令序列n; ; esac word关键字展开支持使用~（根目录）、变量展开$、算术运算展开$[]、命令展开$()等。每个模式匹配中也都支持与word关键字一样的展开功能。 如果命令序列的最后使用了;;（双分号），则case命令不再对后续的模式进行匹配比较，即匹配停止。 如果使用;\u0026amp;替代;;会导致case继续执行下一个模式匹配中附加的命令序列。 如果使用;;\u0026amp;替代;;则会导致case继续对下一个模式进行匹配，如果匹配则执行对应命令序列中的命令。 2.12 实战案例：编写Nginx启动脚本 2.13 揭秘模式匹配与通配符、扩展通配符 表2-7 通配符\n使用shopt命令将Shell的extglob控制选项开启，则在Shell中可以支持如表2-8所示的扩展通配符。\n1 2 3 4 # 开启选项 $ shopt -s extglob # 关闭选项 $ shopt -u extglob 表2-8 扩展通配符\n2.14 Shell小游戏之石头剪刀布 ","permalink":"https://jdxj.github.io/posts/books/linux-shell%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/%E7%AC%AC2%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%84%9A%E6%9C%AC/","summary":"2.1 智能化脚本的基础之测试 条件判断的方式 [[ expr ]] [ expr ] test expr 不管使用哪种方式进行条件判断，系统默认都不会有任何输出结果，可以通过echo $?命令，","title":"第2章 人工智能, 很人工, 很智能的脚本"},{"content":"数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。\n随机访问 数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。\n低效的“插入”和“删除” 需要保证顺序时的情况\n插入\n最好, 在末尾插入, O(1) 最坏, 在开头插入, O(n) 平均, O(n) 删除\n最好, 在末尾删除, O(1) 最坏, 在开头删除, O(n) 平均, O(n) ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%95%B0%E7%BB%84/","summary":"数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 随机访问 数组支持随机访问，根据下标随机访问的时","title":"数组"},{"content":"封装（Encapsulation） 仅暴露必要的操作\n抽象（Abstraction） 只关注功能点不关注实现的设计思路\n继承（Inheritance） 复用代码\n多态（Polymorphism） 提高代码的可扩展性和复用性\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7/","summary":"封装（Encapsulation） 仅暴露必要的操作 抽象（Abstraction） 只关注功能点不关注实现的设计思路 继承（Inheritance","title":"面向对象四大特性"},{"content":" 1 2 # 以10个线程运行5分钟的基准测试，模拟多线程切换的问题 $ sysbench --threads=10 --max-time=300 threads run ","permalink":"https://jdxj.github.io/posts/cmd/sysbench/","summary":"一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况","title":"sysbench"},{"content":" 1 2 3 4 # 间隔5秒后输出一组数据 $ pidstat -u 5 1 13:37:07 UID PID %usr %system %guest %wait %CPU CPU Command 13:37:12 0 2962 100.00 0.00 0.00 0.00 100.00 1 stress 1 2 3 4 5 6 7 8 # 每隔5秒输出1组数据 $ pidstat -w 5 Linux 4.15.0 (ubuntu) 09/23/18 _x86_64_ (2 CPU) 08:18:26 UID PID cswch/s nvcswch/s Command 08:18:31 0 1 0.20 0.00 systemd 08:18:31 0 8 5.40 0.00 rcu_sched ... cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数 自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。 nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数 非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下 文切换。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 每隔1秒输出1组数据（需要 Ctrl+C 才结束） # -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标 $ pidstat -w -u 1 08:06:33 UID PID %usr %system %guest %wait %CPU CPU Command 08:06:34 0 10488 30.00 100.00 0.00 0.00 100.00 0 sysbench 08:06:34 0 26326 0.00 1.00 0.00 0.00 1.00 0 kworker/u4:2 08:06:33 UID PID cswch/s nvcswch/s Command 08:06:34 0 8 11.00 0.00 rcu_sched 08:06:34 0 16 1.00 0.00 ksoftirqd/1 08:06:34 0 471 1.00 0.00 hv_balloon 08:06:34 0 1230 1.00 0.00 iscsid 08:06:34 0 4089 1.00 0.00 kworker/1:5 08:06:34 0 4333 1.00 0.00 kworker/0:3 08:06:34 0 10499 1.00 224.00 pidstat 08:06:34 0 26326 236.00 0.00 kworker/u4:2 08:06:34 1000 26784 223.00 0.00 sshd 1 2 3 4 5 6 7 8 9 10 11 # 每隔1秒输出一组数据（需要 Ctrl+C 才结束） # -wt 参数表示输出线程的上下文切换指标 $ pidstat -wt 1 08:14:05 UID TGID TID cswch/s nvcswch/s Command ... 08:14:05 0 10551 - 6.00 0.00 sysbench 08:14:05 0 - 10551 6.00 0.00 |__sysbench 08:14:05 0 - 10552 18911.00 103740.00 |__sysbench 08:14:05 0 - 10553 18915.00 100955.00 |__sysbench 08:14:05 0 - 10554 18827.00 103954.00 |__sysbench ... 1 2 3 4 5 6 7 8 9 10 # 间隔 1 秒展示了进程的 5 组 CPU 使用率 # 每隔1秒输出一组数据，共输出5组 $ pidstat 1 5 15:56:02 UID PID %usr %system %guest %wait %CPU CPU Command 15:56:03 0 15006 0.00 0.99 0.00 0.00 0.99 1 dockerd ... Average: UID PID %usr %system %guest %wait %CPU CPU Command Average: 0 15006 0.00 0.99 0.00 0.00 0.99 - dockerd 1 2 $ pidstat -p 24344 16:14:55 UID PID %usr %system %guest %wait %CPU CPU Command 1 2 3 4 5 6 # -d 展示 I/O 统计数据，-p 指定进程号，间隔 1 秒输出 3 组数据 $ pidstat -d -p 4344 1 3 06:38:50 UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command 06:38:51 0 4344 0.00 0.00 0.00 0 app 06:38:52 0 4344 0.00 0.00 0.00 0 app 06:38:53 0 4344 0.00 0.00 0.00 0 app kB_rd 表示每秒读的 KB 数 kB_wr 表示每秒写的 KB 数 iodelay 表示 I/O 的延迟（单位是时钟周期） 1 2 3 4 # -d 查看进程I/O情况 $ pidstat -d 1 13:39:51 UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command 13:39:52 102 916 0.00 4.00 0.00 0 rsyslogd 用户 ID（UID）和进程 ID（PID） 。 每秒读取的数据大小（kB_rd/s） ，单位是 KB。 每秒发出的写请求数据大小（kB_wr/s） ，单位是 KB。 每秒取消的写请求数据大小（kB_ccwr/s） ，单位是 KB。 块 I/O 延迟（iodelay），包括等待同步块 I/O 和换入块 I/O 结束的时间，单位是时钟周期。 ","permalink":"https://jdxj.github.io/posts/cmd/pidstat/","summary":"一个常用的进程性能分析工具，用来实时查看进程的CPU、内存、I/O以及上下文切换等性能指标","title":"pidstat"},{"content":" 1 2 3 4 5 6 7 # -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据 $ mpstat -P ALL 5 Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU) 13:30:06 CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 13:30:11 all 50.05 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 49.95 13:30:11 0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 13:30:11 1 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 ","permalink":"https://jdxj.github.io/posts/cmd/mpstat/","summary":"一个常用的多核CPU性能分析工具，用来实时查看每个CPU的性能指标，以及所有CPU的平均指标","title":"mpstat"},{"content":" cs（context switch）是每秒上下文切换的次数。 in（interrupt）则是每秒中断的次数。 r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。 b（Blocked）则是处于不可中断睡眠状态的进程数。 bi 和 bo 则分别表示块设备读取和写入的大小，单位为块 / 秒。因为 Linux 中块的大小是 1KB，所以这个单位也就等价于 KB/s。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 每隔5秒输出1组数据 $ vmstat 5 procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 7005360 91564 818900 0 0 0 0 25 33 0 0 100 0 0 # 间隔1秒后输出1组数据 $ vmstat 1 1 procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 6984064 92668 830896 0 0 2 19 19 35 1 0 99 0 0 # 每隔1秒输出1组数据（需要Ctrl+C才结束） $ vmstat 1 procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 6 0 0 6487428 118240 1292772 0 0 0 0 9019 1398830 16 84 0 0 0 8 0 0 6487428 118240 1292772 0 0 0 0 10191 1392312 16 84 0 0 0 ","permalink":"https://jdxj.github.io/posts/cmd/vmstat/","summary":"一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析CPU上下文切换和中断的次数","title":"vmstat"},{"content":"进行竞争CPU也会导致负载升高\nCPU上下文\n寄存器 程序计数器(Program Counter, PC) CPU 上下文切换，就是先把前一个任务的 CPU 上下文保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行 新任务。\n而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。\n操作系统管理的“任务”\n进程 线程 中断 根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景\n进程上下文切换 线程上下文切换 中断上下文切换 进程上下文切换 进程上下文切换，是指从一个进程切换到另一个进程运行\n内核空间（Ring 0）具有最高权限，可以直接访问所有资源； 用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。 从用户态到内核态的转变，需要通过系统调用来完成, 这个过程会发生CPU上下文切换. 系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用 户空间继续运行进程, 也会发生CPU上下文切换.\n系统调用过程通常称为特权模式切换，而不是上下文切换。但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的。\n进程上下文切换 vs 系统调用\n进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、 寄存器等内核空间的状态。 Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变 慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。\n进程在什么时候触发调度(切换上下文)\n某个进程终止 时间片耗尽 进程所需系统资源不足 进程通过sleep挂起 优先级更高的进程运行 硬件中断 线程上下文切换 线程与进程最大的区别在于，线程是调度的基本单位，而进程则是资源拥有的基本单位。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线 程提供了虚拟内存、全局变量等资源。\n当进程只有一个线程时，可以认为进程就等于线程。 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。 线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。 线程的上下文切换其实就可以分为两种情况\n前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。 前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。 中断上下文切换 跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局 变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。\n对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行， 所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。\n观察中断\n1 2 3 4 5 6 # -d 参数表示高亮显示变化的区域 $ watch -d cat /proc/interrupts CPU0 CPU1 ... RES: 2450431 5279697 Rescheduling interrupts ... 重调度中断（RES），这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制， 通常也被称为处理器间中断（Inter-Processor Interrupts，IPI）。\n每秒上下文切换多少次才算正常\n这个数值其实取决于系统本身的 CPU 性能。在我看来，如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过 一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。\n这时，你还需要根据上下文切换的类型，再做具体分析\n自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题； 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈； 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/cpu/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/","summary":"进行竞争CPU也会导致负载升高 CPU上下文 寄存器 程序计数器(Program Counter, PC) CPU 上下文切换，就是先把前一个任务的 CPU 上下文保存起来，然后加载新","title":"上下文切换"},{"content":"sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。\n1 $ apt install sysstat 包含的命令\nmpstat pidstat ","permalink":"https://jdxj.github.io/posts/cmd/sysstat/","summary":"sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。 1 $ apt install sysstat 包含的命令 mpstat pidstat","title":"sysstat"},{"content":" 1 2 3 4 5 6 # 模拟一个 CPU 使用率 100% 的场景 $ stress --cpu 1 --timeout 600 # 模拟 I/O 压力 $ stress -i 1 --timeout 600 # 模拟的是 8 个进程 $ stress -c 8 --timeout 600 ","permalink":"https://jdxj.github.io/posts/cmd/stress/","summary":"Linux系统压力测试工具","title":"stress"},{"content":"一、股民常犯的错 毫无准备，仓促上阵 入市的准备应该是多方面的，包括规划资金、储备投资知识、了解目标股基本情况等。\n在买入标的上，优先选择流动性好、股价表现稳健的蓝筹股、白马股入手。在熟悉股市风格和个股股性后，再考虑买入更为激进的成长股、小盘股。科创板和新三板一 类本就有投资年限和资金门槛，即便具备了资格，也要对其抱有敬畏之心，多远观，不要随意“亵玩”。至于美股、港股和股指期货等高阶玩家的战场，新手最好回避。\n眼高手低，执迷于“快速致富” 盲目追求高收益只会导致短期行为，错误理解复利效应渴望每天一个涨停板更不可取。\n勇武有余，谋略不足 这体现在操作上，就是习惯于满仓甚至加杠杆杀进杀出，单独押宝单只个股。\n瞻前顾后，犹豫不决 首先，在观念上就不要总抱有买在最低点和卖在最高点这一不切实际的想法，能神奇逃顶抄底的永远只是传说，普通人不可能每次精准卡点。 其次，止盈止损都可以分批进行，分批卖出平滑收益或损失，避免一次性操作犯错后又后悔伤心。 第三，分批操作的依据应该结合基本面和技术面的变化，如估值过高、图形顶背离或跌破关键支撑时考虑卖出，估值合理、图形底背离或仍位于关键支撑之上时不必 急于马上止损。 无视风险，盲从他人 我国国情决定了券商轻易不会发看空研报，一般“中性”和“增持”的观点其实已经隐含了没那么看好个股后市的意思。\n多股评文章并非原创，都是在各个热点题材中找研报抄，找同行文章抄，这些人写的东西可能自己都不相信吧！\n所谓的小道消息，也就是深受散户喜欢的“内幕”，且不说是否属实，即便是真的，传到你那里也基本已是“八手消息”。路人皆知的利好一般发布在股价高位，也就是基 本涨到了找接盘侠接货的时候了。真正有价值的内幕必须是一手消息。而这又有违法违规之嫌，得是多愿意为你两肋插刀的好友会冒如此大风险给你送钱呢？\n二、解决办法 从基础知识学起，不管在现实生活中取得了多大的成就，都请以空杯心态进入这个对你而言全新的领域。建立良好的投资观，严格遵守纪律，做到知行合一。在股市中 慢就是快，只有耐得住寂寞才能守得住繁华。\n常反省错误，总结经验教训，在各类投资方法中选择适合自己的武器，打造自己的交易体系。唯有如此，才能离入门以及将来取得成功更进一步。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E5%BF%B5/%E7%AC%AC%E4%B8%83%E8%8A%82-%E6%96%B0%E6%89%8B%E8%82%A1%E6%B0%91%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/","summary":"一、股民常犯的错 毫无准备，仓促上阵 入市的准备应该是多方面的，包括规划资金、储备投资知识、了解目标股基本情况等。 在买入标的上，优先选择流动性好","title":"第七节 新手股民常犯的错误"},{"content":"一、何为好股 先拉一个“负面投资清单”，将爆出财务造假、业绩急速下滑、实控人或高管层道德品质瑕疵等丑闻的“雷股”，以及行业红利期已过、业绩常年表现不佳、高估值低分红 率的“渣股”，股价长期低位徘徊、成交量换手率明显过低、市场人气不足的“底部股”排除，A股上市公司中能选的标的就没那么多了。\n好行业 自古消费、医药出牛股，这些行业与人们的日常生活息息相关，茅台、格力、恒瑞等“名牌好股”已经持续强势多年。 在科技创新备受重视的当下，科技行业也不能忽视，这一领域可能会出现引领未来十年的好公司和新白马股。 而农业、军工、环境等行业中能持续走强的优质企业较少，和经营不透明、上市部分资产盈利能力弱、单一客户依赖性强、回款能力差等原因相关。 石油、煤钢、有色和化工等周期行业则容易受大经济周期和主营品种小周期等因素影响，股价容易急涨急跌、波动太大而不适合长期持有。 总的来说，好行业就是指那些国计民生需要、国家政策支持、日常经营可持续发展的行业。\n好赛道 在选定大行业后，还可以去挖掘小而美的细分赛道。一个好的赛道，除观察当前规模外，更要深挖其未来潜力及潜在市场。\n旧的赛道经过多年发展，新成员很难再有机会进入。龙头企业经过多年整合，市场份额占比大，经营环境稳定有序，行业话语权强，现金流稳定，每年提供可观的分 红。身骑白马可能跑得不是最快的，但一般会较稳。 而新赛道技术创新快，商业模式变革快，经常会出现新人颠覆旧人的现象。这种背景下选择那些跑得非常快的马，更容易在市场份额争夺战中成为赢家，赚取超额收 益。但参与黑马博弈需要更加谨慎——冷不丁会有马掉坑里或把腿摔断的情况。 好指标 很多质疑价值投资的人会问，财务造假怎么办？这一问题不可回避，但可以通过持续跟踪财务指标变化，定期检视关键指标勾稽关系，以及合理分配投资占比等办法来 解决或优化。此外，选择财务指标比较好的“优等生”至少比去买常年成绩不及格的“差等生”踩雷概率低。\n表1-5 2016—2020年ROE大于15%的上市公司\n好团队 一家优秀的企业离不开优秀的管理团队。 核心成员的道德风险也很重要。 好价格 因市场整体表现、经营环境及突发事件的变化，好股同样会发生股价的颠簸，有时调整的周期还会很长。在选股时，除基于财务指标等基本面分析外，还有必要参考技 术指标或信号。\n二、“长持”的正确姿势 首先是对长线的定义认识不准确。和高矮胖瘦一样，长短也是相对概念，每个人对长短线的定义和感知都会不同。一般而言，短线交易一般会在三五天内了结，今天买 明天卖的模式可谓之“超短”。\n要做好短线，必须对热点概念和题材有敏感而准确的把握，技术图形用5分钟、15分钟、30分钟或日线图来观察和分析。 而对企业业绩、基本面的分析则不是必要的——业绩对股价的影响除在季报、年报集中披露期较为明显外，多数时候两者关系有限。 其次，长持并不是一买了之，买完之后就可以高枕无忧。\n当宏观环境发生对企业根本不利的变化、护城河被竞争对手攻克、业绩被证伪或转为逐年下滑、市盈率飙涨到明显不合理的程度时，我们都应该对长持逻辑进行干预 和修正。 A股存在部分企业账务造假的问题，这要求我们必须对拟长期投资的公司进行密切跟踪和定期检视。如存货、应收账款、周转率和商誉等容易爆雷的指标亮起红灯时， 必须第一时间跟进和处理。 三、如何做到“静” “静”的前提必须是对个股基本面有深刻的认识 “静”还必须不断提高自己的学习和认知水平 四、收获盛开的复利之花 表1-6 初始投资10 000元的回报演练\n简单按财务指标，提取十年净利润增速平均高于25%、ROE高于20%，特殊年份（如2012年的白酒）股价回撤不超过20%的公司。近4000家上市企业中共有77家符合标 准，再剔除上市不足三年和股价波动异常的，剩下不到50只股票，如表1-7所示。\n表1-7 长期财务指标优异个股\n注：根据的是截至2020年5月底的数据。 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E5%BF%B5/%E7%AC%AC%E5%85%AD%E8%8A%82-%E5%A5%BD%E8%82%A1%E9%95%BF%E6%8C%81-%E9%9D%99%E5%BE%85%E8%8A%B1%E5%BC%80/","summary":"一、何为好股 先拉一个“负面投资清单”，将爆出财务造假、业绩急速下滑、实控人或高管层道德品质瑕疵等丑闻的“雷股”，以及行业红利期已过、业绩常年","title":"第六节 好股长持, 静待花开"},{"content":"一、投资和投机的区别 在英文语境中，投资（investment）本身就有买进买入的含义，投机可以被包括在广义的“投资”一词中；而投机（speculation）有沉思、思索、推测、猜测的语 义，本身不带价值判断色彩，更可以理解为是一种经过深思熟虑后，追求交易差价的投资行为。\n格老又在《聪明的投资者》一书中重新阐释了投机和投资的区别——他认为，两者之间最大的区别在于其对股市的态度。投机者的主要兴趣在于预测市场波动，并从中获 利；投资者的主要兴趣在于按合适的价格购买并长期持有合适的股票。\n二、部分股票或许只适合投机的原因 第一，A股牛短熊长，个股经常“坐过山车”。短促的牛市里不分好股、差股，股价都能暴涨。而在漫长的熊市里，很多股将长期下跌。如因追高套牢后自欺欺人骗自己 是“价值投资”，始终无法改变“解套思维”，无疑将白白浪费交易机会，极大降低资金效率。\n第二，“渣男股”太多，雷暴不断。\n蓝田 獐子岛 康美药业 第三，业绩和股价容易大幅波动的公司也尽量少做长持，突出的代表是有色、化工等周期股。\n华友钴业 第四，大量不分红低净资产回报率（ROE）的“铁公鸡”公司股票，不具备长持的逻辑基础。这类企业往往不仅利润质量差，而且盈利能力也很弱。\n紫鑫药业 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E5%BF%B5/%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%A4%9A%E6%95%B0%E8%82%A1%E7%A5%A8%E6%88%96%E8%AE%B8%E5%8F%AA%E9%80%82%E5%90%88%E6%8A%95%E6%9C%BA/","summary":"一、投资和投机的区别 在英文语境中，投资（investment）本身就有买进买入的含义，投机可以被包括在广义的“投资”一词中；而投机（spec","title":"第五节 多数股票或许只适合投机"},{"content":"原文\n1 $ go run -race main.go ","permalink":"https://jdxj.github.io/posts/articles/go/go-race-detector/","summary":"原文 1 $ go run -race main.go","title":"Introducing the Go Race Detector"},{"content":"大 O 复杂度表示法 1 2 3 4 5 6 7 8 int cal(int n) { int sum = 0; int i = 1; for (; i \u0026lt;= n; ++i) { sum = sum + i; } return sum; } T(n) = (2n+2)*unit_time\n1 2 3 4 5 6 7 8 9 10 11 int cal(int n) { int sum = 0; int i = 1; int j = 1; for (; i \u0026lt;= n; ++i) { j = 1; for (; j \u0026lt;= n; ++j) { sum = sum + i * j; } } } T(n) = (2n2+2n+3)*unit_time\nT(n) 表示代码执行的时间； n 表示数据规模的大小； f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。 公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度 （asymptotic time complexity），简称时间复杂度。\n当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。 时间复杂度分析 只关注循环执行次数最多的一段代码 第4, 5行 O(n) 1 2 3 4 5 6 7 8 int cal(int n) { int sum = 0; int i = 1; for (; i \u0026lt;= n; ++i) { sum = sum + i; } return sum; } 加法法则：总复杂度等于量级最大的那段代码的复杂度 sum_1: 100 sum_2: O(n) sum_3: O(n^2) 整段代码的时间复杂度就为O(n^2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int cal(int n) { int sum_1 = 0; int p = 1; for (; p \u0026lt; 100; ++p) { sum_1 = sum_1 + p; } int sum_2 = 0; int q = 1; for (; q \u0026lt; n; ++q) { sum_2 = sum_2 + q; } int sum_3 = 0; int i = 1; int j = 1; for (; i \u0026lt;= n; ++i) { j = 1; for (; j \u0026lt;= n; ++j) { sum_3 = sum_3 + i * j; } } return sum_1 + sum_2 + sum_3; } 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 ret: O(n) sum: O(n) cal: O(n^2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int cal(int n) { int ret = 0; int i = 1; for (; i \u0026lt; n; ++i) { ret = ret + f(i); } } int f(int n) { int sum = 0; int i = 1; for (; i \u0026lt; n; ++i) { sum = sum + i; } return sum; } 几种常见时间复杂度实例分析 非多项式量级 非多项式量级的算法问题叫作 NP, Non-Deterministic Polynomial\nO(2^n) O(n!) 多项式量级 O(1) 1 2 3 int i = 8; int j = 6; int sum = i + j; O(logn), O(nlogn) O(log_2 n)\n1 2 3 4 i=1; while (i \u0026lt;= n) { i = i * 2; } O(log_3 n)\n1 2 3 4 i=1; while (i \u0026lt;= n) { i = i * 3; } 如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。\nO(m+n), O(m*n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int cal(int m, int n) { int sum_1 = 0; int i = 1; for (; i \u0026lt; m; ++i) { sum_1 = sum_1 + i; } int sum_2 = 0; int j = 1; for (; j \u0026lt; n; ++j) { sum_2 = sum_2 + j; } return sum_1 + sum_2; } 空间复杂度分析 空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。\n只分配了new int[n]个空间, 复杂度为O(n)\n1 2 3 4 5 6 7 8 9 10 11 void print(int n) { int i = 0; int[] a = new int[n]; for (i; i \u0026lt;n; ++i) { a[i] = i * i; } for (i = n-1; i \u0026gt;= 0; --i) { print out a[i] } } 常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。\n内容小结 其他时间复杂度 最好情况时间复杂度（best case time complexity） 最坏情况时间复杂度（worst case time complexity） 平均情况时间复杂度（average case time complexity） 均摊时间复杂度（amortized time complexity） ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","summary":"大 O 复杂度表示法 1 2 3 4 5 6 7 8 int cal(int n) { int sum = 0; int i = 1; for (; i \u0026lt;= n; ++i) { sum = sum + i; } return sum; } T(n) = (2n+2)*unit_time 1 2 3 4 5 6 7 8 9 10 11 int cal(int n) { int sum = 0; int i = 1;","title":"复杂度分析"},{"content":"一、组合投资是平衡收益和风险的艺术 股票与其他投资品种一样，也是有风险的，其风险程度较存款、理财等防守型品种更大。股票投资的风险既包括市场整体下跌的系统性风险，还包括行业、个股的各类 黑天鹅事件。\n二、正确理解集中和分散的辩证统一 巴菲特对此曾有过经典论述：“分散投资是对无知者的保护，对于那些清楚自己在干什么的投资者，分散没有太多意义。”\n表1-4　2020年四季度伯克希尔·哈撒韦十大重仓股\n对新人的建议是根据资金体量大小\n10万元以内资金可购置3～5只个股进行组合 百万级别的资金可以适当买多一些，数量控制在6～10只为宜。 千万资金？炒股小白不应该拿这么多钱来练手，先考虑做资产配置吧！ ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E5%BF%B5/%E7%AC%AC%E5%9B%9B%E8%8A%82-%E8%82%A1%E7%A5%A8%E7%BB%84%E5%90%88%E6%8A%95%E8%B5%84%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/","summary":"一、组合投资是平衡收益和风险的艺术 股票与其他投资品种一样，也是有风险的，其风险程度较存款、理财等防守型品种更大。股票投资的风险既包括市场整体","title":"第四节 股票组合投资的必要性"},{"content":"制订资产配置计划，则是根据具体的理财目标配置不同比例的各类资产。\n一、主要资产分类 进攻型资产 进攻型资产大多是牺牲较多安全性和流动性来提高收益的产品，按照风险由大到小排序，主要包括：原油和商品期货、VC/PE等一级市场股权投资、股票和偏股型基金 等。\n稳定型资产 这类资产在牺牲部分流动性和小部分安全性的基础上尽可能提升收益，按照风险由大到小排序，主要包括：基金定投、信托、债券型基金、公募类REITs、理财、国债 等。\n防守型资产 按照收益由高到低排序，防守型资产主要包括定期存款、货币基金或现金管理类理财、活期存款、外汇、黄金和保险等。\n其中的黄金更是属于零息资产，本身没办法生息，却有较高的避险属性，这种避险属性能在经济、政治环境突发重大变化时起到缓冲作用。 同样是避险资产的美元和日元等，则可以在经济环境缺乏流动性时发挥作用，且安全性优于黄金。 而保险从某种角度来说是负息资产，通过牺牲收益率和流动性来降低遭遇风险后的损失。 二、资产配置的目标 资产配置目标应该与人生各阶段的所得和所需相结合，建议按所处的年龄层（生命周期）确定自己的资产配置目标，可分为三个时期。\n青年时期 踏入社会，开始赚工资的年轻人要学习自己打理资产。此时没有财富积累，每月结余也有限，却有“初生牛犊不怕虎”般的好奇心。学习如何理财的兴趣较浓，通常风险 偏好也比较高，可以通过基金定投这种形式每月进行投资。\n指数类基金是一个比较好的选择，可以理解为强制储蓄，建议初学者设置一个止盈目标位。 假如没有时间了解基金类产品，可以选择货币基金、债权类基金以及年金类保险，以季度、年度为单位进行强制储蓄。 如果极度保守，定期存款和国债就是更适合的投资工具。 很多学生初入大学就开启了财富之旅，建议通过债券型基金进行配置，可以兼顾流动性和安全性需求。 中年时期 事业渐入佳境后，收入增多，也相对稳定。但在上有老下有小的压力下，要维持一定水准的生活水平，需要在做好风险防控的前提下加大投资力度。\n该阶段可以将相对较多的资产放在股票、基金等权益型产品中，同时也要设置一些周期较长的“目标投资”，为未来的退休生活作准备。 具体可以选择那些长期风险低、收益稳健的产品，如养老目标FOF、专项基金定投和股债均衡的混合基金等。 同时，为了抗衡风险，有必要配置部分重疾险和意外险。 这个阶段，利用自己青年时期积累的知识和经验，均衡配置进攻型和稳定型资产，并开始逐渐增加保险等防守型资产。\n老年时期 赚钱已不再是第一要务，而应该享受承欢膝下的美好时光，并收获一生资产配置的成果。\n此阶段的消费需求逐渐减少，在资金安排上比较规律，尽量避免做股权、期货、股票和偏股型基金等高风险投资，可以选择中长期的固收类产品，同时可选择护理险、 意外险等保障类保险产品作为老年的风险保障补偿。 有些老年人考虑比较多的还有财富传承问题，这一目标可通过配置黄金、家族信托、终身寿险和保险金信托等实现。 对于这个时期的人群，自身的资产要以防守型和稳定型资产为主，其中保守型资产的结构也以流动性为首要考虑因素。\n三、各类人群的资产配比建议 职场新人 这类人有着“后浪”的锐气，特点是收入和积蓄有限，但因一人吃饱全家不饿，风险承受能力较强。\n图1-4　职场新人核心资产配置比例\n年轻就是资本，职场新人的核心资产配置可围绕“勇于尝试，积累经验”主题进行。\n将60%的资金投入股票或权益基金中，感受市场的残酷，在不断的成功和失败中积累经验，为未来的大额投资打下地基； 再将30%的资金投入偏债基金或进行基金定投，切身感受市场冷暖和经济周期对不同资产的影响，同时发挥基金定投强制储蓄的特性为自己的人生积累财富； 最后剩余10%的资金主要投资于货币型资产，一方面满足自己的日常消费，另一方面则用于提升自己的“硬件”——考证书、看书，学习各种技能。 中产“夹心层” “夹心层”人群的特点是在单位已有一定资历，但又还没站上领导岗位；家中上有老下有小，家庭开支压力较大。增加收入、防范未知风险和为未来谋划是“夹心层”群体 资产配置的核心需求。\n图1-5　中产“夹心层”核心资产配置比例\n用大约20%的家庭资产配置现金类资产和家庭保险 剩下的80%资产均衡地配置在进攻和稳定型资产中。 其中40%的进攻型资产要以股票和权益基金为主 40%的防守型资产均衡地配置在基金定投、债券型、“固收+”或理财等产品中。 所谓“固收+”，是指通过主投较低风险的债券等固定收益类资产构建一定的基础收益，同时辅以小部分权益资产来增强收益的基金，这部分增强收益的方式可以是通过 打新、定增、投资可转债或者二级市场股票等形式。在标准的基金分类中并没有所谓的“固收+”基金，“固收+”更多的是一个营销概念。但由于采取债券固收类为主、 权益为辅投资策略的产品普遍回撤都较小，客户体验好，于是人们就用“固收+”代指采取这种投资策略、回撤较小的基金。\n可以搜索\u0026quot;固收+\u0026ldquo;相关内容\n2021年，终于有人把固收+说清楚了！ 值得注意的是，此阶段无论是进攻型资产还是稳定型资产，在投资周期和期限上都要开始逐渐拉长。股票要以优质公司为主，只用小部分资产参与热点炒作，基金以长 期绩优稳定的主动管理基金为主。而稳定型资产，为未来养老、子女教育等特定目标设置的“专款账户”采用基金定投、偏债基金等波动较大的形式配置，迫在眉睫的短 期目标则尽量以理财、中短债等收益确定性高的产品为主。\n现金类资产以6～12个月日常生活所需的现金量为主，保险则以“保大不保小，保重不保轻”的原则配置。优先保障极端的情况，如重疾险和意外险，优先保障家庭中作 为主要经济来源的成员。另外需要注意，保险就要购买纯粹的保障性产品，不要选择那些把保障、投资、保值混为一谈的产品。冠以各类花名的万能险、分红险、投连 险等产品失去了保险的初心，且真实性价比并不如所宣传的那么高。\n全职美太太 这类人群的特点是有钱且有闲，缺少基本的投资知识却又总想“赚大钱”。这种心理可能和她们想向家人证明自己虽退出职场但依然有能力存在一定关系。\n图1-6　全职美太太核心资产配置比例\n把较多的资金投资于基金是为了充分借助基金经理的专业知识和投研能力，在牛市中帮自己抓住更多的热点，在熊市中减少进攻型资产的损失。如果是浸淫股市却依 然难以实现正收益的老股民，建议不要再炒股，而是通过偏股型基金实现“曲线救国”。 除了进攻型资产，“美太太”们还要用30%的资产均衡配置理财、债基等稳定型资产或定投基金，让自己的资产组合更加稳定。如果本身对风险比较厌恶的话，还可配 置一定比例（不超过10%）的黄金，提高资产组合的保值性和安全性。 最后一定要将20%的资产留作6～12个月的日常生活金，还要给在外辛苦赚钱的丈夫配置一份“爱的保障”——保险。 有钱老板 老板的特点是见识广、收入高，对资本市场有一定认识且风险承受能力强。但因发展事业奇缺时间，经常还有急需的大额资金缺口出现，所以资产配置时要保证充足的 流动性，进攻型资金可以往长持方向摆布。\n图1-7　有钱老板核心资产配置比例\n老板们首先可以拿出40%的资金配置大额存单、活期存款和货币基金等高流动性产品以备不时之需，同时要为自己这根家庭顶梁柱购买保险以提高家庭保障。 剩下的资产中，将40%左右的资金投资于进攻型资产，可以选择基金或者值得长持的好股，毕竟老板们都是大忙人，并没有太多工夫花费在短线炒作上。 稳定型资产以稳健的债券型基金和长期理财为主，建议少有时间管理账户的老板们减少指数基金定投的参与度，因为指数基金波动不小，不能及时止盈止损的话，很 容易频繁坐过山车。 近年来，定投指数基金这种“傻瓜式”的投资形式在财经媒体和财经博主的宣传下火爆“出圈”。但它其实并不像很多人臆想的那样，只要无脑坚持就能坐等收益。\n表1-3　定投沪深300指数基金收益情况\n图1-8　某中证500指数基金累计收益率波动统计\n所以指数定投建议采用适时止盈再定投的策略，即当收益达到目标收益后进行止盈，通过加大定投金额再投资来让收益最大化。\n退休族 该群体的特点是收入下滑但空暇增多，风险承受能力也开始降低。应围绕低风险、低波动和高流动性等关键词展开资产配置\n图1-9　退休族核心资产配置比例\n首先将资产中的30%用于配置流动性现金类资产，以备不时之需（看病、住院等）。 剩下70%的资金建立一个“固收+”组合 20%的股票或基金等进攻型资产加上50%的理财、债基、国债等稳定型固收资产。 这样即便出现极端的市场情况，股票、基金大亏40%，依靠固收类资产的稳定收益，也能把整个资产配置的损失降到5%以内。 最后，建议所有初学者，无论何种人群，无论处在哪个年龄阶段，在资产配置过程中都要尽可能少用杠杆。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E5%BF%B5/%E7%AC%AC%E4%B8%89%E8%8A%82-%E7%A8%B3%E5%81%A5%E8%87%B4%E5%AF%8C%E9%9C%80%E6%A0%91%E7%AB%8B%E8%B5%84%E4%BA%A7%E9%85%8D%E7%BD%AE%E7%90%86%E5%BF%B5-%E4%B8%8B/","summary":"制订资产配置计划，则是根据具体的理财目标配置不同比例的各类资产。 一、主要资产分类 进攻型资产 进攻型资产大多是牺牲较多安全性和流动性来提高收益的","title":"第三节 稳健致富需树立资产配置理念(下)"},{"content":"股票只是各大类资产中的一部分，要想稳健致富，需要依靠配置在各类市场环境中表现不一的资产，实现平滑风险、“东边不亮西边亮”的效果。\n过去很长一段时间里，普通人可投资品种匮乏。除了存款、理财和买房，似乎钱并没有其他太好的去处。而在房地产进入滞涨周期，世界各国不断降息齐步迈入负利率 时代的背景下，这样的配置结构显然不利于对抗通胀。\n图1-1　2019年各国居民资产配置结构\n图1-2　中国财富管理主要产品图谱\n一、资产配置理论简介 图1-3　美林投资时钟模型\n托宾教授“不要把鸡蛋放在同一个篮子”经典之语的后半句是“但也不要放在太多的篮子里”。\n资产配置绝不是让你分散投资同一品种，而是要在各大类资产中进行均衡配置，因为同一品种的资产往往有着较强的相关性，而不同的大类资产的相关性较弱甚至完全 相反。\n资产配置中所谓的相关性，是指两个投资标的在某段时间区间内的涨跌相似性（或者叫作关联程度）。 二、资产配置的基本准则 一是非法的东西不碰。 二是不懂的东西不碰。 三是安全性、收益性和流动性难以兼得。 表1-2　各类金融产品合理收益率\n四是风险应与自身相匹配。 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E5%BF%B5/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E7%A8%B3%E5%81%A5%E8%87%B4%E5%AF%8C%E9%9C%80%E6%A0%91%E7%AB%8B%E8%B5%84%E4%BA%A7%E9%85%8D%E7%BD%AE%E7%90%86%E5%BF%B5-%E4%B8%8A/","summary":"股票只是各大类资产中的一部分，要想稳健致富，需要依靠配置在各类市场环境中表现不一的资产，实现平滑风险、“东边不亮西边亮”的效果。 过去很长一段","title":"第二节 稳健致富需树立资产配置理念(上)"},{"content":"一、短线交易是“负和”游戏 “零和博弈”是博弈论（Game Theory）中的一个经典概念，意指参与博弈的各方，在残酷竞争下，一方的收益必然意味着另一方的损失，博弈各方的收益和损失相加 总和永远为0。\n买卖过程要收取印花税，券商和交易所还要收取各类佣金和费用\n表1-1　上海、深圳证券交易所各类交易税费对比\n所以，对短线交易者而言，炒股连零和交易都算不上，而是标准的“负和”游戏——随着交易次数的增多，买卖双方都可能沦为输家，稳赚不赔的只有税收部门、交易所和 券商。\n二、长线投资能实现共赢 股市零和博弈论者犯的是类似刻舟求剑的机械主义错误，他们将股票视为静态的商品，却忽视了股票背后企业的生命力，也就是股票代表的权益会随时间而变化。\n对于价值投资者而言，股市是一个正和博弈的场所。他们关注的是估值而不是单纯的股价，更注重价格与价值之间的偏离情况，以及公司未来的成长空间。当优质 白马龙头股的股价明显低于合理估值时，价值投资者就会择机介入，当估值存在泡沫时则会卖出。这一部分赚的同样是买卖价差的钱，但和频繁押大小赌博式的交易行 为有本质区别。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E5%BF%B5/%E7%AC%AC%E4%B8%80%E8%8A%82-%E8%82%A1%E5%B8%82%E5%B9%B6%E9%9D%9E%E9%9B%B6%E5%92%8C%E5%8D%9A%E5%BC%88/","summary":"一、短线交易是“负和”游戏 “零和博弈”是博弈论（Game Theory）中的一个经典概念，意指参与博弈的各方，在残酷竞争下，一方的收益必然意味","title":"第一节 股市并非零和博弈"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 # 默认每3秒刷新一次 $ top top - 11:58:59 up 9 days, 22:47, 1 user, load average: 0.03, 0.02, 0.00 Tasks: 123 total, 1 running, 72 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.3 us, 0.3 sy, 0.0 ni, 99.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 8169348 total, 5606884 free, 334640 used, 2227824 buff/cache KiB Swap: 0 total, 0 free, 0 used. 7497908 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 78088 9288 6696 S 0.0 0.1 0:16.83 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.05 kthreadd 4 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 kworker/0:0H ... 每个进程都有一个 %CPU 列，表示进程的 CPU 使用率。它是用户态和内核态 CPU 使用率的总和，包括进程用户空间使用的 CPU、通过系统调用执行的内核 空间 CPU 、以及在就绪队列等待运行的 CPU。在虚拟化环境中，它还包括了运行虚拟机占用的 CPU。\nVIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。 RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。 SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。共享内存 SHR 并不一定是共享的 %MEM 是进程使用物理内存占系统总内存的百分比。 ","permalink":"https://jdxj.github.io/posts/cmd/top/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 # 默认每3秒刷新一次 $ top top - 11:58:59 up 9 days, 22:47, 1 user, load average: 0.03, 0.02, 0.00 Tasks: 123 total, 1 running, 72 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.3 us, 0.3 sy, 0.0 ni, 99.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem :","title":"top"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 # 观察软中断变化速率 $ watch -d cat /proc/softirqs CPU0 CPU1 HI: 0 0 TIMER: 1083906 2368646 NET_TX: 53 9 NET_RX: 1550643 1916776 BLOCK: 0 0 IRQ_POLL: 0 0 TASKLET: 333637 3930 SCHED: 963675 2293171 HRTIMER: 0 0 RCU: 1542111 1590625 ","permalink":"https://jdxj.github.io/posts/cmd/watch/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 # 观察软中断变化速率 $ watch -d cat /proc/softirqs CPU0 CPU1 HI: 0 0 TIMER: 1083906 2368646 NET_TX: 53 9 NET_RX: 1550643 1916776 BLOCK: 0 0 IRQ_POLL: 0 0 TASKLET: 333637 3930 SCHED: 963675 2293171 HRTIMER: 0 0 RCU: 1542111 1590625","title":"watch"},{"content":"平均负载 平均负载(load average)是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数\n可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。 简单理解为，平均负载其实就是平均活跃进程数。\n如当平均负载为 2 时，意味着什么呢？\n在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。 在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。 而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。 CPU使用率 CPU使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。\nCPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的； I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高； 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/cpu/%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD/","summary":"平均负载 平均负载(load average)是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数 可运行状态的进程","title":"平均负载"},{"content":"3.1 链表和链表节点的实现 adlist.h/listNode\n1 2 3 4 5 6 7 8 typedef struct listNode { // 前置节点 struct listNode * prev; // 后置节点 struct listNode * next; //节点的值 void * value; }listNode; 图3-1 由多个listNode组成的双端链表\nadlist.h/list\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 typedef struct list { // 表头节点 listNode * head; // 表尾节点 listNode * tail; // 链表所包含的节点数量 unsigned long len; // 节点值复制函数 void *(*dup)(void *ptr); // 节点值释放函数 void (*free)(void *ptr); // 节点值对比函数 int (*match)(void *ptr,void *key); } list; 图3-2 由list结构和listNode结构组成的链表\nRedis的链表实现的特性\n双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O（1）。 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O（1）。 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O（1）。 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不 同类型的值。 3.2 链表和链表节点的API 表3-1 链表和链表节点API\n","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC3%E7%AB%A0-%E9%93%BE%E8%A1%A8/","summary":"3.1 链表和链表节点的实现 adlist.h/listNode 1 2 3 4 5 6 7 8 typedef struct listNode { // 前置节点 struct listNode * prev; // 后置节点 struct listNode * next; //节点的值 void * value; }listNode; 图3-1 由多个listNode组成的","title":"第3章 链表"},{"content":"2.1 SDS的定义 sds.h/sdshdr\n1 2 3 4 5 6 7 8 9 struct sdshdr { //记录buf数组中已使用字节的数量 //等于SDS所保存字符串的长度 int len; //记录buf数组中未使用字节的数量 int free; //字节数组，用于保存字符串 char buf[]; }; 图2-1 SDS示例\nlen不统计\\0 \\0由SDS函数自动处理 遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数 图2-2 带有未使用空间的SDS示例\n2.2 SDS与C字符串的区别 图2-3 C字符串\n2.2.1 常数复杂度获取字符串长度 获取C字符串的长度必须遍历整个字符串, 复杂度为O(N)\n图2-4 计算C字符串长度的过程\nSDS只要访问len属性即可\n图2-5 5字节长的SDS\n2.2.2 杜绝缓冲区溢出 C字符串不记录剩余空间, 拼接字符串会覆盖其后数据\n1 char *strcat(char *dest, const char *src); 图2-7 在内存中紧邻的两个C字符串\n1 strcat(s1, \u0026#34; Cluster\u0026#34;); 图2-8 S1的内容溢出到了S2所在的位置上\nSDS会检查剩余空间, 不足时会扩容\n1 2 // redis字符串拼接函数 sdscat(s, \u0026#34; Cluster\u0026#34;); 图2-9 sdscat执行之前的SDS\n图2-10 sdscat执行之后的SDS\n2.2.3 减少修改字符串时带来的内存重分配次数 空间预分配 修改后的len\u0026lt;1MB时, 会分配free=len的空闲空间 修改后的len\u0026gt;=1MB时, 会分配free=1MB的空闲空间 图2-11 执行sdscat之前的SDS\n1 sdscat(s, \u0026#34; Cluster\u0026#34;); 图2-12 执行sdscat之后SDS\n1 sdscat(s, \u0026#34; Tutorial\u0026#34;); 有足够空间, 无须内存分配\n图2-13 再次执行sdscat之后的SDS\n惰性空间释放 不立即释放空间, 使用free记录\n图2-14 执行sdstrim之前的SDS\n1 sdstrim(s, \u0026#34;XY\u0026#34;); //移除SDS字符串中的所有\u0026#39;X\u0026#39;和\u0026#39;Y\u0026#39; 图2-15 执行sdstrim之后的SDS\n有真正释放未使用空间的API\n2.2.4 二进制安全 C字符串以\\0来表示结束, 所以数据中不能包含\\0 SDS使用len来判断是否结束 图2-18 保存了特殊数据格式的SDS\n2.2.5 兼容部分C字符串函数 重用\u0026lt;string.h\u0026gt;\n1 2 strcasecmp(sds-＞buf, \u0026#34;hello world\u0026#34;); strcat(c_string, sds-＞buf); 2.2.6 总结 表2-1 C字符串和SDS之间的区别\n2.3 SDS API 表2-2 SDS的主要操作API\n2.4 重点回顾 Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS（Simple Dynamic String，简单动态字符串）作为字符串表示。 比起C字符串，SDS具有以下优点 常数复杂度获取字符串长度。 杜绝缓冲区溢出。 减少修改字符串长度时所需的内存重分配次数。 二进制安全。 兼容部分C字符串函数。 2.5 参考资料 ","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC2%E7%AB%A0-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"2.1 SDS的定义 sds.h/sdshdr 1 2 3 4 5 6 7 8 9 struct sdshdr { //记录buf数组中已使用字节的数量 //等于SDS所保存字符串的长度 int len; //记录buf数组中未使用字","title":"第2章 简单动态字符串 Simple Dynamic String"},{"content":" 面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。 设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等） 的指导原则。 设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来 讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。 编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要 就是编程规范。 重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E4%BA%94%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/","summary":"面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。 设计原则是","title":"面向对象、设计原则、设计模式、编程规范和代码重构五者之间的联系"},{"content":"设计思想、设计原则、设计模式一个最重要的应用场景就是在重构的时候。\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E4%BD%95%E6%97%B6%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","summary":"设计思想、设计原则、设计模式一个最重要的应用场景就是在重构的时候。","title":"何时应用设计模式"},{"content":"1.1 脚本文件的书写格式 多行注释, \u0026lt;\u0026lt;后的字符串区分大小写\n1 2 3 4 #!/usr/bin/env bash \u0026lt;\u0026lt;comment something comment 1.2 脚本文件的各种执行方式 脚本文件自身没有可执行权限 1 2 $ bash xxx.sh $ sh xxx.sh 脚本文件具有可执行权限 1 2 $ chmod +x xxx.sh $ xxx.sh 开启子进程执行的方式 不管是直接执行脚本，还是使用bash或sh这样的解释器执行脚本，都是会开启子进程的。\n不开启子进程的执行方式 1 2 $ source xxx.sh # 或者使用 . xxx.sh 1.3 如何在脚本文件中实现数据的输入与输出 使用echo命令创建一个脚本文件菜单 1 $ echo [选项] 字符串 1 2 3 4 5 6 7 8 9 10 11 12 #!/usr/bin/env bash #version:1.0 #这个脚本仅演示菜单输出，没有具体的功能实现 echo \u0026#34;这是一个打印菜单的例子\u0026#34; echo \u0026#34;1.查看网卡信息\u0026#34; echo \u0026#34;2.查看内存信息\u0026#34; echo \u0026#34;3.查看磁盘信息 4.查看CPU信息 5.查看账户信息\u0026#34; 表1-1 常见转义符号\n扩展知识，使用printf命令创建一个脚本菜单 1 $ printf [格式] 参数 表1-2 常用的格式字符串及功能描述\n1 2 3 $ printf \u0026#34;%d\u0026#34; 12 # 左对齐 $ printf \u0026#34;%-5d\u0026#34; 12 使用read命令读取用户的输入信息 1 $ read [选项] [变量名] 如果未指定变量名，则默认变量名称为REPLY 表1-3 read命令常用的选项\n1 2 3 4 $ read input1 input2 abc def $ echo $input1 $input2 abc def 1.4 输入与输出的重定向 标准输出的文件描述符为1 标准错误输出的文件描述符为2 标准输入的文件描述符则为0 分别重定向标准输出, 标准错误\n1 $ ls -l /etc/hosts /nofile \u0026gt; ok.txt 2\u0026gt; error.txt 重定向标准输出, 标准错误到同一个文件\n1 $ ls -l /etc/hosts /nofile \u0026amp;\u0026gt; test.txt 将标准错误重定向到标准输出或反过来\n1 $ ls /nofile 2\u0026gt;\u0026amp;1 图1-3 ls命令对比\n1 $ echo \u0026#34;hello\u0026#34; 1\u0026gt;\u0026amp;2 图1-4 echo命令对比\n1 $ ls /etc/passwd /nofile \u0026gt;test.txt 2\u0026gt;\u0026amp;1 图1-5 标准输出与错误输出\n输出黑洞/dev/null\n数据一旦导入黑洞将无法找回 用文件重定向输入\n1 $ mail -s warning root@localhosts \u0026lt; /etc/hosts 用\u0026lt;\u0026lt;(Here Document)重定向输入\n1 2 3 4 5 6 7 8 9 10 11 #!/usr/bin/env bash #语法格式: #命令 \u0026lt;\u0026lt; 分隔符 #内容 #分隔符 #系统会自动将两个分隔符之间的内容重定向传递给前面的命令，作为命令的输入。 #注意：分隔符是什么都可以，但前后分隔符必须一致。推荐使用EOF(end of file) mail -s warning root@localhost \u0026lt;\u0026lt; EOF This is content. This is a test mail for redirect. EOF 同时使用重定向输入, 重定向输出\n1 2 3 4 5 6 #!/usr/bin/env bash cat \u0026gt; /tmp/test.txt \u0026lt;\u0026lt; HERE 该文件为测试文件。 测试完后，记得将该文件删除。 Welcome to Earth. HERE 如果数据和EOF前有Tab, 可以用\u0026lt;\u0026lt;-来忽略Tab\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/usr/bin/env bash #不能屏蔽Tab键,缩进将作为内容的一部分被输出 #注意hello和world前面是tab键 cat \u0026lt;\u0026lt; EOF hello world EOF #Tab键将被忽略,仅输出数据内容 cat \u0026lt;\u0026lt;- EOF hello world EOF 1.5 各种引号的正确使用姿势 单引号与双引号 \u0026quot;\u0026quot; 引用一个整体 '' 引用一个整体 不解析特殊字符 \\ 不解析随后的一个特殊字符 命令替换 使用``\n1 $ tar -czf /root/log-`date +%Y%m%d`.tar.gz /var/log/ 使用$()\n1 $ echo \u0026#34;当前系统账户登录数量: $(who|wc -l)\u0026#34; 1.6 千变万化的变量 变量名由字母, 数字, _ 组成 不能用数字开头 赋值时=两边不能有空格. 表1-4 变量名示例\n使用$var或${var}方式读取变量值 删除变量\n1 2 $ test=123 $ unset test 表1-5 常见的系统预设变量\n1.7 数据过滤与正则表达式 1 $ grep [选项] 匹配模式 [文件] -i 忽略大小写 -v 取反匹配 -w 匹配单词 -q 静默匹配，不将结果显示在屏幕上 基本正则表达式（Basic Regular Expression） 表1-6 基本正则表达式及其含义\n扩展正则表达式（Extended Regular Expression） 表1-7 扩展正则表达式及其含义\ngrep命令默认不支持扩展正则表达式，需要使用grep -E或者使用egrep命令进行扩展正则表达式的过滤。\nPOSIX规范的正则表达式 表1-8 POSIX规范字符集\n1 $ grep \u0026#34;[[:digit:]]\u0026#34; /tmp/passwd GNU规范 \\b（边界字符，匹配单词的开始或结尾） \\B（与\\b为反义词，\\Bthe\\B不会匹配单词the，仅会匹配the在中间的单词，如atheist） \\w（等同于[_[:alnum:]]） \\W（等同于[^_[:alnum:]]） \\d表示任意数字 \\D表示任意非数字 \\s表示任意空白字符（空格、制表符等） \\S表示任意非空白字符 1 2 #匹配i结尾的单词 $ grep \u0026#34;i\\b\u0026#34; /tmp/passwd 1.8 各式各样的算术运算 整数运算\n$((expr)) $[expr] let expr 表1-9 常用运算符号\n1 $ echo $((2+4)) 使用let命令计算时，默认不会输出运算的结果，一般需要将运算的结果赋值给变量，通过变量查看运算结果。另外，使用let命令对变量进行计算时，不需要在变量 名前添加$符号。\n1 2 3 $ x=5 $ let x++ $ echo $x 非交互模式使用bc\n1 2 3 4 5 6 $ x=$(echo \u0026#34;(1+2)*3\u0026#34;|bc) $ echo $x $ $ echo \u0026#34;2+3; scale=2;8/19\u0026#34; | bc 5 .42 ","permalink":"https://jdxj.github.io/posts/books/linux-shell%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/%E7%AC%AC1%E7%AB%A0-%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B-%E8%B5%B7%E9%A3%9E%E4%BA%86/","summary":"1.1 脚本文件的书写格式 多行注释, \u0026lt;\u0026lt;后的字符串区分大小写 1 2 3 4 #!/usr/bin/env bash \u0026lt;\u0026lt;comment something comment 1.2 脚本文件的各种执行方式 脚本文件自身没有可执行权限 1 2 $","title":"第1章 从这里开始, 起飞了"},{"content":"原文\n普通代理\n代理服务器解析客户端req, 之后代理服务器向目标服务器发送该req 隧道代理\n代理服务器监听CONNECT方法, 之后转发客户端发来的tcp流量到目标服务器 ","permalink":"https://jdxj.github.io/posts/articles/imququ/http%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/","summary":"原文 普通代理 代理服务器解析客户端req, 之后代理服务器向目标服务器发送该req 隧道代理 代理服务器监听CONNECT方法, 之后转发客户端发来的","title":"HTTP 代理原理及实现（一）"},{"content":"原文\n少使用反射 优先使用 strconv 而不是 fmt 少量的重复不比反射差 慎用 binary.Read 和 binary.Write 避免重复的字符串到字节切片的转换 指定容器容量 行内拼接字符串推荐使用运算符+ 非行内拼接字符串推荐使用 strings.Builder strings.Builder.Grow() 遍历 []struct{} 使用下标而不是 range 使用空结构体节省内存 type Set map[string]struct{} ch := make(chan struct{}) type Door struct{} struct 布局要考虑内存对齐 将字段宽度从小到大由上到下排列，来减少内存的占用 当 struct{} 或空 array 作为结构体最后一个字段时，需要内存对齐 减少逃逸，将变量限制在栈上 小的拷贝好过引用 一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择返回指针。对于只读的占用内存较小的结构体，直接返回值能够获得更好的性能。 如果变量类型不确定，那么将会逃逸到堆上 sync.Pool 复用对象 并发情况采用无锁设计 CAS 串行无锁 分片减少锁竞争 优先使用共享锁而非互斥锁 限制协程数量 开销 内存开销 调度开销 GC开销 池化 使用 sync.Once 避免重复执行 使用 sync.Cond 通知协程 ","permalink":"https://jdxj.github.io/posts/articles/weixin/go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/","summary":"原文 少使用反射 优先使用 strconv 而不是 fmt 少量的重复不比反射差 慎用 binary.Read 和 binary.Write 避免重复的字符串到字节切片的转换 指定容器容量 行内拼接字符串推荐使用运算符+ 非行","title":"Go语言高性能编程手册"},{"content":"原文\n可用的简单配置\n# 禁用旧版本的有漏洞的 SSH 协议 # (旧版本的 sshd 默认允许新旧版本(2,1)的协议，新版本的 sshd 默认只接受新版本(2)的协议） Protocol 2 # 禁止使用密码登入（默认允许） # 注意：需先配置好有 root 权限的用户的公私钥对登入后再禁止密码登入， # 避免自己无法登入服务器，或使用低权限用户登入服务器后无法取得 root 权限。 PasswordAuthentication no # 禁止空密码账户登入（默认禁止） PermitEmptyPasswords no # 禁止 root 账户通过密码登入（默认允许） # （root 账户仍可以通过公私钥对登入，如果配置了的话） PermitRootLogin without-password # （新版本的 sshd 也支持使用更符合直觉的名字 prohibit-password） #PermitRootLogin prohibit-password # 或：禁止 root 账户通过 SSH 登入（默认允许） #PermitRootLogin no ","permalink":"https://jdxj.github.io/posts/articles/zzz/ssh%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/","summary":"原文 可用的简单配置 # 禁用旧版本的有漏洞的 SSH 协议 # (旧版本的 sshd 默认允许新旧版本(2,1)的协议，新版本的 sshd 默认只接受新版本(2)的协议） Protocol 2 #","title":"SSH 安全加固的一些措施"},{"content":"安装Docker Install Docker Engine on Debian 配置containerd\n1 2 3 4 $ containerd config default | tee /etc/containerd/config.toml \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 $ vim /etc/containerd/config.toml SystemdCgroup = true $ systemctl restart containerd 安装K8s 关闭交换\n1 2 $ swapoff -a $ vim /etc/fstab 官方安装教程\n容器运行时 安装 kubeadm 使用 kubeadm 创建集群 网络插件weave\nInstallation 允许控制平面调度pod\n1 $ kubectl taint nodes --all node-role.kubernetes.io/control-plane- bash补全\n启动 kubectl 自动补全功能 参考 如何用 Kubeadm 在 Debian 11 上安装 Kubernetes 集群 master节点部署Pod处于Pending状态 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/k8s/","summary":"安装Docker Install Docker Engine on Debian 配置containerd 1 2 3 4 $ containerd config default | tee /etc/containerd/config.toml \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 $ vim /etc/containerd/config.toml SystemdCgroup = true $ systemctl restart containerd 安装K8s 关闭交换 1 2 $ swapoff -a $ vim /etc/fstab 官方安装教","title":"安装K8s"},{"content":"延迟确认在很多 linux 机器上是没有办法关闭的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible) { struct tcp_sock *tp = tcp_sk(sk); /* More than one full frame received... */ if (((tp-\u0026gt;rcv_nxt - tp-\u0026gt;rcv_wup) \u0026gt; tp-\u0026gt;ack.rcv_mss /* ... and right edge of window advances far enough. * (tcp_recvmsg() will send ACK otherwise). Or... */ \u0026amp;\u0026amp; __tcp_select_window(sk) \u0026gt;= tp-\u0026gt;rcv_wnd) || /* We ACK each frame or... */ tcp_in_quickack_mode(tp) || /* We have out of order data. */ (ofo_possible \u0026amp;\u0026amp; skb_peek(\u0026amp;tp-\u0026gt;out_of_order_queue))) { /* Then ack it now */ tcp_send_ack(sk); } else { /* Else, send delayed ack. */ tcp_send_delayed_ack(sk); } } 需要立马回复 ACK 的场景\n如果接收到了大于一个frame 的报文，且需要调整窗口大小 处于 quickack 模式（tcp_in_quickack_mode） 收到乱序包（We have out of order data.） 其它情况一律使用延迟确认的方式\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4/","summary":"延迟确认在很多 linux 机器上是没有办法关闭的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible) { struct tcp_sock *tp = tcp_sk(sk); /* More than one full frame received... */ if (((tp-\u0026gt;rcv_nxt - tp-\u0026gt;rcv_wup) \u0026gt; tp-\u0026gt;ack.rcv_mss /* ...","title":"延迟确认"},{"content":"减少发送端频繁的发送小包给对方。\n算法思路\nif there is new data to send if the window size \u0026gt;= MSS and available data is \u0026gt;= MSS send complete MSS segment now else if there is unconfirmed data still in the pipe enqueue data in the buffer until an acknowledge is received else send data immediately end if end if end if ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/nagle/","summary":"减少发送端频繁的发送小包给对方。 算法思路 if there is new data to send if the window size \u0026gt;= MSS and available data is \u0026gt;= MSS send complete MSS segment now else if there is unconfirmed data still in the pipe enqueue data in the buffer until an acknowledge is received else send data immediately end if","title":"Nagle"},{"content":" 拥塞窗口 Congestion Window，cwnd 拥塞窗口指的是在收到对端 ACK 之前自己还能传输的最大 MSS 段数。\nTCP 头部的 window 字段其实讲的接收窗口（rwnd）大小。 拥塞窗口初始值等于操作系统的一个变量 initcwnd，最新的 linux 系统 initcwnd 默认值等于 10。 真正的发送窗口大小 = 「接收端接收窗口大小」 与 「发送端自己拥塞窗口大小」 两者的最小值 拥塞处理 算法1: 慢启动 Slow Start 算法过程\n三次握手以后，双方通过 ACK 告诉了对方自己的接收窗口（rwnd）的大小，之后就可以互相发数据了 通信双方各自初始化自己的「拥塞窗口」（Congestion Window，cwnd）大小 cwnd 初始值较小时，每收到一个 ACK，cwnd + 1，所以每经过一个 RTT，cwnd 变为之前的两倍 拥塞窗口达到 N 所花费的时间公式为\n假设 RTT 为 50ms，客户端和服务端的接收窗口为65535字节（64KB），初始拥塞窗口为：10段，那么要达到 64KB 的吞吐量，拥塞窗口的段数 = 65535 / 1460 = 45 段，需要的 RTT 次数 = log2（45 / 10）= 2.12 次，需要的时间 = 50 * 2.12 = 106ms。也就是客户端和服务器之间的 64KB 的吞吐量，需要 2.12 次 RTT，100ms 左右的延迟。\n慢启动阈值 Slow Start Threshold，ssthresh ssthresh 就是一道刹车，让拥塞窗口别涨那么快。\n当 cwnd \u0026lt; ssthresh 时，拥塞窗口按指数级增长（慢启动） 当 cwnd \u0026gt; ssthresh 时，拥塞窗口按线性增长（拥塞避免） todo: ssthresh 的初始值哪里来的?\n算法2: 拥塞避免 Congestion Avoidance 在这个阶段，每一个往返 RTT，拥塞窗口大约增加1个 MSS 大小，直到检测到拥塞为止。\n实际的算法是\n每收到一个 ACK，将拥塞窗口增加一点点（1 / cwnd）: cwnd += 1 / cwnd 算法3: 快速重传 Fast Retransmit 快速重传的含义是：当接收端收到一个不按序到达的数据段时，TCP 立刻发送 1 个重复 ACK，而不用等有数据捎带确认，当发送端收到 3 个或以上重复 ACK，就 意识到之前发的包可能丢了，于是马上进行重传，不用傻傻的等到重传定时器超时再重传。\n选择确认 Selective Acknowledgment，SACK ack中携带已收到的包序号, 只重传丢失的包\n算法4: 快速恢复 Fast Recovery 当收到三次重复 ACK 时，进入快速恢复阶段。\n拥塞阈值 ssthresh 降低为 cwnd 的一半：ssthresh = cwnd / 2 拥塞窗口 cwnd 设置为 ssthresh 拥塞窗口线性增加 超时不会启动快速重传 快速重传下不会进入慢启动(因为收到了ack, 网络问题不大) 快速恢复是在快速重传下适当降低发送速度 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/","summary":"todo: 找一个完整的拥塞控制图","title":"拥塞控制"},{"content":"TCP 包状态分类 粉色部分#1 (Bytes Sent and Acknowledged)：表示已发送且已收到 ACK 确认的数据包。 蓝色部分#2 (Bytes Sent but Not Yet Acknowledged)：表示已发送但未收到 ACK 的数据包。发送方不确定这部分数据对端有没有收到，如果在一段时间内没有收到 ACK，发送端需要重传这部分数据包。 绿色部分#3 (Bytes Not Yet Sent for Which Recipient Is Ready)：表示未发送但接收端已经准备就绪可以接收的数据包（有空间可以接收） 黄色部分#4 (Bytes Not Yet Sent，Not Ready to Receive)：表示还未发送，且这部分接收端没有空间接收 发送窗口（send window）与可用窗口（usable window） 发送窗口是 TCP 滑动窗口的核心概念，它表示了在某个时刻一端能拥有的最大未确认的数据包大小（最大在途数据），发送窗口是发送端被允许发送的最大数据包大 小，其大小等于上图中 #2 区域和 #3 区域加起来的总大小 可用窗口是发送端还能发送的最大数据包大小，它等于发送窗口的大小减去在途数据包大小，是发送端还能发送的最大数据包大小，对应于上图中的 #3 号区域 窗口的左边界表示成功发送并已经被接收方确认的最大字节序号，窗口的右边界是发送方当前可以发送的最大字节序号，滑动窗口的大小等于右边界减去左边界。\nTCP Zero Window 零窗口探测包其实就是一个 ACK 包\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","summary":"TCP 包状态分类 粉色部分#1 (Bytes Sent and Acknowledged)：表示已发送且已收到 ACK 确认的数据包。 蓝色部分#2 (Bytes Sent but Not Yet Acknowledged)","title":"滑动窗口"},{"content":"Retransmission TimeOut，RTO\n计算RTO 经典方法 适用 RTT 波动较小的情况 取平均值 Smoothed round trip time，SRTT\nα 是平滑因子，建议值是0.8 ~ 0.9 SRTT = ( α * SRTT ) + ((1- α) * RTT) 超时重传时间 RTO 的计算公式\nβ 是加权因子，一般推荐值为 1.3 ~ 2.0 RTO = min(ubound, max(lbound, β * SRTT)) 标准方法（Jacobson / Karels 算法） 公式\nSRTT = (1 - α) * SRTT + α * RTT // 已平滑的 RTT 平均偏差估计器 round-trip time variation RTTVAR = (1 - β) * RTTVAR + β * (|RTT-SRTT|) RTO= µ * SRTT + ∂ * RTTVar 权重因子 α 的建议值是 0.125 平均偏差是标准方差的良好近似，计算较为容易，无需标准方差的求平方根运算。 β 取建议值 0.25 μ 建议值取 1，∂ 建议值取 4 这种算法下 RTO 与 RTT 变化的差值关系更密切，能对变化剧烈的 RTT做出更及时的调整。\n重传二义性与 Karn / Partridge 算法 Karn / Partridge 算法就是为了解决重传二义性的。它的思路也是很奇特，解决问题的最好办法就是不解决它：\n既然不能确定 ACK 包到底对应重传包还是非重传包，那这次就忽略吧，这次重传的 RTT 不会被用来更新 SRTT 及后面的 RTO 只有当收到未重传过的某个请求的 ACK 包时，才更新 SRTT 等变量并重新计算RTO Karn 算法采用了出现重传就将 RTO 翻倍的方法，指数级退避（Exponential backoff）。\n/proc/sys/net/ipv4/tcp_retries2 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0/","summary":"Retransmission TimeOut，RTO 计算RTO 经典方法 适用 RTT 波动较小的情况 取平均值 Smoothed round trip time，SRTT α 是平滑因子，建议值是0.8 ~ 0.9 SRTT = ( α * SRTT )","title":"超时重传"},{"content":"当发送端收到 3 个或以上重复 ACK，就意识到之前发的包可能丢了，于是马上进行重传，不用傻傻的等到超时再重传。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0/","summary":"当发送端收到 3 个或以上重复 ACK，就意识到之前发的包可能丢了，于是马上进行重传，不用傻傻的等到超时再重传。","title":"快速重传与SACK"},{"content":"SO_LINGER SO_LINGER 参数是一个 linger 结构体\n1 2 3 4 struct linger { int l_onoff; /* linger active */ int l_linger; /* how many seconds to linger for */ }; l_onoff 用来表示是否启用 linger 特性，非 0 为启用，0 为禁用 ，linux 内核默认为禁用。这种情况下 close 函数立即返回，操作系统负责把缓冲队 列中的数据全部发送至对端 l_linger 在 l_onoff 为非 0 （即启用特性）时才会生效 如果 l_linger 的值为 0，那么调用 close，close 函数会立即返回，同时丢弃缓冲区内所有数据并立即发送 RST 包重置连接 如果 l_linger 的值为非 0，那么此时 close 函数在阻塞直到 l_linger 时间超时或者数据发送完毕，发送队列在超时时间段内继续尝试发送，如果发送 完成则皆大欢喜，超时则直接丢弃缓冲区内容 并 RST 掉连接。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/socket-options/","summary":"SO_LINGER SO_LINGER 参数是一个 linger 结构体 1 2 3 4 struct linger { int l_onoff; /* linger active */ int l_linger; /* how many seconds to linger for */ }; l_onoff 用来表示是否启用 linger 特性，非 0 为启用，0 为禁用 ，linux 内核默认为禁","title":"Socket Options"},{"content":"端口未监听 断电丢失连接 设置SO_LINGER为true 如果设置 SO_LINGER 为 true，linger 设置为 0，当调用 socket.close() 时， close 函数会立即返回，同时丢弃缓冲区内所有数据并立即发送 RST 包 重置连接。\n参考SO_LINGER\n丢失RST 如果客户端收到了这个 RST，就会自然进入CLOSED状态释放连接。如果 RST 依然丢失，客户端只是会单纯的数据丢包了，进入数据重传阶段。如果还一直收不到 RST，会在一定次数以后放弃。\nConnection reset by peer 其实就是收到了RST\nBroken pipe 在一个 RST 的套接字继续写数据\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E5%B8%B8%E8%A7%81rst/","summary":"端口未监听 断电丢失连接 设置SO_LINGER为true 如果设置 SO_LINGER 为 true，linger 设置为 0，当调用 socket.close() 时， close 函数会立即返回，同时丢弃缓冲","title":"发生RST的情景"},{"content":"3.1 中间业务概述 什么是中间业务 商业银行的中间业务广义上是指“不构成商业银行表内资产、表内负债，形成银行非利息收入的业务”\n中间业务可以分成两大类：\n金融服务业务, 不形成或有资产、或有负债 表外业务。会形成或有资产、或有负债 所谓或有资产和或有负债，是指因过去的交易或事项，今后可望获得的资产和负债，也就是说或有资产和或有负债的产生具有不确定性。因此，在结果未发生前不能将 其计入银行的资产负债表，只能记录在表外。\n信用卡的未使用额度就属于或有资产 为其他公司提供的债务担保就属于或有负债 在金融服务业务中，商业银行是以代理人的身份为客户办理各种业务，并从中收取手续费。由于金融服务业务完全不产生任何资产，所以这一类业务是完全不承担风险 的，相应也不会产生任何减值需求。这类业务主要包括：\n清算结算业务 银行卡业务 代理业务 托管业务 咨询顾问业务等。 在表外业务中，虽然在业务发生时并不直接涉及资产负债表，但是这类业务与银行的资产业务和负债业务关系紧密，而且未来很可能由于某些条件触发转换为资产业务 和负债业务。这类业务主要包括：\n担保业务 承诺业务 金融衍生业务。 中间业务的优势 中间业务对于商业银行来说是非常重要的一项业务, 因为中间业务最大的特征是没有风险资产（金融服务类业务）或者风险资产很少（表外业务的或有资产有一定的折 算比例）。虽然中间业务的费率不高（通常是在0.5%～1%），办理时消耗的人力资源也很大，但是由于完全不消耗或者消耗极少的资本金，其依然是商业银行未来发 展的重要方向。\n发展中间业务的另外一个好处就是可以增加客户的黏性，不论是对公还是零售。\n对利润表影响较大的中间业务主要包括资管业务和代理业务。\n3.2 资管业务 金融市场发展的产物 资产管理业务（以下简称“资管业务”）是指证券、期货、基金等金融机构作为资产管理人，根据资产管理合同约定的方式、条件、要求及限制，对客户资产进行经营运 作，为客户提供证券及其他金融产品的投资管理服务，并从中收取一定的管理费甚至是提成。\n资管业务的内容 银行的资管业务主要包括通道业务、委托投资业务和理财业务。\n对于理财业务，就是我们常说的在银行购买理财产品。银行把募集的资金按照理财契约的规定投向某类资产，包括基金、债券、非标资产等。而在这个过程中，银行 要收取一定的管理费。 通道业务，起源于银行受限制于资本充足率或者监管的行业禁贷令而不得对某些客户提供信贷服务，那么这个时候，银行就会找第三方金融公司，可以是信托也可以 是券商，由第三方将贷款放给客户，然后将收益权包装成理财产品卖给最终的个人客户。 可以看到，这个操作和投资业务中的应收类投资很相似，唯一的区别是理财通道业务的负债和资产都不进入银行的资产负债表。银行在其中只收取管理费或手续费， 风险和收益都是由个人投资者承担。 委托投资业务，通常是委托行以委托理财服务的名义吸收个人客户的资金，然后以同业存款的方式投给受托行，之后再跟受托行签订一个“抽屉协议”，规定了受托行 必须将此笔资金投向指定的投资对象。 可以看到，通道业务和委托投资业务很多是为了绕开监管，这其中有一定的风险。 相对来说，在资管业务中，银行开展更多的还是理财业务。 对资管新规的解读 公募理财产品除了配置标准的债券和股票外可以在一些封闭型产品中配置非标产品，但是要求期限不得错配，且资金流向必须是国家支持的重点工程或者小微信贷。 理财产品必须打破刚兑，坚持净值型为主。但是在过渡期货币 类理财产品和6个月以上的定期开放产品可以参考货币基金的估值方法和摊余成本法，未来过渡期结束后对于封闭型理财产品可以继续使用摊余成本法。 拓宽了公募理财产品投资公募基金的范围。 单只公募理财的起售点从5万元降低到1万元。 对于过渡期结束后非标资产回表给予补充资本工具的支持。 3.3 代理业务 代理业务是代理人接受客户委托，以被代理人的名义代为办理其指定的经济事务的业务。\n代理业务和信托业务非常相似，其中最本质的差别是：\n在信托业务中，委托人需要将信托财产的财产权转移给受托人； 而在代理业务中，财产的权属是不发生转移的。 这一根本特征决定了在代理业务中，代理机构能够帮助被代理人执行的任务是相对简单的，以被代理人的提前授权为执行任务的基础。但是，正是由于代理业务不涉及 财产转移，银行相对来说承担的风险和连带责任就更小，可以说是无风险的业务。\n代理业务涉及的业务种类繁多，对银行的影响也不同，最常见的代理业务包括：\n代收代付业务 代理证券业务 代理保险业务 其他代理业务等。 代收代付业务对于银行的作用主要在于增加客户黏性，通过代发工资，代付水电、煤气、电话费，给客户节省时间，让更多的零售客户将主要资金账户留在银行。\n理证券业务包括第三方存管、债券承销、国债的代发代兑、代销基金等。代理证券业务对于银行来说具有两方面的意义：\n第一，可以给客户提供更加丰富的资产保值增值手段，这也是留住客户的一种策略。 第二，可以收取丰厚的手续费。 表3.1　2014—2018年招商银行基金、保险代销金额与手续费\n代理保险业务，也就是大家经常说的银保业务。保险公司通过银行的渠道销售保险，并支付给银行一定的回佣作为报酬。从表3.1中可以看到，代销保险的回佣远高于 代销基金。从2017年开始保监会明显加大了对银保渠道的监管力度，特别是开始强调保险的保障功能。以前在银保渠道畅销的红利险和万能险开始明显收缩，反映在 银行的财报上是这部分收入呈逐年萎缩的状态。但是，随着银行系保险公司的崛起，未来银保业务借着保险业快速发展的“东风”，依然会是银行中间业务收入的重要组 成部分。\n","permalink":"https://jdxj.github.io/posts/books/%E7%9C%8B%E9%80%8F%E9%93%B6%E8%A1%8C-%E6%8A%95%E8%B5%84%E9%93%B6%E8%A1%8C%E8%82%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC3%E7%AB%A0-%E9%93%B6%E8%A1%8C%E7%9A%84%E4%B8%AD%E9%97%B4%E4%B8%9A%E5%8A%A1/","summary":"3.1 中间业务概述 什么是中间业务 商业银行的中间业务广义上是指“不构成商业银行表内资产、表内负债，形成银行非利息收入的业务” 中间业务可以分成两大类","title":"第3章 银行的中间业务"},{"content":"Max Segment Lifetime MSL（报文最大生存时间）是 TCP 报文在网络中的最大生存时间。这个值与 IP 报文头的 TTL 字段有密切的关系。\nTTL: IP 报文最大可经过的路由数 Linux 的套接字实现假设 MSL 为 30 秒，因此在 Linux 机器上 TIME_WAIT 状态将持续 60秒。 TIME_WAIT 存在的原因 第一个原因是：数据报文可能在发送途中延迟但最终会到达，因此要等老的“迷路”的重复报文段在网络中过期失效，这样可以避免用相同源端口和目标端口创建新连接 时收到旧连接姗姗来迟的数据包，造成数据错乱。\n第二个原因是确保可靠实现 TCP 全双工终止连接。关闭连接的四次挥手中，最终的 ACK 由主动关闭方发出，如果这个 ACK 丢失，对端（被动关闭方）将重发 FIN，如果主动关闭方不维持 TIME_WAIT 直接进入 CLOSED 状态，则无法重传 ACK，被动关闭方因此不能及时可靠释放。\n可以想象为ack(4)马上就要到了, 但是发生了丢包.\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/msl/","summary":"Max Segment Lifetime MSL（报文最大生存时间）是 TCP 报文在网络中的最大生存时间。这个值与 IP 报文头的 TTL 字段有密切的关系。 TTL: IP 报文最大可经过的路由数 Linux 的套接字实","title":"MSL"},{"content":"原文\n修改内核参数的方法\n编辑/etc/sysctl.conf添加配置 执行sysctl -p立即生效 ","permalink":"https://jdxj.github.io/posts/articles/code2life/tcp%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/","summary":"原文 修改内核参数的方法 编辑/etc/sysctl.conf添加配置 执行sysctl -p立即生效","title":"Linux内核参数优化及原理"},{"content":" TCP拥塞控制及BBR原理分析 BBR TCP ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/bbr%E5%88%86%E6%9E%90/","summary":"TCP拥塞控制及BBR原理分析 BBR TCP","title":"一些关于BBR的文章"},{"content":"Debian11应该默认开启了, 验证\nlsmod | grep bbr #或成功则会出现类似的内容 tcp_bbr 20480 1 参考\nDebian11开启bbr ","permalink":"https://jdxj.github.io/posts/articles/cnblogs/ahlxjg/bbr/","summary":"Debian11应该默认开启了, 验证 lsmod | grep bbr #或成功则会出现类似的内容 tcp_bbr 20480 1 参考 Debian11开启bbr","title":"Debian11开启BBR"},{"content":"TFO 是在原来 TCP 协议上的扩展协议，它的主要原理就在发送第一个 SYN 包的时候就开始传数据了，不过它要求当前客户端之前已经完成过「正常」的三次握手。 快速打开分两个阶段：请求 Fast Open Cookie 和 真正开始 TCP Fast Open\n请求 Fast Open Cookie 的过程\n客户端发送一个 SYN 包，头部包含 Fast Open 选项，且该选项的Cookie 为空，这表明客户端请求 Fast Open Cookie 服务端收取 SYN 包以后，生成一个 cookie 值（一串字符串） 服务端发送 SYN + ACK 包，在 Options 的 Fast Open 选项中设置 cookie 的值 客户端缓存服务端的 IP 和收到的 cookie 值 第一次过后，客户端就有了缓存在本地的 cookie 值，后面的握手和数据传输过程如下\n客户端发送 SYN 数据包，里面包含数据和之前缓存在本地的 Fast Open Cookie。（注意我们此前介绍的所有 SYN 包都不能包含数据） 服务端检验收到的 TFO Cookie 和传输的数据是否合法。如果合法就会返回 SYN + ACK 包进行确认并将数据包传递给应用层，如果不合法就会丢弃数据包，走正常三次握手流程（只会确认 SYN） 服务端程序收到数据以后可以握手完成之前发送响应数据给客户端了 客户端发送 ACK 包，确认第二步的 SYN 包和数据（如果有的话） 后面的过程就跟非 TFO 连接过程一样了 TCP Fast Open 的优势\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tfo/","summary":"TFO","title":"TCP Fast Open"},{"content":"用来解决 SYN Flood 攻击的，现在服务器上的 tcp_syncookies 都是默认等于 1，表示连接队列满时启用，等于 0 表示禁用，等于 2 表示始终启用。由 /proc/sys/net/ipv4/tcp_syncookies控制。\nSYN Cookie 机制其实原理比较简单，就是在三次握手的最后阶段才分配连接资源\ncookie占用序列号空间, 导致tcp可选功能失效, e.g.扩充窗口, 时间戳 参考\n深入浅出TCP中的SYN-Cookies ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/syn-cookie/","summary":"用来解决 SYN Flood 攻击的，现在服务器上的 tcp_syncookies 都是默认等于 1，表示连接队列满时启用，等于 0 表示禁用，等于 2 表示始终启用。由 /proc/sys/net/","title":"SYN Cookie"},{"content":"客户端大量伪造 IP 发送 SYN 包，服务端回复的 ACK+SYN 去到了一个「未知」的 IP 地址，势必会造成服务端大量的连接处于 SYN_RCVD 状态，而服务器的 半连接队列大小也是有限的，如果半连接队列满，也会出现无法处理正常请求的情况。\n如何应对 SYN Flood 攻击\n调大net.ipv4.tcp_max_syn_backlog的值，不过这只是一个心理安慰，真有攻击的时候，这个再大也不够用。 重试次数由 /proc/sys/net/ipv4/tcp_synack_retries控制，默认情况下是 5 次，当收到SYN+ACK故意不回 ACK 或者回复的很慢的时候，调小这个值 很有必要。 tcp_syncookies net.core.netdev_max_backlog 接收自网卡, 但未被内核协议栈处理的报文队列长度 net.ipv4.tcp_abort_on_overflow 可以返回RST ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/syn-flood/","summary":"客户端大量伪造 IP 发送 SYN 包，服务端回复的 ACK+SYN 去到了一个「未知」的 IP 地址，势必会造成服务端大量的连接处于 SYN_RCVD 状态，而服务器的 半连接队列大小也是有限的","title":"SYN Flood 攻击"},{"content":" 半连接队列（Incomplete connection queue），又称 SYN 队列 全连接队列（Completed connection queue），又称 Accept 队列 半连接队列（SYN Queue） 当客户端发起 SYN 到服务端，服务端收到以后会回 ACK 和自己的 SYN。这时服务端这边的 TCP 从 listen 状态变为 SYN_RCVD (SYN Received)，此 时会将这个连接信息放入「半连接队列」，半连接队列也被称为 SYN Queue，存储的是 \u0026ldquo;inbound SYN packets\u0026rdquo;。 服务端回复 SYN+ACK 包以后等待客户端回复 ACK，同时开启一个定时器，如果超时还未收到 ACK 会进行 SYN+ACK 的重传，重传的次数由 tcp_synack_retries 值确定。在 CentOS 上这个值等于 5。 一旦收到客户端的 ACK，服务端就开始尝试把它加入另外一个全连接队列（Accept Queue）。 半连接队列的大小与三个值有关\n用户层 listen 传入的backlog 系统变量 net.ipv4.tcp_max_syn_backlog，默认值为 128 系统变量 net.core.somaxconn，默认值为 128 全连接队列（Accept Queue） 包含了服务端所有完成了三次握手，但是还未被应用调用 accept 取走的连接队列。此时的 socket 处于 ESTABLISHED 状态。每次应用调用 accept() 函数会移除队列头的连接。如果队列为空，accept() 通常会阻塞。全连接队列也被称为 Accept 队列。\n如果全连接队列满，内核会舍弃掉 client 发过来的 ack（应用层会认为此时连接还未完全建立）\nSYN+ACK重传的次数是由操作系统的一个文件决定\ncat /proc/sys/net/ipv4/tcp_synack_retries 全连接队列的大小是 listen 传入的 backlog 和 somaxconn 中的较小值\nss命令\nss -lnt | grep :9090 State Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 51 50 *:9090 *:* 对于 LISTEN 状态的套接字，Recv-Q 表示 accept 队列排队的连接个数，Send-Q 表示全连接队列（也就是 accept 队列）的总大小。 多大的 backlog 是合适的 你如果的接口处理连接的速度要求非常高，或者在做压力测试，很有必要调高这个值 如果业务接口本身性能不好，accept 取走已建连的速度较慢，那么把 backlog 调的再大也没有用，只会增加连接失败的可能性 tcp_abort_on_overflow 参数 默认情况下，全连接队列满以后，服务端会忽略客户端的 ACK，随后会重传SYN+ACK，也可以修改这种行为，这个值由 /proc/sys/net/ipv4/tcp_abort_on_overflow决定。\n0表示三次握手最后一步全连接队列满以后 server 会丢掉 client 发过来的 ACK，服务端随后会进行重传 SYN+ACK。 1表示全连接队列满以后服务端直接发送 RST 给客户端。 回给客户端 RST 包会带来另外一个问题，客户端不知道服务端响应的 RST 包到底是因为「该端口没有进程监听」，还是「该端口有进程监听，只是它的队列 满了」。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/","summary":"半连接队列（Incomplete connection queue），又称 SYN 队列 全连接队列（Completed connection queue），又称 Accept 队列 半连接队列（SYN Queu","title":"连接队列"},{"content":"原文\n学习要结合实践\n","permalink":"https://jdxj.github.io/posts/articles/plantegg/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%AD%A6%E4%B9%A0/","summary":"原文 学习要结合实践","title":"如何在工作中学习"},{"content":"完整的状态转换 三次握手的状态变化 同时打开的状态变化 自连接的状态变化 其实就是同时打开, 步骤5, 6在原文当中是window update包, 所以seq=1了.\n四次挥手的状态变化 同时关闭的状态变化 同时关闭原文和图有点不一致(TIME-WAIT), 这里应该看文字.\n最初客户端和服务端都处于 ESTABLISHED 状态 客户端发送 FIN 包，等待对端对这个 FIN 包的 ACK，随后进入 FIN-WAIT-1 状态 处于FIN-WAIT-1状态的客户端还没有等到 ACK，收到了服务端发过来的 FIN 包 收到 FIN 包以后客户端会发送对这个 FIN 包的的确认 ACK 包，同时自己进入 CLOSING 状态 继续等自己 FIN 包的 ACK 处于 CLOSING 状态的客户端终于等到了ACK，随后进入TIME-WAIT 在TIME-WAIT状态持续 2*MSL，进入CLOSED状态 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/","summary":"完整的状态转换 三次握手的状态变化 同时打开的状态变化 自连接的状态变化 其实就是同时打开, 步骤5, 6在原文当中是window update包, 所以s","title":"连接状态转换"},{"content":"MSS TCP 为了避免被发送方分片，会主动把数据分割成小段再交给网络层，最大的分段大小称之为 MSS（Max Segment Size）。\nMSS = MTU - IP header头大小 - TCP 头大小 MSS指TCP最大载荷的大小 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/mss/","summary":"MSS TCP 为了避免被发送方分片，会主动把数据分割成小段再交给网络层，最大的分段大小称之为 MSS（Max Segment Size）。 MSS = MTU - IP header头大小 -","title":"MSS"},{"content":"MTU 数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层，这个限制被称为「最大传输单元（Maximum Transmission Unit, MTU）」\nMTU是指整个IP数据报的大小 以太网帧格式\nIP分段 当一个 IP 数据包大于 MTU 时，IP 会把数据报文进行切割为多个小的片段(小于 MTU），使得这些小的报文可以通过链路层进行传输\nIP 头部中有一个表示分片偏移量的字段，用来表示该分段在原始数据报文中的位置\n路径 MTU 一个包从发送端传输到接收端，中间要跨越很多个网络，每条链路的 MTU 都可能不一样，这个通信过程中最小的 MTU 称为「路径 MTU（Path MTU）」。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/mtu/","summary":"MTU 数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层，这个限制被称为「最大传输单元（Maximum Transmission Unit, MTU）」 MTU是指整","title":"MTU"},{"content":" 可选项格式\n时间戳选项 TCP Timestamps Option，TSopt\n由4部分组成\n类别（kind） 长度（Length） 发送方时间戳（TS value） 回显时间戳（TS Echo Reply） 是否使用时间戳选项是在三次握手里面的 SYN 报文里面确定的。\n发送方发送数据时，将一个发送时间戳 1734581141 放在发送方时间戳TSval中 接收方收到数据包以后，将收到的时间戳 1734581141 原封不动的返回给发送方，放在TSecr字段中，同时把自己的时间戳 3303928779 放在TSval中 后面的包以此类推 Timestamps 选项的作用\n两端往返时延测量（RTTM） 序列号回绕（PAWS） 测量 RTTM 启用Timestamps选项后可以避免重传包无法计算rtt的问题.\nPAWS TCP 的窗口经过窗口缩放可以最高到 1GB（2^30)，在高速网络中，序列号在很短的时间内就会被重复使用。\n如果有 Timestamps 的存在，内核会维护一个为每个连接维护一个 ts_recent 值，记录最后一次通信的的 timestamps 值，在 t7 时间点收到迷途数据包 2 时，由于数据包 2 的 timestamps 值小于 ts_recent 值，就会丢弃掉这个数据包。等 t8 时间点真正的数据包 6 到达以后，由于数据包 6 的 timestamps 值大于 ts_recent，这个包可以被正常接收。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-options/","summary":"可选项格式 时间戳选项 TCP Timestamps Option，TSopt 由4部分组成 类别（kind） 长度（Length） 发送方时间戳（TS value） 回显时间戳（T","title":"TCP Options"},{"content":" window size只有16位, 起初表示最大窗口为65535B 后来不够用就引入了TCP窗口缩放选项, 范围为0~14 0: 不缩放 !=0: 窗口大小为 windowSize * 2^n 窗口缩放在握手时指定 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-window-size/","summary":"window size只有16位, 起初表示最大窗口为65535B 后来不够用就引入了TCP窗口缩放选项, 范围为0~14 0: 不缩放 !=0: 窗口大小为 windowSize * 2^n 窗口缩放在","title":"TCP窗口大小"},{"content":" 这些标记可以组合使用，比如 SYN+ACK，FIN+ACK 等\nSYN（Synchronize）：用于发起连接数据包同步双方的初始序列号 ACK（Acknowledge）：确认数据包 RST（Reset）：这个标记用来强制断开连接，通常是之前建立的连接已经不在了、包不合法、或者实在无能为力处理 FIN（Finish）：通知对方我发完了所有数据，准备断开连接，后面我不会再发数据包给你了。 PSH（Push）：告知对方这些数据包收到以后应该马上交给上层应用，不能缓存起来 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-flags/","summary":"这些标记可以组合使用，比如 SYN+ACK，FIN+ACK 等 SYN（Synchronize）：用于发起连接数据包同步双方的初始序列号 ACK（A","title":"TCP Flags"},{"content":"序列号 Sequence Number 序列号指的是本报文段第一个字节的序列号\n32位无符号整数 初始序列号 在建立连接之初，通信双方都会各自选择一个序列号，称之为初始序列号。在建立连接时，通信双方通过 SYN 报文交换彼此的 ISN\n初始序列号是如何生成的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 __u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr, __be16 sport, __be16 dport) { u32 hash[MD5_DIGEST_WORDS]; net_secret_init(); hash[0] = (__force u32)saddr; hash[1] = (__force u32)daddr; hash[2] = ((__force u16)sport \u0026lt;\u0026lt; 16) + (__force u16)dport; hash[3] = net_secret[15]; md5_transform(hash, net_secret); return seq_scale(hash[0]); } static u32 seq_scale(u32 seq) { return seq + (ktime_to_ns(ktime_get_real()) \u0026gt;\u0026gt; 6); } 代码中的 net_secret 是一个长度为16的 int 数组，只有在第一次调用 net_secret_init 的时时候会将将这个数组的值初始化为随机值。在系统重启前保 持不变。 可以看到初始序列号的计算函数 secure_tcp_sequence_number() 的逻辑是通过源地址、目标地址、源端口、目标端口和随机因子通过 MD5 进行进行计算。 如果仅有这几个因子，对于四元组相同的请求，计算出的初始序列号总是相同，这必然有很大的安全风险，所以函数的最后将计算出的序列号通过 seq_scale 函 数再次计算。 seq_scale 函数加入了时间因子，对于四元组相同的连接，序列号也不会重复了。 序列号回绕了怎么处理 1 2 3 4 static inline bool before(__u32 seq1, __u32 seq2) { return (__s32)(seq1-seq2) \u0026lt; 0; } 测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; func main() { var ( seq1 uint8 = 255 seq2 uint8 = 1 ) fmt.Println(\u0026#34;case1(未回绕):\u0026#34;) fmt.Printf(\u0026#34;befort: %t\\n\\n\u0026#34;, before(seq1, seq2)) seq1 = 255 seq2 = 128 fmt.Println(\u0026#34;case2(已回绕):\u0026#34;) fmt.Printf(\u0026#34;befort: %t\\n\u0026#34;, before(seq1, seq2)) } func before(seq1, seq2 uint8) bool { fmt.Printf(\u0026#34;seq1: %d, signed: %d\\n\u0026#34;, seq1, int8(seq1)) fmt.Printf(\u0026#34;seq2: %d, signed: %d\\n\u0026#34;, seq2, int8(seq2)) return int8(seq1-seq2) \u0026lt; 0 } 输出\ncase1(未回绕): seq1: 255, signed: -1 seq2: 1, signed: 1 befort: true case2(已回绕): seq1: 255, signed: -1 seq2: 128, signed: -128 befort: false 确认号 Acknowledgment Number 不是所有的包都需要确认的 不是收到了数据包就立马需要确认的，可以延迟一会再确认 ACK 包本身不需要被确认，否则就会无穷无尽死循环了 确认号永远是表示小于此确认号的字节都已经收到 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp%E5%BA%8F%E5%88%97%E5%8F%B7/tcp%E5%BA%8F%E5%88%97%E5%8F%B7/","summary":"序列号 Sequence Number 序列号指的是本报文段第一个字节的序列号 32位无符号整数 初始序列号 在建立连接之初，通信双方都会各自选择一个序列号，称之为初始序列号。","title":"TCP序列号/确认号"},{"content":"TCP Options\n-------------------------------- |type(1byte)|len(1byte)|content(len-2)| -------------------------------- ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-header/","summary":"TCP Options\n-------------------------------- |type(1byte)|len(1byte)|content(len-2)| -------------------------------- ","title":"TCP Header"},{"content":" 面向连接 可靠 校验和 序列号解决乱序, 重复 超时重传 流量控制, 拥塞控制 基于字节流 全双工 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp%E7%89%B9%E7%82%B9/","summary":"面向连接 可靠 校验和 序列号解决乱序, 重复 超时重传 流量控制, 拥塞控制 基于字节流 全双工","title":"TCP的特点"},{"content":"9.1 TCP的低效率因素，以及HTTP TCP运行的基本方式会导致5个主要的问题，它们至少影响到了HTTP：\n有一个连接创建的延迟。要在连接开始时协商发送方和接收方可以使用的序列号。 TCP慢启动算法限制了TCP的性能，它小心翼翼地处理发送的数据量，以尽可能防止重传。 不充分使用连接会导致限流阈值降低。如果连接未被充分使用，TCP会将拥塞窗口的大小减小，因为它不确定在上个最优的拥塞窗口之后网络参数有没有发生变化。 丢包也会导致TCP的限流阈值降低。TCP认为所有的丢包都是由窗口拥堵造成的，但其实并不是。 数据包可能被排队。乱序接收到的数据包会被排队，以保证数据是有序的。 9.1.1 创建HTTP连接的延迟 图9.1　HTTPS连接所需要的TCP和HTTPS设置\n9.1.2 TCP拥塞控制对性能的影响 拥塞控制算法和概念增加了稳定性，但也带来了低效的问题\nTCP慢启动\n表9.1　常见的TCP慢启动增长\n图9.4　TCP慢启动到最佳容量的过程\n当达到最大容量之后，如果没有发生丢包，TCP拥塞控制就进入拥塞避免阶段，随后拥塞窗口还会持续增长，但会变成慢得多的线性增长, 直到它开始看到丢包，认为 到了最大容量\nTCP慢启动很慢吗\n因为TCP慢启动的指数增长特性，所以按大多数定义来说它并不慢。 尽量把东西放到前14KB中\n开始的10个TCP数据包（至少）会被如下消息使用：\n两个HTTPS响应（Server Hello和Change Spec） 两个HTTP/2 SETTINGS帧（服务器发送一个，另外一个用来确认客户端的SETTINGS帧） 一个HEADERS帧，响应第一个请求 表9.2　通常使用6个连接的TCP慢启动增长\n连接闲置降低性能\n在连接刚启动时和连接闲置时，TCP慢启动算法会导致延迟。TCP比较小心谨慎，在闲置一段时间后，网络情况可能发生变化，所以TCP将拥塞窗口大小降低，重新进行 慢启动流程，以再次找到最佳的拥塞窗口大小。\n丢包降低TCP性能\ntcp在遇到丢包时, 直接将拥塞窗口大小减半\n图9.6　TCP拥塞窗口大小受丢包影响\n丢包带来的影响在HTTP/2中尤其严重，因为它只使用单个连接。在HTTP/2的世界中，一次丢包会导致所有的资源下载速度变慢。而HTTP/1.1可能有6个独立的连接， 一次丢包只会减慢其中一个连接，但是另外5个不受影响。\n丢包会导致数据排队\n图9.7　同时传输多个响应\n图9.8　TCP重传一个HTTP/2帧的一部分\n如果没有发生其他的丢包，流7和流9会在重传的数据到来之前被完整接收。但这些响应必须排队，因为TCP要保证顺序，所以尽管已经完整下载，script.js和 image.jpg还不能被使用。\n图9.9　HTTP/1.1下TCP重传只影响需要重传的连接\nHTTP/2在HTTP层解决了队头阻塞（HOL）的问题，因为有多路复用，单个响应的延迟不会影响其他资源使用当前的HTTP连接。但是，在TCP层队头阻塞依然存在。 一个流的丢包会直接影响到其他所有的流，尽管它们可能不需要排队。\n9.1.3 TCP低效率因素对HTTP/2的影响 9.1.4 优化TCP 在Linux中，大多数TCP设置在如下路径中\n/proc/sys/net/ipv4 查看\ncat /proc/sys/net/ipv4/tcp_slow_start_after_idle 设置\nsysctl -w net.ipv4.tcp_slow_start_after_idle=0 提高初始拥塞窗口大小\n这个设置值通常被写死到内核代码中，所以除非升级操作系统，否则不建议修改。 支持窗口缩放\n在传统情况下，TCP所允许的最大拥塞窗口大小是65 535字节，但新版本中添加了缩放因子，理论上允许拥塞窗口最大到1GB。\ncat /proc/sys/net/ipv4/tcp_window_scaling 使用SACK\nSelective Acknowledgment /proc/sys/net/ipv4/tcp_sack 禁止重启慢启动\ncat /proc/sys/net/ipv4/tcp_slow_start_after_idle // 禁用 sysctl -w net.ipv4.tcp_slow_start_after_idle=0 使用TFO\nTCP Fast Open 出于安全的原因，这个数据包只能在TCP重连时使用，而不能在初次连接时使用，它同时需要客户端和服务端的支持。 图9.17　未使用TFO和使用了TFO的TCP和HTTPS重连握手\ncat /proc/sys/net/ipv4/tcp_fastopen 表9.5　TFO设置项的取值\necho \u0026#34;3\u0026#34; \u0026gt; /proc/sys/net/ipv4/tcp_fastopen 使用拥塞控制算法，PRR和BBR\nBBR是Google发明的，从Linux内核4.9版开始可以启用它，它不需要客户端支持。 9.1.5 TCP和HTTP的未来 9.2 QUIC 创建QUIC时考虑到了以下特性\n大量减少连接创建时间。 改善拥塞控制 。 多路复用，但不要带来队头阻塞。 前向纠错。 连接迁移。 FEC（Forward Error Correction，前向纠错）试图通过在邻近的数据包中添加一个QUIC数据包的部分数据来减少数据包重传的需求。这个想法是，如果只丢了 一个数据包，那应该可以从成功传送的数据包中重新组合出该数据包。\n连接迁移旨在减少连接创建的开销，它通过支持连接在网络之间迁移来实现。\n9.2.1 QUIC的性能优势 9.2.2 QUIC和网络技术栈\n图9.18　QUIC在HTTP技术栈中所处的位置\nQUIC不会替代HTTP/2，但它会接管传输层的一些工作，在上层运行较轻的HTTP/2实现。\n9.2.3 什么是UDP，为什么QUIC基于它 为什么不改进TCP\n主要缺点是此类改进的实施速度慢。 为什么不使用SCTP\nSCTP的采用率很低，这主要是因为到目前为止TCP已经足够好。因此，迁移到SCTP可能与升级TCP需要一样长的时间。 为什么不直接使用IP\n直接使用IP与直接使用SCTP具有相同的问题。该协议必须在操作系统级别实现，因为很少有应用程序可以直接访问IP数据包。 UDP的优点\nUDP是一种基础协议，也在内核中实现。在它之上的任何东西都需要在应用层中构建，也就是所说的用户空间。在内核之外构建，可以通过部署应用程序来实现快速创 新，无论是在服务端还是在客户端。\n图9.19　查看www.google.com上部署的QUIC版本\nQUIC会一直使用UDP吗\n9.2.4 标准化QUIC 两个版本的QUIC：gQUIC和iQUIC\ngQUIC（Google QUIC）和iQUIC（IETF QUIC） gQUIC和iQUIC的区别\n随着两个版本协议的发展，它们之间的区别会越来越大 Google使用自定义加密设计，而iQUIC使用TLSv1.3 QUIC标准\nQUIC Invariants —— QUIC中恒定不变的部分 QUIC Transport —— 核心传输协议 QUIC Recovery —— 丢包检测和拥塞控制 QUIC TLS —— QUIC中如何使用TLS加密 HTTP/3 —— 主要基于HTTP/2，但有一些不同 QUIC QPACK —— 使用QUIC的HTTP协议的首部压缩 需要注意的一点是，QUIC旨在成为一种通用的协议，HTTP只是它的一种用途。虽然HTTP目前是QUIC的主要用例，也是工作组目前正在关注的焦点，但该协议的设计 考虑了潜在的其他应用场景。\n9.2.5 HTTP/2和QUIC的不同 QUIC和HTTPS\nHTTPS内置于QUIC中，与HTTP/2不同，QUIC不能用于未加密的HTTP连接。做出这个选择的原因与HTTP/2相同，无论从实际使用上，还是人们的意愿上，只能通过 HTTPS进行Web浏览\n创建一个QUIC连接\n因为QUIC是基于UDP的，连接到Web服务器的浏览器必须先使用TCP连接，然后再升级到QUIC。这个过程就需要依赖基于TCP的HTTP，这就抵消了QUIC带来的一 个关键好处（大量减少连接创建时间）。有一些变通方法，比如同时尝试TCP和UDP，或者就接受第一次的性能损耗，并记住下次服务器使用QUIC。\nQPACK\nQUIC旨在消除连接层顺序传输数据包的要求，以允许流独立处理。HPACK仍然需要这种保证（至少对于HEADERS帧），因此它重新引入了队头阻塞，而这正是它试图 解决的问题。\n因此，HTTP/3需要有一种HPACK的变体，也就是QPACK（原因显而易见）。这个变体很复杂\n其他区别\n一些传输层协议的帧从HTTP/3层中被移除了（例如PING和WINDOW_UPDATE帧），移动到了核心QUIC-Transport层，这不是针对HTTP的（这是合理的，因为这些 帧很可能会用于基于QUIC的非HTTP协议）。\n9.2.6 QUIC的工具 9.2.7 QUIC实现 Caddy 9.2.8 你应该使用QUIC吗 与SPDY不同，gQUIC并未被更广泛的社区所接受，而且iQUIC似乎也不太可能现在被标准化。所以，除非你使用了Google Cloud Platform，否则不推荐你使用 QUIC。\n总结 在TCP和HTTPS层中，当前的HTTP网络栈存在若干低效率因素。 由于TCP的连接建立延迟和谨慎的拥塞控制算法，TCP连接达到最大容量需要时间，HTTPS握手会增加更多时间。 有一些创新可以解决这些低效问题，但它们的推出速度很慢，特别是TCP中的创新。 QUIC是一种基于UDP的新协议。 通过使用UDP，QUIC谋求比TCP创新的速度更快。 QUIC的创建基于HTTP/2，其使用了许多相同的概念，它是在原来的基础上再创新。 QUIC不仅适用于HTTP，它未来也可以用于其他协议。 基于QUIC的HTTP将被称为HTTP/3。 QUIC有两个版本：Google QUIC（gQUIC），当前有少量应用，但没有被标准化；IETF QUIC（iQUIC），正在标准化过程中。 在iQUIC被批准成为正式标准时，gQUIC将被取代，就像HTTP/2取代了SPDY。 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC4%E9%83%A8%E5%88%86-http%E7%9A%84%E6%9C%AA%E6%9D%A5/%E7%AC%AC9%E7%AB%A0tcp-quic-http3/","summary":"9.1 TCP的低效率因素，以及HTTP TCP运行的基本方式会导致5个主要的问题，它们至少影响到了HTTP： 有一个连接创建的延迟。要在连接开始时协","title":"第9章TCP, QUIC和HTTP/3"},{"content":" 如果不再严格要求只针对具体的请求响应推送，HTTP/2推送是否可以代替WebSockets或者SSE？ 当资源更新时，HTTP/2推送是否可以用来更新浏览器缓存？ 它可以用来改进渐进式JPEG吗？ 它可以用于API吗？ 是否会在其他场景中添加通知？ 总结 HTTP/2推送是HTTP/2中的一个新概念，它允许为一个请求返回多个响应。 HTTP/2推送被提议时，目的是作为内联关键资源的替代方案。 很多服务器和CDN通过使用HTTP link首部实现HTTP/2推送。 新的103状态码可用来更早提供link首部。 HTTP/2推送在客户端的实现方式可能没有那么显而易见。 很容易就会推送过多的内容，这会降低网站性能。 HTTP/2推送带来的性能提升可能没那么大，但是风险很高。 相较于使用推送，配合使用预加载和103状态码可能更好。 HTTP/2推送可能有其他应用场景，但有些需要更改协议。 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.9/","summary":"如果不再严格要求只针对具体的请求响应推送，HTTP/2推送是否可以代替WebSockets或者SSE？ 当资源更新时，HTTP/2推送是否可以","title":"5.9 HTTP/2推送的其他应用场景"},{"content":"图5.18　使用状态码103告诉Web服务器更早推送资源\n图5.19　使用带有preload首部的103状态码代替HTTP/2推送\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.8/","summary":"图5.18 使用状态码103告诉Web服务器更早推送资源 图5.19 使用带有preload首部的103状态码代替HTTP/2推送","title":"5.8 对比推送和预加载"},{"content":"高效使用HTTP/2推送的关键是利用连接未被使用时的空闲带宽。\n图5.17　HTTP/2推送的资源和主动请求的资源响应时间不同\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.7/","summary":"高效使用HTTP/2推送的关键是利用连接未被使用时的空闲带宽。 图5.17 HTTP/2推送的资源和主动请求的资源响应时间不同","title":"5.7 HTTP/2推送对性能的影响"},{"content":" 你在使用HTTP/2吗？ 你的服务器支持HTTP/2推送吗？ 你的服务器在其他基础架构之后吗？如果你的服务器之前有负载均衡器，或者其他中断HTTP/2连接的基础架构，则它可能不支持HTTP/2推送，尽管你的服务器本身 是支持的。就算它支持HTTP/2推送，它也有可能不会透传推送的资源，推送的资源应该由边缘节点处理。 服务器正在推送资源吗？可以使用nghttp查看具体的帧 页面需要这些资源吗？如果页面不需要这些资源，则浏览器不会使用它们 你在使用服务器支持的正确方式推送吗？如何推送取决于服务器。很多服务器使用HTTP link首部，但并不是所有的服务器都这么做 服务器是否明确指定不推送这个资源？ 要推送的资源存在吗？ 你是否在一个客户端预料之外的连接上推送？ 你在使用自签名的证书或者其他不受信任的证书吗？对于不受信任的HTTP证书（包含本机使用的自签名的虚假证书），Chrome忽略推送请求 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.6/","summary":"你在使用HTTP/2吗？ 你的服务器支持HTTP/2推送吗？ 你的服务器在其他基础架构之后吗？如果你的服务器之前有负载均衡器，或者其他中断HTT","title":"5.6 HTTP/2推送常见问题"},{"content":"5.5.1 你能推送什么 规范规定了一些HTTP/2推送的基本规则：\n在SETTINGS帧中将SETTINGS_ENABLE_PUSH设置为0，客户端可以禁用推送。此后，服务端不能使用PUSH_PROMISE帧。 推送请求必须使用可以缓存的方法（GET、HEAD和一些POST请求）。 推送请求必须是一些安全请求（通常为GET或者HEAD请求）。 推送请求不能包含请求体（但经常包含响应体）。 只将推送请求发送到权威服务器的域。 客户端不能推送，只有服务端可以。 资源可以在当前请求的响应中推送。如果没有请求，则服务端不可能发起一个推送。 由于这些规则，只有GET请求会被推送。\n5.5.2 应该推送什么 只有关键资源才应该被推送 应该推送很可能缓存里没有的资源。 5.5.3 自动化推送 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.5/","summary":"5.5.1 你能推送什么 规范规定了一些HTTP/2推送的基本规则： 在SETTINGS帧中将SETTINGS_ENABLE_PUSH设置为0，客户端可以","title":"5.5 推送什么"},{"content":"使用HTTP/2推送的风险是推送浏览器不需要的资源\n5.4.1 在服务端跟踪推送的资源 需要记状态, 比较复杂\n会遇到资源限制 负载均衡问题 5.4.2 使用HTTP条件请求 客户端发送一个if-modified-since或者etag首部，而引用这个CSS的页面已经在浏览器的缓存中，但已过期。\n5.4.3 使用基于cookie的推送 在客户端记录哪些资源已经被推送。cookie是做这个的理想载体，当然也可以使用LocalStorage和SessionStorage。\n5.4.4 使用缓存摘要 缓存摘要是一个提议，浏览器用它来告诉服务器缓存里有什么内容。当连接建立时，浏览器发送一个CACHE_DIGEST帧，列出当前域名（或者本连接授权的其他域名） 的HTTP缓存中的所有资源。\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.4/","summary":"使用HTTP/2推送的风险是推送浏览器不需要的资源 5.4.1 在服务端跟踪推送的资源 需要记状态, 比较复杂 会遇到资源限制 负载均衡问题 5.4.2 使用HTTP条件请","title":"5.4 如何实现条件推送"},{"content":"差速器锁\n为什么越野型汽车要配差速器锁？ 限滑差速器只能部分阻止车轮的差速，而对于强调越野性的车型来说，在越野时最好是将差速器锁死，使其完全失去差速作用。将差速器锁死的装置，称为差速器锁。 带有锁止功能的差速器，称为锁止式差速器。\n牙嵌入式差速锁构造图\n差速器锁功能示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E5%8A%A8%E7%B3%BB%E7%BB%9F/5.06/","summary":"差速器锁 为什么越野型汽车要配差速器锁？ 限滑差速器只能部分阻止车轮的差速，而对于强调越野性的车型来说，在越野时最好是将差速器锁死，使其完全失去","title":"5.06 差速器锁Differential Lock"},{"content":"为什么差速器会导致车轮打滑？ 四驱汽车差速器作用示意图\n什么是差速限制器？ 我们将用来限制差速器差速功能的装置，称为差速限制器。差速限制器根据行驶需要，将左右车轮或前后轴的转速差控制在一定范围之内，既保证车辆顺利转弯，又能 阻止车轮打滑。\n根据构造和原理不同，差速限制器可分为转矩感应型、转速感应型和电子限滑型等多种形式。虽然，实现限制差速的手段不同，但是最终目的都是一致的，都是在不需 要差速时限制差速器的差速功能，保证车辆正常行驶。\n差速器锁是差速限制器的极端装置，它使差速器完全失去差速功能，将原本可以差动的两轴硬性地连接在一起，以完全相同的转速转动，使差速为零。\n限滑差速器构造图\n什么是限滑差速器？ 在开放式差速器上装备差速限制器，如电控多片离合器、黏性耦合器等，以便在车轮打滑时对差速器的差速功能进行限制，阻止车轮继续打滑。通常我们把具备差速限 制功能的差速器，称为限滑差速器（Limited Slip Differential，缩写为LSD）。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E5%8A%A8%E7%B3%BB%E7%BB%9F/5.05/","summary":"为什么差速器会导致车轮打滑？ 四驱汽车差速器作用示意图 什么是差速限制器？ 我们将用来限制差速器差速功能的装置，称为差速限制器。差速限制器根据行驶","title":"5.5 差速限制器 Differential Limiter"},{"content":" 为什么汽车需要差速器？ 对于驱动轮来讲，由于左右两侧的车轮都接受来自发动机和变速器的同样的力，要想让它们在接受同样驱动力的情况下又能和谐运转，就需要一种装置来协调或吸收左 右两个驱动轮之间的转速差，这个装置就是差速器。\n差速器是怎样差速的？ 后差速器车上位置示意图\n轮间差速器工作原理示意图\n差速器\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E5%8A%A8%E7%B3%BB%E7%BB%9F/5.04/","summary":"为什么汽车需要差速器？ 对于驱动轮来讲，由于左右两侧的车轮都接受来自发动机和变速器的同样的力，要想让它们在接受同样驱动力的情况下又能和谐运转，","title":"5.4 差速器 Differential"},{"content":"传动轴和半轴起什么作用？ 发动机的动力经变速器调整，最后要传递到驱动轮上。如果是前置发动机、后轮驱动的车辆，要用一根传动轴将动力从车辆前部传递到后差速器上，再用半轴将动力从 后差速器一分为二传递到两个后轮上；如果是前置发动机、前轮驱动的车辆，前差速器和变速器整合在一起，只需要用两根半轴将动力从前差速器一分为二传递到两个 前轮上即可；如果是四轮驱动，基本是将上述两种方式进行整合，要用两根传动轴、四根半轴、三个差速器才能将动力分配到四个车轮上。\n后轮驱动汽车传动轴和半轴示意图\n标致汽车前驱车型前桥构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E5%8A%A8%E7%B3%BB%E7%BB%9F/5.03/","summary":"传动轴和半轴起什么作用？ 发动机的动力经变速器调整，最后要传递到驱动轮上。如果是前置发动机、后轮驱动的车辆，要用一根传动轴将动力从车辆前部传递","title":"5.3 传动轴和半轴 Drive Shaft and Half Shaft"},{"content":"为什么说离合器是动力开关？ 传动系统\n为了让发动机的动力能够平顺地传递到变速器，离合器必须采用摩擦方式进行接触，而不能采用刚性连接。因此，才出现了最常用的摩擦离合器。\n离合器的位置和作用示意图\n离合器工作原理\n离合器构造及液压操纵系统\n发动机和6速手动变速器\n![](https://res.weread.qq.com/wrepub/epub_26688761_260\n离合器工作原理\n离合器工作原理示意图\n膜片弹簧离合器主要部件\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E5%8A%A8%E7%B3%BB%E7%BB%9F/5.02/","summary":"为什么说离合器是动力开关？ 传动系统 为了让发动机的动力能够平顺地传递到变速器，离合器必须采用摩擦方式进行接触，而不能采用刚性连接。因此，才出现","title":"5.2 离合器 Clutch"},{"content":"2.1 资产业务概述 银行通过网点服务客户获得的各种负债，最终必须通过配置到不同类别的资产中，进而获得利息收入。\n收益与风险的平衡\n通常银行的资产收益率并不是越高越好，而是要在风险和收益之间寻找利益最大化的平衡点。 久期与期限错配\n通常来讲，久期越长的资产收益率越高。 配置长久期资产的风险 流动性风险(挤兑) 期限错配引发的利率风险 从金融的角度看，银行本身就是在依靠一定程度的期限错配挣钱。银行既要保持一定的期限错配以获得利润，但是又不能把期限错配做得太过分，造成过高风险。 银行的资产配置\n生息资产: 贷款、投资、存放央行、存放同业或其他金融机构、拆出资金及买入返售资产 存放央行主要是由存款准备金率决定的，属于被动型资产 非生息资产: 现金、贵金属、商誉、其他资产等 越少越好 2.2 贷款/垫款业务 业务分类 贷款/垫款业务是银行现行资产业务中占比最高的业务，也是对银行营收贡献最大的一项业务。\n贷款/垫款业务按照放贷的对象和方式不同，可以分成零售贷款、对公贷款和票据贴现三大类。\n零售贷款，就是发放给个人或者个体经营者的贷款，主要包括：房屋按揭、信用卡、消费贷、汽车贷、助学贷等。零售贷款的特点是：单笔金额小，风险相对较低， 收益率偏高。 对公贷款，顾名思义就是贷款的发放对象是企事业单位。对公贷款的特点是：单笔金额较大，风险相对较高，收益率和放贷对象的信用等级密切相关。 对公与零售的优劣对比 总体来说，对公贷款的平均不良率要高于零售信用贷款，但是平均收益率反而比零售信用贷款低。\n对公贷款和零售贷款相比也有其自身的优势\n第一，对公贷款的贷前尽调成本低。银行在放贷之前需要对被放贷的对象进行贷前风险尽职调查，以确定放贷对象的风险级别。对于对公贷款来说，假设一家公司贷 款1亿元，只需要做一次尽调。如果换成零售贷款，每个对象50万元，需要做200次尽调。 第二，对公贷款可以派生存款。通常企业申请贷款后并不是马上全部用掉，而是为后期项目准备资金。所以，贷款发放后，会有部分资金变成存款，银行又可以用这 些存款去放贷。这变相帮助银行扩张了资产负债规模。而零售贷款发放后多数被直接用掉，所以无法帮助银行派生存款。 零售贷款的风险相对较低，主要得益于两点。\n第一，我国社会信用体系的逐渐完善。随着国家信用体系的建立，对于失信人群的限制越来越多 第二，中国没有个人破产保护制度，意味着银行对于个人债务具有无限追索权。 零售贷款的收益率明显高于对公贷款，除了因为信用卡贷款利率较高外，主要的原因还在于个人在办理贷款的过程中和银行处于不平等的地位。不同于公司对银行有议 息的资格，个人通常只能单方面接受银行规定的利率。\n除了招商银行和平安银行零售贷款高于对公贷款外，其他银行都低于对公贷款。\n表2.2　主要银行的对公、零售贷款占比（%）\n票据贴现 票据贴现是指资金借贷者以手中未到期的商业票据、银行承兑汇票等向银行要求变成现款。\n票据贴现中最常见的票据是银行承兑汇票和商业承兑汇票。\n银行承兑汇票贴现是以票据承兑银行的信用为基础进行的融资行为； 而商业承兑汇票贴现是以票据承兑企业的商业信用为基础进行的融资行为。 一般来说，承兑的银行或企业信用级别越高，票据贴现融资就越容易成功。\n2.3 投资业务 中庸的投资策略 主要的投资方向包括：债券、非标资产、投资基金、贵金属、股权投资等。其中，多数银行占比较多的是债券和非标资产，但是也有少数银行对投资基金配置量较大。\n在银行的资产负债表中，政府债券的配置比例是最高的，政策性银行债券次之，企业债占比最少。\n配置国债有很多好处\n国债的风险加权资产因子为零，也就是说配置国债是完全不消耗银行资本金的； 国债的利息收入免征所得税，按照现行的监管规则，国债和货币基金的利息收入可以免征； 国债作为最优秀的抵押品，在流动性紧张的时候随时可以作为担保品抵押给同业或者央行进行头寸拆借。 金融创新的产物：非标资产 非标准化债权资产，简称非标资产，指的是未在银行间市场及证券交易所上市交易的债权性资产，包括但不限于信贷资产、信托贷款、委托债权、承兑汇票、信用证、 应收账款、各类受（收）益权、带回购条款的股权性融资等。\n做非标业务主要有以下的动力\n规避贷款监管指标限制。 可以减少资本金消耗和资产减值损失计提。 目前非标资产受到的监管越来越严格，要求银行对非标资产进行穿透管理，足额计提资本金和风险减值，在严监管下银行做非标的好处会减少，所以未来这部分资产会 显著收缩。\n投资资产的划分 对于未实施IFRS9的银行，投资资产里面报表上最大的几类是：\n可供出售金融资产, 指银行的交易类资产和其他不打算持有至到期的股票和债券等，这部分资产主要的目的是在交易中获利。 持有至到期金融资产, 指企业打算并且能够持有至到期的债券等。 应收款项类投资, 指银行用资金承接第三方的非标资产包，其中以非标票据资产和非标贷款资产为主。 按照IFRS9国际新会计准则, 投资资产主要包括如下几项：\n以公允价值计量且其变动计入当期损益的投资 以公允价值计量且其变动计入其他综合收益的债务工具投资 以摊余成本计量的债务工具投资 新的分类将取代原有的可供出售金融资产、持有至到期金融资产和应收款项类投资。\n投资类资产是银行资产表中相对最复杂的，变化最多的，也是最容易隐藏风险的地方。由于银行的报表中不需要强制披露和投资资产相关的风险和资产细节，这对于投 资者准确评估银行的风险情况造成了不小的障碍，所以，建议投资者对投资资产占比过高的银行要更加谨慎。\n2.4 信用卡业务 信用卡业务简要介绍 在信用卡使用的场景中，一个最普通的刷卡消费场景就涉及了五方\n发卡行, 信用卡的发行银行，也是最终提供垫付资金的银行。 收单行, 刷卡机（POS机）的提供银行，它负责接受发卡行通过信用卡组织转过来的消费款并计入商家在自家银行的对公账户中。 商家 消费者 信用卡组织, 负责在发卡行和收单行之间进行交易清算和手续费分配。 在整个刷卡消费的过程中，手续费由商家负责支付，手续费的比例在国内一般按照刷卡金额的0.6%收取. 在我国，信用卡组织主要就是银联，信用卡刷卡手续费在国 内按照7∶2∶1的比例在发卡行、收单行和银联之间分配。\n信用卡的免息期通常是指在消费者刷卡后，到最后还款期限之前的这一段时间。\n发卡行每月会在固定日期通过电子邮件或者纸质账单的形式给客户寄送信用卡账单。 账单日后15～20个日历日就是最后还款日，客户在最后还款日之前偿还账单上的全部欠款则不需要支付任何利息。 所以，理论上来说，信用卡的最长免息期可达到45～50个自然日。 如果在最后还款日之前无法全额还款，那么发卡行将对消费者收取罚息，实际上就是贷款利息。 这种贷款利息和普通的贷款利息有很大不同\n利率高。默认的信用卡罚息是日利率0.05%，年化利率18%。 利滚利计息。如果在逾期后的第二个月，消费者依然没有全额还款，那么第一个月产生的逾期罚息将会在第二个月滚存入本金产生逾期利息 全额罚息。所谓全额罚息是指在规定的最后还款期限内，如果消费者没有全额还款，那么第二个月的利息计算是以全部消费额计算，而不是以未偿还消费额计算。 在消费者产生逾期后，实际上可以有三种不同的处理方式\n不做任何处理，放任银行按照逾期进行处理。 申请最低还款额，并偿还超过最低还款额的部分。 申请分期支付。 这三种处理方式对于消费者的区别是：\n第一种会产生不良征信记录，影响未来的贷款、买房等。 第二种虽然不会产生不良征信记录，但是会利滚利，甚至全额罚息。 第三种，分期偿还既不会产生不良征信记录，也不会出现利滚利和罚息问题。 信用卡分期费率探讨 分歧年化利率计算公式\n年化利率 = 24*分期数*分期利率/(分期数+1) 表2.4　分期费率和年化利率的对应（%）\n","permalink":"https://jdxj.github.io/posts/books/%E7%9C%8B%E9%80%8F%E9%93%B6%E8%A1%8C-%E6%8A%95%E8%B5%84%E9%93%B6%E8%A1%8C%E8%82%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC2%E7%AB%A0-%E9%93%B6%E8%A1%8C%E7%9A%84%E8%B5%84%E4%BA%A7%E4%B8%9A%E5%8A%A1/","summary":"2.1 资产业务概述 银行通过网点服务客户获得的各种负债，最终必须通过配置到不同类别的资产中，进而获得利息收入。 收益与风险的平衡 通常银行的资产收益率","title":"第2章 银行的资产业务"},{"content":"具体和实现有关, 服务器推送的资源, 大多数浏览器不会立即使用, 而是放到缓存中, 如果浏览器需要某资源先去缓存中查找.\n5.3.1 查看推送缓存如何工作 推送的资源存放在单独的内存中（HTTP/2推送缓存），等待浏览器请求，而后它们会被加载到页面中。 如果设置了缓存首部，则在后来使用它们时它们照旧会被保存到浏览器的HTTP缓存中。 基于Chromium的浏览器不会缓存不受信任的HTTP/2推送 浏览器可能先去HTTP缓存中查找资源, 然后是HTTP/2推送缓存 图5.15　浏览器和HTTP/2推送的交互\n图5.16　在Chrome中对未声明的推送资源进行跟踪\nHTTP/2推送缓存和连接绑定，这意味着如果连接关闭，推送资源也就无法使用了。 如果使用另外一个连接，也用不到推送的资源。 当资源从连接的推送缓存中被“认领”并拿出后，就不能再从推送缓存中使用它了。 5.3.2 使用RST_STREAM拒绝推送 在服务端收到RST_STREAM帧并做出响应之前，可能整个推送的资源已经发完了。\n只有在浏览器知道它不需要推送的资源时，RST_STREAM帧才有用 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.3/","summary":"具体和实现有关, 服务器推送的资源, 大多数浏览器不会立即使用, 而是放到缓存中, 如果浏览器需要某资源先去缓存中查找. 5.3.1 查看推送缓存如何工作 推送的","title":"5.3 HTTP/2推送在浏览器中如何运作"},{"content":"汽车都有哪些传动形式？ 前置发动机、前轮驱动车型（F F），对车内空间安排比较有利，发动机、变速器、传动机构都整合在车头部位，甚至都在前车轴上方，这样可以从容安排驾乘室空间 和行李箱空间。但是，这种驱动形式会造成车头过重，在制动时易出现“点头”现象。\n发动机放置方式和传动形式示意图\n发动机的动力是怎样传递到车轮上的？ 动力从发动机到车轮要经过多个环节，要经过离合器、变速器、传动轴、差速器和半轴等才能到达车轮。根据车型定位和性能需要，可以设计多种动力传递形式。通常 情况下，汽车的发动机都放在汽车的前端，也就是前置发动机。根据驱动车轮的位置和数量不同，大致可分为前轮驱动、后轮驱动和四轮驱动三大形式。\n前驱车动力传递路线\n后驱车动力传递路线\n四驱车动力传递路线\n四轮驱动汽车动力传递方向示意图\n前置发动机四轮驱动汽车传动系统构造图\n前置发动机后轮驱动汽车动力传递方向示意图\n前置前驱（FF）有什么特点？ 前置前驱是指发动机放置在车前部，并采用前轮驱动（Front engine Front wheel drive，简称FF）。\n优点\n它的特点是头重尾轻，整车60%以上的重量集中在车身前段。由于车体是被前轮“拉着走”的，因此FF的直线行驶稳定性非常好。 在FF车型上，发动机经差速器后用半轴直接驱动前轮，不需经传动轴，动力损耗较小，所以适合小型车。 FF车后排座椅间少了后驱车必有的传动轴凸包，后座的乘员不用缩脚挤在狭窄的空间里，这一点可说是FF最大的优点。 缺点\n头重尾轻的设计使得车辆在高速行驶时，踩下制动踏板的瞬间，车头容易下沉，车尾易扬起甚至悬空造成危险。 由于前部较重，且前车轮同时负责驱动和转向，因此方向盘较重，转弯半径较大，容易出现转向不足现象。 前置前驱示意图\n前置前驱汽车构造图\n前置后驱（FR）有什么特点？ 前置后驱示意图\n前置后驱汽车构造图\n前置后驱是指将发动机放置在车前部，并采用后轮驱动（Front engine Rear wheel drive，简称FR）。\nFR在轴荷分配上比前驱车平均，可以达到50∶50的最佳比例，因此它拥有较佳的操控性和行驶稳定性。 理论上，FR车在转弯时的最大速度会更高。但是，由于汽车前轮直接受转向系统支配，在已经改变行驶方向的情况下，后面的驱动轮仍有向前的惯性，所以容易出现 转向过度现象。 汽车在起步或加速时，整车重量会向后轮转移，如果后轮是驱动轮，无疑它的起步或加速性能会更好些。同时，前轮负担较轻，在紧急制动时，不致产生车头下沉、 后轮悬空的现象。 后置后驱（RR）有什么特点？ 后置后驱是指将发动机放在后轴的后部，并采用后轮驱动（Rear engine Rear wheel drive，简称RR）。\nRR车的重量大多集中于后方，又是后轮驱动，所以起步、加速性能在所有驱动形式中是最好的。因此，超级跑车一般都采用RR方式。 RR的转弯性能比FF和FR更加敏锐，但后轴承受较大负荷，因此后轮的抓地力达到极限时，易出现打滑甩尾现象，且不容易控制。 RR的另一特点，就是车头较轻，所以开始进入转弯时，较容易造成转向过度的现象。 后置后驱示意图\n后置后驱汽车构造图\n中置后驱（MR）有什么特点？ 中置后驱示意图\n后中置后驱汽车构造图\n中置后驱是指发动机放在驾乘室与后轴之间，并采用后轮驱动（后中置后驱），或发动机放在前轴后面并用后轮驱动（前中置后驱）。其英文是Middle engine Rear wheel drive，简称MR。\n它的最大特点，就是将车辆中惯性最大的、沉重的发动机置于车体的中央，这是使MR车获得最佳运动性能的最主要保证。 MR兼具FF、FR的优点，转向灵敏准确，制动时不会出现头沉尾翘的现象。 MR有一个先天毛病：直线稳定性较差。为解决这一问题，所有MR汽车的后轮尺寸均比前轮大。 第二个缺点是车厢太窄，一般只能有两个座位。 另外，由于驾乘人员离发动机太近，因此噪声较大。 前轮驱动和后轮驱动哪个更好？ 前轮驱动（Front Wheel Drive，简称FWD）相当于发动机在前面“拉”着汽车前进，而后轮驱动（Rear Wheel Drive，简称RWD）相当于从后面推着汽车前进。 “拉”和“推”的不同方式，造成驱动力对汽车的作用点不同，从而使汽车在行驶中具有不同的行驶特性。\n前轮驱动的优势\nFWD汽车的直线行驶性较好 动力传递效率高 FWD结构较RWD紧凑，部件少，一般可减轻质量25～40千克，因此比同级别的RWD汽车更省油 一般说来，F W D汽车的车内空间利用好 前轮驱动的劣势\n发动机、变速器、差速器、转向系统等都放置在车辆前部，使车辆的前部要比后部重得多 当汽车起步和加速时，汽车的重心后移，使前轮的附着力减少，如果急加速就很容易造成前轮打滑，使汽车不能很快地起步和加速 制动时由于重心前移，加上前部重量较大，很容易使汽车在制动时点头，从而降低舒适性。 在过弯时，前轮既承担驱动力，也承担转向力。 如果在弯道中加速或减速，也就是改变驱动力的大小，就会影响转向力的发挥，从而会使汽车的转向特性发生变化。 如果在弯道中急加速，就可能使驱动力突破前轮的附着力，从而使转向力为零，此时汽车便不再转向，而是直直地往弯道外侧冲去，也就是发生转向不足现象，俗 称“推头”。 后轮驱动的优势\n由于发动机可纵向放置在车头，可允许较窄的前轮距和较低的发动机罩，以减小风阻，获得较佳的空气动力性能。另外，由于各总成较分散并独立，从组装到维修保 养都比较方便。 与F W D汽车相比，RWD汽车加速时还可获得更大的驱动力。 R W D汽车的前轮负责转向，后轮负责驱动，可保证车辆拥有充分的转向力。 R W D汽车具有较灵活的转向特性，并且更容易实现前后50∶50的配重比，因此驾驶乐趣更强。 后轮驱动的劣势\nR W D汽车对驾驶技术要求更高 与F W D汽车相比，RWD汽车要增加一些部件，从而导致车重增加。另外，它的动力传递路线较长，也比较曲折，因此动力传递效率也不如FWD汽车高，这都可能造 成RWD汽车的油耗稍高。 四轮驱动可以前拉后推 四轮驱动汽车最大的特点，是将原本集中在两个车轮上的驱动力分摊给四个车轮，即使有部分车轮打滑，汽车仍有车轮存在驱动力，可以帮助汽车摆脱困境。\n四驱汽车构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E5%8A%A8%E7%B3%BB%E7%BB%9F/5.01/","summary":"汽车都有哪些传动形式？ 前置发动机、前轮驱动车型（F F），对车内空间安排比较有利，发动机、变速器、传动机构都整合在车头部位，甚至都在前车轴上方","title":"5.1 传动形式 Drive Type"},{"content":"变速器档位数的多少对汽车性能有什么影响？ 对于汽车来说，变速器的档位数较多，那么汽车加速时更顺畅、省力，加速时的顿挫感也较小，舒适性会更好，同时也更省油。如果有级变速器相当于上楼梯台阶，那 么无级变速器就相当于乘坐滚梯了，可以没有台阶地一路斜上，没有顿挫感，非常顺畅，而且更省劲，也更省油了。\n福特双离合变速器\n手动变速器构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.11/","summary":"变速器档位数的多少对汽车性能有什么影响？ 对于汽车来说，变速器的档位数较多，那么汽车加速时更顺畅、省力，加速时的顿挫感也较小，舒适性会更好，同","title":"4.11 变速器档位数"},{"content":"自动离合变速器是怎样变速的？ 自动离合变速器是在手动变速器的基础上加装一套自动换档装置，它可以替代驾驶人进行离合器分离及更换档位的动作。它的基本变速结构和手动变速器是一样的，但 它可以利用电子控制单元收集驾驶人的操作信息和车辆运行信息，指挥电子液压机构来操纵离合器和换档拨叉，从而实现自动换档。\n这类在手动变速器的基础上改进而来的变速器简称为AMT（Automated Manual Transmission），也称半自动变速器等。\n雪铁龙电控自动离合变速器构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.10/","summary":"自动离合变速器是怎样变速的？ 自动离合变速器是在手动变速器的基础上加装一套自动换档装置，它可以替代驾驶人进行离合器分离及更换档位的动作。它的基","title":"4.10 自动离合变速器（AMT）"},{"content":"序列式变速器是怎样变速的？ 序列式变速器简称为SMG（Sequential Manual Gearbox），全称为序列式手动变速器。\n序列式变速器（SMG）构造图\n序列式变速器（SMG）构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.09/","summary":"序列式变速器是怎样变速的？ 序列式变速器简称为SMG（Sequential Manual Gearbox），全称为序列式手动变速器。 序列式变速器（SMG）构","title":"4.9 序列式变速器（SMG）"},{"content":"双离合变速器是怎样变速的？ 双离合变速器（Double Clutch Transmission，简称DCT）是从手动变速器进化而来的，它的变速结构和原理与手动变速器一样，只不过比手动变速器多了一个 离合器，因此称为双离合变速器。或者说，双离合变速器相当于把两个手动变速器整合在一起，交替传递动力。\n雷诺汽车双离合变速器原理示意图\n大众汽车6速双离合变速器\n双离合变速器\n奥迪汽车7速双离合变速器原理示意图\n大众汽车6速双离合变速器原理示意图\n双离合变速器\n奥迪汽车7速双离合变速器构造图（正在3档工作状态）\n奥迪7速双离合变速器\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.08/","summary":"双离合变速器是怎样变速的？ 双离合变速器（Double Clutch Transmission，简称DCT）是从手动变速器进化而来的，它的变速结构和原理与手","title":"4.8 双离合变速器（DCT）"},{"content":"5.2.1 使用HTTP link首部推送 nginx\n例子来源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 server { listen 443 ssl http2 default_server; ssl_certificate ssl/certificate.pem; ssl_certificate_key ssl/key.pem; root /var/www/html; http2_push_preload on; location = /demo.html { add_header Set-Cookie \u0026#34;session=1\u0026#34;; add_header Link $resources; } } map $http_cookie $resources { \u0026#34;~*session=1\u0026#34; \u0026#34;\u0026#34;; default \u0026#34;\u0026lt;/style.css\u0026gt;; as=style; rel=preload, \u0026lt;/image1.jpg\u0026gt;; as=image; rel=preload, \u0026lt;/image2.jpg\u0026gt;; as=image; rel=preload\u0026#34;; } rel=preload属性来指示Web服务器，要将这个资源推送过去 as=style部分（指示资源的类型）是可选的。这个as属性可以用来决定优先级 preload HTTP首部和HTTP/2推送\nhttp/2之前, 这个首部允许浏览器直接获取资源，不用等着下载、读取、解析整个页面之后才决定是否下载另一个资源。 HTTP/2的实现重新修改了preload link首部的使用目的，实现服务端推送 如果想使用原来的preload方式，但不让服务器推送资源，通常可以使用nopush属性 通常只有HTTP首部支持HTTP/2推送。HTTP/2推送通常忽略HTML中的标签，因为对于服务器来说，解析HTML并提取这些首部，比从HTTP首部中获取这些信息要复杂 得多，也要花更多时间。\n5.2.2 查看HTTP/2推送 图5.6　在Chrome开发者工具Network标签中查看HTTP/2推送的资源\n图5.7　与图5.6中一样的页面加载，但是没有服务端推送\n图5.8　在WebPagetest中的一个推送资源\n使用nghttp发送Web请求\n在连接之后，使用SETTINGS和PRIORITY帧完成连接设置。nghttp2使用HEADERS帧发出页面请求\n在收到返回的页面之前，会收到一个PUSH_PROMISE帧。需要注意的是，nghttp先展示收到帧的内容，然后才是帧的详情：\n有点疑惑, 客户端发送HEADERS帧(stream_id=13)请求页面, 为啥返回的PUSH_PROMISE帧还是用stream_id=13\n猜测是因为h2是1对多模型, 1个请求可以有多个响应, 这些响应处于同一流中\nPUSH_PROMISE帧和浏览器在请求资源时发送的HEADERS帧类似，但有两点区别\n这个帧由服务端发送到客户端，而不是由客户端发送到服务端。 它包含一个promised_stream_id，代表所要推送资源的流ID，表明要推送的资源将要通过流2发送。服务端发起的流ID（当前只用以推送）是偶数。 在这之后，服务器返回开始时请求的资源(stream_id=13)，使用HEADERS帧，后面跟着DATA帧。然后服务器在stream_id=2上推送资源，使用一个HEADERS帧， 后面跟着DATA帧\n5.2.3 使用link首部从下游系统推送 图5.9　在HTTP/2下，从下游的应用服务器推送link首部\n图5.10　使用link首部从后端应用服务器推送资源\n创建一个简单的node服务，使用HTTP/1.1\nhtml中的link只是表示渲染页面时需要common.css, 重点在setHeader中.\n该页面在HEAD标签中引用一个样式表（通过link首部引用这个样式表）。在另外一个窗口中使用curl来查看结果：\n图5.11　在link首部中引用的资源下游系统可以推送\nWeb服务器不能给其他域名推送资源\n5.2.4 更早推送 Chrome开发者工具中不显示未使用到的推送资源如果被页面用到，推送的资源会在Chrome开发者工具Network标签页中显示。预加载器会使用preload提示\n图5.12　加载后端处理时间较长的网页\n图5.13　更早推送以尽量利用可能被浪费的时间\n修改这个简单的NodeJS服务来模拟延迟\n如果再次使用nghttp来调用这段代码的服务，然后使用grep过滤输出，只显示recv frame相关的行，你会看到，在连接建立之后有一个10 s的延迟，直到 PUSH_PROMISE帧被发送（对应前面代码中的10 s的sleep）\n如果改变Apache的推送配置，使用H2PushResource而不是等待link首部，则推送会直接发生，不需要10 s的延迟，因为要推送的资源不再被主资源所阻塞\n也就是说应用程序添加link首部会导致类似队头阻塞问题, 所以nginx中的http2_push_preload应该是指示nginx提前推送.\n所以nginx应该记住哪些资源提前推送了?\n使用Web服务器的更早推送指令（如H2PushResource）的缺点是，你不能再使用应用来发起这些推送\n为了解决这个问题，有了一个新的HTTP状态码——103 Early Hints, 其允许通过preload HTTP link首部来提前指示是否需要一个资源。 在HTTP/1.1中，这个代码看起来像是两个请求挨着\n图5.14　使用状态码103告诉Web服务器更早推送资源\n在nghttp中，场景可能看起来像这样\nhttp 103为啥也返回给了客户端, 之前以为是103是给nginx看的.\n书中提到:\nApache支持处理103响应，它会处理其中的link首部来推送资源，但是它故意不将103响应发送给浏览器，因为一些浏览器不支持这些响应，可能会发生错误。\n对103状态码的支持比较少还有一个原因，它需要在一个请求中发送多个响应。\n5.2.5 使用其他方式推送 应用服务器自己也可以使用http/2推送\n需要在全链路上支持推送吗\n需要考虑客户端, 中间代理, 应用服务对http/2的支持情况 HTTP/2规范声明：中间节点可以从服务端接收推送的资源，并选择不将它们推送到客户端。换句话说，如何利用推送的信息取决于中间节点。同样，中间节点可以 选择向客户端推送额外的资源，而不需要后端服务器做任何操作。 实际上，让边缘节点服务器使用HTTP link首部（用不用103 Early Hints均可）来处理推送逻辑会更简单。 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.2/","summary":"5.2.1 使用HTTP link首部推送 nginx 例子来源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 server { listen 443 ssl http2 default_server; ssl_certificate ssl/certificate.pem; ssl_certificate_key ssl/key.pem; root /var/www/html; http2_push_preload on; location = /demo.html { add_header Set-Cookie \u0026#34;session=1\u0026#34;; add_header Link $resources; } } map $http_cookie $resources {","title":"5.2 如何推送"},{"content":"HTTP/2服务端推送（以下称为HTTP/2推送）允许服务器发回客户端未请求的额外资源。\nHTTP/2多路复用技术允许在同一连接上并行请求所有资源，因为这样排队会减少，所以它优于HTTP/1。 如果没有HTTP/2推送，浏览器必须在下载初始页面之后才能请求这些关键的资源。 图5.1　关键资源需要一个额外的请求往返(http/1)\n图5.2　关键资源的往返延迟瀑布图(http/1)\n这个往返延迟催生了一些性能优化手段，如将样式通过\u0026lt;style\u0026gt;标签内联到HTML页面中，或类似的，通过\u0026lt;script\u0026gt;标签将JavasScript内联到HTML中。通过 内联这些关键资源，浏览器可以在原始页面下载解析之后马上开始渲染，而不需要等待附加的关键资源。\n内联资源有几个缺点\n需要将关键CSS提取出来防止页面过大, 但是该操作比较复杂, 也有可能造成重复代码 要求使用JavaScript来加载非关键CSS文件 变更困难(重复的地方都要改) 图5.3　使用HTTP/2推送可以避免关键资源的往返延迟\n服务器岂不是解析html才能发送被关联资源?\n图5.4　使用HTTP/2推送在一个往返中接收所有请求的瀑布图\n图5.5　一个基本的网页请求流，不使用HTTP/2推送（左边）和使用HTTP/2推送（右边）的情况\n如果使用方法正确，HTTP/2推送可以减少加载时间。但如果你多推送了资源（客户端不需要，或者已经在缓存里），则将会延长加载时间。所以，在使用HTTP/2推送 时应该小心，经过考虑后再使用。\nHTTP/2推送是否能替代WebSockets或者SSE\n诸如WebSockets和服务器发送事件（SSE）之类的技术真正允许双向流，HTTP/2中不是真正的双向流，一切都仍然是从客户端请求发起的。按照HTTP/2推送现在的 规范，它不是WebSockets或SSE的替代品，但如果以后它进一步扩展的话，也许有替代它们的机会\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.1/","summary":"HTTP/2服务端推送（以下称为HTTP/2推送）允许服务器发回客户端未请求的额外资源。 HTTP/2多路复用技术允许在同一连接上并行请求所有","title":"5.1 什么是HTTP/2服务端推送"},{"content":"4.3.1 查看HTTP/2帧 使用Chrome net-export\n抓包chrome://net-export 查看日志 https://netlog-viewer.appspot.com/#import 图4.7　在Chrome中查看HTTP/2帧\n以下输出来自一个SETTINGS帧：\n使用nghttp\n使用Wireshark\n需要告诉Wireshark HTTPS密钥 对于macOS，设置SSLKEYLOGFILE环境变量 或者直接作为命令行参数提供 在Wireshark中加载密钥 图4.8　设置Wireshark HTTPS密钥文件\n图4.9　Wireshark中显示的HTTP/2魔法字符串\n图4.10　Wireshark中的ClientHello消息中的ALPN扩展\n4.3.2 HTTP/2帧数据格式 每个HTTP/2帧由一个固定长度的头部和不定长度的负载组成。\n表4.1　HTTP/2帧头部格式\nStream Identifier, 将此字段限制为31位的其中一个原因是考虑到Java的兼容性，因为它没有32位无符号整数 4.3.3 HTTP/2消息流示例 可以使用-n参数来隐藏数据，仅显示帧头部：\n首先，通过HTTPS（h2）协商建立HTTP/2连接。nghttp不输出HTTPS建立过程和HTTP/2前奏/“魔术”消息，因此我们首先看到SETTINGS帧： SETTINGS帧 SETTINGS帧（0x4）是服务器和客户端必须发送的第一个帧（在HTTP/2前奏/“魔术”消息之后）。该帧不包含数据，或只包含若干键/值对\n表4.2　SETTINGS帧格式\n规范中的Value是默认值, 顺序与Identifier对应, e.g. 0x1-\u0026gt;4096.\n再回头看第一个消息\n收到的SETTINGS帧有30个8位字节数据，没有设置标志位（因此不是确认帧），使用的流ID为0。流ID 0是保留数字，用于控制消息（SETTINGS和 WINDOW_UPDATE帧），所以服务器使用流ID 0发送此SETTINGS帧是合理的。\n在此示例中有5个设置项（niv=5），每个设置项长度为16位（标识符）+32位（值）。也就是说，每项设置有48位即6字节\n查看接下来的3个SETTINGS帧 nghttp接收初始服务器SETTINGS帧（刚讨论过），然后，客户端发送带有几个设置项的SETTINGS帧。接下来，客户端确认服务器的SETTINGS帧。确认SETTINGS 帧非常简单，只有一个ACK（0x01）标志，长度为0，因此只有0设置（niv=0）。再接下来是服务器确认客户端的SETTINGS帧，格式同样简单。\nWINDOW_UPDATE帧 WINDOW_UPDATE帧（0x8）用于流量控制，比如限制发送数据的数量，防止接收端处理不完。在HTTP/1下，同时只能有一个请求。如果客户端无法及时处理数据，它 会停止处理TCP数据包，然后TCP流量控制（类似HTTP/2流量控制）开始工作，降低发送数据的流量，直到接收方可以正常处理为止。在HTTP/2下，在同一个连接上 有多个流，所以不能依赖TCP流量控制，必须自己实现针对每个流的减速方法。\n表4.3　WINDOW_UPDATE帧格式\nWINDOW_UPDATE帧未定义标志位，该设置用于给定的流，如果流ID指定为0，则应用于整个HTTP/2连接。发送方必须跟踪每个流和整个连接。\n如果流ID指定为0中的流ID应该是帧首部中的Stream Identifier.\nHTTP/2流量控制设置仅应用于DATA帧，所有其他类型的帧（至少目前定义的），就算超出了窗口大小的限制也可以继续发送。这个特性可以防止重要的控制消息（比 如WINDOW_UPDATE帧自己）被较大的DATA帧阻塞。同时DATA帧也是唯一可以为任意大小的帧。\nPRIORITY帧 通过dep_stream_id，它将其他流悬挂在开始时创建的流之下(该流依赖dep_stream_id所指定的流)。使用之前创建的流的优先级，可以方便地对请求进行优先级 排序，无须为每个后续新创建的流明确指定优先级。并非所有HTTP/2客户端都给流预定义优先级\n表4.4　PRIORITY帧格式\nPRIORITY帧（0x2）长度固定，没有定义标志位。\nHEADERS帧 一个HTTP/2请求以HEADERS帧开始发送（0x1）\nHTTP/2定义了新的伪首部（以冒号开始），以定义HTTP请求中的不同部分：\n:authority伪首部代替了原来HTTP/1.1的Host首部 HTTP/2伪首部定义严格，不像标准的HTTP首部那样可以在其中添加新的自定义首部 不能这样创建新的伪首部\n:barry: value 如果应用需要，还得用普通的HTTP首部，没有开头的冒号\nbarry: value 可以依照新的规范来创建新的伪首部\n在Bootstrapping WebSockets with HTTP/2 RFC中添加:protocol伪首部。应用新的伪首部需要使用新的SETTINGS参数，也需要客户端和服务端的支持。 可以在客户端工具中查看这些伪首部，它们表明正在使用HTTP/2请求 图4.11　Chrome开发者工具中的伪首部\nHTTP/2强制将HTTP首部名称小写, HTTP首部的值可以包含不同的大小写字母\nHTTP/2对HTTP首部的格式要求也更严格。开头的空格、双冒号或者换行，在HTTP/2中都会带来问题 当客户端发现首部格式不正确时，报错信息通常含义不明（比如Chrome中的ERR_SPDY_PROTOCOL_ERROR） 表4.5　HEADERS帧格式\n添加Pad Length和Padding字段是出于安全原因，用以隐藏真实的消息长度。 Header Block Fragment（首部块片段）字段包含所有的首部（和伪首部）。这个字段不是纯文本的，不像nghttp里所显示的那样。(首部压缩了) HEADERS首部定义了4个标志位\nEND_STREAM(0x1)，如果当前HEADERS帧后面没有其他帧（比如POST请求，后面会跟DATA帧），设置此标志。有点违反直觉的是，CONTINUATION帧不受此限 制，它们由END_HEADERS标志控制，被当作HEADERS帧的延续，而不是额外的帧。 END_HEADERS（0x4），它表明所有的HTTP首部都已经包含在此帧中，后面没有CONTINUATION帧了。 PADDED(0x8)，当使用数据填充时设置此标志位。这个标志表明，DATA帧的前8位代表HEADERS帧中填充的内容长度。 PRIORITY(0x20)，表明在帧中设置了E、Stream Dependency和Weight字段。 如果HTTP首部尺寸超出一个帧的容量，则需要使用一个CONTINUATION帧（紧接着是一个HEADERS帧），而不是使用另外一个HEADERS帧。\n这个过程相较于HTTP正文来说好像过于复杂，HTTP正文会使用多个DATA帧。因为表4.5中的其他字段只能使用一次，所以如果同一个请求有多个HEADERS帧，并 且它们的其他字段值不同，就会带来一些问题。 要求CONTINUATION帧紧跟在HEADERS帧后面，其中不能插入其他帧，这影响了HTTP/2的多路复用，人们正考虑其他替代方案。 实际上CONTINUATION帧很少使用，大多数请求都不会超出一个HEADERS帧的容量。 再回头看这些日志输出\n每个新的请求都会被分配一个独立的流ID，其值在上一个流ID的基础上自增（在这个示例中上一个流ID是11，它是nghttp创建的PRIORITY帧，所以这个帧使用 流ID13创建，偶数12是服务端使用的）。 同时设置了多个标志位，组合起来的十六进制数为0x25 其中的END_STREAM（0x1）和END_HEADERS（0x4）标志位说明，当前帧包含完整的请求，没有DATA帧（可能用于POST请求）。 PRIORITY标志位（0x20）表明，此帧使用了优先级策略。 将这些十六进制数加起来（0x1 + 0x4 + 0x20），结果是0x25，在帧首部中显示。 这个流依赖流11，所以被分配了对应的优先级，权重为16。 nghttp的注释说，这个流是新建的（Open new stream）， 然后列出了多个HTTP伪首部和HTTP请求首部 HTTP响应在同一个流上也使用HEADERS帧发送\n作者也提到了nghttp将HEADERS帧首部放到帧详情之后是一个疑惑点.\n尾随首部 HTTP/1.1引入了尾随首部的概念，可以在正文之后发送它。这些首部可以支持不能提前计算的信息。例如，在以流的形式传输数据时，内容的校验和或者数字签名可 以包含在尾随首部中。\n实际上，尾随首部的支持很差，很少应用。但是HTTP/2决定继续支持它，所以一个HEADERS帧（或者一个后跟CONTINUATION帧的HEADERS帧）可能出现在流 的DATA帧之前或者之后。\nDATA帧 表4.6　DATA帧格式\nDATA帧定义了两个标志位\nEND_STREAM(0x1)，当前帧是流中的最后一个。 PADDED(0x8)，当使用数据填充时设置此标志位。这个标志表明，DATA帧的前8位代表HEADERS帧中填充的内容长度。 GOAWAY帧 用于关闭连接，当连接上没有更多的消息，或发生了严重错误时使用该帧。\n表4.7　GOAWAY帧格式\n查看之前nghttp输出日志中最后的消息，会看到一个GOAWAY帧的示例\n当响应被处理，并且客户端不再等待更多的数据时，它会发送这个帧来关闭HTTP/2连接。Web浏览器可能会保持连接打开，以供后续的请求使用。\n4.3.4 其他帧 CONTINUATION帧 太大的首部需要使用CONTINUATION帧（0x9），它紧跟在HEADERS帧或者PUSH_PROMISE帧后面。因为在请求可以被处理之前，需要完整的HTTP首部，并且为了应 用HPACK的字典，所以CONTINUATION帧必须紧跟在HEADERS帧后面。\n这种要求降低了HTTP/2的多路复用性 很少被用到 表4.8　CONTINUATION帧格式\nCONTINUATION帧只定义了一个标志位\nEND_HEADERS（0x4），当设置这个标志的时候，表明HTTP首部内容到此帧结束，后续没有别的CONTINUATION帧了。 PING帧 PING帧（0x6）用以计算发送方的消息往返时间，也可以用来保持一个不使用的连接。当收到这类帧的时候，接收方应当马上回复一个类似的PING帧。两个PING帧都 应当在控制流（流ID为0）上发送。\n表4.9　PING帧格式\nPING帧定义了一个可以在通用帧首部中使用的标志位\nACK（0x1）标志位，在发起方的PING帧中不设置，在返回方中需要设置。 PUSH_PROMISE帧 服务器使用PUSH_PROMISE帧（0x5）通知客户端它将推送一个客户端没有明确请求的资源。PUSH_PROMISE帧需要提供将要向其推送资源的客户端信息，所以它包含 通常在HEADERS帧中包含的那些首部信息（同样，如果要推送的资源首部比较大，则它后面也可能会跟一个CONTINUATION帧）。\n表4.10　PUSH_PROMISE帧格式\nPUSH_PROMISE帧定义了两个标志位\nEND_HEADERS（0x4），它表明所有的HTTP首部都已经包含在此帧中，后面没有CONTINUATION帧了。 PADDED(0x8)，当使用数据填充时设置此标志位。这个标志表明，DATA帧的前8位代表PUSH_PROMISE帧中填充的内容长度。 RST_STREAM帧 用于直接取消（重置）一个流。该取消可能是由于一个错误，或者是因为请求已经不需要进行了。可能是客户端已经跳转到其他页面、取消了加载，或者不再需要服务 器推送的资源了。\nHTTP/1.1不提供这种功能。如果你正在下载页面上一个较大的资源，除非中断连接，否则就算跳转到其他页面，这个资源的下载也不会停止。 表4.11　RST_STREAM帧格式\nALTSVC帧 其允许服务端宣告获取资源时可用的其他服务。这个帧可以用来进行升级（比如从h2升级到h2c）或者重定义流量到另外一个版本。\n表4.12　ALTSVC帧格式\nORIGIN帧 服务器使用它来宣告自己可以处理哪些源（比如域名）的请求。当客户端决定是否合并HTTP/2连接的时候，该帧非常有用。\n该帧可以包含多组Origin-Len/Origin。 CACHE_DIGEST帧 客户端可以使用这个帧来表明自己缓存了哪些资源。例如，它指示服务器不必再推送这些资源，因为客户端已经有了。\n表4.14　CACHE_DIGEST帧格式\nCACHE_DIGEST帧定义了如下标志位\nRESET(0x1)，客户端用来告诉服务器重置当前保存的CACHE_DIGEST信息。 COMPLETE(0x2)，表明当前包含的缓存摘要代表所有的缓存，而不是缓存的一部分。 总结 HTTP/2是一个二进制协议，其消息有明确的、精细的格式和结构。 由于这个原因，客户端和服务端在发送HTTP消息之前必须协商都使用HTTP/2。 对于Web浏览器，这个协商的过程主要在HTTPS连接协商中完成，使用一个新的叫ALPN的扩展。 在HTTP/2中，请求和响应通过HTTP/2帧的形式传输。 一个HTTP/2 GET请求，通常以HEADERS帧的形式发送，接收的响应通常是一个HEADERS帧，跟着一个DATA帧。 大多数Web开发者和Web服务器管理员，不需要关心HTTP/2帧的细节，尽管可以使用工具查看这些帧。 当前有几种HTTP/2帧，以后还会添加新的帧。 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC4%E7%AB%A0-http2%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/4.3/","summary":"4.3.1 查看HTTP/2帧 使用Chrome net-export 抓包chrome://net-export 查看日志 https://netlog-viewer.appspot.com/#import 图4.7 在Chrome中查看HTTP/2帧 以下输出","title":"4.3 HTTP/2帧"},{"content":" 使用HTTPS协商。 使用HTTP Upgrade首部。 和之前的连接保持一致。 理论上，HTTP/2支持基于未加密的HTTP（也就是h2c）创建连接，也支持基于加密的HTTPS（即h2）创建连接。实际上，所有的Web浏览器仅支持基于HTTPS（h2） 建立HTTP/2连接，所以浏览器使用第一个方法来协商HTTP/2。服务器之间的HTTP/2连接可以基于未加密的HTTP（h2c）或者HTTPS（h2）。\n4.2.1 使用HTTPS协商 HTTPS需要经过一个协议协商阶段来建立连接，在建立连接并交换HTTP消息之前，它们需要协商SSL/TLS协议、加密的密码，以及其他的设置。这个过程比较灵活， 可以引入新的HTTPS协议和密码，只要客户端和服务端都支持就行。在HTTPS握手的过程中，可以同时完成HTTP/2协商，这就不需要在建立连接时增加一次跳转。\nHTTPS握手\n公钥私钥加密被称为非对称加密, 但它比较慢，所以这种加密方式用于协商一个对称加密的密钥，以便在创建连接之后使用对称密钥加密消息。\n图4.4　HTTPS握手 (TLSv1.2, 与TLSv1.3略微不同)\n握手过程涉及4类消息：\n客户端发送一个ClientHello消息，用于详细说明自己的加密能力。不加密此消息，因为加密方法还没有达成一致。 服务器返回一个SeverHello消息，用于选择客户端所支持的HTTPS协议（如TLSv1.2）。基于客户端在ClientHello中声明的密码，和服务器本身支持的密码， 服务器返回此连接的加密密码（如ECDHE-RSA-AES128-GCM-SHA256）。 之后提供服务端HTTPS证书（ServerCertificate）。 然后是基于所选密码加密的密钥信息（ServerKeyExchange） 以及是否需要客户端发送客户端证书（CertificateRequest，大多数网站不需要）的说明。 最后，服务端宣告本步骤结束（ServerHelloDone）。 客户端校验服务端证书，如果需要发送客户端证书（ClientCertificate，大多数网站不需要）。 然后发送密钥信息（ClientKeyExchange）。这些信息通过服务端证书中的公钥加密，所以只有服务端可以通过密钥解密消息。 如果使用客户端证书，则会发送一个CertificateVerify消息，此消息使用私钥签名，以证明客户端对证书的拥有权。 客户端使用ServerKeyExchange和ClientKeyExchange信息来定义一个加密过的对称加密密钥，然后发送一个ChangeCipherSpec消息通知服务端加密开 始 最后发送一个Finished消息。 配置客户端证书需要私钥吗?\n服务端也切换到加密连接上（ChangeCipherSpec），然后发送一个加密过的Finished消息。 当HTTPS会话建立完成后，在同一个连接上的HTTP消息就不再需要这个协商过程了。类似地，后续的连接（不管是并发的额外连接，还是后来重新打开的连接）可以 跳过其中的某些步骤 —— 如果它复用上次的加密密钥，这个过程就叫作TLS会话恢复。\nTLSv1.3可以将协商过程中的消息往返减少到1个（如果复用之前的协商结果，则可以降到0个）\nALPN\nALPN给ClientHello和ServerHello消息添加了功能扩展，客户端可以用它来声明应用层协议支持（“嗨，我支持h2和http/1，你用哪个都行。”），服务端 可以用它来确认在HTTPS协商之后所使用的应用层协议（“好的，我们用h2吧”）。\n图4.5　使用ALPN的HTTPS握手\nNPN\n在使用NPN时，客户端决定最终使用的协议，而在使用ALPN时，服务端决定最终使用的协议。\n图4.6　使用NPN的HTTPS握手\n现在不再推荐使用NPN，应该使用ALPN。\n使用ALPN进行HTTPS握手的示例(curl)\n4.2.2 使用HTTP Upgrade首部 通过发送Upgrade首部，客户端可以请求将现有的HTTP/1.1连接升级为HTTP/2。这个首部应该只用于未加密的HTTP连接（h2c）。基于加密的HTTPS连接的 HTTP/2（h2）不得使用此方法进行HTTP/2协商，它必须使用ALPN。我们已经说过多次，Web浏览器只支持基于加密连接的HTTP/2，所以它们不会使用这个方法。\n示例1：一个不成功的Upgrade请求\n客户端支持并想要使用HTTP/2，发送一个带Upgrade首部的请求：\n这样的请求必须包含一个HTTP2-Settings首部，它是一个Base-64编码的HTTP/2 SETTINGS帧\n不支持HTTP/2的服务器可以像之前一样返回一个HTTP/1.1消息，就像Upgrade首部没有发送一样：\n示例2：一个成功的Upgrade请求\n支持HTTP/2的服务器可以返回一个HTTP/1.1 101响应以表明它将切换协议，而不是忽略升级请求，并返回HTTP/1.1 200响应：\n然后服务器直接切换到HTTP/2，发送SETTINGS帧（见4.3.3节），之后以HTTP/2格式发送响应。\n示例3：服务端请求的升级\n当客户端认为服务器不支持HTTP/2时，它会发送不带Upgrade的请求：\n一个支持HTTP/2的服务端可以返回一个200响应，但是在响应首部中添加Upgrade来说明自己支持HTTP/2。这个时候，它是一个升级建议，而不是升级请求，因为只 有客户端才发起升级请求。\n如下是一个服务端宣告支持h2（基于HTTPS的HTTP/2）和h2c（基于纯文本的HTTP/2）的示例：\n客户端可以利用这个信息来完成协议升级，并在下一个请求中发送一个Upgrade首部\n发送Upgrade首部的问题\n由于所有的浏览器都只支持基于HTTPS的HTTP/2，因此这个Upgrade方法可能永远不会被浏览器使用，这会带来问题。\n应用服务器可能会发送一个Upgrade首部，帮助升级到HTTP/2以提升性能。反向代理Web服务器可能会透传这个首部。浏览器会收到升级建议，并决定升级。但是 与客户端直接连接的这个反向代理Web服务器并不支持HTTP/2。 在类似的场景中，可能反向代理已经和Web浏览器使用HTTP/2交互，但使用HTTP/1.1将请求代理到后端应用服务器。应用服务器可能会发出升级建议，如果其被反 向代理透传，浏览器就会困惑，因为当前已经使用HTTP/2通信了，服务端还在建议升级到HTTP/2。 4.2.3 使用先验知识 有不同的方法可以让客户端事先知道服务器是否支持HTTP/2。如果你使用反向代理来卸载HTTPS，则可能会通过基于纯文本的HTTP/2（h2c）与后端服务器通信，因 为你知道它们支持HTTP/2。或者，可以根据Alt-Svc首部（HTTP/1.1）或ALTSVC帧（参见4.3.4节）推断先前的连接信息。\n4.2.4 HTTP Alternative Services 第4种方法是使用HTTP Alternative Services（替代服务），它没有被包含在原来的标准中，在HTTP/2发布之后，将其列为单独的标准。此标准允许服务器使用 HTTP/1.1协议（通过Alt-Svc HTTP首部）通知客户端，它所请求的资源在另一个位置（例如，另一个IP或端口），可以使用不同的协议访问它们。该协议可以使用 先验知识启用HTTP/2。\n4.2.5 HTTP/2前奏消息 不管使用哪种方法启用HTTP/2连接，在HTTP/2连接上发送的第一个消息必须是HTTP/2连接前奏，或者说是“魔法”字符串。此消息是客户端在HTTP/2连接上发送的 第一个消息。它是一个24个八位字节的序列，以十六进制表示法显示如下：\n这个序列被转换为ASCII字符串后如下所示：\n这个无意义的看起来像HTTP/1样式的消息，目的是兼容，客户端向不支持HTTP/2的服务端发送HTTP/2消息的情况。然后服务器会尝试解析此消息，就像收到其他 HTTP消息时一样。因为它无法识别这个无意义的方法（PRI）和HTTP版本（HTTP/2.0），所以解析会失败，从而拒绝此消息。注意，此消息前奏是官方规范中唯一一 处使用HTTP/2.0的地方，在其他地方都是HTTP/2，正如4.1节中所讨论的。而对于支持HTTP/2的服务器，可以根据这个收到的前奏消息推断出客户端支持HTTP/2， 它不会拒绝这个神奇的消息，它必须发送SETTINGS帧作为其第一条消息（可以为空）。\n为什么是PRI和SM\n在早期的草稿中，HTTP/2规范中的消息前奏使用FOO和BAR或者BA表示，它们是编程中常见的占位符。但是在规范草稿的第4个版本中，这个占位符变成了PRI SM， 但是没有说为什么。\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC4%E7%AB%A0-http2%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/4.2/","summary":"使用HTTPS协商。 使用HTTP Upgrade首部。 和之前的连接保持一致。 理论上，HTTP/2支持基于未加密的HTTP（也就是h2c）创建连","title":"4.2 如何创建一个HTTP/2连接"},{"content":"新版本的协议与原来的协议有很大的不同，新增了如下概念：\n二进制协议 多路复用 流量控制功能 数据流优先级 首部压缩 服务端推送 HTTP/1.0的Web服务器可以支持HTTP/1.1的消息，并可以忽略后来的版本中新增的功能，但在HTTP/2中，就不能兼容了，HTTP/2使用了不同的数据结构和格式。 出于这个原因，HTTP/2被视为主版本更新。\nHTTP/2.0还是HTTP/2\nHTTP/2定义了新版本HTTP的主要部分（二进制、多路复用等），并且未来的任何实现或变更（如果有HTTP/2.1的话），此规范都兼容。 所以小版本号不太重要.\n此外，与HTTP/1消息不同，在HTTP/2请求中未明确声明版本号。 例如，HTTP/2中没有GET /index.html HTTP/1.1形式的请求。 但是，许多实现会在日志文件中使用次要版本号（.0）。例如，在Apache日志文件中，版本号显示为HTTP/2.0，其甚至会伪造HTTP/1形式的请求 4.1.1 使用二进制格式替换文本格式 使用基于文本的协议，要先发完请求，并接收完响应之后，才能开始下一个请求。\nHTTP的小改进\nHTTP/1.0引入了二进制的HTTP消息体，支持在响应中发送图片或其他媒体文件。 HTTP/1.1引入了管道化和分块编码。 都有队头阻塞（HOL）的问题——在队列首部的消息会阻塞后面消息的发送，更不用说，管道化在实际应用中并没有得到很好的支持。 4.1.2 多路复用代替同步请求 HTTP/1是一种同步的、独占的请求-响应协议。HTTP/1的主要解决方法是打开多个连接，并且使用资源合并以减少请求数，但这两种解决方法都会引入其他的问题和 带来性能开销。\n图4.1　并发多个HTTP/1请求，需要多个TCP连接\nHTTP/2允许在单个连接上同时执行多个请求，每个HTTP请求或响应使用不同的流。通过使用二进制分帧层，给每个帧分配一个流标识符，以支持同时发出多个独立请 求。当接收到该流的所有帧时，接收方可以将帧组合成完整消息。\n图4.2　使用多路复用技术的HTTP/2连接请求三个资源\nHTTP/2连接在请求发出后不需要阻塞到响应返回 服务器发送响应的顺序完全取决于服务器，但客户端可以指定优先级。 每个请求都有一个新的、自增的流ID（如图4.2中所示的流5、7和9）。返回响应时使用相同的流ID 响应完成后，流会被丢弃而且不能重用 为了防止流ID冲突，客户端发起的请求使用奇数流ID, 服务器发起的请求使用偶数流ID。 请注意，在写作本书时，从技术上讲服务器不能新建一个流，除非是特殊情况（服务端推送，但也要客户端先发起请求） ID为0的流（图中未显示出）是客户端和服务器用于管理连接的控制流。 小结\nHTTP/2使用多个二进制帧发送HTTP请求和响应，使用单个TCP连接，以流的方式多路复用。 HTTP/2与HTTP/1的不同主要在消息发送的层面上，在更上层，HTTP的核心概念不变。例如，请求包含一个方法（例如GET）、想要获取的资源 （例如/styles.css）、首部、正文、状态码（例如200、404）、缓存、Cookie等，这些都与HTTP/1保持一致。 图4.3　HTTP/2中的流和HTTP/1中的连接相似\n4.1.3 流的优先级和流量控制 现在HTTP/2对并发的请求数量的限制放宽了很多（在许多实现中，默认情况下允许同时存在100个活跃的流），因此许多请求不再需要浏览器来排队，可以立即发送它 们。这可能导致带宽浪费在较低优先级的资源（例如图像）上，从而导致在HTTP/2下页面的加载速度变慢。所以需要控制流的优先级，使用更高的优先级发送最关键 的资源。\n流的优先级控制是通过这种方式实现的：当数据帧在排队时，服务器会给高优先级的请求发送更多的帧。\n流量控制是在同一个连接上使用多个流的另一种方式。如果接收方处理消息的速度慢于发送方，就会存在积压，需要将数据放入缓冲区。而当缓冲区满时会导致丢包， 需要重新发送。在连接层，TCP支持限流，但HTTP/2要在流的层面实现流量控制。\n4.1.4 首部压缩 HTTP首部（包括请求首部和响应首部）用于发送与请求和响应相关的额外信息。在这些首部中，有很多信息是重复的，多个资源使用的首部经常相同。\nCookie User-Agent Host Accept Accept-Encoding 4.1.5 服务端推送 HTTP/2添加了服务端推送的概念，它允许服务端给一个请求返回多个响应。\nHTTP/2服务端推送是HTTP协议中的新概念，如果使用不当，它很容易浪费带宽。浏览器并不需要推送的资源，特别是，在之前已经请求过的服务器推送的资源，放在 浏览器缓存中。决定什么时候推送、如何推送，是充分利用服务端推送的关键。\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC4%E7%AB%A0-http2%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/4.1/","summary":"新版本的协议与原来的协议有很大的不同，新增了如下概念： 二进制协议 多路复用 流量控制功能 数据流优先级 首部压缩 服务端推送 HTTP/1.0的Web服","title":"4.1 为什么是HTTP/2而不是HTTP/1.2"},{"content":"3.1 HTTP/2的支持 你能否在网站上使用新的网络技术，主要取决于三点：\n浏览器是否支持这项技术？ 你的基础设施是否支持？ 如果这项技术未获得支持，是否有健壮的回退机制？ 3.1.1 浏览器对HTTP/2的支持 图3.1　caniuse.com中的HTTP/2数据\n图3.2　caniuse.com中的HTTP/2数据，Usage Relative视图\n浏览器对HTTP/2和HTTPS的支持\n在前面的图中，每个支持HTTP/2的浏览器都有一个小2作为备注，底部有“仅支持基于TLS的HTTP2（https）”的说明，因此不使用HTTPS的网站无法从HTTP/2中受 益。SPDY也有类似的限制，当HTTP/2被标准化时，人们也对此限制进行了大篇幅的讨论，许多参与方都要求强制将HTTPS作为规范的一部分。后来，这个要求被排除 在HTTP/2的正式规范之外，但是所有浏览器厂商都表示，他们将仅支持基于HTTPS的HTTP/2，这使其成为事实上的标准。要求支持HTTPS无疑会使仅支持HTTP 网站的站长不开心，但这种要求有两个很好的理由。\n第一个理由纯粹从实用方面考虑。仅通过HTTPS使用HTTP/2意味着不太可能出现兼容性问题。网上许多基于HTTP的基础设施，在升级之前不知道如何处理HTTP/2 消息。在HTTPS中包装消息，可以隐藏HTTP消息本身，从而避免兼容性问题。 第二个理由比较主观。许多浏览器厂商（和其他人，包括我）坚信，要远离未加密的HTTP，所有网站都应该转向HTTPS。因此，较新的功能通常仅支持HTTPS，以 鼓励人们切换为HTTPS。 即使你的网站支持了HTTPS，仍可能遇到问题。\n一些浏览器（如Chrome、Firefox和Opera）上的备注4意味着“只有服务器支持ALPN，其才支持HTTP2。 许多浏览器在使用HTTP/2之前需要更新为更安全的密码套件。 中间代理\n为了能够使用HTTP/2，浏览器和服务器都必须支持HTTP/2。但是，如果用户使用代理，把一个HTTP连接变成两个，且这个代理不支持HTTP/2，那HTTP/2还是不能 启用。\n查看计算机是否使用代理的最简单方法，是查看HTTPS证书，看看它是由谁颁发的，由真正的证书颁发机构颁发（有很多证书颁发机构，所以可能弄不清楚）还是由本 地软件颁发。\n图3.3　查看直接连接Google和通过反病毒产品连接Google时的HTTPS证书\n浏览器对HTTP/2支持情况的总结\n有几个情况可能导致无法使用HTTP/2，如服务端HTTPS设置不匹配，在使用拦截代理等。 对HTTPS的要求，尤其对ALPN的要求，使得启用HTTP/2变得更复杂了，会引起疑惑。这里的复杂性主要体现在，要求服务器正确设置 论。网络正朝着HTTPS大步迈进，未加密的HTTP网站受到的惩罚将继续增加，会有更明显的警告，新功能更少。 evergreen浏览器\n一些浏览器（如Chrome和Firefox）会在后台静默更新，不提示用户，我们称之为evergreen浏览器。这些浏览器的用户可能运行的是最新版本的浏览器，它们支持 HTTP/2。\n3.1.2 服务器对HTTP/2的支持 HTTPS库及其对HTTP/2的支持\nChrome和Opera仅支持基于ALPN的HTTP/2，而不支持NPN（Next Protocol Negotiation，下一代协议协商）。与之前的NPN一样，ALPN允许Web服务器在 HTTPS协商的过程中，声明服务器支持哪些应用程序协议；\n问题是ALPN仅包含在最新版本的OpenSSL（1.0.2及更高版本）中，在很多标准版本中并没有包含。 表3.1　不同的Linux系统对ALPN的支持\n服务端支持总结\n3.1.3 兼容不支持HTTP/2的情况 当客户端不支持HTTP/2时，网站仍然能正常工作，因为它们可以降级到HTTP/1.1。HTTP/1.1距离被废弃（如果会的话）还很遥远。从理论上讲，如果可能，应该启 用HTTP/2，因为并没有客户端不支持的问题。\n3.2 网站开启HTTP/2的方法 3.2.1 在Web服务器上开启HTTP/2 图3.4　Web服务器上的HTTP/2\n表3.2　流行的Web服务器开始支持HTTP/2的版本\n3.2.2 反向代理实现HTTP/2 图3.5　通过反向代理实现HTTP/2\n反向代理很常见，主要用于以下两种场景：\n作为负载均衡器 用以卸载一些功能，如HTTPS或者HTTP/2 图3.6　反向代理负载均衡\n是否需要在整个链路中支持HTTP/2\nHTTP/2的主要优点是可以提升高延迟、低带宽连接的速度，连接到边缘服务器（在这种情况下为反向代理）的用户通常处在这样的网络环境下。从反向代理到其他Web 基础架构的流量一般处于低延迟、高带宽、短距离的网络环境中（即使不是同一台机器，也通常是相同的数据中心），因此此场景下通常不需要考虑HTTP/1.1的性能 问题。\n如果反向代理到实际服务器的连接使用HTTP/2，则采用HTTP/2单个连接的方式收益也不高。因为反向代理到服务器的连接数不受限于浏览器设置的6个连接。甚至有 些人担心使用单个连接可能会导致性能问题，具体取决于在反向代理和目标服务器上的实现方式。Nginx已经声明，它不会为代理连接实现HTTP/2，所以也有这 方面原因。\n图3.7　在应用服务器/数据库服务器之前使用Web服务器\n图3.8　添加临时的反向代理，来测试HTTP/2\n3.2.3 通过CDN实现HTTP/2 大多数CDN已经支持HTTP/2了，所以你可以通过使用CDN的方式来启用HTTP/2，而源站只需要支持HTTP/1.1就行了。这个方法和使用反向代理类似，但是CDN有很 多反向代理服务器，它们可以帮你管理这个基础架构。\n图3.9　通过CDN启用HTTP/2\n3.2.4 小结 3.3 常见问题 表3.3　常见TLS库对ALPN的支持\n总结 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC1%E9%83%A8%E5%88%86-%E5%90%91http2%E9%9D%A0%E6%8B%A2/%E7%AC%AC3%E7%AB%A0-%E5%8D%87%E7%BA%A7%E5%88%B0http2/","summary":"3.1 HTTP/2的支持 你能否在网站上使用新的网络技术，主要取决于三点： 浏览器是否支持这项技术？ 你的基础设施是否支持？ 如果这项技术未获得支持，是","title":"第3章 升级到HTTP/2"},{"content":" 1 $ git config --global pager.branch false 执行git branch的结果将直接输出, 而不是输出到类似 more 命令的界面.\n可以利用自动补全查看pager.*下其他可配置东西.\n","permalink":"https://jdxj.github.io/posts/cmd/git/%E7%9B%B4%E6%8E%A5%E5%B1%95%E7%A4%BA%E7%BB%93%E6%9E%9C%E5%88%B0%E7%BB%88%E7%AB%AF%E8%80%8C%E4%B8%8D%E6%98%AFpager/","summary":"要不还得按\u003ccode\u003eq\u003c/code\u003e退出","title":"直接展示结果到终端而不是pager"},{"content":"无级变速器如何实现无级变速的？ 无级变速器的主要部件是两个滑轮和一条金属带，金属带套在两个滑轮上。\n无级变速器\n奥迪无级变速器工作原理示意图\n无级变速器视频\n无级变速器变速原理示意图\n奥迪无级变速器构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.07/","summary":"无级变速器如何实现无级变速的？ 无级变速器的主要部件是两个滑轮和一条金属带，金属带套在两个滑轮上。 无级变速器 奥迪无级变速器工作原理示意图 无级变","title":"4.7 无级变速器（CVT）"},{"content":"自动变速器是怎样利用行星齿轮变速的？ 自动变速器由两大部分组成：一是前面介绍的液力变矩器；二是下面要介绍的行星齿轮变速系统。\n从发动机输出的动力，经液力变矩器后，就会传递到变速结构。这个变速结构虽然也是利用齿轮组合来调节传动比，但它和手动变速器采用普通齿轮的方式截然不同， 而是采用行星齿轮机构，利用行星齿轮机构的特点调节出不同的传动比。\n所谓行星齿轮，是指有自转和公转的齿轮结构。中间的齿轮就像是太阳，只能自转；其周围的小齿轮则像是行星，可以围绕中间的太阳轮进行公转。当将太阳轮或行星 齿轮中的某一种齿轮固定不动时，就会变化出不同的传动比来，包括反转，从而可以输出不同的转速和转矩。\n行星齿轮是怎样实现变速的？ 自动变速器中的行星齿轮机构共有三种齿轮：中间的大齿轮称为太阳轮，黄色的小齿轮称为行星齿轮，最外面的齿圈称为环齿轮。这三种齿轮在进行变速时，分别作为 固定齿轮、主动齿轮和从动齿轮，根据不同的任务分配，就可变换出不同的传动比。\n环齿轮固定：太阳齿轮为主动齿轮，行星轮为从动齿轮，或相反。 行星齿轮固定：太阳齿轮为主动齿轮，环齿轮为从动齿轮，或相反。 太阳齿轮固定：环齿轮为主动齿轮，行星齿轮为从动齿轮，或相反。 自动变速器构造图\n自动变速器\n锁止离合器起什么作用？ 当液力变矩器传递动力时，由于它采用液压油作为传递介质，不是刚性传递，其间大约有10%的能量损失，这对节能降耗很不利，也会影响操控性。为了解决这个问题， 在液力变矩器和飞轮之间设置了一个单向锁止离合器，当车速较高时，用电控的方式起动此离合器，将液力变矩器的输入轴和输出轴锁止在一起，实现刚性直接传递动 力。也就是从发动机曲轴输出的动力，不需经过液力变矩器而直接传递到变速机构，从而提高传动效率。\n采埃孚9速自动变速器\n自动变速器最多档位数是多少？ 自从自动变速器被发明以来，它的前进档位数一直在增长，从最初发明时的3速，已增加到现在最多9速自动变速器，如奔驰、路虎和吉普等就有采用9速自动变速器的 车型。现在，8速自动变速器主要配备在宝马和奥迪等车型上，而7速自动变速器仅在奔驰老款车型上还有使用。现在，市场上主流的还是6速自动变速器，使用5速自动 变速器的越来越少，而使用4速自动变速器就非常落后了。\n奔驰9G-TRONIC PLUS 9速自动变速器 Continuous Variable Transmission\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.06/","summary":"自动变速器是怎样利用行星齿轮变速的？ 自动变速器由两大部分组成：一是前面介绍的液力变矩器；二是下面要介绍的行星齿轮变速系统。 从发动机输出的动力","title":"4.6 行星齿轮变速系统"},{"content":"液力变矩器是怎样工作的？ 液力变矩器主要由三个“轮”组成：泵轮、导轮和涡轮。在三个轮之间充满了液压油。泵轮与发动机曲轴相连，当发动机旋转时，泵轮便会随之旋转，并搅动液压油，将 其“甩向”与后面变速机构相连的涡轮，使涡轮旋转，从而将动力传向后面的变速机构，最终传递到车轮。固定不动的导轮的作用是增大传递转矩。\n液力变矩器\n奥迪A8轿车8速自动变速器\n液力变矩器构造示意图 Planetary Gear Transmission System\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.05/","summary":"液力变矩器是怎样工作的？ 液力变矩器主要由三个“轮”组成：泵轮、导轮和涡轮。在三个轮之间充满了液压油。泵轮与发动机曲轴相连，当发动机旋转时，泵","title":"4.5 液力变矩器 Hydraulic Torque Converter"},{"content":"奥迪汽车6速自动变速器构造示意图\n为什么自动变速器没有离合器？ 自动变速器组成: 液力变矩器、控制器、电磁控制机构、多片离合器和行星齿轮等\n液力变矩器的作用相当于手动档汽车上的离合器。其原理类似两个对吹的电风扇，当一个电扇通电旋转后，另一个电扇也会被吹得随之旋转。对吹电扇传递动力的介质 是空气，而液力变矩器传递动力的介质是油液。通过控制油液的流动状态，就可以控制动力和转速输出的大小。\n液力变矩器的原理类似两个对吹的电风扇，它们通过介质可以传递动力，起到离合器传递动力的作用\n液力变矩器\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.04/","summary":"奥迪汽车6速自动变速器构造示意图 为什么自动变速器没有离合器？ 自动变速器组成: 液力变矩器、控制器、电磁控制机构、多片离合器和行星齿轮等 液力变矩","title":"4.4 自动变速器（AT）Automatic Transmission"},{"content":"为什么手动变速器需要同步器？ 在手动变速器上，所有档位的主动齿轮和从动齿轮副都一直处于啮合状态并持续旋转，但只有一个档位的齿轮副与动力输出轴相接合。当我们操纵变速杆换档时，其实 是更换与动力输出轴接合的齿轮副。\n在与新的齿轮副接合时，由于动力输出轴基本保持原来上个档位的旋转速度，它与新的齿轮副之间的转速有差别，这样在与新齿轮副接合时就会产生一定的速度差，而 不同转速的部件硬性接合时就会产生冲击，损坏齿轮。\n为了避免换档时的冲击，使换档更加顺畅，手动变速器中都设有几个同步器。利用同步器的特殊性能，可以减少换档冲击。\n老式的汽车变速器上没有同步器，为了减少换档冲击，换档时必须采取“两脚离合”的方法：升档时在空档位置稍停顿一下，降档时在空档位置稍踩下加速踏板，以减少 齿轮之间的转速差。\n手动变速器原理示意图\n手动变速器构造图\n同步器是怎样工作的？ 同步器也称为犬牙啮合套，因为它在与档位齿轮接合时如同犬牙一样相互交错在一起。如图所示，当向左推动同步器时，同步器上的同步环就与档位齿轮上的接合齿圈 犬牙交错在一起。同步器毂与动力输出轴是接合在一起的，这样就可以使档位齿轮与动力输出轴接合在一起，从而达到变速的目的。\n同步器与档位齿轮接合示意图\n单件式同步器构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.03/","summary":"为什么手动变速器需要同步器？ 在手动变速器上，所有档位的主动齿轮和从动齿轮副都一直处于啮合状态并持续旋转，但只有一个档位的齿轮副与动力输出轴相","title":"4.3 同步器 Synchronizer"},{"content":"手动变速器\n手动变速器是怎样变速的？ 当离合器接合时，不管是在空档还是在任何档位，变速器中每个档位的主动齿轮（红色齿轮）以及每个档位的从动齿轮（蓝色部分）始终啮合在一起，并按照各自的转 速不停地旋转。但是，在空档时，各个档位的所有从动齿轮并没有和输出轴连接，此时输出轴是静止不转的。\n当挂上1档或其他前进档位时，实际上是将1档或其他档位的从动齿轮通过同步器（或称犬牙啮合套）和输出轴接合起来共同旋转。当变换档位时，则是换成新档位的从 动齿轮来与输出轴接合并共同旋转。\n5速手动变速器原理示意图\n倒档的主动齿轮和从动齿轮之间“夹”了一个中间轮，这样就可使输出轴的旋转方向与其他档位相反。\n4速手动变速器构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.02/","summary":"手动变速器 手动变速器是怎样变速的？ 当离合器接合时，不管是在空档还是在任何档位，变速器中每个档位的主动齿轮（红色齿轮）以及每个档位的从动齿轮（","title":"4.2 手动变速器 (MT) Manual Transmission"},{"content":"为什么汽车需要变速器？ 自行车变速原理示意图\n当主动链轮的直径和转速固定不变时，从动链轮越小，从动链轮的转速也会越高，输出的转矩也会越小；反之亦然\n汽车也是一样，发动机的转速非常高，但输出的转矩非常有限。起步时，不需要较大的车速，但需要较大的转矩，因此在起步阶段最好是让汽车低速、大转矩平稳运行； 在车速提高后，就不需要太大的转矩，而需要较高的车速。变速器的作用就如同自行车的变速齿轮，可以由驾驶人根据行驶情况来调节发动机输出的转速和转矩，从而 使汽车顺利地起步、爬坡和快速行驶等。\n什么是齿轮传动比？ 齿轮传动比简称齿比，是指主动齿轮与被动齿轮的角转速之比，也等于被动齿轮与主动齿轮的齿数之比。变速器的每个档位齿轮组合，都有一个与其他档位不同的传动 比。档位越低，其传动比越大；档位越高，其传动比越小。\n变速器各档位传动比值示例\n为什么变速器中要使用很多齿轮？ 一对相互啮合的齿轮，直径较小的齿轮以较小的力旋转，那么在较大齿轮上就会获得更大的力，但作为获得较大力的代价，大齿轮的转速则会相应降低。或者说，相互 啮合的一对齿轮，直径越大或齿数越多的齿轮，它的转速越低，转矩越大；转速越高，则转矩越小。\n齿轮变速原理示意图\n利用齿轮原理，可以将较大的转速转变为较小的转速，也可以将较小的转速转变为较大的转速\n齿轮放大转矩原理示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.01/","summary":"为什么汽车需要变速器？ 自行车变速原理示意图 当主动链轮的直径和转速固定不变时，从动链轮越小，从动链轮的转速也会越高，输出的转矩也会越小；反之亦","title":"4.1 变速原理 Transmission Principle"},{"content":"1.1　负债概述 银行负债业务的主要目标就是给银行提供放贷用的资金。\n现代银行的业务模式和我们日常生活中的个人借贷不同，平时我们借钱给亲戚朋友是用我们自有的资金，而银行放贷的资金只有很少一部分是自有的，多数是从个人或 机构吸纳或拆借过来的。\n银行本身重要的职能之一就是从社会上吸收闲散资金并贷给需要资金周转的企业或个人。\n考察一家银行的负债业务是优秀还是平庸，最重要的指标就是负债成本。负债成本包含两部分：\n直接成本是指银行全部计息负债的综合利率，用综合利率乘以计息负债就可以得到一家银行的利息支出。 间接成本是指银行为了获取足够多的负债需要投入多少营运费用，包括网点租金、人工薪酬、设备采购费等。 9家典型的大中型银行2017年年报中的负债数据为例进行分析。其中，按照营运费用由负债业务和资产业务各占一半的标准来计算负债的间接成本。\n表1.1　2017年9家典型银行的负债成本\n注：表中负债利率并非精确数据，因此负债总额乘以利率计算得出的利息与表中利息支出有误差。 第一大阵营是四大行（指工、农、中、建四大国有商业银行，下同）。\n四大行的负债成本如此之低，一个重要的原因就是过去几十年开设的遍布全国各地的网点。虽然电子银行、手机银行等金融科技的发展正在逐渐抵消四大行的网点优势， 但是“瘦死的骆驼比马大”，在未来十年内，股份行（指股份制商业银行，下同）都不可能在负债成本优势上赶超四大行。\n第二大阵营就是“浦民兴平”这四家股份行。\n间接成本除了最近开始搞零售的平安银行稍高外，其他几家的间接成本甚至比四大行还要低。这主要是因为这几家股份行都是以对公业务为主，负债结构中零售客户的 负债占比较低。\n对私业务少, 营运费用少.\n招商银行（以下简称“招行”）\n招行的直接负债成本略高于四大行，但是又远低于其他股份行，间接负债成本是表中所有银行中最高的。这和招行“服务高端人群”的战略定位有一定的相关性。\n考察负债能力的另一个指标就是流动性覆盖率。\n这一指标能够反映银行在未来30天内是否有足够多的流动性资金来应对资金流出的压力。这一指标是从2014年开始推行的，并要求逐年提高达标线，2018年以后需 要高于100%。 这一指标的本质是压缩银行利用期限错配进行套利的空间，降低了这种操作带来的流动性风险。 期限错配是什么？\n期限错配在金融行业的表现是资金来源短期化、资金运用长期化。银行的资金成本和资产收益一般和时间周期正相关，久期越长的资金，其成本或者收益率也就越高。 这一模式正常运行的前提条件是：短期负债到期后可以续借，一旦负债不能续借或者利率大幅上行，就会产生流动性风险或利率倒挂。 流动性覆盖率=合格优质流动性资产／未来30天现金净流出量。 可用现金是未来30天流出现金的多少倍.\n为了提高流动性覆盖率，要么做高分子，要么降低分母。\n做高分子需要增加商业银行对高流动性优质资产如国债、政策金融债等利率债的持有，同时降低对二级资产如同业存单、一般工商企业债等的配置。 降低分母则意味着商业银行主动控制现金净流出，即寻求长期负债来替代短期负债、寻求稳定性较高负债（存款等）替代流动性较高负债（同业负债等）。 1.2 存款业务 1.2.1 存款的分类 按照存期划分\n活期存款 定期存款, 定期存款还可以按照久期的不同分为3个月、6个月、1年、2年、3年、5年等 另外有一些比较特殊的存款，包括：通知存款、协议存款和结构化存款等。 通知存款\n通知存款本身是介于活期和定期之间的一种无固定期限的存款，存款人必须预先通知银行方能提取。在我国常见的是1天通知存款和7天通知存款。通知存款按日计息， 利率视通知期限长短而定，一般高于活期、低于定期存款。\n协议存款\n协议存款是银行与其他机构法人或法人授权机构，通过签订协议约定存放利率，办理的一定期限、一定金额以上的存款业务。由于机构法人掌握的资金量大，所以谈判 的筹码就多一些。最终机构能够拿到的协议存款利率远高于银行给出的普通存款利率，而且除此之外可以得到很多流动性的支持。\n错误认识\n很多人认为储户购买了某宝或者某货币基金，银行吸收的存款就减少了。这是一个明显的误解，储户将存款转化为某宝或者某货币基金的时候，实际上是钱从个人存款 科目转移到了公司存款或者同业存款科目。所以，银行业总体的存款不会减少，只是负债的成本可能会上升。类似地，购买股票或者购买国债也都不会减少存款总量， 只是存款从一个个体转移到另一个个体或者机构账户上。\n结构化存款\n结构化存款是一种将存款和金融衍生品相结合的产品。结构化存款通常可以保本，利息可以有保底利息，也可以没有保底利息，但是一般最高可能的收益率会远远高于 普通存款的收益率。具体的产品设计大概是这样的：当用户购买了结构化存款后，银行实际上是把吸纳的资金存了定期，然后通过把定期存款应得的利息用于买入一种 衍生品，比如黄金看多期货或者黄金看空期货，如果压中了正确的衍生品，那么从衍生品获得的额外收入就会计入对客户的利息。\n按照客户性质划分\n对公存款, 就是企业的存款。由于企业的流动性需求比较大，所以，对公存款的活期占比较高，且相对稳定。 零售存款, 就是个人存款 对公贷款的派生存款: 公司向银行贷款, 但是没用完, 暂时又放到银行进行存款\n1.2.2 如何评估银行吸收存款的能力 银行吸收存款的能力主要考察两个方面：数量和质量\n所谓数量就是吸收存款的绝对数量和相对增速, 可以比较较长一段时间的存款增长率 所谓质量就是银行吸收存款的直接成本, 可以横向对比不同银行的存款成本。 表1.2　2008—2017年主要银行存款增速\n虽然股份行的存款增速远高于四大行，但是存款成本高\n表1.3　主要银行的存款成本（%）\n为什么招行的零售存款活期占比那么高?\n看完书上讲的和招行零售AUM突破10万亿意味着什么这篇文章, 我的理解是: 招行以AUM为目标, 在这 过程中会吸引大量需要流动性的资金且不用提高利率, 而以存款为目标的其他银行为获得更多存款提高利率, 从而使存款成本变高.\n感觉是降维打击了.\n1.2.3 和存款相关的指标 衡量货币流动性的指标\nM0=流通中现金，指银行体系以外各个单位和居民持有的现金之和。 M0反映的是流通中的现金量，是最狭义上的货币供应量，也是央行直接发行的钞票扣除银行留存的现金后剩余的部分。 M1=M0+企业在银行的活期存款+机关团体的存款+农村存款。 M1又称为狭义货币供应量，它反映了社会的直接购买力。 M1和社会商品供应量之间需要保持相对稳定，如果M1增幅大幅超越商品供应量的增幅，就会带来经济过热，反之就会带来萧条。 M2=M1+企业的定期存款+个人的储蓄存款+证券客户的保证金。 M2又叫作广义货币供应量，它反映了经济中的现实和潜在购买力。 如果M1增速大幅高过M2，则表明需求强劲，投资不足，存在通货膨胀的风险； 如果M2增速过高、M1增速过低，表明投资过热，需求不旺，可能有资产泡沫。 在这组指标中，M2和银行的关系最大。这是因为在整个货币体系中，M0的量是非常小的，以2018年8月央行披露的数据为例：M0共计7.06万亿元，M1有53.83万亿 元，M2则有178.87万亿元。M2基本上约等于银行体系内存款的数量，也就约等于银行的资产负债表规模。所以， M2的增速也就可以近似看成银行的存款增速和资产规模的增速。\n银行的资产规模增长因子和息差因子共同决定了占银行收入大头的净利息收入的增速，而最近两年一直在谈的金融降杠杆，说的就是要降低M2的增速。也就是说，在 “降杠杆”的经济环境，银行规模增长的因子下降是无法避免的。\n存款准备金：控制货币供给的“蓄水池”\n存款准备金是指金融机构为保证客户提取存款和资金清算需要而准备的资金，是缴存在中央银行的存款，中央银行要求的存款准备金占其存款总额的比例就是存款准备 金率。\n这些存款当中有多少不能动.\n行发放给企业的贷款通常会重新存放在银行形成派生存款。在极端情况下，一笔存款可以派生无限量的贷款和存款，这样会造成M2激增, 这肯定是央行无法容忍的。 所以，央行说：“不行，你们每吸收100份存款，就要缴存若干份到央行作为准备金。”那么在极限状态，一笔存款可以派生的总存款为(存款准备金率设为12%)\n1+0.88+0.88^2+…=（1-0.88^n）/（1-0.88）≈1/0.12≈8.33（倍） 可以看到存款准备金相当于一个控制广义货币的蓄水池。\n当市场流动性泛滥时，央行通过提升存款准备金率(增大分母)来收紧流动性； 而当流动性紧张的时候，央行通过降低存款准备金率(减小分母)来释放流动性。 存贷比：审视银行盈利水平的指标\n“存贷比”其实应该被称为“贷存比”，是银行贷款总额与存款总额的比率。 如果一家银行的存款很多、贷款很少，就意味着它成本高、收入少，银行的盈利能力就较差。 存贷比这个指标实际上已经不是强制性指标了 如果存贷比很高，实际上也反映了银行的存款增长乏力，无法支持银行资产负债表的扩张。这是因为存款不够的时候只能通过同业拆借和向央行拆借来满足负债需 求，而同业拆借的成本和央行借款的成本远高于存款的成本，过多使用拆借负债会显著压低银行的净息差。 1.3 同业负债 从本质上说，同业负债就是金融同业机构间的负债关系，传统的资金端通常以回购、拆借、同业存款的形式建立同业债权。\n对于不同的银行来说，同业负债的作用完全不同。有的银行是把同业负债作为一种短期资金调配方式或者被动负债，而有的银行则是把同业负债作为扩张资产负债表的 武器。银行的态度不同，其同业负债的占比和成本等都会有极大的差别。\n表1.4　不同银行的同业负债特点\n同业负债主要包括同业和其他金融机构存放、同业拆入和卖出回购。\n其中，同业和其他金融机构存放的占比是最大的；而卖出回购是最神秘的，相对也是占比最少的。 同业存放相对来说是比较少的，是指各银行为了方便结算，在各自有关的结算单位开立存款账户，这部分资金和资产表中的存放同业正好是相反的资金流向。 由于这部分资金要求的流动性很高，所以无论是同业存放还是存放同业的利率都是很低的 其他金融机构存放的这部分就有很大差别了。其他金融机构存放之中，有的是其他金融机构在这家银行存放的结算资金，比如：基金公司在托管银行存放的赎回备兑 金等；有的则是其他金融机构冲着高利率放过来的协议存款，比如：银行高息吃入余额宝的协议存款。因此， 不同银行在同业负债上的差异主要体现在其他金融机构存放上。 同业存放和存放同业的区别\n同业拆借, 又称同业拆放市场，是金融机构之间进行短期、临时性头寸调剂的市场。 这个市场产生的最主要原因是我国实行的存款准备金制度。每天银行间市场收市的时候，央行会冻结这部分存款准备金。 央行的存款准备金率远低于其他资产的收益率，所以，没有银行愿意在央行放太多的钱。 但是，由于银行每日的存款余额和汇兑情况都在发生变化，这就造成了有的银行手头资金富余，有的不足以交够存款准备金。那么，资金富余的银行就可以将手头 的闲置资金拆借给缺乏资金的银行。 但需要注意的是，这种拆借资金的权属并没有发生改变，也就是说在约定期限到期后，这些拆借资金必须还给拆出方。 这个和下面要介绍的卖出回购金融资产最大的不同就是拆借没有资产抵押，完全是建立在信用的基础上。 卖出回购资产回款，是同业负债中占比最小的，也是普通投资者接触最少的。 它是指银行将一些债券、股票等资产卖给其他银行，并约定好在什么时间以什么价格回购这些资产。 通常来讲，回购的总金额会高于银行卖出资产获得的资金总额，其中的差值就是卖方支付给买方的利息。 在这个交易过程中，两家银行更像是一种借贷关系，而用来交易的资产可以看作一种抵押物。 同业负债相比存款稳定性较差。同业负债有一定流动性风险，因为同业存放和同业拆借都是短期负债。同业市场本身也有其存在的重要意义, 可以通过同业业务实现资 本合理配置，从而实现“双赢”。\n1.4 同业存单 同业存单是存款类金融机构在全国银行间市场上发行的记账式定期存款凭证。\n同业存单就是一家金融机构向另一家花钱（本金+利息）买存款。 它并不是一直存在的，其实它是在2013年下半年才开始在银行间试行的，是应对利率市场化的一个重要步骤。 同业存单的期限不超过1年，一般可分为1个月、3个月、6个月、9个月和1年。 同业拆借的目的是调剂存款准备金的缺口，通常是短期的，参考的是Shibor利率 而同业存单的目的是补偿负债的缺口，通常是中长期的，参考国债利率。 谁缺钱谁发行.\n同业存单的计息方式有两种：固定利率和浮动利率。一般固定利率是在发行的时候约定一个利率，在兑付的时候按照原先约定的利率进行利息兑付；浮动利率则是按照 Shibor加点的方式计息。\n同业存单，本身在会计科目上一般被计入银行负债表中的“应付债券”。虽然应付债券中也包含其他的负债，但是，同业存单应该是应付债券中的大头。同业存单本身都 是零息债券，所谓零息债券又叫作贴息债券。\n同业存单对于四大行和股份行的作用完全不同。在市场上，国有四大行通常拥有较好的存款基础，所以愿意作为同业存单的买入行；而股份行多数存款不足，所以经常 作为同业存单的发行银行。同业存单的利率实际上形成了银行间中长期资金拆借的利率，能够间接反映银行间的流动性。\n通常在流动性充裕的时候，同业存单利率走低； 在流动性紧张的时候，同业存单利率走高。 表1.5　2018年6月股份银行同业存单发行情况\n表1.6　2018年7月股份银行同业存单发行情况\n同业存单的优势是不需要为其建立相应的网络和基础设施，就可以获取大量的负债，这种优势对于网点较少的股份行非常有诱惑力。通过同业存单拿到负债就意味着不 用像吸储那样付出附加成本（网点营运费用、员工工资等），而且负债规模可以快速扩张。\n但是，同业存单也有其自身的问题。同业存单是所有负债中对流动性最敏感的。如果碰见市场流动性突然紧缩，就很容易出现利差损甚至是拆借不到资金的情况。 同业存单对于银行股的投资者来说具有非凡的意义。因为各家银行发行同业存单的情况是在特定的网站上每天公布的，这样投资者通过查询每天发行的同业存单利率、 金额和久期，就可以评估银行间的流动性松紧情况，同时可以根据同业存单的利率水平推测其他同业负债的利率变化趋势。\n由于股份行中多数同业负债占比较高，所以通过同业存单的数据，可以对这些股份行的息差进行预测。同业存单是少数可以实时窥测银行负债利率和数量变化趋势的工 具，所以，致力于银行基本面研究的读者，绝对不能放过对同业存单这个负债品种的监测。\n1.5 央行借款 向央行借款的途径\n在早期一般情况下，商业银行向中央银行的借款只能用于调剂头寸、补充储蓄的不足和资产的应急调整，而不能用于贷款和证券投资。但是，随着这几年各种流动性政 策调节工具的丰富，向央行借款也可以投向特定的信贷领域。\n因此，在向央行借款的负债科目下，包括三大类：再贷款、再贴现和其他流动性政策工具。\n再贷款是早期我国商业银行向中央银行借款的主要形式，一方面是早期国内商业票据信用市场尚不完善；另一方面是在商业银行改制前，商业银行对于央行资金的依 赖度较高。我国中央银行的再贷款有年度性贷款、季节性贷款和日拆性贷款三种，分别应对商业银行不同周期的头寸调节需求。 再贴现是近些年随着商业票据市场的发展而逐步发展起来的，而且在未来会逐步取代再贷款。所谓再贴现就是商业银行把未到期的已贴现票据作为抵押物向央行进行 再贴现，本质上就是商业银行通过票据债权转让，从央行进行再贷款。 结构性货币政策工具\n从2013年开始，央行开始推出多种结构性货币政策工具，用以调节银行间的流动性。这些工具多数以国债、央行票据等高等级信用票据为质押品，期限从7天到1年不 等。这些工具主要包括：SLF、MLF、TMLF、SLO、PSL、TLF等。央行利用这些工具在公开市场上拿钱买卖有价证券，来调节货币供应量和利率。\n表1.7　货币政策工具概览\n","permalink":"https://jdxj.github.io/posts/books/%E7%9C%8B%E9%80%8F%E9%93%B6%E8%A1%8C-%E6%8A%95%E8%B5%84%E9%93%B6%E8%A1%8C%E8%82%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC1%E7%AB%A0-%E9%93%B6%E8%A1%8C%E7%9A%84%E8%B4%9F%E5%80%BA%E4%B8%9A%E5%8A%A1/","summary":"1.1 负债概述 银行负债业务的主要目标就是给银行提供放贷用的资金。 现代银行的业务模式和我们日常生活中的个人借贷不同，平时我们借钱给亲戚朋友是用我们","title":"第1章 银行的负债业务"},{"content":"跳过\n","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC10%E7%AB%A0-%E5%85%B8%E5%9E%8B%E6%B6%88%E8%B4%B9%E5%93%81%E4%BC%81%E4%B8%9A%E8%B4%A2%E6%8A%A5%E5%88%86%E6%9E%90/","summary":"跳过","title":"第10章 典型消费品企业财报分析"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/httparchive/","summary":"主页","title":"http archive"},{"content":"转子发动机是怎样产生动力的？ 现在所说的转子发动机，是指德国工程师菲利克斯·汪克尔在20世纪50年代设计的三角形活塞式转子发动机。因此，转子发动机也被称为汪克尔发动机。\n转子发动机的主要部件结构简单，体积小，功率大，高速时运转平稳，性能较好，曾引起汽车行业的关注，纷纷进行研制试验。但是，经过几十年的试验证明， 这种机型尚无法与传统往复活塞式发动机相媲美，其边缘磨损严重，油耗较高。\n马自达RX-8跑车转子发动机\n转子发动机工作行程示意图\n转子发动机 转子发动机\n往复式四行程发动机工作原理示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.19/","summary":"转子发动机是怎样产生动力的？ 现在所说的转子发动机，是指德国工程师菲利克斯·汪克尔在20世纪50年代设计的三角形活塞式转子发动机。因此，转子发","title":"3.19 转子发动机 Rotary Engine"},{"content":"奔驰V6柴油发动机构造图\n柴油发动机\n为什么柴油发动机没有点火系统？ 柴油发动机是一种压燃式内燃机，是以柴油为燃料的内燃机。柴油发动机利用气体被压缩后温度会上升的原理，用活塞压缩进入气缸的空气；当空气温度上升到 柴油燃点温度时，用喷油器将柴油喷成雾状射入气缸；柴油一旦与灼热的空气相遇，即发生燃烧；燃烧所产生的高温高压燃气在气缸内膨胀，从而推动活塞做功。 柴油是在高温高压之下“自燃”的，不是被点燃的，所以柴油发动机不需要点火系统。\n随着技术的发展，现在一些柴油发动机也被应用在轿车上，甚至作为跑车的动力系统。尤其在欧洲，柴油发动机在轿车上的应用非常普遍。\n柴油发动机是怎样工作的？ 进气行程. 进气门打开，排气门关闭，空气从进气门被吸入气缸，然后进气门关闭。 压缩行程. 活塞上升并压缩吸入的空气，使空气温度升高。喷油器将燃油喷入气缸，并混入热空气中 做功行程. 柴油与空气的混合气越来越热，以至于温度升高到可以自燃。混合气燃烧爆炸的力量将活塞向下推动，并通过连杆推动曲轴旋转。 排气行程. 排气门打开。旋转的曲轴推动活塞向上运动，活塞将燃烧后的废气从排气门推出气缸。 柴油发动机\n柴油发动机工作行程示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.18/","summary":"奔驰V6柴油发动机构造图 柴油发动机 为什么柴油发动机没有点火系统？ 柴油发动机是一种压燃式内燃机，是以柴油为燃料的内燃机。柴油发动机利用气体被压","title":"3.18 柴油发动机 Diesel Engine"},{"content":"发动机润滑系统示意图\n发动机润滑过程\n机油在发动机内是怎样流动的？ 当发动机不工作时，机油主要储存在油底壳。当发动机运转时，机油从油底壳经机油集滤器被机油泵抽送到机油滤清器中，经机油滤清器过滤后再进入主油道， 然后再通过各分油道进入润滑部位进行润滑。润滑后的机油，在重力作用下再流回到油底壳，参与再循环。\n为什么机油能起润滑作用？ 机油分散在摩擦面上，在摩擦面之间形成隔离层，并可以四处自由流动，这样就可以避免接触面上微小凹凸颗粒之间的摩擦，从而使部件之间的相对运动更加顺 畅。\n通用汽车V8发动机润滑系统示意图\n发动机润滑过程\n为什么要使用机油滤清器？ 为了不断清除润滑系统中的杂质，如金属屑、机油中的胶质等，在机油循环系统中必须装备机油滤清器，并且要定期更换，以保证它拥有较佳的过滤性能。\n下图中，黄色表示还没有过滤的机油，绿色表示已经过滤的机油。\n机油滤清器构造图\n奥迪3.0升V6 TFSI发动机润滑循环系统\n湿式油底壳和干式油底壳有什么不同？ 湿式油底壳，发动机的曲轴曲拐和连杆大头在曲轴每旋转一周时都会浸入油底壳的机油内一次，从而起到润滑作用，同时曲拐每次高速浸入油液内都会激起一定 的油花和油雾，还可以对曲轴和轴瓦进行润滑。\n这种润滑方式对于追求运动性能和越野性能的车型来讲就存在一个比较大的问题，当汽车高速过弯或者在极限越野中车身倾斜很大时，离心力或者重力会造成机 油聚集于油底壳的一个局部，导致部分曲拐不能浸入油液，从而影响润滑。\n为了解决这个问题，把发动机底部的油底壳，改成一个独立安装的机油箱，利用机油泵的压力强制将机油送到各个润滑点，并将润滑后的机油回送到机油箱。这 样的润滑方式，可以不受重力和离心力的影响，这就是干式油底壳。\n奔驰SLS发动机干式油底壳构造图\n保时捷水平对置6缸发动机润滑系统示意图\n为什么水平对置发动机的润滑系统更复杂？ 水平对置发动机的气缸都呈横卧形状，而且是对向排列，因此，要将机油抽送到气缸各处参与润滑，其难度比直列或V形发动机要大得多。更难的是，参与润滑后 的机油无法在重力作用下流回油底壳，必须通过机油泵才能回送到机油箱。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.17/","summary":"发动机润滑系统示意图 发动机润滑过程 机油在发动机内是怎样流动的？ 当发动机不工作时，机油主要储存在油底壳。当发动机运转时，机油从油底壳经机油集滤","title":"3.17 润滑系统 Lubrication System"},{"content":"发动机都有哪些冷却方式？ 风冷是在气缸体周围设计散热片，利用自然风或风扇来吹散发动机的热气，达到降低发动机温度的目的。 水冷是指利用冷却液来降低发动机的温度。 发动机冷却系统\n散热器和风扇构造图\n散热器是怎样散热的？ 汽车发动机冷却系统示意图\n为什么发动机不能过热或过冷？ 如果发动机温度过高，活塞和气门在高温下就可能发生膨胀变形，导致发动机损坏；如果冷却不良，发动机动力输出会下降，甚至引起爆燃等不正常的燃烧现象。 如果发动机过冷，会使汽油雾化效果变差，燃烧效率降低，燃烧不完全，进而降低动力输出，增加油耗。\n发动机内部温度有多高？ 在发动机内部，当发动机以极高速度运转时，它的最高燃烧温度可以高达2500℃，最低也要超过1000℃。可惜的是，这些热量很难被有效利用。不仅如此，它还 会使与其接触的机械部件受热膨胀，因此还必须消耗机械能量使其降温。据测试，燃油燃烧产生的总热量有1/3被吹散到大气中，被白白浪费掉。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.16/","summary":"发动机都有哪些冷却方式？ 风冷是在气缸体周围设计散热片，利用自然风或风扇来吹散发动机的热气，达到降低发动机温度的目的。 水冷是指利用冷却液来降低","title":"3.16 冷却系统 Coolant System"},{"content":"活塞的直线运动怎样转变成曲轴的旋转运动？ 与我们骑自行车的情况类似。\n活塞相当于人的膝盖，连杆相当于人的小腿，曲轴相当于脚蹬子，当活塞上下运动时，便会带动曲轴做旋转运动。 由直线运动转变为旋转运动示意图\n发动机直线运动转为旋转运动构造图\n发动机内部运动\n汽油发动机内部构造 为什么说活塞是心脏中的心脏？ 在发动机中，活塞的工作条件最严酷，不仅要承受巨大的压力，而且要承受非常高的温度。在高速运转中，活塞的行进速度有时可达到20米/秒。因此，活塞对 材质和制作精度等要求都非常高。\n活塞的顶部一般都不是平的，而是凹进去一点，这主要是为燃烧室留出空间。另外，为了减轻活塞的重量，一般都将它设计成空心的。\n被拆解的活塞连杆组件\n发动机活塞\n活塞和连杆构造和分解图\n活塞连杆构造图\n1马力代表1匹马的力量吗？ 马力最早是指一匹货运马在一定时间内所做的功，而不是指一匹马的力量或它的“劲儿”有多大。\n1英制马力（hp）=76千克力·米/秒\n“马力”概念示意图\n后来马力又被定义为：1公制马力（ps）=75千克力·米/秒\n在正规场合或专业术语中，人们基本不再使用马力作为功率的单位，而是使用瓦特（W）或千瓦（k W）作为功率的标准单位，或同时用马力和千瓦来表示。\n1英制马力（hp）=0.746千瓦（kW） 1公制马力（ps）=0.735千瓦（kW） 美国SAE标准常用英制马力（hp），而德国DIN、欧共体EEC和日本JIS标准常用公制马力（ps）。\n怎样理解转矩的概念？ 用一根1米长的扳手去扭动一个螺母，如果你用1牛顿或1千克力的手力量去扭动，那么施加在螺母上的转矩就是“1牛·米”或“1千克力·米”。\n所谓发动机的动力, 其大小是转矩与转速的乘积。\n应该功率.\n什么是曲轴、曲拐、曲柄？ 发动机主要构造分解图\n曲轴上的曲柄长度对发动机性能有直接影响。曲柄长度越大，它的最大转矩输出相对也越大，但最大转速相对较低；反之，如果曲柄越短，则它的发动机最大转 矩相对较小，但最高转速相对较高。另外，气缸的行程等于曲柄长度的2倍。\n曲轴在发动机中的位置示意\n为什么说曲轴是中心轴？ 发动机产生的动力经由活塞、连杆再传到曲轴，使曲轴每分钟旋转数千次，将动力传递到传动系统，使车轮转动。曲轴的旋转也会带动水泵、机油泵、发电机和 凸轮轴带轮等。可以说，曲轴是发动机动力的中转轴，是中心轴。由于它是弯弯曲曲的轴，故称为曲轴。\n为什么需要平衡重和平衡轴？ 平衡重的作用\n曲轴通过连杆将活塞的往复运动转变成圆周运动，既要承受很大的力，又要高速旋转，它的强度必须非常高，刚性也要好，因此一般都比较粗壮，运动起来振动 也较大。为了减小曲轴运转中的振动，一般都会在它上面装有平衡重块，以保证发动机运转平稳。\n平衡轴的作用\n当活塞运行到上止点和下止点时，连杆是倾斜的，会产生一个横向力，从而使曲轴在运转时产生振动。由于活塞完成一次往复运动要产生两次振动，因此又把这 种振动称为二次振动。在曲轴两侧设置两根平衡轴，并且使平衡轴的转速是曲轴的2倍，以平衡二次振动。\n平衡轴有链传动和齿轮传动形式，它们的转速都是曲轴的2倍。\n发动机平衡轴\n发动机曲轴构造图\n链传动的双平衡轴曲轴构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.15/","summary":"活塞的直线运动怎样转变成曲轴的旋转运动？ 与我们骑自行车的情况类似。 活塞相当于人的膝盖，连杆相当于人的小腿，曲轴相当于脚蹬子，当活塞上下运动时","title":"3.15 发动机主运动部件 Engine Major Moving Parts"},{"content":"发动机共有多少个部件？ 根据构造复杂程度的不同，一台发动机不可拆解的零部件总数，大概为300～600个。据称，一辆法拉利跑车的发动机约有800个独立的零部件，而布加迪威航的 W16发动机约有3500个零件。\n雪佛兰克尔维特V8发动机部件分解图\n克尔维特V8发动机\n克尔维特ZR1跑车6.2升V8机械增压汽油发动机分解图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.14/","summary":"发动机共有多少个部件？ 根据构造复杂程度的不同，一台发动机不可拆解的零部件总数，大概为300～600个。据称，一辆法拉利跑车的发动机约有800","title":"3.14 发动机整体构造 Engine Structure"},{"content":"为什么说火花塞像闪电？ 火花塞构造图\n要想产生燃烧，必须满足三个条件：燃料、氧气和温度。\n柴油发动机上没有火花塞，它是先将气缸内的空气强力压缩，直到空气温度升高到柴油的燃点，然后向气缸内喷射柴油，便可瞬间点燃柴油。\n火花塞产生高压放电的原理和雷电产生的原理是一样的。分别带正电和负电的两个电极离得非常近，一般不到1毫米。当它们分别带正电和负电时，一旦接近就会 产生电火花，电压甚至高达1万伏。它可以在瞬间点燃气缸中已被压缩升温的混合气。\n发动机是怎样起动的？ 发动机起动\n汽油发动机起动系统示意图\n汽车起动和点火流程示意图\n发动机起动和充电系统\n起动机是怎样工作的？ 汽车起动机构造示意图\n起动机工作原理\n为什么不能再用“接线法”起动汽车了？ 在传统汽车的点火起动系统中，只要将起动机与蓄电池之间的电路接通，就能利用起动机带动发动机的活塞运转，同时带动分电器工作，控制每个气缸的点火和 喷油，使发动机正常起动。因此，即使不用车钥匙，也能用“接线法”将汽车起动。\n现在的发动机已没有了分电器，不再用机械方式控制每个气缸的点火和喷油，而是由发动机电脑（ECU）控制。因此，即使将起动机的电源线接通，也只能使起 动机转动，并不能使点火和喷油系统正常工作。当车钥匙插入并扭转时，汽车上的防盗系统会识别车钥匙内密码芯片的信息，当确认合法后，才会起动燃油喷射 和点火系统。否则，将拒绝喷油和点火，使车辆无法起动。\n车辆起动防盗系统\n蓄电池的作用是什么？ 蓄电池只是储存电能的设备，而产生电能的部件还是由发动机驱动的发电机。发电机与蓄电池并联使用。\n蓄电池构造图\n汽车发电机构造图\n为什么发动机起动需要飞轮？ 飞轮的作用是储存发动机的运动能量，因为无论旋转速度多高，活塞在完成的四个行程中只有一次是做功的，而进气、压缩、排气三个行程中活塞都会遇到较大 的阻力，需要一定的力量才能完成任务。因此，利用重量和直径都较大的飞轮先把动能储存起来，便可带动曲轴平稳运转。\n飞轮还有另外两个作用：\n一是它的外周镶有齿环，它与起动机直接相连，通过起动机带动飞轮旋转从而起动发动机； 二是利用飞轮圆盘的大面积，可以让它与离合器相连，从而向传动系统传递动力。 发动机的气缸数越多，动力重叠便越多，因此不必储存太多动能，飞轮就可以小一点。虽然飞轮越重，发动机越平稳，但是因为惯性，太重的飞轮也会使发动机 加速或减速都慢。因此，载货车发动机的飞轮大而重，跑车发动机的飞轮则小而轻。\n发动机飞轮构造图\n飞轮作用一：储存能量，带动曲轴平稳旋转。\n飞轮作用二：起动机通过带动飞轮旋转来起动发动机。\n飞轮作用三：与离合器相连，向传动系统传递动力。\n发动机制动是怎么回事？ 当驾驶人完全抬起加速踏板，但不踏下离合器踏板，车辆的惯性力就会带动车轮继续旋转，进而由驱动轮通过半轴、差速器齿轮、变速器齿轮、发动机飞轮等传 动机构，带动发动机曲轴旋转。而此时发动机的压缩行程会产生压缩阻力，加上发动机内摩擦力和进排气阻力等，就会对驱动轮形成制动作用。这种现象就称为 发动机制动。\n发动机制动时，档位越低，发动机制动力就越大；反之，则越小。在下长坡道路行驶时，挂入低速档，利用发动机制动，可以减少制动次数，防止制动器过热引 起制动力热衰减；在冰雪、湿滑路面上行驶，应用发动机制动，可以防止侧滑。\n发动机制动原理示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.13/","summary":"为什么说火花塞像闪电？ 火花塞构造图 要想产生燃烧，必须满足三个条件：燃料、氧气和温度。 柴油发动机上没有火花塞，它是先将气缸内的空气强力压缩，直","title":"3.13 点火起动系统 Ignition Starting System"},{"content":"多点喷射和单点喷射有什么不同？ 如果每个气缸的进气歧管上都单独装配一个喷油器，每个喷油器只向一个气缸喷射燃油，那么就称之为多点喷射（M P I）。反之，只在进气管入口处装配一个 喷油器，由这一个喷油器向进气管处喷射燃油，然后再由进气歧管把混合气分散到各个气缸中，那么就称其为单点喷射。其实，随着多点喷射系统制造成本的下 降，现在轿车上已很少采用单点喷射了。\n单点燃油喷射系统示意图\n多点燃油喷射系统示意图\n发动机燃油喷射\n什么是“双喷”发动机？ “双喷”发动机配有两套燃油喷射装置，除了缸内燃油直喷系统外，还在进气道内设计了一个喷油器。根据行驶状况，缸内喷射与缸外喷射之间可以进行切换或共 同混合喷射，确保高效的动力输出和最佳的燃油经济性。\n丰田“双喷”发动机\n缸内直喷和缸外喷射有什么不同？ 缸外喷射是将燃油喷射到进气道中，与进气混合后再进入气缸内。缸内直喷是直接将燃油喷射入气缸中，如所有的柴油发动机和部分缸内直喷汽油机。由于燃油 缸内直喷对提高燃油经济性、提高动力输出都很有帮助，因此现在采用缸内直喷发动机的车辆越来越多。燃油缸内直喷已成为发动机先进技术的代表之一。\n缸外燃油喷射系统示意图\n缸内燃油喷射系统示意图\n“双喷”发动机喷射系统示意图\n怎样控制喷油时刻和喷油量？ 缸内直喷发动机上最先进的喷油器采用压电式喷嘴，它由无数个相互叠置的微型陶瓷碟片组成。如果给电磁线圈施予电压，陶瓷碟片的晶体结构就会发生改变（ 也就是所谓的压电效应），碟片随后以最低限度强力扩张，快速而精确地作用于控制阀，控制阀则会触发喷射针，从而喷射燃油；当电磁线圈断电后，磁力消失， 在压力弹簧的作用下，喷油针阀回复原位，喷油结束。这样，通过控制电磁线圈的电压，就可以实现喷油时刻和喷油量的精确控制。\n什么是高压油轨？ 缸内直喷发动机的高压油轨系统中的“轨”其实是一个储压器，其中燃油由油泵供给，可在最高200兆帕的压强下存储燃油，这相当于将一辆高档豪华轿车的重量 集中在1平方厘米的面积上。正是由于高压作用以及喷嘴上一个直径只有0.1毫米的精细小孔设计，共轨系统的喷射器能够将燃油雾化为极为精细的微粒，从而确 保出色、均匀的油气混合及高效的燃烧。\n奥迪缸内燃油直喷发动机喷油器\n高压共轨\n奥迪直列4缸汽油发动机燃油喷射系统\n燃油是怎样供给到发动机的？\n燃油被燃油泵从燃油箱中抽出，在进入发动机之前，还要经过燃油滤清器，才能进入燃油轨道，并在发动机电脑（ECU）的控制下喷射到进气道（缸外喷射） 或气缸内（缸内直喷），最终参与燃烧。\n由于燃油喷射的压力较大，在喷入进气歧管时可能造成进气歧管内压力不平衡，从而影响燃烧效率。为此，专门设置了一个压力调节器，当进气歧管内压力差较 大时，压力调节器打开阀门，允许一部分燃油流回燃油箱中。\n燃油供给\n燃油供给路线示意图\n燃油箱和炭罐\n炭罐起什么作用？ 汽油是易挥发的燃料，油箱内的燃油很容易挥发并增加油箱内部的压力，当压力到达一定值时就会产生危险。为了避免危险，在燃油箱和发动机之间设置了一个 充满活性炭的炭罐，让油箱中多余的燃油蒸气不再排到大气中，而是通过蒸气导管引入炭罐中，由活性炭来吸附燃油蒸气。当汽车开动时，炭罐电磁阀适时打开， 新鲜空气进入炭罐中，将炭罐中吸附的燃油“吹”向进气歧管，加入发动机燃烧中，以达到节约燃油和环保的目的。\n燃油箱是怎样布置的？ 现在，轿车用的燃油箱大多采用高分子高密度聚乙烯塑料制成。这种塑料燃油箱的优点是强度高，密封性好，容易制成符合布置空间的异形，从而可充分利用空 间，而且重量轻，耐腐蚀，抗冲击性好，在燃烧时也不易爆炸等。\n奥迪A8轿车燃油箱构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.12/","summary":"多点喷射和单点喷射有什么不同？ 如果每个气缸的进气歧管上都单独装配一个喷油器，每个喷油器只向一个气缸喷射燃油，那么就称之为多点喷射（M P I）。","title":"3.12 燃油供给系统 Fuel Supply System"},{"content":"机械增压器\n机械增压器是怎样工作的？ 机械增压（Supercharger）与涡轮增压的原理完全不同，它并不是依靠排出的废气来压缩进气，而是通过一个机械式的空气压缩机与曲轴相连，通过发动机曲 轴的动力带动空气压缩机旋转来压缩进气。压缩机是通过两个转子的相对旋转来压缩进气的。正因为需要通过曲轴转动的能量来压缩进气，机械增压会对发动机 输出的动力造成一定程度的损耗。\n机械增压器的特性也与涡轮增压器的特性刚好相反，由于机械增压器始终在“增压”，因此在发动机低转速时，其转矩输出就十分出色。另外，由于进气压缩量完 全是按照发动机转速线性上升的，整个发动机运转过程与自然吸气发动机极为相似，加速过程呈线性，没有涡轮增压发动机在涡轮介入那一刻的唐突，也没有涡 轮增压发动机的低速迟滞。但由于高转速时机械增压器对发动机动力的损耗巨大，因此在高转速时，其作用就不太明显了。\n机械增压器构造图\n带中冷器的机械增压发动机进气示意图\n机械增压器\n机械增压发动机工作原理示意图\n梅赛德斯-奔驰机械增压发动机构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.11/","summary":"机械增压器 机械增压器是怎样工作的？ 机械增压（Supercharger）与涡轮增压的原理完全不同，它并不是依靠排出的废气来压缩进气，而是通过一","title":"3.11 机械增压器 Supercharger"},{"content":"涡轮增压器\n涡轮增压器如何增压？ 涡轮增压（Turbocharger）发动机，是指利用排气冲击涡轮来压缩进气的增压发动机，简称Turbo或T。如果在一些轿车尾部看到字母Turbo或T，就表明该车 采用涡轮增压发动机。\n涡轮增压拥有良好的加速持续性，用通俗的话说就是后劲十足，而且最大转矩输出的转速范围宽广，转矩曲线平直。但是，低速时由于涡轮不能及时介入，导致 动力性稍差。\n大众汽车涡轮增压发动机构造图\n为什么要配备增压器？ 涡轮增压发动机原理示意图\n为什么涡轮增压器还要使用中冷器？ 气体有这样一个特性：当它受到压缩时，随着它的密度增加，它的温度也会上升，从而影响发动机的充气效率。如果想要进一步提高增压发动机的充气效率，就 要降低进气温度。\n热胀冷缩\n如果未经冷却的增压空气进入燃烧室，除了会影响发动机的充气效率外，还很容易导致发动机燃烧温度过高，造成爆燃等非正常燃烧，而且会增加废气中氮氧化 物的含量，加重排放污染。\n中冷器实际上就是个散热器，它被放置在通风良好的位置，吸收进气被压缩时产生的热量，从而降低进气温度。\n涡轮增压器\n奥迪2.5升直列5缸涡轮增压发动机\n涡轮增压器工作原理示意图\n为什么排气会有动力？ 排气的冲击力来自活塞上升时挤压燃烧废气的力量，当燃烧废气被“挤出”气缸时，废气就会带有一定的冲击力。\n双涡管单涡轮增压器是怎么回事？ 宝马直列6缸双涡管单涡轮增压发动机原理示意图\n宝马双涡管涡轮增压器\n4缸双涡管单涡轮增压器怎样工作？ 在宝马直列4缸双涡管单涡轮发动机排气系统中，将点火时间相邻的两个气缸的排气歧管两两分开（1和4一组，2和3一组），这样当3缸完成做功进行排气时， 1缸进入进气行程。由于1缸和3缸的排气歧管不相连，3缸的排气不会影响1缸的进气效果。其他缸工作时原理相同。这样点火相邻的两个缸的进排气不受干涉影 响，可以提高各个气缸的进排气量，从而有效提高发动机的效率。\n直列4缸双涡管单涡轮增压器构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.10/","summary":"涡轮增压器 涡轮增压器如何增压？ 涡轮增压（Turbocharger）发动机，是指利用排气冲击涡轮来压缩进气的增压发动机，简称Turbo或T。如","title":"3.10 涡轮增压器 Turbocharger"},{"content":"可变气缸和可变排量是怎么回事？ 每个厂商的可变气缸技术并不完全相同，但基本都是采用关闭气门和停止喷油的方式来关闭气缸的。\nDid You Know?\n在进排气凸轮轴上安装一套零行程的凸轮，当需要关闭部分气缸的工作时，只要指挥步进电动机使凸轮轴左右移动，就可以使部分气门处于零行程的工作状态， 也就是停止工作，使对应的气缸也停止工作\n奥迪可变气缸技术\n奥迪可变气缸发动机构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.09/","summary":"可变气缸和可变排量是怎么回事？ 每个厂商的可变气缸技术并不完全相同，但基本都是采用关闭气门和停止喷油的方式来关闭气缸的。 Did You Know? 在进排气凸轮轴上","title":"3.9 可变气缸 Variable Cylinder"},{"content":"可变气门有什么优点？ 当高转速时，需要吸入更多的空气（混合气），因此如果能把气门提得更高些（改变升程）或延长气门的打开时间（改变正时），便能满足需求，从而提高动 力； 反之低速时，则可以降低气门的升程或缩短打开时间，少吸入混合气，从而节省燃料。 奔驰可变气门\n宝马V12发动机可变气门发动机\n宝马Valvetronic电子气门是怎样工作的？ 宝马Valvetronic电子气门示意图\n宝马Valvetronic电子气门构造图\n宝马电子气门\n奥迪AVS可变气门是怎么回事？ 奥迪可变气门\n奥迪发动机可变气门构造图\n奥迪发动机可变气门AVS工作原理示意图\n本田VTEC可变气门是怎么回事？ 本田可变气门\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.08/","summary":"可变气门有什么优点？ 当高转速时，需要吸入更多的空气（混合气），因此如果能把气门提得更高些（改变升程）或延长气门的打开时间（改变正时），便能满","title":"3.8 可变气门技术 Variable Valve Technology"},{"content":"气缸内部构造图\n进气门和排气门\n进气门为什么比排气门大？ 因为进气是被“吸”进去的，而排气是被“推”出去的，所以进气比排气更困难，而且进气越多，燃烧得越好，发动机的性能也越好。因此，一般都将进气门设计得 比排气门大，以降低进气难度，提高进气量。有的干脆多设计一个进气门，这才有了3气门（2进1排）和5气门（3进2排）设计。\n气门构造及其辅助零件\n气门数为什么不能太多？ 多气门发动机具有高转速、高效率的优点。由于气门较多，高转速时进排气效果较好，且火花塞放在中央可提高压缩比，因此发动机性能也较好。但是，多气门 设计较复杂，气门驱动方式、燃烧室构造和火花塞位置都要精密安排，而且制造成本高，工艺要求先进，维修也较困难，其带来的效果并不是特别明显，或者说 有点不太划算。因此，现在基本放弃每缸5气门设计，而采用更为流行的每缸4气门设计。\n汽油发动机构造图\n为什么说凸轮轴像是指挥棒？ 在凸轮轴上，有数个圆盘形的凸轮。当凸轮轴旋转时，凸轮便会依序下压而使气门运动，使发动机产生四行程循环运动。同时，通过灵活控制凸轮轴的运行，还 可调节气门的升程和正时，从而提高发动机的性能。\n双顶置凸轮轴（DOHC）构造图\nV12发动机双顶置凸轮轴（DOHC）构造图\n配气正时机构示意图\n什么是顶置凸轮轴和双顶置凸轮轴？ 如果凸轮轴位于气缸的顶部，就称为顶置凸轮轴（Over Head Camshaft，简称OHC）。 如果在顶部只有一根凸轮轴同时负责进气门和排气门的开关，则称为单顶置凸轮轴（Single Over Head Camshaft，简称SOHC）。 如果在顶部有两根凸轮轴分别负责进气门和排气门的开关，则称为双顶置凸轮轴（Double Over Head Camshaft，简称DOHC） 奥迪V6发动机正时机构示意图\n为什么发动机需要正时？ 在进气、压缩、做功和排气四个行程中，曲轴要转两周，而进气门或排气门只动作一次。由此可知，凸轮轴的转速必须是曲轴转速的一半，才能上下合拍，也就 是达到正时。因此，凸轮轴齿（带）轮齿数是曲轴齿（带）轮齿数的两倍，以使它的转速慢下一半来。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.07/","summary":"气缸内部构造图 进气门和排气门 进气门为什么比排气门大？ 因为进气是被“吸”进去的，而排气是被“推”出去的，所以进气比排气更困难，而且进气越多，燃","title":"3.7 气门和气门正时 Valve and Valve Timing"},{"content":"为什么发动机要进气和排气？ 空气由进气口进入，通过空气滤清器过滤后，经进气歧管进入气缸，并在进气歧管内布置有节气门和空气流量计来控制和调节进气量。\n发动机排气系统的作用，是将已燃烧的废气排入大气。它主要由排气歧管、排气管和排气消声器组成，并在排气管段布置有三元催化转化器，以净化排气。\n汽油发动机进气和排气系统构造图\n节气门起什么作用？ 进气系统主要包括两大部件：\n一是空气滤清器，它主要滤清空气，去除空气中的杂质； 二是进气道，它将空气与燃油的混合气引入气缸。 在进气道中有节气门，它可控制进入气缸的混合气的多少。\n此节气门与驾驶人脚下的加速踏板（俗称“油门踏板”）直接相连，加速踏板踏下越深，节气门开度越大，混合气进入就越多，发动机的转速就越高。 如果加速踏板和节气门是通过电信号控制的，而不是拉索硬性连接，那么就称其为电子节气门（俗称“电子油门”）。 节气门体和进气歧管\n节气门在发动机上的位置图\nhttps://res.weread.qq.com/wrepub/epub_26688761_73\n进气歧管系统\n节气门体\n什么是理想空燃比？ 空气与汽油的混合比也称空燃比。根据计算，它的理想值大概在14.7∶1左右，也就是燃烧1千克的汽油需要吸入14.7千克的空气。如果按体积之比，则大概为 9000∶1，就是说要燃烧1升的汽油，必须吸入9000升的空气。这样算来，汽车每分钟要吸入3000～5000升的空气，而我们人体每分钟只需吸入6升空气就够用 了。\n为了提高进气量，人们想出了各种方法，比如增大发动机的排气量、采用进气歧管可变技术、采用气门可变技术、配备增压器等。可以说，现在的发动机技术， 基本就是指怎样精确调节进气的技术，使发动机顺畅呼吸，让燃油得到充分燃烧，从而提高动力，节省燃油，降低排放。\n每分钟吸入空气量比较\n为什么进气歧管长度可以变化？ 原理是根据需要打开或关闭进气歧管中的一些阀门，使进气“走捷径”或“绕道”来改变进气行程，从而调节进气量和进气速率。\n可变进气歧管长度示意图\n可变进气歧管发动机\n为什么排气歧管奇形怪状？ 排气歧管是指从排气门出来的七扭八歪的那部分金属管。由于每个气缸的排气时刻都不一样，为了保证每个气缸的排气顺畅，必须防止不同气缸之间的排气有干 扰。因此，在设计排气歧管时要遵循四项基本原则：\n排气歧管要尽可能长。 各缸排气歧管要尽可能等长。 各缸排气歧管要尽可能独立，互不干涉。 排气歧管内表面要尽可能光滑。 排气管上的部件相对要多一些，如氧传感器（2个）、三元催化转化器（1～2个）、消声器（1～2个），都要安装在排气管上。\n发动机排气歧管造型\n氧传感器起什么作用？ 氧传感器位置示意图\n发动机排气系统\n现在，汽车的发动机都采用电脑（ECU）控制燃油的喷射，必须精确地控制混合气的空燃比（空气和燃油比例的理想值为14.7∶1），才能使燃油的燃烧效率尽可 能高。氧传感器实际上就是测量排气中氧气含量的部件，当排气中氧气含量高于或低于规定时（也就是空燃比偏离理想值时），氧传感器就会向发动机ECU报告， ECU就会根据情况自动调节喷油量。\n目前，车辆大多安装有两个氧传感器，在三元催化转化器前后方各有一个。\n前方氧传感器的作用是检测发动机不同工况的空燃比，同时ECU根据该信号调整喷油量和计算点火时间。 后方氧传感器的作用主要是检测三元催化转化器的工作好坏，即催化器的转化率。通过与前氧传感器数据的比较，来检测三元催化转化器是否工作正常。 ","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.06/","summary":"为什么发动机要进气和排气？ 空气由进气口进入，通过空气滤清器过滤后，经进气歧管进入气缸，并在进气歧管内布置有节气门和空气流量计来控制和调节进气","title":"3.6 进气和排气系统 Intake and Exhaust System"},{"content":"为什么发动机会发出有节奏的声音？ 活塞在气缸中要完成吸气、压缩、燃烧和排气四个行程，才算是完成一个工作循环。在此期间，活塞要在气缸内上下各两次，曲轴则同时要旋转两周。\n为什么发动机的动力能够源源不断？ 活塞在气缸中上下移动，活塞下行到的最低点叫下止点，上行到顶点的位置称为上止点。上止点与下止点之间的距离称为行程。当活塞在上止点时，活塞顶端的 空间称为燃烧室。\n发动机工作原理\n发动机工作原理示意图\n气缸结构示意图\n前面所述的发动机，活塞在气缸中移动四个行程，也就是曲轴转720°（2周）才完成一次动力输出，因此称为四冲程发动机。\n如果活塞在气缸中移动两个行程，也就是曲轴转360°（1周）就可完成一次动力输出，则称为二冲程发动机。以前，在汽车上曾使用过二冲程发动机，但现在只 在摩托车上使用。二冲程发动机的进气和压缩动作可以在一个行程中完成，而燃烧做功和排气动作则在另一个行程完成。\n发动机内部构造图(四冲程)\n发动机工作原理\n二冲程\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.05/","summary":"为什么发动机会发出有节奏的声音？ 活塞在气缸中要完成吸气、压缩、燃烧和排气四个行程，才算是完成一个工作循环。在此期间，活塞要在气缸内上下各两次","title":"3.5 发动机工作循环 Engine Working Cycle"},{"content":"为什么发动机需要吸入大量的空气？ 书中没直接描述原因, 猜测是氧气不足时会导致能量转换效率不高.\n汽油蕴含巨大能量\n同等重量情况下，汽油所含能量大约是糖的3倍，木头的5倍，电池的200倍。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.04/","summary":"为什么发动机需要吸入大量的空气？ 书中没直接描述原因, 猜测是氧气不足时会导致能量转换效率不高. 汽油蕴含巨大能量 同等重量情况下，汽油所含能量大约","title":"3.4 发动机燃烧原理 Engine Combustion Principle"},{"content":"汽油在气缸内燃烧爆炸示意图\n为什么说发动机动力来自于爆炸？ 如果将汽油和空气按照最适合的燃烧比例（1∶14.7）混合，并对它们进行大力压缩使之温度上升，此时点燃它们就会产生更大的爆炸力。 将这种力量通过一系列的机构“引导”到车轮上，便会推动汽车前进。 发动机排气量和压缩比计算方式示意图\n为什么动力与排量大小有关？ 气缸排气量是指活塞从下止点到上止点所扫过的气体容积，它取决于缸径和活塞行程。 发动机排量是各气缸排量的总和，一般用c c（立方厘米）、m L （毫升）或L（升）来表示。 发动机的排量越大，每次吸入的可燃混合气就越多，燃烧时产生的动力就越强。 ","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.03/","summary":"汽油在气缸内燃烧爆炸示意图 为什么说发动机动力来自于爆炸？ 如果将汽油和空气按照最适合的燃烧比例（1∶14.7）混合，并对它们进行大力压缩使之温","title":"3.3 发动机工作过程 Engine Working Process"},{"content":"发动机的气缸有哪几种排列形式？ 最常见的有3种气缸排列形式：直列、V形和水平对置。 还有一种W形气缸排列形式，但这种形式较为少见，而且与V形发动机较为相似。 发动机气缸形式\n直列发动机气缸排列示意图\n水平对置发动机 宝马V8发动机构造示意图\nV8发动机\nV形发动机更先进吗？ V形发动机的气缸成一角度对向布置，还可以抵消一部分振动。V形发动机的缺点，就是必须使用两个气缸盖，结构较为复杂。 W形发动机为什么应用少？ 与V形发动机相比，W形发动机最大的问题，就是发动机由一个整体被分割为两个部分，在运作时必然会引起很大的振动，因此现在应用极少。 针对这一问题，大众汽车在W形发动机上设计了两个反向转动的平衡轴，让两个部分的振动在内部相互抵消。现在，只有大众汽车集团某些品牌车型采用W形发 动机，如W8、W12和W16等发动机。 奥迪W12发动机构造图\nW16气缸形式\nW形发动机气缸夹角示意图\nW12发动机气缸排列示意图\nW12发动机气缸体\n什么是内燃机和外燃机？ 我们经常把汽车发动机称为内燃机，难道还有外燃机？是的，外燃机是存在的，比如原来火车上用的蒸汽机，发电厂和轮船上使用的汽轮机等，都是外燃机。它 们都是利用燃料在发动机气缸的外部燃烧来产生动力的。如早期的蒸汽机，它利用燃料（木材、煤、煤气、柴油等）烧开锅炉中的水，使之产生高压蒸汽并进入 气缸内，利用蒸汽压力推动活塞做功，从而产生动力。\n内燃机则是相对外燃机而言的，它的燃料在气缸内燃烧。现在，汽车上用的汽油发动机和柴油发动机，都是内燃机。\n外燃机工作原理示意图\n内燃机工作原理示意图\n为什么说水平对置发动机更有个性？ 水平对置发动机的英文为Boxer Engine，含义就是“拳击手发动机”，简称为B型发动机。比如B6、B4发动机，分别代表水平对置6缸和4缸发动机。 由于相邻两个气缸水平对置，这种发动机可以很简单地相互抵消振动，使发动机运转更平稳。水平对置发动机的重心低，能让车头设计得又扁又低。这两点都 增强了汽车的行驶稳定性。 水平对置发动机本身就左右对称，因此它可使变速器等放置在车身正中，让汽车左右重量对称，而不会像大多数汽车那样重心偏向一侧。 水平对置发动机的动力输出轴方向与传动轴方向一致，因此不需要改变动力传递方向，而是可以直接与离合器、变速器对接，大大提高了动力传递效率，使汽 车的起动和加速更迅猛。 水平对置发动机的缺点是维修不方便，而且各缸点火间隔不一致，使其排气声音比较怪异。普通汽车极少装配水平对置发动机，现在只有保时捷、斯巴鲁和丰 田等仍在生产和使用这种发动机。 水平对置6缸发动机构造图\n水平对置发动机\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.02/","summary":"发动机的气缸有哪几种排列形式？ 最常见的有3种气缸排列形式：直列、V形和水平对置。 还有一种W形气缸排列形式，但这种形式较为少见，而且与V形发动","title":"3.2 气缸排列形式 Cylinder Arrangement"},{"content":"汽车动力从哪里来？ 汽车动力来源于它的“心脏”，也就是发动机。那么发动机的“心脏”是什么？气缸！\n汽油发动机构造剖视图\n直列4缸汽油发动机构造图\n发动机原理\n气缸数为什么不能太多？ 在同样功率的要求下，缸数越多，缸径就可越小，转速就可提高，发动机的运转平衡性也更好。但是，随着气缸数的增加，发动机的零部件数也成比例增加，从 而使发动机结构更复杂、可靠性降低、重量增加、制造成本和使用费用增加、油耗增加等。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.01/","summary":"汽车动力从哪里来？ 汽车动力来源于它的“心脏”，也就是发动机。那么发动机的“心脏”是什么？气缸！ 汽油发动机构造剖视图 直列4缸汽油发动机构造图 发","title":"3.1 发动机基本原理 Engine Principle"},{"content":"9.1 新消费主张带来新品牌崛起 我们通常把1995～2010年出生的一代人称为“Z世代”。\n“Z世代”是注重个体、追求悦己的一代。追求品质, 强调个性 “Z世代”是在互联网环境下成长起来的一代，被称为“互联网原住民”，更加习惯于在互联网上获取信息，并通过互联网进行社交活动。 社交平台的风向可以对“Z世代”的消费决策产生较大影响 各种各样的圈层文化，包括“饭圈文化”“二次元文化”等，这些圈层文化会影响人们的消费决策。 “Z世代”是在文化自信下成长起来的一代。喜欢传统文化、国潮元素、红色经典 “Z世代”消费者对国潮的喜爱，对于国产品牌来说是千载难逢的机会。\n表9-1 运动服饰品牌在天猫上的销售额排行(2021)\n“Z世代”消费者对于生活方式的新主张也将带来新的品牌成长机会。\n比如健康食品、无糖饮料赛道， 互联网已经成为“Z世代”相互交流的主要场所。\n“买网友们真实体验后相互种草推荐的商品”是一个新的消费决策方式，我们将其称为“互联网主张” 互联网运营能力将成为决定未来品牌分化趋势的关键变量 总之，未来消费品投资的第一个大方向就是顺着“Z世代”消费者的消费主张，寻找对应品牌标的的成长机会。关键在于对消费群体的了解，对品牌定位的把握，对网络 风向和热点的洞察。比如国潮崛起对应着国产品牌的崛起；健康的生活方式带来了无糖饮料、健康食品等领域的投资机会；互联网传播对应互联网运营能力强的消费品 品牌和新锐品牌的投资机会。\n9.2 关注新消费习惯带来的需求增长 从长远来看，当人们的收入增长之后，消费结构将会发生改变。其中，食品等必需品的支出占比将会下降，而服务类消费的占比将会提升。\n从什么地方能够找到新消费习惯形成的机会？\n人们的根本诉求是一个很好的出发点。比如对美的追求、对娱乐和刺激的需求、对陪伴和认同的渴望、对方便的需求、对新奇事物的好奇等。 图9-1 中国医美市场规模(2021)\n图9-2 2020年部分国家每千人医美诊疗次数\n健康、多元的生活方式也是一个新消费习惯带来的潜在投资机会。健身消费 文娱需求也是一个重要的发展方向。 电影、电视剧、文艺创作、游戏等 旅游 图9-3 全国旅游收入和增速\n懒人经济将是未来的重点方向。 器具，即帮我们省事的商品, 洗碗机, 洗菜机, 烘干机, 扫地机器人 让人们“懒”的服务. 餐饮业, 外卖, 跑腿 新消费需求往往在大家的生活中潜移默化地生成，其发展很多时候具备长期的趋势性，而不会像技术突破那样猛烈。这样的匀速持续增长，恰恰是最适合价值投资者长 期发挥的领域——不但要发现这些投资机会，也要拿得住持续上涨的股票。\n9.3 新技术的突破 增长最迅猛的一类消费品投资机会基于技术突破，更好地满足了人们的一些固有需求。这类技术突破直接体现为消费品渗透率的直接提升\n比如电池技术的量变引发质变带来了电动车的普及 移动互联网带宽的提升带来了短视频和直播电商等。 技术突破带来的投资机会往往来势迅猛，投资者往往会因为错过了新科技龙头企业的成长机会而捶胸顿足。但从另一个角度看，追逐新技术的投资往往也伴随着高风险。 大多数自身无明显信息优势、技术背景不深的投资者，在参与这类机会时，应该三思而后行。\n","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC9%E7%AB%A0-%E6%9C%AA%E6%9D%A5%E6%B6%88%E8%B4%B9%E5%93%81%E6%96%B0%E6%9C%BA%E4%BC%9A/","summary":"9.1 新消费主张带来新品牌崛起 我们通常把1995～2010年出生的一代人称为“Z世代”。 “Z世代”是注重个体、追求悦己的一代。追求品质, 强调个性","title":"第9章 未来消费品新机会"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/hh1024/","summary":"主页","title":"红人点集"},{"content":"2.1 HTTP/1.1和当前的万维网 图2.1　网站加载内容平均大小（2014年—2018年）\n表2.1　美国访问量排名前10网站\n2.1.1 HTTP/1.1根本的性能问题 图2.2　在一个简单的网站示例中，HTTP请求及响应的流程\n处理时间在整个请求流程中占比很小, 大部分时间都在等待, 效率低 现代互联网最大的问题之一是延迟而不是带宽。 2.1.2 HTTP/1.1管道化 图2.3　简单示例网站的HTTP管道化\n管道化技术应该会对HTTP带来巨大的性能改善，但由于多种原因，它很难实现，易于出错，并且没有获得Web浏览器和Web服务器的良好支持。因此，它很少被 使用。没有一个主流的Web浏览器支持管道化技术。\n即使管道化技术得到了更好的支持，它仍然需要按照请求的顺序返回响应。如果图像2可用，但必须从另一台服务器获取图像1，则图像2的响应会等待，即 使应该可以立即发送图像2。此问题被称为队头（HOL）阻塞问题，在其他网络协议及HTTP中很常见。\n2.1.3 网络性能瀑布流图 图2.4　示例网站的请求瀑布图\n图2.5　示例网站使用管道化技术的瀑布图\n在这两个示例中，第一条垂直线表示可以渲染初始页面的时间（称为开始绘制时间或开始渲染时间），第二条垂直线表示页面何时加载完成。浏览器通常会在下 载图像之前尝试绘制页面，并在稍后填充图像，因此图像下载通常在这两个时间之间。\n图2.6　webpagetest.org上的瀑布图\n它将每个请求分成几个部分\nDNS查询 网络连接时间 HTTPS（或SSL）协商时间 请求的资源分类（并且还将资源负载分成两部分，用于请求的颜色较浅，用于响应的颜色较深） 加载页面各个阶段的各种垂直线 其他图表，显示CPU使用率、网络带宽，以及浏览器工作在哪个主线程中 2.2 解决HTTP/1.1性能问题的方案 随着时间的推移，已经有各种突破HTTP/1.1的性能限制的技术，这些技术分为以下两类：\n使用多个HTTP连接。 合并HTTP请求。 其他的和HTTP关联不大的性能优化技术，包括优化用户请求资源的方式（比如先请求关键CSS），减小下载资源的大小（压缩和使用响应式图片），减少浏览器 的渲染任务（更高效的CSS和JavaScript）。这些技术的细节超出了本书的讨论范围，但我们会在第6章涉及一些。Manning出版社所出版的 Web Performance in Action（Jeremy Wagner著）一书，是学习这些技术 的绝佳资料。\n\u0026laquo;Web性能实战\u0026raquo; 内容可能有点旧.\n2.2.1 使用多个HTTP连接 与管道化技术不同，该技术不会导致HOL阻塞，因为每个HTTP连接都独立于其他HTTP连接。因此，大多数浏览器可以为每个域名打开6个连接。\n为了进一步突破6个连接的限制，许多网站从子域提供静态资源, 如图像、CSS和JavaScript，Web浏览器从而可以为每个新域名打开另外6个连接。这种技术称 为域名分片\n除了提高并发数，域名发散还有其他优势，比如减小HTTP请求首部（如cookies） 图2.7　stackoverflow.com使用多个域名加载资源\n使用多个http连接的缺点\n打开TCP连接需要时间 维护连接需要更多的内存和CPU资源。 图2.8　TCP三次握手\nTCP在开启连接时比较小心，在确认网络不拥堵之前只会发送比较少的数据包。CWND（Congestion Window，拥塞窗口）随着时间的推移逐渐增加，只要连接 没发现丢包，就可以处理更大的流量。\nTCP拥塞窗口的大小受TCP慢启动算法控制。 在拥塞窗口中的TCP数据包需要在收到ACK消息之后发送。 在CWND比较小时，可能需要多个TCP ACK消息才能发出一个完整的HTTP请求。 HTTP响应常常比请求大很多，所以它同样也会受到拥塞窗口的影响。 最后，就算没有TCP建立连接的开销和慢启动的问题，使用多个独立的连接也可能导致带宽问题。例如，如果所有带宽都用掉了，就会导致TCP超时，和其他的 连接上的重传。在这些独立的连接之间，没有优先级的概念，这就无法更高效地利用带宽。\n优先级如何使带宽高效利用?\n创建TCP连接之后，安全的网站要求建立HTTPS连接。这个过程可以节约开销，比如，重用TCP连接的参数，不从零开始。但这个过程依然需要更多的网络往返，这意 味着更多的时间。\n使用多个连接会导致额外的tcp/https握手过程, 反而导致延迟问题. 过多的连接数, 收益会比较低 2.2.2 发送更少的请求 减少不必要的请求, 比如在浏览器中缓存静态资源(相当于不发请求) 以更少的HTTP请求获取同样的资源(打包合并静态资源) 对于图片来说，这种打包技术叫作精灵图。\n图2.9　TinyPNG的精灵图\n如果是CSS和JavaScript文件，很多网站就将多个文件合并为一个文件，这样需要的请求数就少了，但是总的代码量并不少。在合并文件的时候，通常还会去掉代码 中不必要的空格、注释和其他不必要的元素，以减小CSS和JavaScript的文件尺寸。这些方法都会提升效率，但是会增加配置的难度。\n其他的技术还包括内联资源到其他文件。比如，Critical CSS经常直接被内联在HTML的\u0026lt;style\u0026gt;标签中。图片可以包含在CSS中，通过行内SVG，或者转换为 Base64编码，也能减少HTTP请求数。\n另外一个问题是，合并会导致文件的浪费。\n一些网页可能只用到一张精灵图中的一两个图标，但却要下载整张精灵图。 当有新的精灵图时，还要重写CSS文件，以防止新的精灵图中图标的位置发生变化。 同样，如果合并了太多文件，JavaScript也可能会变得臃肿。有时候我们只需要其中的很少一部分，却要下载一个大得多的文件。 无论是从网络的方面（特别在开始的时候，TCP启动慢）还是从浏览器执行的方面（浏览器需要处理它不需要的代码）来说，这种技术都不够高效。 最后一个问题是缓存。\n如果把精灵图缓存了很长一段时间（这样用户就不需要频繁下载它），当需要添加一个图标的时候，必须让浏览器再次下载整个精灵图，但访客并不需要。 可以使用很多技术来解决这个问题，比如添加版本号或者使用查询参数，但是这些技术也会浪费资源。使用CSS和JavaScript也一样，改变一行代码就需要重新下 载整个合并文件。 2.2.3 HTTP/1性能优化总结 归根到底，优化HTTP/1性能的方法是一些解决HTTP/1基础缺陷的小技巧。应该有更好的办法在协议层面解决这个问题，从而节省时间，这正是HTTP/2要做的。\n2.3 HTTP/1.1的其他问题 基于文本的协议处理起来复杂易出错, 还会导致安全问题. 文本协议编码效率不高, 体积大 首部内容有重复 就算只有主页需要cookie，每个发向服务器的HTTP请求中都会包含cookie。 纯文本协议的安全和隐私问题（HTTPS加密很好地解决了这个问题） 缺少状态的问题（cookie在一定程度上解决了这个问题）。 2.4 实际案例 用于测试web性能的WebPageTest\n2.4.1 示例网站1: amazon.com 图2.10　www.amazon.com的部分运行结果\n首个请求是主页的请求\n图2.11　首页的第一个请求\nHTML引用了几个CSS文件\n图2.13　图片下载\n图2.14　加载amazon.com的连接视图\n2.4.2 示例网站2：imgur.com 图2.15　imgur.com的瀑布图\n图2.16　Chrome开发者工具中imgur.com的瀑布图\n2.4.3 这个问题究竟有多严重 你必须认识到，和其他性能问题想比，HTTP协议的问题有多严重。导致网站缓慢的原因很多，从网络连接的质量到网站的大小，再到某些网站可能使用荒唐的 JavaScript文件数，再到越来越多的性能低下的广告、数据追踪服务，等等。尽管更高效和更快地下载资源可以解决一部分问题，但是很多网站还是会慢。很多网站 清楚地知道HTTP协议对网站性能的影响，所以他们实现了一些优化HTTP/1.1性能的方法。但是因为这些方法复杂且难以理解，所以很多其他的网站没有实现。\n另外一个问题是，这些解决方案也有一些限制。这些方案本身也会引入低效率的因素，随着网站内容和复杂度的增加，最终这些变通的解决方案也会失效。尽管浏览器 在每个域名上打开6个连接，并且可以增大这个数，但这么做的收益较低，这也是为什么浏览器限制并发的连接数为6个，尽管站长们可以通过域名分片的方法来突破这 个限制。\n2.5 从HTTP/1.1到HTTP/2 工作组曾经展开过新版本的工作（HTTP-NG)，该工作本应对HTTP的工作方式做完全的重新设计，但是1999年该工作被中止了。人们普遍感觉这些变化太复杂，无法 推广。\n2.5.1 SPDY HTTP-NG尝试解决HTTP/1的多种问题，而SPDY的主要目标是解决HTTP/1.1的性能问题。它引入了一些关键的概念来解决HTTP/1.1的问题：\n流多路利用 —— 请求和响应使用单个TCP连接传输数据，它们被分成不同的数据包，以流的方式分组。 请求优先级 —— 在同时发送所有请求时，为了避免引入新的性能问题，引入了请求优先级的概念。 HTTP首部压缩 —— HTTP体早就可以压缩了，现在首部也可以压缩了。 SPDY在HTTP层实现了TCP的相关概念，所以它可以同时传输不同的HTTP消息。\n服务器推送这种高级功能，允许服务器返回额外的资源。如果你请求主页面，服务器可以在主页面的请求中推送所需要的CSS文件内容。这种方式可以节省浏览器再次 发送CSS请求的时间，也能避免将critical CSS变为行内样式带来的复杂度。\n图2.17　自HTTP/2发布以来，SPDY的支持率下降\n2.5.2 HTTP/2 我想要强调的是，HTTP/2已经向你走来，请尽情使用它。它已经在实际应用中得到验证，可以显著提高性能，而且它解决了本章中描述的HTTP/1.1的问题。\n2.6 HTTP/2对Web性能的影响 2.6.1 展示HTTP/2能力的绝佳示例 作者的网站\n图2.18　HTTP、HTTPS、HTTP/2性能测试\n图2.19　HTTPS测试的瀑布图。忽略第18行，其是个302响应。\n图2.20　HTTP/2测试的瀑布图\n图2.21　HTTP/2下的延迟和瀑布图\n2.6.2 对HTTP/2提升性能的期望 如果网站还有其他性能问题，那么切换到HTTP/2后可能看不到任何性能提升，这也意味着HTTP/1.1的低效率对这些网站来说问题不大。\n对于一些网站，还有两个原因会导致使用HTTP/2没什么改善。\n第一个原因是这些网站已经优化得足够好了——使用2.2节中提到的变通办法，由HTTP/1带来的缓慢问题比较少。 其他的性能问题远超HTTP/1带来的影响。 让HTTP/2变慢的其他情况还是网络丢包\n表2.2　HTTP/2可能给Amazon带来的提升\n加载时间指页面发起onload事件的时间 —— 通常指所有的CSS和阻塞式JavaScript加载完成的时间。 首字节时间指从网站收到第一个字节的时间。通常，此响应是第一个真正的响应，不是重定向。 开始渲染时间指页面开始绘制的时间。此指标是一项关键性能指标，因为如果用户没有看到正在访问的页面有更新，他们可能会离开。 视觉完整时间指页面停止变化的时间，通常在初始加载时间之后很久，异步的JavaScript可能还在更新页面。 speed index为由WebPagetest计算的页面每部分加载的平均时间，以ms为单位。 图2.22　通过HTTP/1加载Amazon主页的一个副本\n图2.23　通过HTTP/2加载Amazon主页的一个副本\n2.6.3 HTTP/1.1的一些性能变通方法可能是反模式 例如，如果网站使用域名分片并强制使用多个连接，则无法享受使用单个TCP连接加载网站带来的性能提升。HTTP/2使得在默认情况下创建一个高性能网站变得更加 简单。\n然而，事实并非如此简单，，在HTTP/2的应用更加广泛之前，完全放弃这些技术可能为时尚早。在客户端，尽管有强大的浏览器支持，一些用户仍会使用HTTP/1.1。 他们可能正在使用较旧的浏览器，或通过尚不支持HTTP/2的代理（包括防病毒扫描程序和公司代理）进行连接。\n总结 HTTP/1.1存在一些根本的性能问题，特别是在获取多个资源时。 对于这些性能问题有多种变通的解决方法（使用多个连接、域名分片，以及使用精灵图等），但它们有其自身的缺点。 可以通过WebPageTest等工具生成瀑布图，从中很容易看到性能问题。 SPDY旨在解决这些性能问题。 HTTP/2是SPDY的标准化版本。 并非所有性能问题都可以通过HTTP/2解决。 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC1%E9%83%A8%E5%88%86-%E5%90%91http2%E9%9D%A0%E6%8B%A2/%E7%AC%AC2%E7%AB%A0-%E9%80%9A%E5%90%91http2%E4%B9%8B%E8%B7%AF/","summary":"2.1 HTTP/1.1和当前的万维网 图2.1 网站加载内容平均大小（2014年—2018年） 表2.1 美国访问量排名前10网站 2.1.1 HTTP/1.1根本","title":"第2章 通向http2之路"},{"content":"1.1 万维网的原理 HTTP是访问远程Web应用和资源的关键技术。\n1.1.1 因特网与万维网 因特网(Internet)和万维网(World Wide Web或Web)的区别\n因特网是使用IP（Internet Protocol，因特网协议）连接在一起实现消息传递的计算机构成的网络。因特网上有很多服务，包括万维网，以及电子邮件、 文件共享、因特网电话等。 因此万维网（注意，是World Wide Web，简称Web）只是因特网上的一种服务形式，但其却是人们最常看到的形式，因为人们经常会通过Web应用（如 Gmail、Hotmail和Yahoo!）来收发邮件。我们日常所说的上网，既可以理解为上万维网，也可以理解为上因特网。 Tim Berners-Lee当初发明万维网时，一共创造了三项核心技术\nHTTP URL HTML 1.1.2 打开网页时会发生什么 假设我们打开浏览器访问www.google.com。在接下来的几秒钟内，会发生下面这些事情\n图1.1　浏览器请求网页时的典型交互过程\n由于因特网是全球性的，所以大公司通常会把服务器部署在世界各地。我们在向DNS查询IP地址时，通常会得到一个距离你最近的服务器的IP地址，以便你能快 速访问。\n怎么没有IPv5? IP包的前4位表示版本，理论上限是15个版本。在被广泛使用的IPv4以前，出现过0～3共4个实验性版本。但是，直到第4版，这几个版本一直没有被标准化（参 见: https://tools.ietf.org/html/rfc760 , 这个协议后来被升级和替换了，见 https://tools.ietf.org/html/rfc791 )。此后，第5个版本被 指定为Internet Stream Protocol，其主要在实时音频和视频流应用中使用，与VoIP（Voice over IP，IP语音）后来的发展类似。可是，这个版本一直 没启用，原因之一就是存在与第4版一样的地址限制。后来第6版出来的时候，第5版的工作被叫停，于是IPv6就成了IPv4的后续版本。据说一开始由于人们以为 6也被占用了，所以IPv6最早被称为第7版(参见 https://archive.is/QqU73#selection-417.1-417.15 )。版本7、8、9同样也被占用，而且以后也不 会再使用了。假如IPv6还有后续版本，很可能会是IPv10或更高的版本。到时候，无疑还会导致与今天类似的疑惑。\n你的浏览器会自动将简短的网址（www.google.com）扩展为语法上更为准确的URL地址（http://www.google.com）。 而包含端口在内的完整URL应该是http://www.google.com:80，只不过在使用标准端口（80用于HTTP，443用于HTTPS）的情况下，浏览器会隐藏端口号。 如果使用的是非标准端口，端口就会被显示出来。比如在某些环境特别是开发环境下，HTTP可以使用8080端口，HTTPS则可以使用8443端口。\n1.2 什么是HTTP OSI模型（Open System Interconnection，开放式系统互联通信参考模型）\n图1.2　网络数据传输的分层\n1.3 HTTP的语法和历史 1.3.1 HTTP/0.9 HTTP的第一个规范是1991年发布的0.9版本。\n该规范指定\n通过TCP/IP（或类似的面向连接的服务）与服务器和端口（可选的，如果未指定端口，则使用80）建立连接。 客户端应发送一行ASCII文本，包括GET、文档地址（无空格）、回车符和换行符（回车是可选的）。 服务器使用HTML格式的消息进行响应，该消息被定义为“ASCII字符的字节流”。规范还指定，“通过服务器关闭连接来终止消息”，所以在每个请求之后 都关闭连接。 在处理错误时，规范声明：“错误响应以可读的文本显示，使用HTML语法。除了文本的内容，没有办法区分错误响应和正确响应。” 在文档结尾处，规范指出：“请求是幂等的。服务器不需要在断开连接后存储关于请求的任何信息。”本规范为我们提供了HTTP的无状态特性，这是一把双刃 剑，有利（这很简单）也有弊（因为必须附加HTTP cookies等技术以允许状态跟踪，这对于复杂的应用程序是必需的）。 HTTP/0.9可能仅有的指令\nGET /section/page.html↵ 1.3.2 HTTP/1.0 HTTP/1.0新增了一些关键特性\n更多的请求方法。除了先前定义的GET方法，新增了HEAD和POST方法。 为所有的消息添加HTTP版本号字段。此字段是可选的，为了向后兼容，默认情况下使用HTTP/0.9。 HTTP首部。它可以与请求和响应一起发送，以提供与正在执行的请求或发送的响应相关的更多信息。 一个三位整数的响应状态码，（例如）用来表示响应是否成功。此状态码还可以用来表示重定向请求、条件请求和错误状态 HTTP/1.0旨在记录现实世界中多数Web服务器上已经发生的事情，而不是定义新的功能/语法。\nHTTP/1.0的方法\nGET方法与HTTP/0.9中的基本相同，但是新增的首部允许客户端发送条件GET（仅当在客户端上次请求之后，资源发生变化时，才请求资源内容；否则，告诉 客户端资源没变化，继续使用旧的副本）。此外，用户可以使用GET方法获取更多的资源，而不仅仅是超文本文档，比如使用HTTP下载图像、视频或其他 类型的媒体内容。 HEAD方法允许客户端获取资源的所有元信息（例如HTTP头）而无须下载资源本身。 POST方法允许客户端发送数据到Web服务器。也就是说，POST方法允许将内容作为HTTP请求的一部分从客户端发送到服务器，这表示 HTTP请求终于和HTTP响应一样，拥有了正文部分。 GET方法允许将数据包含在URL尾部指定的查询参数中发送，通常放在?字符之后。 URL受到长度和内容方面的限制（例如，无法发送二进制数据），并且某些机密数据（密码、信用卡数据等）也不应出现在URL中，因为很容易就可以在屏幕和 浏览器历史记录中看到这些数据。 POST方法通常是一种更好的数据发送方式，其中的数据也不是那么显而易见（尽管在通过透明的HTTP而不是安全的HTTPS发送时仍应小心）。 是GET请求是幂等的，而POST请求不是。 HTTP请求首部\n没有首部的情况\n可以发送具有相同名称的多个首部\n等于\n一个经典的HTTP/1.0 GET请求\nHTTP响应状态码\n表1.1　HTTP/1.0响应码\nHTTP响应首部\n1.3.3 HTTP/1.1 HTTP/1.1更像是对HTTP/1.0的调整，它没有从根本上改变协议。从0.9到1.0是一个较大的变化，增加了HTTP首部。HTTP/1.1做了进一步的改进，以便充分 利用HTTP协议（例如，持久连接、强制响应首部、更好的缓存选项和分块编码）。更重要的是，它提供了一个正式标准，后来的万维网正是基于它构筑。虽然 HTTP的基础知识很容易理解，但是里面许多错综复杂的细节、实现方式的不同，以及正式标准的缺乏使得它难以扩展。\n强制添加Host首部\n如今，很多Web服务器上面有多个网站（虚拟主机托管），所以告诉服务器要访问哪个网站和访问哪个相对URL同样重要。此功能可以通过下面的方法实现：将 HTTP请求中的URL修改为完整的包含绝对路径的URL。但如果采用这种方法，则很多现有的Web服务器和客户端都不能正常运行。所以，我们在请求首部中添加 Host来实现该功能：\n指定强制Host首部字段，而不是将相对URL更改为绝对URL，带来了一些争论。HTTP/1.1引入的HTTP代理允许通过中间HTTP服务器连接到目标HTTP服务器。 代理的语法要求所有的请求使用完整的绝对URL，但实际的Web服务器（也称为源服务器）要求强制使用Host首部。\n持久连接（也就是KEEP-ALIVE）\nHTTP/1.0服务器是支持持久连接的, 但不在HTTP/1.0规范中\n服务器像往常一样响应，但如果它支持持久连接，它会在响应中包含一个Connection: Keep-Alive首部\nHTTP/1.1不仅将持久连接添加到文档标准中，还将其作为默认行为。即使响应中没有Connection:Keep-Alive首部，也可以假定任何HTTP/1.1连接都 使用持久连接。如果服务器确实想要关闭连接，无论出于何种原因，则它必须在响应中显式包含Connection:close HTTP首部\n在此基础上，HTTP/1.1增加了管道的概念，因此应该可以通过同一个持久连接发送多个请求并按顺序获取响应。\n由于某些原因，管道化并没有流行起来，并且客户端（浏览器）和服务器对管道化的支持都很差。因此，虽然持久连接允许在同一个TCP上顺序发出多个请 求，这也是一个很好的性能改进，但大多数HTTP/1.1的实现仍然是遵循请求响应再请求再响应的模式的。当一个请求被处理时，HTTP连接被阻塞，不能用于其 他请求。\n其他新功能\nHTTP/1.1又定义了新的方法，如PUT、OPTIONS和比较少见的CONNECT、TRACE及DELETE。 更好的缓存方法。这些方法允许服务器指示客户端将资源（例如CSS文件）存储在浏览器的缓存中，以便在以后需要时重复使用。在HTTP/1.1中引入的 Cache-Control HTTP首部比HTTP/1.0中的Expires首部的选项更多。 HTTP cookies，允许HTTP维护状态。 引入字符集（如本章的一些例子所示），在HTTP响应中新增语言选项。 支持代理。 支持权限验证。 新的状态码。 尾随首部 1.4 HTTPS简介 HTTPS是HTTP的安全版本，它使用TLS（Transport Layer Security，传输层加密）协议对传输中的消息进行加密，TLS的前身是我们熟知的SSL（Secure Sockets Layer，安全套接字层）\nHTTPS对HTTP消息添加了三个重要概念\n加密——传输过程中第三方无法读取消息。 完整性校验——消息在传输过程中未被更改，因为整个加密消息已经过数字签名，并且该签名在解密之前已通过加密验证。 身份验证——服务器不是伪装的。 SSL、TLS、HTTPS和HTTP\nHTTPS使用SSL或TLS加密。SSL是由Netscape发明的。SSLv1从未在Netscape之外发布，因此第一个生产版本是1995年发布的SSLv2。1996年发布的 SSLv3解决了一些安全漏洞。 由于SSL由Netscape拥有，因此它不是正式的互联网标准，尽管它随后由IETF作为历史文档发布。SSL被标准化为TLS（传输层加密）。 TLSv1.0与SSLv3类似，但它们不兼容。 TLSv1.1和TLSv1.2分别于2006年和2008年推出，并且它们更加安全。 TLSv1.3在2018年被批准为标准。虽然还需要一些时间它才能普及，但它更安全，更高效。 在2014年，在SSLv3中发现了重大漏洞，SSLv3因此被要求停止使用，并且浏览器也停止对它的支持。从这时人们才开始大量向TLS迁移。在TLSv1.0中发 现类似的漏洞后，安全专家强烈建议使用TLSv1.1或更高版本。 HTTPS使用公钥加密，服务器在用户首次连接时以数字证书的形式提供公钥。\nHTTPS的一个重大问题是，它只保证你正在连接到该服务器，而不能保证服务器值得信任。 HTTPS站点通常在Web浏览器中显示为绿色挂锁，许多用户认为这意味着安全，但其实它仅仅意味着加密。 OpenSSL提供了一个s_client命令，可使用该命令将HTTP命令发送到HTTPS服务器，和使用Telnet类似：\n1.5 查看、发送和接收HTTP消息的工具 1.5.1 浏览器开发者工具 1.5.2 发送HTTP请求 Advanced REST Client\n1.5.3 其他工具 curl, wget, httpie, SOAP-UI, Chrome的net-internals页面, Fiddler, Wireshark\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC1%E9%83%A8%E5%88%86-%E5%90%91http2%E9%9D%A0%E6%8B%A2/%E7%AC%AC1%E7%AB%A0-%E4%B8%87%E7%BB%B4%E7%BD%91%E4%B8%8Ehttp/","summary":"1.1 万维网的原理 HTTP是访问远程Web应用和资源的关键技术。 1.1.1 因特网与万维网 因特网(Internet)和万维网(World Wide Web或Web)","title":"第1章 万维网与HTTP"},{"content":"谓词逻辑中的层级、集合论中的层级 对于EXISTS来说，层级的差别与EXISTS谓词及其参数有关，因此属于谓词逻辑中的阶。而GROUP BY中的阶与元素和集合的区别有关，因此属于集合论中的阶。\n为什么聚合后不能再引用原表中的列 Teams\n首先，我们还是以组为单位进行聚合查询。\n1 2 3 4 5 6 7 8 9 10 11 12 --以组为单位进行聚合查询 SELECT team, AVG(age) FROM Teams GROUP BY team; team AVG(age) ---- -------- A 23.3 B 34.5 C 30.0 D 25.5 那么如果我们把它改成下面这样，结果会怎么样呢？\n1 2 3 4 --以组为单位进行聚合查询？ SELECT team, AVG(age), age FROM Teams GROUP BY team; 标准SQL规定，在对表进行聚合查询的时候，只能在SELECT子句中写下面3种内容。\n通过GROUP BY子句指定的聚合键 聚合函数（SUM、AVG等） 常量 表Teams中的“age”列存储了每位成员的年龄信息。但是需要注意的是，这里的年龄只是每个人的属性，而不是小组的属性。所谓小组，指的是由多个人组成的 集合。因此，小组的属性只能是平均或者总和等统计性质的属性。\nGROUP BY的作用是将一个个元素划分成若干个子集。这样看的话，关系模型中“列”的正式名称叫作“属性”，其实也是有道理的。\n下面这条语句的错误也是相同的原因造成的。\n1 2 3 4 --错误 SELECT team, AVG(age), member FROM Teams GROUP BY team; 向小组询问姓名是不会得到回答的。如果非要在结果中包含“member”列的值，那么只能像下面这样使用聚合函数。\n1 2 3 4 --正确 SELECT team, AVG(age), MAX(member) FROM Teams GROUP BY team; MAX(member)会计算出小组成员中以字典序排序后最后一个人的姓名，因此这无疑是小组的属性。\n如果稍微扩展一下这条查询语句，我们还可以求出“小组中年龄最大的成员”，SQL语句如下所示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 SELECT team, MAX(age), (SELECT MAX(member) FROM Teams T2 WHERE T2.team = T1.team AND T2.age = MAX(T1.age)) AS oldest FROM Teams T1 GROUP BY team; team max(age) oldest ----- -------- ------ A 28 大木 B 40 山田 C 30 桥田 D 28 野野宫 这条语句的关键点有两个。\n第一个是，子查询中的WHERE子句里使用了MAX(T1.age)这样的聚合函数作为条件。我们在初学SQL时，会学到不可以在WHERE子句中使用聚合函数，但是在 本题中却是可以的。原因是，这里对外层的表T1也进行了聚合，这样一来我们就可以在SELECT子句中通过聚合函数来引用“age”列了（不能反过来在子查询 中直接引用“age”列）。 另一个是，当一个小组中年龄最大的成员有多人时，必须选出其中一个人作为代表。这个是通过子查询中SELECT子句里的MAX(member)来实现的。例如，D 小组中野野宫和鬼塚两人的年龄都是最大的，但是结果中只出现了野野宫一人。如果不使用MAX函数，那么子查询会返回多条数据，这样就会出现执行错误。 单元素集合也是集合 只有一个元素的集合，在集合论中叫作单元素集合（singleton）。一般来说，单元素集合的属性和其唯一元素的属性是一样的。\n现在的集合论认为单元素集合是一种正常的集合。单元素集合和空集一样，主要是为了保持理论的完整性而定义的。因此对于以集合论为基础的SQL来说，当然也 需要严格地区分元素和单元素集合。因此，元素a和集合{a}之间存在着非常醒目的层级差别。\n1 a ≠ {a} 这两个层级的区别分别对应着SQL中的WHERE子句和HAVING子句的区别。\nWHERE子句用于处理“行”这种0阶的对象 而HAVING子句用来处理“集合”这种1阶的对象。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-10-sql%E4%B8%AD%E7%9A%84%E5%B1%82%E7%BA%A7/","summary":"谓词逻辑中的层级、集合论中的层级 对于EXISTS来说，层级的差别与EXISTS谓词及其参数有关，因此属于谓词逻辑中的阶。而GROUP BY中的","title":"2-10 SQL中的层级"},{"content":"~告全体数据库工程师书~ NULL这个怪物最可怕的地方：一开始会让我们觉得很好用，于是在设计系统时，我们会非常自然地保留它，但当注意到问题的时候，系统已经变得非常复杂、低 效、不符合预期了，开发和维护也变得非常困难。\n为什么NULL如此惹人讨厌 在进行SQL编码时，必须考虑违反人类直觉的三值逻辑。 在指定IS NULL、IS NOT NULL的时候，不会用到索引，因而SQL语句执行起来性能低下。 如果四则运算以及SQL函数的参数中包含NULL，会引起“NULL的传播”。 在接收SQL查询结果的宿主语言中，NULL的处理方法没有统一标准。 与一般列的值不同，NULL是通过在数据行的某处加上多余的位（bit）来实现的。因此NULL会使程序占据更多的存储空间，使得检索性能变差。 对于第3个原因，我们来稍微解释一下。例如，如果四则运算中包含NULL，那么运算结果也肯定都是NULL。\n1 2 3 4 5 1 + NULL = NULL 2- NULL = NULL 3 ＊ NULL = NULL 4 / NULL = NULL NULL / 0 = NULL 并不能完全消除NULL 无法完全消除NULL的原因是它扎根于关系数据库的底层中。仅仅靠在表中所有列加上NOT NULL的约束是不够的。因为即使这样做，在使用外连接，或者SQL-99 中添加的带CUBE或ROLLUP的GROUP BY时，还是很容易引入NULL的。\n编号：使用异常编号 标志性编号, 例如性别\n使用varchar/char not null类型 1: 男性, 2: 女性, 0: 未知, 9: 不适用 名字：使用“无名氏” 一般来说，与编号相比，名字被用于聚合的频度很低，大多时候只作为冗余列使用。我们不用刻意地消除其中的NULL，但是最好还是让NULL从名字列中消失。\n数值：用0代替 转换为0。 如果一定要区分0和NULL，那么允许使用NULL。 日期：用最大值或最小值代替 当需要表示开始日期和结束日期这样的“期限”的时候，我们可以使用0000-01-01或者9999-12-31这样可能存在的最大值或最小值来处理。\n当默认值原本就不清楚的时候，例如历史事件发生的日期，或者某人的生日等，也就是当NULL的含义是“未知”的时候，这时可以允许使用NULL。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-9-%E6%B6%88%E7%81%ADnull%E5%A7%94%E5%91%98%E4%BC%9A/","summary":"~告全体数据库工程师书~ NULL这个怪物最可怕的地方：一开始会让我们觉得很好用，于是在设计系统时，我们会非常自然地保留它，但当注意到问题的时","title":"2-9 消灭NULL委员会"},{"content":"适当地抛开命题的真假吧 历史上最早提出三值逻辑（three-valued-logic）体系的是波兰的著名逻辑学家卢卡西维茨（Jan Lukasiewicz, 1878—1956）。\n卢卡西维茨考虑的“可能”这一真值的本质，其实是对未来不确定性的描述，丝毫没有Codd提出的“不适用”的含义。 第二个论点突破了一个命题只能有一个固定真值的观念，开拓出了新的思路，认为命题的真值可能会随时间发生“可能”→“真”，或者“可能”→“假”这样的变 化。 逻辑学的革命 除了三值逻辑，还有布劳威尔（Luitzen Egbertus Jan Brouwer）和海廷（Arend Heyting）等人创立的直觉主义逻辑学。三值逻辑通过导入第三个真值， 从语义学的角度对二值逻辑发起了挑战；而直觉主义逻辑从语法学的角度对二值逻辑发起了挑战。\n人类的逻辑学 在这种新的逻辑学中，命题的真值不仅有“真”和“假”，还可以有“无意义”“当前未知”“矛盾”等反映各种认知的值。于是诞生了三值逻辑，而且允许三个以上的真 值的多值逻辑学（many-valued logic）的研究也在进行中。没有神的逻辑学——人类的逻辑学诞生了。\n数据库的使用者当然是人类，而不是神。因此，数据的表达方式也应该基于有限而且不完善的人类的认知，而不是神的完美无缺的认知。这就是关系数据库采用 三值逻辑的原因。\n但是，这种面向人类的思维方式是一把双刃剑。确实，通过采用三值逻辑（主要是NULL和unknown），正如Codd所说，关系数据库变得非常接近人类的认知， 而且具有非常灵活的表达能力。但讽刺的是，人类又不得不引入许多不太直观的奇怪的逻辑运算。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-8-%E4%BA%BA%E7%B1%BB%E7%9A%84%E9%80%BB%E8%BE%91%E5%AD%A6/","summary":"适当地抛开命题的真假吧 历史上最早提出三值逻辑（three-valued-logic）体系的是波兰的著名逻辑学家卢卡西维茨（Jan Lukasiewicz, 1878—","title":"2-8 人类的逻辑学"},{"content":"实际工作中的递归集合 冯·诺依曼究竟是如何想到“用集合定义自然数”这样非同寻常的方法的呢？\n冯·诺依曼的前辈们 冯·诺依曼提出用递归集合定义自然数，是在1923年发表的论文《关于超限序数的引入》中。这是他发表的第二篇论文。从论文标题中的“序数”可以看出，实际 上冯·诺依曼提出的与其说是“自然数的定义”，还不如说是“序数的定义”。序数可以理解成自然数的别称，即在强调0的下一个是1,1的下一个是2,2的下一个是3 ……这种顺序时的名称（相反，在不强调顺序时，自然数有“基数”这样一个别称）。\n冯·诺依曼提出的自然数的递归定义\n各种自然数的递归定义\n按照冯·诺依曼方法，集合中的元素个数等于想要定义的数。\nSQL可以通过COUNT函数计算出元素个数，与冯·诺依曼方法的定义方式兼容性很好。\n相反，策梅洛方法不太适合在SQL中使用（SQL本来就不使用括号表示集合）。 数是什么 皮亚诺公理\n存在起到0的作用的东西 没有在0前面的自然数 每一个自然数a，都具有后继自然数（successor） 像这样得出某个自然数的后继自然数的函数叫作后继函数，写作suc(x)。于是有suc(5) ＝6、suc(17)＝18。因此，使用后继函数生成自然数时，可以像下面 这样嵌套使用。\n1 2 3 4 5 6 7 0 = 0 1 = suc(0) 2 = suc(suc(0)) 3 = suc(suc(suc(0))) · · · 这里需要着重理解的是，我们并没有指定该后继函数的内部实现。无论什么样的内部实现，只要能够生成下一个自然数就可以，这是一个比较宽松的条件。\n冯·诺依曼方法和弗雷格方法的后继函数：suc(a) = a∪{a} 策梅洛方法的后继函数：suc(a) = {a} 自然数的定义是由皮亚诺列举的5个条件给出的，冯·诺依曼等人只是根据皮亚诺公理生成了自然数而已。这样看来，冯·诺依曼等人的工作可以称为“构建”。\n构建自然数并不一定要使用集合。在计算机科学相关领域还有一种使用λ演算函数来构建自然数的方法。\n使用λ演算构建的自然数被阿隆佐·邱奇（Alonzo Church）以自己的姓氏命名为了“邱奇数”。不过，虽然取名叫“数”，其本质却是输入输出均为函数的高阶 函数。 0:=λ fx.x 1:=λ fx.fx 2:=λ fx.f(fx) 3:=λ fx.f(f(fx)) SQL的魔术与科学 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-7-sql%E5%92%8C%E9%80%92%E5%BD%92%E9%9B%86%E5%90%88/","summary":"实际工作中的递归集合 冯·诺依曼究竟是如何想到“用集合定义自然数”这样非同寻常的方法的呢？ 冯·诺依曼的前辈们 冯·诺依曼提出用递归集合定义自然数","title":"2-7 SQL和递归集合"},{"content":"不管是面向过程语言还是文件系统，都是将复杂的东西看成是由简单单元组合而成的——这是一种还原论的思维方式。\nSQL中没有赋值或者循环的处理，数据也不以记录为单位进行处理，而以集合为单位进行处理。SQL和关系数据库的思维方式更像是一种整体论的思维方式。\n1．用CASE表达式代替IF语句和CASE语句。SQL更像一种函数式语言 之所以叫它CASE“表达式”而不是CASE“语句”（statement），是因为CASE表达式与1+(2-4)或者(x＊y)/z一样，都是表达式，在执行时会被整体当作一个值 来处理。既然同样是表达式，那么能写1+1这样的表达式的地方就都能写CASE表达式，而且因为CASE表达式最终会作为一个确定的值来处理，所以我们也可以把 CASE表达式当作聚合函数的参数来使用。\n1 2 3 4 5 \u0026#39;Lisp中使用cond函数进行条件分支 cond( ((= x 1)\u0026#39;x是1\u0026#39;) ((= x 2)\u0026#39;x是2\u0026#39;) (t \u0026#39;x是1和2以外的数’)) 1 2 3 4 5 --SQL中使用CASE表达式进行条件分支 CASE WHEN x = 1 THEN\u0026#39;x是1\u0026#39; WHEN x = 2 THEN\u0026#39;x是2\u0026#39; ELSE \u0026#39;x是1和2以外的数’ END 参考→1-3节\n2．用GROUP BY和关联子查询代替循环 SQL中没有专门的循环语句。虽然可以使用游标实现循环，但是这样的话还是面向过程的做法，和纯粹的SQL没有关系。SQL在设计之初，就有意地避免了循环。\n参考→1-6节、 1-7节\n3．表中的行没有顺序 将表看成文件的最大问题是会误认为表中的行是有顺序的。\n在关系数据库中，从表中读取数据时的的确确会发生这样的情况。读出的数据不一定是按照INSERT的顺序排列的，因为SQL在处理数据时不需要它们这样。 SQL在处理数据时可以完全不依赖顺序。 在定义视图时指定ORDER BY子句（如果某种数据库支持这种写法，那么它本身就有问题），或者轻易地使用Oracle中的rownum这样依赖具体实现的 “行编号”列，都是典型的依赖顺序的不好的写法。 参考→1-4节、 1-9节、 1-10节\n4．将表看成集合 实际上，一张表并非对应一个文件，读取表时也并不是像读取文件一样一行一行地进行的。\n参考→1-2节\n5．理解EXISTS谓词和“量化”的概念 在SQL中，谓词逻辑的主要应用场景是“将多行数据作为整体”处理的时候。谓词逻辑中具有能将多个对象作为一个整体来处理的工具“量化符”。对于SQL来说， 量化符就是EXISTS谓词。\n参考→1-8节、 1-9节\n6．学习HAVING子句的真正价值 HAVING子句是集中体现了SQL之面向集合理念的功能。\n参考→1-4节、 1-10节\n7．不要画长方形，去画圆 传统的结构图(structure diagram), 数据流图(data flow diagram)用于描述动态数据, 而SQL只是用来描述所需数据的查询条件的，并不能描述动态的 处理过程。\n能够准确描述静态数据模型的标准工具是维恩图\n能否深刻理解并灵活使用嵌套子集（=递归集合），可以说是衡量SQL编程能力是否达到中级水平的关键。\n参考→1-4节、 1-7节\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-6-%E4%BB%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/","summary":"不管是面向过程语言还是文件系统，都是将复杂的东西看成是由简单单元组合而成的——这是一种还原论的思维方式。 SQL中没有赋值或者循环的处理，数据","title":"2-6 从面向过程思维向声明式思维, 面向集合思维转变的7个关键点"},{"content":"写在前面 关系数据库中不存在编程语言中一般被称为“指针”的物理性数据结构。但是严格来说，它其实是存在的，只不过被隐藏了，因而对用户不可见。\n不过，如果这么说，可能会有人列举出用户可以使用的指针，比如Oracle中的rowid或PostgreSQL中的oid来反对。确实，用户可以使用这些指针，但是它们 都是个别数据库厂商违反SQL标准而进行的扩展，而标准SQL一直在努力摆脱指针。\n关系模型是为摆脱地址而生 在关系模型中，我们通过完全关联的编址来代替位置编址。\n在关系数据库中，每个数据可以借助于关系名、主键的值以及属性名唯一地编址。这种形式的关联地址使用户（是的，也使得程序员）把以下两点留给系统来 完成： 确定要插入数据库的一块新信息的放置细节； 当检索数据时选择适当的存取通路。 这里说的“地址”不仅包括指针操作的地址，还包括数组下标等。 数据库中的关系无论如何都不能具有指针的那些属性。众所周知，关系数据库出现以前，数据库中充满了指针的概念，为了访问到想要的数据必须借助很多指 针。对这些数据库进行应用程序编程时很容易出现错误，而且数据不能由终端用户直接访问，这些问题都是指针导致的。 放弃地址的深刻意义是，通过放弃掉系统中没有意义的东西，创造出一个易于人类理解的有意义的世界。\n所以写代码也要偏向于易读而不是易写.\n编程中泛滥的地址 是的，变量——它正是编程语言中地址的化身。所有的变量都由没有实际意义的地址管理着。而且，要想在面向过程语言中处理数据，只能通过把数据赋值给变量。 只要使用变量，就无法逃出地址的魔咒。反过来说，之所以SQL能成为不依赖于地址的自由的语言，也是因为它不使用变量。\n不曾远去的老将——J.Backus的梦想 声明式语言SQL和函数式语言Lisp在当今的编程世界里都处于边缘，而且从来没有成为主流语言过。但是最近SQL中增加了许多丰富的功能，渐渐到了需要重新 评价SQL和函数式语言优点的时候了。“地址的解放战争”最终有怎样的归宿，现在还不好预测，但是笔者期待能够在不久的将来写一写它。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-4-%E5%9C%B0%E5%9D%80%E8%BF%99%E4%B8%80%E5%B7%A8%E5%A4%A7%E7%9A%84%E6%80%AA%E7%89%A9/","summary":"写在前面 关系数据库中不存在编程语言中一般被称为“指针”的物理性数据结构。但是严格来说，它其实是存在的，只不过被隐藏了，因而对用户不可见。 不过","title":"2-4 地址这一巨大的怪物"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/di/","summary":"原文","title":"Go工程化 - 手摸手带你理解依赖注入"},{"content":"了解啥是libcontainer、runc、containerd、CRI、OCI\n原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9Acontainerd%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"了解啥是libcontainer、runc、containerd、CRI、OCI 原文","title":"一文搞定Containerd的使用"},{"content":"从运算角度审视集合 “封闭性”（closure property）, 这个性质简单地说就是“运算的输入和输出都是关系”\n多亏了关系的封闭性，这些运算的输出才可以直接作为其他运算的输入。 与unix管道类比\n按照对四则运算是否封闭，我们可以把集合分为下面几类。\n群（group）：对加法和减法（或者乘法和除法）封闭 环（ring）：对加法、减法、乘法封闭 域（filed）：对加法、减法、乘法、除法封闭，即可以自由进行四则运算 如果要举个关于“群”的具体示例，那么最简单的就是整数集了，因为任何两个整数之间进行加法或者减法运算，结果一定还是整数。整数集也是环，但却不是域\n比如1÷2的结果是小数，不满足封闭性。 如果将整数集扩展成有理数集或者实数集的话，那么结果就满足域的条件了。 实践和原理 关系支持加法（UNION）运算和减法（EXCEPT）运算，因此满足群的条件。关系还支持相当于乘法运算的CROSS JOIN，所以也满足环的条件。关系中没有除法 运算符，所以不满足域的条件。\nSQL中没有除法运算符。但是我们在1-4节中说过，除法运算的定义是有的。因此，关系也满足域的条件。 Theory is practical.\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-3-%E5%BC%80%E5%A7%8B%E4%BA%8E%E5%85%B3%E7%B3%BB-%E7%BB%93%E6%9D%9F%E4%BA%8E%E5%85%B3%E7%B3%BB/","summary":"从运算角度审视集合 “封闭性”（closure property）, 这个性质简单地说就是“运算的输入和输出都是关系” 多亏了关系的封闭性，这些运算","title":"2-3 开始于关系, 结束于关系"},{"content":"为什么不叫“表”模型 Codd:\n当初思考关系模型的时候，从事数据处理工作的人们有一种普遍的观点，即认为多个对象之间的关系（或者关联）必须通过一种链接数据结构来表示。为了纠 正这个误解，我特意选择了“关系模型”这个词作为名字； 与关系相比，表的抽象度更低，容易给人可以像数组一样操作的印象，而n元关系就不会了。还有，数据库表中数据的内容和行的顺序没有关系，在这一点上表 更容易带来误解。尽管表有这样的小缺点，但依然是表达关系概念时最重要的手段。毕竟表的概念人们更熟悉一些。 关系的定义 数据库采用了关系模型，因此才被称为关系数据库。\n关系模型之父Codd本人也表示时不时地会收到这样的疑问，并给出了前文中的两个解释。\n其中(1)与现在的数据库工程师没有什么关系。“链接数据结构”指的是使用指针连接数据的链表结构，这是分层模型和网状模型数据结构流行的时期特有 的。 而(2)现在仍然有思考的价值，因为它触及了“关系”这一概念的本质。简单概括的话，关系和表看起来很相似，实质却不相同。 关系和表比较典型的区别。\n关系中不允许存在重复的元组（tuple），而表中可以存在。即，关系是通常说的不允许存在重复元素的集合，而表是多重集合（multiset） 关系中的元组没有从上往下的顺序，而表中的行有从上往下的顺序 关系中的属性没有从左往右的顺序，而表中的列有从左往右的顺序 关系中所有的属性的值都是不可分割的，而表中列的值是可以分割的。换句话说，关系中的属性满足第一范式，而表中的列不满足第一范式 元组和属性是关系模型中较为正式的术语，与非正式的日常用语有以下对应关系\n关系的定义可以用下面这样一个公式来给出。\n关系用符号R表示，属性用符号Ai表示，属性的定义域用符号Di表示 R ⊆（D1×D2×D3 · · · ×Dn） 这个公式读作“关系R是定义域D1, D2, …, Dn的笛卡儿积的子集”。\n我们假设属性a1可以取1种值，属性a2可以取2种值，属性a3可以取3种值。各属性对应的定义域分别叫作d1、d2、d3。\nd1 = { 1 } d2 = { 男 , 女 } d3 = { 红 , 绿 , 黄 } 使用这3个定义域生成关系时，最大的元组数是多少？答案是6。计算方法很简单，就是1×2×3＝6。\n关系就是定义域间的组合?\n定义域的忧虑 一段用Pascal语言写的代码\ntype Day = { Sun, Mon, Tue, Wed, Thu, Fri, Sat }; var Today : Day; 现在的DBMS是具备简单的定义域功能的，只不过比较初级. 这些定义域主要是字符型、数值型等叫作标量类型的数据类型。因为它们对属性的取值范围有约束， 所以尽管有局限性，但是标量类型也是定义域的一种。\n关系值和关系变量 值（value）和变量（variable）是很容易混淆的概念，在讨论和数据库相关的话题时，两者经常会被混用。一般提到“关系”这个词时，如果不加特殊说明， 指的都是“关系变量”。而关系值指的是关系变量在某一时刻取的值。实际上或许我们也可以说，值就是变量的时间切片（time-slice）。\n这与数学或者编程语言中变量和值之间的关系是一样的。在编程语言中，整数型变量存储整数值。同样，在关系模型中，关系型变量存储关系值。理解了这一点， 我们应该就不会像刚接触这些概念时那样觉得不可思议了。关键在于我们在学校中学到的变量和值基本上都是标量型的单一类型值，所以只是不习惯把关系 这样的复合型结构看成一个值。FROM子句中写的表名正是变量的名称\n存在“关系的关系”吗 这个问题可以替换成“存在递归的关系吗”或者“定义域中可以包含关系吗”。\n“关系的关系”在逻辑上是可能存在的。但是，为此必须定义能够使定义域包含关系的谓词，而且如果再考虑对关系的量化，就需要实现二阶谓词逻辑，因此实现 “关系的关系”非常困难。\n因此这里我们只简单地了解一下描述这种现实中还不存在的“关系的关系”的关系模型大概是什么样子。首先请看一个具体的表。\n如果接受了这种“关系的关系”，那么自然就能进一步扩展到“关系的关系的关系”或者“关系的关系的关系的关系”这样更高阶的关系。当然它们也都是嵌套式的递 归结构。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/","summary":"为什么不叫“表”模型 Codd: 当初思考关系模型的时候，从事数据处理工作的人们有一种普遍的观点，即认为多个对象之间的关系（或者关联）必须通过一种链接数","title":"2-2 为什么叫关系模型"},{"content":"8.1 为什么中国没有本土大型连锁便利店 电商改变了中国零售行业的发展路径 图8-1 2021年我国消费品零售渠道分布\n电商的出现改变了我国零售行业的发展路径。\n国外零售行业的发展路径从传统零售开始，发展出连锁零售（A\u0026amp;P等），进化到现代大型商超（沃尔玛等），再到仓储店（开市客等）与便利店（7-11等）， 最后发展出电商（亚马逊等）。 而国内零售行业的发展路径，是在连锁零售尚未发展完善时，就出现了电商；电商出现后不久就实现了极其迅速的增长，并且一定程度上挤压了传统线下零售 的生存空间。 图8-2 我国网民整体及手机网民规模\n图8-3 我国电商行业与全渠道消费品零售额增速\n图8-4 我国现代线下零售、传统线下零售和电商的市场份额变化\n图8-5 我国超市、便利店与消费品零售业整体增速对比\n电商改变渠道拓扑结构 电商的变革并不是单纯把交易场景从线下搬到线上、省去房租和人工费用、提升经营效率、把流通成本做到更低。以上变化都只是表象，电商改变的是整个交易 的思维和逻辑，并给商家集中度、品类结构等方面带来种种变化。\n商家的边界变得不同，线上商家的马太效应会越来越高 线下零售是区域竞争，每家店的辐射范围都不同。对于线下零售而言，门店的“点位”至关重要。 线上生意就不同了。网店的展现对于全国各地的消费者一视同仁，消费者距离某家网店的距离都是一样的。 适合线上、线下销售的品类会变得不同 电商适合的消费类型是标准化、重复消费的大众商品. 比如，数码、护肤品等产品就适合线上销售，因为它们是标准化且重复消费的产品； 线下渠道适合具备一定体验感、即时性需求的品类。生鲜、软饮、奢侈品就适合线下消费，因为生鲜、软饮对即时性有要求，奢侈品对消费过程中的体验 有要求。 图8-6 2020年各品类电商渗透率\n电商变革改变了中国零售的发展路径 电商难以解决“最后一公里”履约的成本和时效问题，其实并不太适合销售生鲜产品。所以在超市、便利店发展比较一般的情况下，生鲜就这样被留在了农贸市场。\n图8-7 2019年部分国家生鲜分销渠道\n8.2 为什么“美国的淘宝”eBay争不过亚马逊 图8-8 2020年中国电商平台市场份额\n美国的电商市场格局和我国很不一样\n美国电商的市场集中度远远低于我国。 品牌自营电商、连锁超市电商很难在我国占据一席之地，但在美国可以 头部平台的经营模式有所不同，我国排名第一的阿里巴巴是一个平台模式的电商，而美国排名第一的亚马逊是一个自营模式的电商。 图8-9 美国2020年电商前10名销售额\n中美电商在历史、环境上的差异，还导致了品牌和电商平台间话语权的不同。在渠道和品牌的博弈过程之中，中国电商平台的地位要比美国电商平台的地位更强。\n其一，流量高度集中于少数头部电商平台，这类平台的分发方式较为中心化，拥有较强的话语权。 其二，由于我国广阔的国土面积、多样的地域特色、复杂的城市层级，现阶段品牌方很难实现完全的渠道自主、数据自主，或多或少需要依附于头部电商平台。 因此，未来品牌与平台的博弈将始终存在。对于品牌来说，研究如何在电商平台上获取、转化、留存流量至关重要。 8.3 再论马太效应：社交电商、熟人经济、推荐算法使电商马太效应降低了吗 淘系平台转向信息流推荐之后，仍然由大商家主导；熟人电商发展势头一直比较一般；社交种草、直播带货主要还是肥了头部达人……这是为什么？\n电商平台转向信息流推荐并没有阻断马太效应形成的链条。推荐算法也会给头部商品较大的权重倾斜，使销量高的商品得到更多的曝光。 熟人经济很可能是一个伪命题。熟人之间互相推荐商品非常有效，但熟人关系可能不适合用来做电商。从熟人手上买东西，如果买贵了、买回来不好用，非常 不好处理，买家向卖家索要退款或其他售后的过程很可能损害朋友关系。 大多数直播带货实质上并非兴趣电商，而是折扣电商。这类电商显然与“去中心化”没有任何关系。主播成交额越高能拿到的折扣越高，拿到的折扣越高成交额 越高，这分明是另一个马太效应循环。 社交种草的直接收益通常并不明显，中腰部达人生态不佳。用户会对过于频繁的广告产生反感 现在的电商环境仍然呈现头部集中的态势。在一定程度上实现了“去中心化”的其实是抖音，但这个“去中心化”一定程度上建立在平台设法使用推荐算法抑制中心 化趋势的基础之上。\n8.4 结语 未来商家有可能持续加大在电商平台上的投入，使得部分品类在电商平台的费用率高于线下渠道。 对于电商平台来说，其未来的广告货币化率仍有可观的提升空间，并带动平台利润持续提升。 对于能够线上化的品类，我们可以投资线上渠道做得不错的品牌和商家；对于餐饮、旅游这类消费，继续押注线下消费的发展也是一个不错的选择。 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC8%E7%AB%A0-%E6%B8%A0%E9%81%93%E5%8F%98%E9%9D%A9%E7%9A%84%E7%9C%9F%E7%9B%B8/","summary":"8.1 为什么中国没有本土大型连锁便利店 电商改变了中国零售行业的发展路径 图8-1 2021年我国消费品零售渠道分布 电商的出现改变了我国零售行业的发展","title":"第8章 渠道变革的真相"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/mktindex/","summary":"主页","title":"魔镜市场情报"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/mobduos/","summary":"主页","title":"多多情报通"},{"content":"写在前面 关系模型的创始人E.F.Codd（1923—2003）。\n下面的内容主要依据C.J.Date的著作The Database Relation Model。\n两篇论文 Codd写了两篇与关系模型相关的论文。第一篇是写于1969年的《大型数据库中关系存储的可推导性、冗余与一致性》。遗憾的是，这篇论文发表在IBM公司内部 期刊IBM Research Report上了，因此并没有引起外界的注意。\n在接下来的1970年，Codd又在权威学术杂志Communications of ACM上，以《大型共享数据库的关系模型》为题发表了第二篇论文。至此，关系模型 真正地问世了。现在人们读到的论文基本上都是这一篇。\nCodd的贡献 Codd这两篇论文的主要贡献可以归纳为以下3点。\n定义了关系运算（relational calculus）。// todo 定义了关系代数（relational algebra）。选择、投影、并、交等8种运算 采用谓词逻辑作为数据库操作的基础。逻辑体系 1969年——一切从这里开始 1969年的论文不仅给出了关系的定义，还考虑到了主键的概念, Codd此时提出的“主键”这个词并非我们现在所说的“主键”，而更像是“超键”。因为Codd允许主 键存在冗余，而且一张表中可以存在多个主键。1970年的论文又追加了“外键”的概念。\n1969年的论文中有一句非常重要的话\n将数据看作关系后，有可能创造出以二阶谓词逻辑为基础的用于查询一般数据的子语言。 由于关系数据库以谓词逻辑作为基础，逻辑学的研究成果才可以直接应用于数据管理系统。\n“Codd最具决定性的重要思想就是把数据看成关系的集合，然后再把关系看成（真）命题的集合。这样，在创造出基于谓词逻辑的语言之后，就能直接使用这 种语言查询数据了”——C.J.Date的这句评论说到了关键点上。 1970年——远离地址 在Codd提出关系模型之前，数据库系统的主流模型是分层模型和网状模型。这两种模型在查找数据时都需要使用索引（指针），因此用户必须知道数据的存储位 置，抽象程度非常低。正因如此，Codd的首要目标就是将用户从这种毫无意义的烦恼中解放出来。于是“数据库中不再包含索引，字段间也没有顺序了”。\n范式 1970年的论文除了强调数据的独立性之外，还有一个重要的变化，那就是出现了范式的概念。\n“按照第一范式进行规范化的关系”其实就是“定义域只包含原子值（atomic value）的关系”（Codd）。这里所说的原子值，我们今天称为标量值。它指的是 不能再进行细分的最小单位的数据结构\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-1-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8E%86%E5%8F%B2/","summary":"写在前面 关系模型的创始人E.F.Codd（1923—2003）。 下面的内容主要依据C.J.Date的著作The Database Relation Model。 两篇论文 Cod","title":"2-1 关系数据库的历史"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/feigua/","summary":"主页","title":"飞瓜数据"},{"content":"","permalink":"https://jdxj.github.io/posts/data/coonav/","summary":"","title":"小葫芦大数据"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/bihukankan/","summary":"主页","title":"壁虎看看"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/qianzhan/","summary":"主页","title":"前瞻产业研究院"},{"content":"写在前面 下面两张卡片上各画了几个圆圈，哪个更容易数清楚呢？\n编程行为就像是一种沟通方式。因此，对编程风格的研究也可以看成是对提高系统开发中沟通效率的方法的研究（因此在只有一个人编程的项目中，很难注意到 代码风格的重要性）。\n表的设计 名字和意义 名称既包括用来指代具体东西的固有名称，也包括用来指代概念或者集合的一般名称。 地址没有指代任何具有实际意义的概念或者事物。 命名时允许的字符有以下3种\n英文字母 阿拉伯数字 下划线“_” 属性和列 在数据库中，列代表的是“属性”，因此应该具有一贯性。\n有些时候指代的是年龄，有些时候指代的是体重, 这种设计是不允许的 编程的方针 注释 就SQL而论，最好还是写注释。这样说主要有两个原因：\nSQL是声明式语言，即使表达同样的处理过程，逻辑仍然比面向过程语言凝练得多； SQL很难进行分步的执行调试。分析代码时主要需要进行桌面调试。 注释的写法有以下两种\n1 2 3 4 -- 单行注释 -- 从SomeTable中查询col_1 SELECT col_1 FROM SomeTable; 1 2 3 4 5 6 /＊ 多行注释 从SomeTable中查询col_1 ＊/ SELECT col_1 FROM SomeTable; SQL语句中不能有空行，却可以像下面这样加入注释。\n1 2 3 4 5 6 SELECT col_1 FROM SomeTable WHERE col_1 =\u0026#39;a\u0026#39; AND col_2 =\u0026#39;b\u0026#39; -- 下面的条件用于指定col_3的值是’c’或者’d\u0026#39; AND col_3 IN (\u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;); 注释也可以与代码在同一行\n1 2 SELECT col_1 -- 从SomeTable中查询col_1 FROM SomeTable; 缩进 1 2 3 4 5 6 7 8 9 10 11 12 13 14 --√好的示例 SELECT col_1, col_2, col_3, COUNT(＊) FROM tbl_A WHERE col_1 =\u0026#39;a\u0026#39; AND col_2 = ( SELECT MAX(col_2) FROM tbl_B WHERE col_3 = 100 ) GROUP BY col_1, col_2, col_3 1 2 3 4 5 6 7 8 9 --×坏的示例 SELECT col_1, col_2, col_3, COUNT(＊) FROM tbl_A WHERE col_1 =\u0026#39;a\u0026#39; AND col_2 = ( SELECT MAX(col_2) FROM tbl_B WHERE col_3 = 100 ) GROUP BY col_1, col_2, col_3 比起①这种所有关键字都顶格左齐的写法，②这种让关键字右齐的写法更好。\n①左齐\n1 2 3 4 5 6 SELECT FROM WHERE GROUP BY HAVING ORDER BY ②右齐\n1 2 3 4 5 6 7 SELECT FROM WHERE GROUP BY HAVING ORDER BY 空格 1 2 3 4 5 --√好的示例 SELECT col_1 FROM tbl_A A, tbl_B B WHERE ( A.col_1 \u0026gt;= 100 OR A.col_2 IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) ) AND A.col_3 = B.col_3; 1 2 3 4 5 --×坏的示例 SELECT col_1 FROM tbl_A A, tbl_B B WHERE (A.col_1\u0026gt;=100 OR A.col_2 IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;)) AND A.col_3=B.col_3; 大小写 在SQL里，关于应该如何区分使用大小写字母有着不成文的约定：关键字使用大写字母，列名和表名使用小写字母\n1 2 3 4 5 6 7 8 9 --√大小写有区分，易读 SELECT col_1, col_2, col_3, COUNT(＊) FROM tbl_A WHERE col_1 =\u0026#39;a\u0026#39; AND col_2 = ( SELECT MAX(col_2) FROM tbl_B WHERE col_3 = 100 ) GROUP BY col_1, col_2, col_3; 1 2 3 4 5 6 7 8 9 --×大小写没有区分，难读：全是小写 select col_1, col_2, col_3, count(＊) from tbl_a where col_1 =\u0026#39;a\u0026#39; and col_2 = ( select max(col_2) from tbl_b where col_3 = 100 ) group by col_1, col_2, col_3; 1 2 3 4 5 6 7 8 9 --×大小写没有区分，难读：全是大写 SELECT COL_1, COL_2, COL_3, COUNT(＊) FROM TBL_A WHERE COL_1 =\u0026#39;A\u0026#39; AND COL_2 = ( SELECT MAX(COL_2) FROM TBL_B WHERE COL_3 = 100 ) GROUP BY COL_1, COL_2, COL_3; 逗号 前置逗号\n1 2 3 4 5 SELECT col_1 , col_2 , col_3 , col_4 FROM tbl_A; 这种写法有优点有缺点, 这里列出仅供参考\n不使用通配符 写出所需的字段\n1 2 × SELECT ＊ FROM SomeTable; √ SELECT col_1, col2, col3 ... FROM SomeTable; ORDER BY中不使用列编号 前面讲过的通配符一样，一般来说会受列的顺序和位置影响的写法都应该避免\n1 2 × SELECT col_1, col2 FROM SomeTable ORDER BY 1, 2; √ SELECT col_1, col2 FROM SomeTable ORDER BY col_1, col2; SQL编程方法 请说普通话 SQL是一种有多种方言的语言，各种数据库实现都为我们做了各种扩展, 在日常开发中养成使用标准语法的习惯, 避免影响移植性\n不使用依赖各种数据库实现的函数和运算符 很多依赖数据库实现的函数都是转换函数或字符串处理函数。不要使用这些函数：DECODE(Oracle)、IF(MySQL)、NVL(Oracle)、STUFF(SQL Server)等。 请使用CASE表达式或者COALESCE、NULLIF等标准函数代替它们。此外，像SIGN或ABS、REPLACE这些，虽然标准SQL没有定义它们，但是几乎所有的数据库都 实现了它们，所以使用一下也没关系。\n连接操作使用标准语法 在很早的时候，连接条件和普通的查询条件一样，都是写在WHERE子句里的。\n1 2 3 4 SELECT ＊ FROM Foo F, Bar B WHERE F.state = B.state AND F.city =’东京’; 标准SQL使用INNER或CROSS等表明连接类型的关键字，连接条件可以使用ON子句分开写。\n1 2 3 4 5 --内连接，而且一眼就能看明白连接条件是F.state = B.state SELECT ＊ FROM Foo F INNER JOIN Bar B ON F.state = B.state WHERE F.city =’东京’; 外连接请使用LEFT OUTER JOIN、RIGHT OUTER JOIN或者FULL OUTER JOIN来写。使用(+)运算符(Oracle)、＊=运算符(SQL Server)等依赖数据库实 现的写法会降低代码的可移植性，而且表达能力也有限，所以还是尽量避免吧。标准SQL中允许省略关键字OUTER，但是这个关键字便于我们理解它是外连接而非 内连接，所以还是写上吧。\n“左派”和“右派” 外连接有左连接、右连接和全连接三种类型。其中，左连接和右连接的表达能力是一样的，理论上讲使用哪个都可以。\n在代码风格方面，左连接有一个优势：一般情况下表头都出现在左边。使用左边的表作为主表的话，SQL就能和执行结果在格式上保持一致。\n一般表头都在左边\n表头在右边的话看起来有点奇怪\n从FROM子句开始写 大家在写SQL语句时，是按照什么顺序写的呢？笔者想，大部分人都会说是从SELECT子句开始写的。他们可能会觉得“SELECT子句在开头，难道不该从它开始写 吗？”\n原因是SELECT子句是SQL语句中最后执行的部分，写的时候根本没有必要太在意。SQL中各部分的执行顺序是：FROM→WHERE→GROUP BY→HAVING→SELECT (→ORDER BY)。严格地说，ORDER BY并不是SQL语句的一部分，因此可以排除在外。这样一来，SELECT就是最后才被执行的部分了。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-12-sql%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95/","summary":"写在前面 下面两张卡片上各画了几个圆圈，哪个更容易数清楚呢？ 编程行为就像是一种沟通方式。因此，对编程风格的研究也可以看成是对提高系统开发中沟通","title":"1-12 SQL编程方法"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/tracing/","summary":"原文","title":"链路追踪（Tracing）的前世今生（上）"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/cnblogs/xuning/redis/","summary":"原文","title":"高可用Redis服务架构分析与搭建"},{"content":"边缘节点应该用以下方法来设置\nproxy_set_header X-Forwarded-For $remote_addr; 原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/ip/","summary":"边缘节点应该用以下方法来设置 proxy_set_header X-Forwarded-For $remote_addr; 原文","title":"如何获取客户端真实 IP？从 Gin 的一个 \"Bug\" 说起"},{"content":"使用高效的查询 参数是子查询时，使用EXISTS代替IN Class_A\nClass_B\n从Class_A表中查出同时存在于Class_B表中的员工, 使用EXISTS的SQL语句更快一些\n1 2 3 4 5 6 7 8 9 10 11 12 13 --慢 SELECT ＊ FROM Class_A WHERE id IN (SELECT id FROM Class_B); --快 SELECT ＊ FROM Class_A A WHERE EXISTS (SELECT ＊ FROM Class_B B WHERE A.id = B.id); 两个结果都如下所示\n1 2 3 4 id name -- ---- 1 田中 2 铃木 使用EXISTS时更快的原因有以下两个。\n如果连接列（id）上建立了索引，那么查询Class_B时不用查实际的表，只需查索引就可以了。 如果使用EXISTS，那么只要查到一行数据满足条件就会终止查询，不用像使用IN时一样扫描全表。在这一点上NOT EXISTS也一样。 其他\n使用in会生成临时表, exists不会 in的可读性更好 如果确信in也能很快, 就没必要改成exists 很多数据库改善了in的性能 参数是子查询时，使用连接代替IN 1 2 3 4 --使用连接代替IN SELECT A.id, A.name FROM Class_A A INNER JOIN Class_B B ON A.id = B.id; 至少用到了id上的索引\n避免排序 会排序的运算\nGROUP BY子句 ORDER BY子句 聚合函数（SUM、COUNT、AVG、MAX、MIN） DISTINCT 集合运算符（UNION、INTERSECT、EXCEPT） 窗口函数（RANK、ROW_NUMBER等） 灵活使用集合运算符的ALL可选项 SQL中有UNION、INTERSECT、EXCEPT三个集合运算符。在默认的使用方式下，这些运算符会为了排除掉重复数据而进行排序。\n1 2 3 SELECT ＊ FROM Class_A UNION SELECT ＊ FROM Class_B; 1 2 3 4 5 6 id name -- ----- 1 田中 2 铃木 3 伊集院 4 西园寺 如果不在乎结果中是否有重复数据，或者事先知道不会有重复数据，请使用UNION ALL代替UNION。这样就不会进行排序了。\n1 2 3 SELECT ＊ FROM Class_A UNION ALL SELECT ＊ FROM Class_B; 集合运算符ALL可选项的实现情况\nOracle使用MINUS代替EXCEPT MySQL连INTERSECT和EXCEPT运算本身还没有实现 mysql8 了, 应该再搜一下看有没有\n使用EXISTS代替DISTINCT 如果需要对两张表的连接结果进行去重，可以考虑使用EXISTS代替DISTINCT，以避免排序。\nItems\nSalesHistory\n使用distinct\n1 2 3 SELECT I.item_no FROM Items I INNER JOIN SalesHistory SH ON I. item_no = SH. item_no; 1 2 3 4 5 6 7 8 9 item_no ------- 10 10 20 20 30 30 30 为了排除重复数据，我们需要使用DISTINCT。\n1 2 3 4 5 6 7 8 9 SELECT DISTINCT I.item_no FROM Items I INNER JOIN SalesHistory SH ON I. item_no = SH. item_no; item_no ------- 10 20 30 使用exists\n1 2 3 4 5 6 SELECT item_no FROM Items I WHERE EXISTS (SELECT ＊ FROM SalesHistory SH WHERE I.item_no = SH.item_no); 在极值函数中使用索引（MAX/MIN） 使用这两个函数时都会进行排序。但是如果参数字段上建有索引，则只需要扫描索引，不需要扫描整张表。\n1 2 3 --这样写需要扫描全表 SELECT MAX(item) FROM Items; 1 2 3 --这样写能用到索引 SELECT MAX(item_no) FROM Items; 对于联合索引，只要查询条件是联合索引的第一个字段，索引就是有效的，所以也可以对表SalesHistory的sale_date字段使用极值函数。\n能写在WHERE子句里的条件不要写在HAVING子句里 下面两条SQL语句返回的结果是一样的。\n1 2 3 4 5 --聚合后使用HAVING子句过滤 SELECT sale_date, SUM(quantity) FROM SalesHistory GROUP BY sale_date HAVING sale_date = \u0026#39;2007-10-01\u0026#39;; 1 2 3 4 5 --聚合前使用WHERE子句过滤 SELECT sale_date, SUM(quantity) FROM SalesHistory WHERE sale_date = \u0026#39;2007-10-01\u0026#39; GROUP BY sale_date; 1 2 3 sale_date sum(quantity) -------------- -------------- \u0026#39;2007-10-01\u0026#39; 17 从性能上来看，第二条语句写法效率更高。原因通常有两个。\n第一个是在使用GROUP BY子句聚合时会进行排序，如果事先通过WHERE子句筛选出一部分行，就能够减轻排序的负担。 第二个是在WHERE子句的条件里可以使用索引。HAVING子句是针对聚合后生成的视图进行筛选的，但是很多时候聚合后的视图都没有继承原表的索引结构。 在GROUP BY子句和ORDER BY子句中使用索引 特别是，在一些数据库中，如果操作对象的列上建立的是唯一索引，那么排序过程本身都会被省略掉。\n真的用到索引了吗 假设我们在一个叫作col_1的列上建立了索引，然后来看一看下面这条SQL语句。这条SQL语句本来是想使用索引，但实际上执行时却进行了全表扫描。\n在索引字段上进行运算 1 2 3 SELECT ＊ FROM SomeTable WHERE col_1 ＊ 1.1 \u0026gt; 100; 把运算的表达式放到查询条件的右侧，就能用到索引了\n1 WHERE col_1 \u0026gt; 100 / 1.1 在查询条件的左侧使用函数时，也不能用到索引\n1 2 3 SELECT ＊ FROM SomeTable WHERE SUBSTR(col_1, 1, 1) = \u0026#39;a\u0026#39;; 使用IS NULL谓词 通常，索引字段是不存在NULL的，所以指定IS NULL和IS NOT NULL的话会使得索引无法使用，进而导致查询性能低下。\n1 2 3 SELECT ＊ FROM SomeTable WHERE col_1 IS NULL; 关于索引字段不存在NULL的原因，简单来说是NULL并不是值。非值不会被包含在值的集合中\n如果需要使用类似IS NOT NULL的功能，又想用到索引，那么可以使用下面的方法，假设“col_1”列的最小值是1。\n1 2 3 4 --IS NOT NULL的代替方案 SELECT ＊ FROM SomeTable WHERE col_1 \u0026gt; 0; 使用否定形式 下面这几种否定形式不能用到索引。\n\u0026lt;\u0026gt; != NOT IN 下面的SQL语句也会进行全表扫描。\n1 2 3 SELECT ＊ FROM SomeTable WHERE col_1 \u0026lt;\u0026gt; 100; 使用OR 在col_1和col_2上分别建立了不同的索引，或者建立了（col_1, col_2）这样的联合索引时，如果使用OR连接条件，那么要么用不到索引，要么用到了但是 效率比AND要差很多。\n1 2 3 4 SELECT ＊ FROM SomeTable WHERE col_1 \u0026gt; 100 OR col_2 = \u0026#39;abc\u0026#39;; 如果无论如何都要使用OR，那么有一种办法是位图索引。但是这种索引的话更新数据时的性能开销会增大，所以使用之前需要权衡一下利弊。\n使用联合索引时，列的顺序错误 假设存在这样顺序的一个联合索引“col_1, col_2, col_3”。\n1 2 3 4 5 ○ SELECT ＊ FROM SomeTable WHERE col_1 = 10 AND col_2 = 100 AND col_3 = 500; ○ SELECT ＊ FROM SomeTable WHERE col_1 = 10 AND col_2 = 100 ; × SELECT ＊ FROM SomeTable WHERE col_1 = 10 AND col_3 = 500 ; × SELECT ＊ FROM SomeTable WHERE col_2 = 100 AND col_3 = 500 ; × SELECT ＊ FROM SomeTable WHERE col_2 = 100 AND col_1 = 10 ; 联合索引中的第一列（col_1）必须写在查询条件的开头，而且索引中列的顺序不能颠倒。有些数据库里顺序颠倒后也能使用索引，但是性能还是比顺序正确时 差一些。\n如果无法保证查询条件里列的顺序与索引一致，可以考虑将联合索引拆分为多个索引。\n使用LIKE谓词进行后方一致或中间一致的匹配 使用LIKE谓词时，只有前方一致的匹配才能用到索引。\n1 2 3 × SELECT ＊ FROM SomeTable WHERE col_1 LIKE\u0026#39;%a\u0026#39;; × SELECT ＊ FROM SomeTable WHERE col_1 LIKE\u0026#39;%a%\u0026#39;; ○ SELECT ＊ FROM SomeTable WHERE col_1 LIKE\u0026#39;a%\u0026#39;; 进行默认的类型转换 对char类型的“col_1”列指定条件的示例\n1 2 3 × SELECT ＊ FROM SomeTable WHERE col_1 = 10; ○ SELECT ＊ FROM SomeTable WHERE col_1 =\u0026#39;10\u0026#39;; ○ SELECT ＊ FROM SomeTable WHERE col_1 = CAST(10, AS CHAR(2)); 默认的类型转换不仅会增加额外的性能开销，还会导致索引不可用 在需要类型转换时显式地进行类型转换吧（别忘了转换要写在条件表达式的右边）。 减少中间表 频繁使用中间表会带来两个问题，一是展开数据需要耗费内存资源，二是原始表中的索引不容易使用到\n灵活使用HAVING子句 不习惯使用HAVING子句的数据库工程师可能会倾向于像下面这样先生成一张中间表，然后在WHERE子句中指定筛选条件。\n1 2 3 4 5 sale_date tot_qty ------------ --------- 07-10-01 10 07-10-03 32 07-10-04 22 对聚合结果指定筛选条件时不需要专门生成中间表\n1 2 3 4 SELECT sale_date, MAX(quantity) FROM SalesHistory GROUP BY sale_date HAVING MAX(quantity) \u0026gt;= 10; HAVING子句和聚合操作是同时执行的，所以比起生成中间表后再执行的WHERE子句，效率会更高一些，而且代码看起来也更简洁。\n需要对多个字段使用IN谓词时，将它们汇总到一处 SQL-92中加入了行与行比较的功能。这样一来，比较谓词＝、＜、＞和IN谓词的参数就不能是标量值，而应是值列表了。\n这里对多个字段使用了IN谓词，“id”列是主键。\n1 2 3 4 5 6 7 8 SELECT id, state, city FROM Addresses1 A1 WHERE state IN (SELECT state FROM Addresses2 A2 WHERE A1.id = A2.id) AND city IN (SELECT city FROM Addresses2 A2 WHERE A1.id = A2.id); 如果像下面这样把字段连接在一起，那么就能把逻辑写在一处了。\n1 2 3 4 5 SELECT ＊ FROM Addresses1 A1 WHERE id || state || city IN (SELECT id || state|| city FROM Addresses2 A2); 这样一来，子查询不用考虑关联性，而且只执行一次就可以。此外，如果所用的数据库实现了行与行的比较，那么我们也可以像下面这样，在IN中写多个字段的 组合。\n1 2 3 4 5 SELECT ＊ FROM Addresses1 A1 WHERE (id, state, city) IN (SELECT id, state, city FROM Addresses2 A2); 这种方法与前面的连接字段的方法相比有两个优点。\n一是不用担心连接字段时出现的类型转换问题 二是这种方法不会对字段进行加工，因此可以使用索引。 先进行连接再进行聚合 连接和聚合同时使用时，先进行连接操作可以避免产生中间表。原因是，从集合运算的角度来看，连接做的是“乘法运算”。连接表双方是一对一、一对多的关系 时，连接运算后数据的行数不会增加。而且，因为在很多设计中多对多的关系都可以分解成两个一对多的关系，因此这个技巧在大部分情况下都可以使用。\n合理地使用视图 如果没有经过深入思考就定义复杂的视图，可能会带来巨大的性能问题。特别是视图的定义语句中包含以下运算的时候，SQL会非常低效，执行速度也会变得非常 慢。\n聚合函数（AVG、COUNT、SUM、MIN、MAX） 集合运算符（UNION、INTERSECT、EXCEPT等） 越来越多的数据库为了解决视图的这个缺点，实现了物化视图（materialized view）等技术。当视图的定义变得复杂时，可以考虑使用一下。\n本节小结 不管是减少排序还是使用索引，抑或是避免中间表的使用，都是为了减少对硬盘的访问。\n下面是本节要点。\n参数是子查询时，使用EXISTS或者连接代替IN。 使用索引时，条件表达式的左侧应该是原始字段。 在SQL中排序无法显式地指定，但是请注意很多运算都会暗中进行排序。 尽量减少没用的中间表。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-11-%E8%AE%A9sql%E9%A3%9E%E8%B5%B7%E6%9D%A5/","summary":"推荐看","title":"1-11 让SQL飞起来"},{"content":"各队，全体点名 你需要做的是查出现在可以出勤的队伍。可以出勤即队伍里所有队员都处于“待命”状态。\nTeams\n“所有队员都处于‘待命’状态”这个条件是全称量化命题，所以可以用NOT EXISTS来表达。\n1 2 3 4 5 6 7 8 -- 用谓词表达全称量化命题 SELECT team_id, member FROM Teams T1 WHERE NOT EXISTS (SELECT ＊ FROM Teams T2 WHERE T1.team_id = T2.team_id AND status \u0026lt;\u0026gt;’待命’); 执行结果\n1 2 3 4 5 6 team_id member ------- ------ 3 简 3 哈特 3 迪克 4 贝斯 使用HAVING子句\n1 2 3 4 5 6 7 -- 用集合表达全称量化命题(1) SELECT team_id FROM Teams GROUP BY team_id HAVING COUNT(＊) = SUM(CASE WHEN status =’待命’ THEN 1 ELSE 0 END); 执行结果\n1 2 3 4 team_id ------- 3 4 第一步还是使用GROUP BY子句将Teams集合以队伍为单位划分成几个子集。\nHAVING子句中的条件还可以像下面这样写。\n1 2 3 4 5 6 -- 用集合表达全称量化命题(2) SELECT team_id FROM Teams GROUP BY team_id HAVING MAX(status) =’待命’ AND MIN(status) =’待命’; 极值函数可以使用参数字段的索引，所以这种写法性能更好（当然本例中只有3种值，建立索引也并没有太大的意义）。\n也可以把条件放在SELECT子句里，以列表形式显示出各个队伍是否所有队员都在待命\n1 2 3 4 5 6 7 -- 列表显示各个队伍是否所有队员都在待命 SELECT team_id, CASE WHEN MAX(status) =’待命’AND MIN(status) =’待命’ THEN ’全都在待命’ ELSE’队长！人手不够’END AS status FROM Teams GROUP BY team_id; 1 2 3 4 5 6 7 team_id status ------- -------------------------- 1 队长！人手不够 2 队长！人手不够 3 全都在待命 4 全都在待命 5 队长！人手不够 单重集合与多重集合 关系数据库中的集合是允许重复数据存在的多重集合。与之相反，通常意义的集合论中的集合不允许数据重复，被称为“单重集合”（这是笔者自己造的词，并非 公认的术语）。\n生产地的材料库存的表\nMaterials\n为了在各生产地之间调整重复的材料，我们需要调查出存在重复材料的生产地。\n按生产地分组\n“排除掉重复元素后和排除掉重复元素前元素个数不相同”。如果不存在重复的元素，不管是否加上DISTINCT可选项，COUNT的结果都是相同的。\n1 2 3 4 5 -- 选中材料存在重复的生产地 SELECT center FROM Materials GROUP BY center HAVING COUNT(material) \u0026lt;\u0026gt; COUNT(DISTINCT material); 执行结果\n1 2 3 4 center ------ 东京 名古屋 显示哪种材料重复\n1 2 3 4 5 6 7 8 9 10 11 12 SELECT center, CASE WHEN COUNT(material) \u0026lt;\u0026gt; COUNT(DISTINCT material) THEN’存在重复’ ELSE’不存在重复’END AS status FROM Materials GROUP BY center; center status ---------- ---------- 大阪 不存在重复 东京 存在重复 福冈 不存在重复 名古屋 存在重复 这个问题也可以通过将HAVING改写成EXISTS的方式来解决。\n1 2 3 4 5 6 7 8 9 --存在重复的集合：使用EXISTS SELECT center, material FROM Materials M1 WHERE EXISTS (SELECT ＊ FROM Materials M2 WHERE M1.center = M2.center AND M1.receive_date \u0026lt;\u0026gt; M2.receive_date AND M1.material = M2.material); 1 2 3 4 5 6 7 8 center material ------- --------- 东京 锌 东京 锌 名古屋 钛 名古屋 钢 名古屋 钢 名古屋 钛 寻找缺失的编号：升级版 1-4节介绍过下面这样一条查询数列的缺失编号的查询语句\n1 2 3 4 -- 如果有查询结果，说明存在缺失的编号 SELECT’存在缺失的编号’AS gap FROM SeqTbl HAVING COUNT(＊) \u0026lt;\u0026gt; MAX(seq); 这条SQL语句有一个前提条件，即数列的起始值必须是1。\n放宽这个限制条件，思考一下不管数列的最小值是多少，都能用来判断该数列是否连续的SQL语句。\n(1)不存在缺失编号（起始值＝1）\n(2)存在缺失编号（起始值＝1）\n(3)不存在缺失编号（起始值\u0026lt;\u0026gt;1）\n(4)存在缺失编号（起始值\u0026lt;\u0026gt;1）\n如果数列的最小值和最大值之间没有缺失的编号，它们之间包含的元素的个数应该是“最大值－最小值+1”。\n1 2 3 4 -- 如果有查询结果，说明存在缺失的编号：只调查数列的连续性 SELECT’存在缺失的编号’ AS gap FROM SeqTbl HAVING COUNT(＊) \u0026lt;\u0026gt; MAX(seq) - MIN(seq) + 1 ; 不论是否存在缺失的编号，都想要返回结果\n1 2 3 4 5 6 7 -- 不论是否存在缺失的编号都返回一行结果 SELECT CASE WHEN COUNT(＊) = 0 THEN ’表为空’ WHEN COUNT(＊) \u0026lt;\u0026gt; MAX(seq) - MIN(seq) + 1 THEN ’存在缺失的编号’ ELSE’连续’END AS gap FROM SeqTbl; 改进一下查找最小的缺失编号的SQL语句，去掉起始值必须是1的限制。\n1 2 3 4 5 6 7 8 9 10 11 -- 查找最小的缺失编号：表中没有1时返回1 SELECT CASE WHEN COUNT(＊) = 0 OR MIN(seq) \u0026gt; 1 -- 最小值不是1时→返回1 THEN 1 ELSE (SELECT MIN(seq +1) -- 最小值是1时→返回最小的缺失编号 FROM SeqTbl S1 WHERE NOT EXISTS (SELECT ＊ FROM SeqTbl S2 WHERE S2.seq = S1.seq + 1)) END FROM SeqTbl; 这条SQL语句会返回下面这样的结果\n情况(1):6（没有缺失的编号，所以返回最大值5的下一个数） 情况(2):3（最小的缺失编号） 情况(3):1（因为表中没有1） 情况(4):1（因为表中没有1） 为集合设置详细的条件 学生考试成绩的表\nTestResults\n第1题：请查询出75%以上的学生分数都在80分以上的班级。\n1 2 3 4 5 6 7 SELECT class FROM TestResults GROUP BY class HAVING COUNT(＊) ＊ 0.75 \u0026lt;= SUM(CASE WHEN score \u0026gt;= 80 THEN 1 ELSE 0 END) ; 执行结果\n1 2 3 class ------- B 第2题：请查询出分数在50分以上的男生的人数比分数在50分以上的女生的人数多的班级。\n1 2 3 4 5 6 7 8 9 SELECT class FROM TestResults GROUP BY class HAVING SUM(CASE WHEN score \u0026gt;= 50 AND sex =’男’ THEN 1 ELSE 0 END) \u0026gt; SUM(CASE WHEN score \u0026gt;= 50 AND sex =’女’ THEN 1 ELSE 0 END) ; 执行结果\n1 2 3 4 class ------- B C 第3题：请查询出女生平均分比男生平均分高的班级。\n1 2 3 4 5 6 7 8 9 10 -- 比较男生和女生平均分的SQL语句(1)：对空集使用AVG后返回0 SELECT class FROM TestResults GROUP BY class HAVING AVG(CASE WHEN sex =’男’ THEN score ELSE 0 END) \u0026lt; AVG(CASE WHEN sex =’女’ THEN score ELSE 0 END) ; 执行结果\n1 2 3 4 class ------- A D 根据标准SQL的定义，对空集使用AVG函数时，结果会返回NULL\n1 2 3 4 5 6 7 8 9 10 -- 比较男生和女生平均分的SQL语句(2)：对空集求平均值后返回NULL SELECT class FROM TestResults GROUP BY class HAVING AVG(CASE WHEN sex =’男’ THEN score ELSE NULL END) \u0026lt; AVG(CASE WHEN sex =’女’ THEN score ELSE NULL END) ; 这回D班男生的平均分是NULL。因此不管女生的平均分多少，D班都会被排除在查询结果之外。\n本节小结 用于调查集合性质的常用条件及其用途\n在SQL中指定搜索条件时，最重要的是搞清楚搜索的实体是集合还是集合的元素。\n如果一个实体对应着一行数据→那么就是元素，所以使用WHERE子句。 如果一个实体对应着多行数据→那么就是集合，所以使用HAVING子句。 HAVING子句可以通过聚合函数（特别是极值函数）针对集合指定各种条件。 如果通过CASE表达式生成特征函数，那么无论多么复杂的条件都可以描述。 HAVING子句很强大。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-10-having%E5%AD%90%E5%8F%A5%E5%8F%88%E5%9B%9E%E6%9D%A5%E4%BA%86/","summary":"各队，全体点名 你需要做的是查出现在可以出勤的队伍。可以出勤即队伍里所有队员都处于“待命”状态。 Teams “所有队员都处于‘待命’状态”这个条件是全称","title":"1-10 HAVING子句又回来了"},{"content":"生成连续编号 谜题：00～99的100个数中，0, 1, 2, …, 9这10个数字分别出现了多少次？\n00～99的数中，数字0～9各出现了20次\n无论多大的数，都可以由这张表中的10个数字组合而成。\nDigits\n通过对两个Digits集合求笛卡儿积而得出0～99的数字\n1 2 3 4 --求连续编号(1)：求0~99的数 SELECT D1.digit + (D2.digit ＊ 10) AS seq FROM Digits D1 CROSS JOIN Digits D2 ORDER BY seq; 执行结果\n1 2 3 4 5 6 7 8 9 10 seq --- 0 1 2 ： ： ： 98 99 笛卡儿积：得到所有可能的组合\n如果只想生成从1开始，或者到542结束的数，只需在WHERE子句中加入过滤条件就可以了。\n1 2 3 4 5 6 7 --求连续编号(2)：求1~542的数 SELECT D1.digit + (D2.digit ＊ 10) + (D3.digit ＊ 100) AS seq FROM Digits D1 CROSS JOIN Digits D2 CROSS JOIN Digits D3 WHERE D1.digit + (D2.digit ＊ 10) + (D3.digit ＊ 100) BETWEEN 1 AND 542 ORDER BY seq; 通过将这个查询的结果存储在视图里，就可以在需要连续编号时通过简单的SELECT来获取需要的编号。\n1 2 3 4 5 6 7 8 9 10 11 --生成序列视图（包含0~999） CREATE VIEW Sequence (seq) AS SELECT D1.digit + (D2.digit ＊ 10) + (D3.digit ＊ 100) FROM Digits D1 CROSS JOIN Digits D2 CROSS JOIN Digits D3; --从序列视图中获取1~100 SELECT seq FROM Sequence WHERE seq BETWEEN 1 AND 100 ORDER BY seq; 求全部的缺失编号 假设存在下面这样一张编号有缺失的表。\nSeqtbl\n利用序列视图\n1 2 3 4 5 6 7 8 9 10 11 12 --EXCEPT版 SELECT seq FROM Sequence WHERE seq BETWEEN 1 AND 12 EXCEPT SELECT seq FROM SeqTbl; --NOT IN版 SELECT seq FROM Sequence WHERE seq BETWEEN 1 AND 12 AND seq NOT IN (SELECT seq FROM SeqTbl); 执行结果\n1 2 3 4 5 seq --- 3 9 10 可能像下面这么做性能会有所下降，但是通过扩展BETWEEN谓词的参数，我们可以动态地指定目标表的最大值和最小值。\n1 2 3 4 5 6 7 --动态地指定连续编号范围的SQL语句 SELECT seq FROM Sequence WHERE seq BETWEEN (SELECT MIN(seq) FROM SeqTbl) AND (SELECT MAX(seq) FROM SeqTbl) EXCEPT SELECT seq FROM SeqTbl; 这种写法在查询上限和下限未必固定的表时非常方便。两个自查询没有相关性，而且只会执行一次。 如果在“seq”列上建立索引，那么极值函数的运行可以变得更快速。 三个人能坐得下吗 火车座位预订情况的表\nSeats\n问题是，从1～15的座位编号中，找出连续3个空位的全部组合。\n希望得到的结果是\n3～5 7～9 8～10 9～11 假设所有的座位排成了一条直线。\n7～11的序列包含3个子序列\n借助上面的图表我们可以知道，需要满足的条件是，以n为起点、n+(3-1)为终点的座位全部都是未预订状态\n1 2 3 4 5 6 7 8 9 --找出需要的空位(1)：不考虑座位的换排 SELECT S1.seat AS start_seat, \u0026#39;~\u0026#39;, S2.seat AS end_seat FROM Seats S1, Seats S2 WHERE S2.seat = S1.seat + (:head_cnt -1) --决定起点和终点 AND NOT EXISTS (SELECT ＊ FROM Seats S3 WHERE S3.seat BETWEEN S1.seat AND S2.seat AND S3.status \u0026lt;\u0026gt;’未预订’); 发生换排的情况。假设这列火车每一排有5个座位。我们在表中加上表示行编号“row_id”列。\nSeats2\n因为发生换排，所以9~11的序列不符合条件\n1 2 3 4 5 6 7 8 9 10 --找出需要的空位(2)：考虑座位的换排 SELECT S1.seat AS start_seat, \u0026#39;~\u0026#39;, S2.seat AS end_seat FROM Seats2 S1, Seats2 S2 WHERE S2.seat = S1.seat + (:head_cnt -1) --决定起点和终点 AND NOT EXISTS (SELECT ＊ FROM Seats2 S3 WHERE S3.seat BETWEEN S1.seat AND S2.seat AND ( S3.status \u0026lt;\u0026gt;’未预订’ OR S3.row_id \u0026lt;\u0026gt; S1.row_id)); 执行结果\n1 2 3 4 5 start_seat \u0026#39;~\u0026#39; end_seat ---------- --- -------- 3 ~ 5 8 ~ 10 11 ~ 13 序列内的点需要满足的条件是，“所有座位的状态都是‘未预订’，且行编号相同”。这里新加的条件是“行编号相同”，等价于“与起点的行编号相同”（当然，与终 点的行编号相同也可以）。把这个条件直接写成SQL语句的话，就是像下面这样。\n1 S3.status =’未预订’AND S3.row_id = S1.row_id 由于SQL中不存在全称量词，所以我们必须使用这个条件的否定，即改成下面这样的否定形式。\n1 2 NOT (S3.status =’未预订’AND S3.row_id = S1.row_id) = S3.status \u0026lt;\u0026gt;’未预订’OR S3.row_id \u0026lt;\u0026gt; S1.row_id 最多能坐下多少人 这次要查询的是“按现在的空位状况，最多能坐下多少人”。换句话说，要求的是最长的序列。\nSeats3\n要想保证从座位A到另一个座位B是一个序列，则下面的3个条件必须全部都满足。\n条件1：起点到终点之间的所有座位状态都是“未预订”。 条件2：起点之前的座位状态不是“未预订”。 条件3：终点之后的座位状态不是“未预订”。 不符合条件1的情况\n不符合条件2的情况\n不符合条件3的情况\n先生成一张下面这样的视图。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --第一阶段：生成存储了所有序列的视图 CREATE VIEW Sequences (start_seat, end_seat, seat_cnt) AS SELECT S1.seat AS start_seat, S2.seat AS end_seat, S2.seat - S1.seat + 1 AS seat_cnt FROM Seats3 S1, Seats3 S2 WHERE S1.seat \u0026lt;= S2.seat --第一步：生成起点和终点的组合 AND NOT EXISTS --第二步：描述序列内所有点需要满足的条件 (SELECT ＊ FROM Seats3 S3 WHERE ( S3.seat BETWEEN S1.seat AND S2.seat AND S3.status \u0026lt;\u0026gt;’未预订’) --条件1的否定 OR (S3.seat = S2.seat + 1 AND S3.status =’未预订’) --条件3的否定 OR (S3.seat = S1.seat -1 AND S3.status =’未预订’)); --条件2的否定 这个视图包含以下的内容。\n1 2 3 4 5 start_seat end_seat seat_cnt ------------ ---------- ---------- 2 5 4 7 7 1 9 10 2 我们从这个视图中找出座位数（seat_cnt）最大的一行数据。\n1 2 3 4 --第二阶段：求最长的序列 SELECT start_seat, \u0026#39;~\u0026#39;, end_seat, seat_cnt FROM Sequences WHERE seat_cnt = (SELECT MAX(seat_cnt) FROM Sequences); 单调递增和单调递减 某公司股价动态的表\nMyStock\n求一下股价单调递增的时间区间。从上表来看，目标结果是下面两个。\n2007-01-06～2007-01-08 2007-01-14～2007-01-17 首先进行第一步——通过自连接生成起点和终点的组合。\n1 2 3 4 5 --生成起点和终点的组合的SQL语句 SELECT S1.deal_date AS start_date, S2.deal_date AS end_date FROM MyStock S1, MyStock S2 WHERE S1.deal_date \u0026lt; S2.deal_date; 第二步——描述起点和终点之间的所有点需要满足的条件。\n对于区间内的任意两个时间点，命题“较晚时间的股价高于较早时间的股价”都成立。 然后，我们将这个条件反过来，得到需要的条件——区间内不存在两个时间点使得较早时间的股价高于较晚时间的股价。 1 2 3 4 5 6 7 8 9 10 11 12 --求单调递增的区间的SQL语句：子集也输出 SELECT S1.deal_date AS start_date, S2.deal_date AS end_date FROM MyStock S1, MyStock S2 WHERE S1.deal_date \u0026lt; S2.deal_date --第一步：生成起点和终点的组合 AND NOT EXISTS ( SELECT ＊ --第二步：描述区间内所有日期需要满足的条件 FROM MyStock S3, MyStock S4 WHERE S3.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S4.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S3.deal_date \u0026lt; S4.deal_date AND S3.price \u0026gt;= S4.price); 执行结果\n1 2 3 4 5 6 start_date end_date ------------ ------------- 2007-01-06 2007-01-08 2007-01-14 2007-01-16 2007-01-14 2007-01-17 2007-01-16 2007-01-17 最后，我们要把这些不需要的子集排除掉。使用极值函数很容易就能实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --排除掉子集，只取最长的时间区间 SELECT MIN(start_date) AS start_date, --最大限度地向前延伸起点 end_date FROM (SELECT S1.deal_date AS start_date, MAX(S2.deal_date) AS end_date --最大限度地向后延伸终点 FROM MyStock S1, MyStock S2 WHERE S1.deal_date \u0026lt; S2.deal_date AND NOT EXISTS (SELECT ＊ FROM MyStock S3, MyStock S4 WHERE S3.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S4.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S3.deal_date \u0026lt; S4.deal_date AND S3.price \u0026gt;= S4.price) GROUP BY S1.deal_date) TMP GROUP BY end_date; 执行结果\n1 2 3 4 start_date end_date ------------ ------------- 2007-01-06 2007-01-08 2007-01-14 2007-01-17 本节小结 SQL处理数据的方法有两种。\n第一种是把数据看成忽略了顺序的集合。 第二种是把数据看成有序的集合，此时的基本方法如下。 首先用自连接生成起点和终点的组合 其次在子查询中描述内部的各个元素之间必须满足的关系 要在SQL中表达全称量化时，需要将全称量化命题转换成存在量化命题的否定形式，并使用NOT EXISTS谓词。这是因为SQL只实现了谓词逻辑中的存在量词。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-9-%E7%94%A8sql%E5%A4%84%E7%90%86%E6%95%B0%E5%88%97/","summary":"生成连续编号 谜题：00～99的100个数中，0, 1, 2, …, 9这10个数字分别出现了多少次？ 00～99的数中，数字0～9各出现了20次 无论多大的","title":"1-9 用SQL处理数列"},{"content":"理论篇 什么是谓词 谓词是一种特殊的函数，返回值是真值。\ntrue false unknown 在关系数据库里，表中的一行数据可以看作是一个命题。\nTbl_A\n实体的阶层 同样是谓词，但是与=、BETWEEN等相比，EXISTS的用法还是大不相同的。概括来说，区别在于“谓词的参数可以取什么值”。\n1 2 3 4 5 6 SELECT id FROM Foo F WHERE EXISTS (SELECT ＊ FROM Bar B WHERE F.id=B.id ); 看一下EXISTS()的括号中的内容\n1 2 3 SELECT ＊ FROM Bar B WHERE A.id = T2.id 在EXISTS的子查询里，SELECT子句的列表可以有下面这三种写法。\n通配符：SELECT ＊ 常量：SELECT ‘这里的内容任意’ 列名：SELECT col 不管采用上面这三种写法中的哪一种，得到的结果都是一样的。\n=或者BETWEEEN等输入值为一行的谓词叫作“一阶谓词”，而像EXISTS这样输入值为行的集合的谓词叫作“二阶谓词”。阶（order）是用来区分集合或谓词的阶 数的概念。\n三阶谓词＝输入值为“集合的集合”的谓词 四阶谓词＝输入值为“集合的集合的集合”的谓词 …… 我们可以像上面这样无限地扩展阶数，但是SQL里并不会出现三阶以上的情况\nEXISTS因接受的参数是集合这样的一阶实体而被称为二阶谓词，但是谓词也是函数的一种，因此我们也可以说EXISTS是高阶函数。\n全称量化和存在量化 “所有的x都满足条件P”或者“存在（至少一个）满足条件P的x”。前者称为“全称量词”，后者称为“存在量词”，分别记作∀、∃。这两个符号看起来很奇怪。其 实，全称量词的符号其实是将字母A上下颠倒而形成的，存在量词则是将字母E左右颠倒而形成的。\nsql没有实现全称量词, 但是没有全称量词并不算是SQL的致命缺陷。因为全称量词和存在量词只要定义了一个，另一个就可以被推导出来。\n∀ xPx = ¬ ∃ x¬P（所有的x都满足条件P＝不存在不满足条件P的x） ∃ xPx = ¬ ∀ x¬Px（存在x满足条件P＝并非所有的x都不满足条件P） 实践篇 查询表中“不”存在的数据 在有些情况下，我们不得不从表中查找出“不存在的数据”。\nMeetings\n目标结果如下所示\n1 2 3 4 5 6 meeting person ---------- -------- 第1次 宫田 第2次 坂东 第2次 水岛 第3次 伊藤 思路是先假设所有人都参加了全部会议，并以此生成一个集合，然后从中减去实际参加会议的人。这样就能得到缺席会议的人。\n所有人都参加了全部会议的集合可以通过下面这样的交叉连接来求得。\n1 2 SELECT DISTINCT M1.meeting, M2.person FROM Meetings M1 CROSS JOIN Meetings M2; 所有人都参加了全部会议时\n然后我们从这张表中减掉实际参会者的集合\n1 2 3 4 5 6 7 8 --求出缺席者的SQL语句(1)：存在量化的应用 SELECT DISTINCT M1.meeting, M2.person FROM Meetings M1 CROSS JOIN Meetings M2 WHERE NOT EXISTS (SELECT ＊ FROM Meetings M3 WHERE M1.meeting = M3.meeting AND M2.person = M3.person); 这道例题还可以用集合论的方法来解答，即像下面这样使用差集运算。\n1 2 3 4 5 6 ----求出缺席者的SQL语句(2)：使用差集运算 SELECT M1.meeting, M2.person FROM Meetings M1, Meetings M2 EXCEPT SELECT meeting, person FROM Meetings; 全称量化(1)：习惯“肯定⇔双重否定”之间的转换 学生考试成绩的表\nTestScores\n请查询出“所有科目分数都在50分以上的学生”\n将查询条件“所有科目分数都在50分以上”转换成它的双重否定“没有一个科目分数不满50分”，然后用NOT EXISTS来表示转换后的命题。\n1 2 3 4 5 6 7 SELECT DISTINCT student_id FROM TestScores TS1 WHERE NOT EXISTS --不存在满足以下条件的行 (SELECT ＊ FROM TestScores TS2 WHERE TS2.student_id = TS1.student_id AND TS2.score \u0026lt; 50); --分数不满50分的科目 执行结果\n1 2 3 4 5 student_id ----------- 100 200 400 查询出满足下列条件的学生。\n数学的分数在80分以上。 语文的分数在50分以上。 针对同一个集合内的行数据进行了条件分支后的全称量化。\n“某个学生的所有行数据中，如果科目是数学，则分数在80分以上；如果科目是语文，则分数在50分以上。” 1 2 3 CASE WHEN subject =’数学’AND score \u0026gt;= 80 THEN 1 WHEN subject =’语文’AND score \u0026gt;= 50 THEN 1 ELSE 0 END 首先，数学和语文之外的科目不在我们考虑范围之内，所以通过IN条件进行一下过滤。然后，通过子查询来描述“数学80分以上，语文50分以上”这个条件。\n1 2 3 4 5 6 7 8 9 10 SELECT DISTINCT student_id FROM TestScores TS1 WHERE subject IN (’数学’, ’语文’) AND NOT EXISTS (SELECT ＊ FROM TestScores TS2 WHERE TS2.student_id = TS1.student_id AND 1 = CASE WHEN subject =’数学’AND score \u0026lt; 80 THEN 1 WHEN subject =’语文’AND score \u0026lt; 50 THEN 1 ELSE 0 END); 排除掉没有语文分数的学号为400的学生。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 SELECT student_id FROM TestScores TS1 WHERE subject IN (’数学’, ’语文’) AND NOT EXISTS (SELECT ＊ FROM TestScores TS2 WHERE TS2.student_id = TS1.student_id AND 1 = CASE WHEN subject =’数学’AND score \u0026lt; 80 THEN 1 WHEN subject =’语文’AND score \u0026lt; 50 THEN 1 ELSE 0 END) GROUP BY student_id HAVING COUNT(＊) = 2; --必须两门科目都有分数 student_id ---------- 100 200 全称量化(2)：集合VS谓词——哪个更强大？ 项目工程管理表\nProjects\n从这张表中查询出哪些项目已经完成到了工程1\nJoe Celko曾经借助HAVING子句用面向集合的方法进行过解答\n1 2 3 4 5 6 7 --查询完成到了工程1的项目：面向集合的解法 SELECT project_id FROM Projects GROUP BY project_id HAVING COUNT(＊) = SUM(CASE WHEN step_nbr \u0026lt;= 1 AND status =’完成’THEN 1 WHEN step_nbr \u0026gt; 1 AND status =’等待’THEN 1 ELSE 0 END); 执行结果\n1 2 3 project_id ----------- CS300 针对每个项目，将工程编号为1以下且状态为“完成”的行数，和工程编号大于1且状态为“等待”的行数加在一起，如果和等于该项目数据的总行数，则该项目符合 查询条件。\n用谓词逻辑\n1 2 3 4 5 6 7 8 9 10 --查询完成到了工程1的项目：谓词逻辑的解法 SELECT ＊ FROM Projects P1 WHERE NOT EXISTS (SELECT status FROM Projects P2 WHERE P1.project_id = P2. project_id --以项目为单位进行条件判断 AND status \u0026lt;\u0026gt; CASE WHEN step_nbr \u0026lt;= 1 --使用双重否定来表达全称量化命题 THEN ’完成’ ELSE ’等待’ END); 执行结果\n1 2 3 4 5 6 7 project_id step_nbr status ----------- -------- ------ CS300 0 完成 CS300 1 完成 CS300 2 等待 CS300 3 等待 对列进行量化：查询全是1的行 ArrayTbl\n在使用这种模拟数组的表时遇到的需求一般都是下面这两种形式。\n查询“都是1”的行。 查询“至少有一个9”的行。 1 2 3 4 5 6 7 8 9 --“列方向”的全称量化：不优雅的解答 SELECT ＊ FROM ArrayTbl WHERE col1 = 1 AND col2 = 1 · · · AND col10 = 1; SQL语言其实还准备了一个谓词，帮助我们进行“列方向”的量化。\n1 2 3 4 --“列方向”的全称量化：优雅的解答 SELECT ＊ FROM ArrayTbl WHERE 1 = ALL (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 1 2 3 key col1 col2 col3 col4 col5 col6 col7 col8 col9 col10 --- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----- C 1 1 1 1 1 1 1 1 1 1 如果想表达“至少有一个9”这样的存在量化命题，可以使用ALL的反义谓词ANY。\n1 2 3 4 --列方向的存在量化(1) SELECT ＊ FROM ArrayTbl WHERE 9 = ANY (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 1 2 3 4 key col1 col2 col3 col4 col5 col6 col7 col8 col9 col10 --- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----- D 9 E 3 1 9 9 或者也可以使用IN谓词代替ANY。\n1 2 3 4 --列方向的存在量化(2) SELECT ＊ FROM ArrayTbl WHERE 9 IN (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 如果左边不是具体值而是NULL，这种写法就不行了。\n1 2 3 4 --查询全是NULL的行：错误的解法 SELECT ＊ FROM ArrayTbl WHERE NULL = ALL (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 不管表里的数据是什么样的，这条SQL语句的查询结果都是空。这是因为，ALL谓词会被解释成col1 = NULL AND col2 = NULL AND ……col10 = NULL。 这种情况下，我们需要使用COALESCE函数。\n1 2 3 4 --查询全是NULL的行：正确的解法 SELECT ＊ FROM ArrayTbl WHERE COALESCE(col1, col2, col3, col4, col5, col6, col7, col8, col9, col10) IS NULL; 1 2 3 key col1 col2 col3 col4 col5 col6 col7 col8 col9 col10 --- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----- A 本节小结 SQL中的谓词指的是返回真值的函数。 EXISTS与其他谓词不同，接受的参数是集合。 因此EXISTS可以看成是一种高阶函数。 SQL中没有与全称量词相当的谓词，可以使用NOT EXISTS代替。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-8-exists%E8%B0%93%E8%AF%8D%E7%9A%84%E7%94%A8%E6%B3%95/","summary":"理论篇 什么是谓词 谓词是一种特殊的函数，返回值是真值。 true false unknown 在关系数据库里，表中的一行数据可以看作是一个命题。 Tbl_A 实体的阶层 同样是谓词，但是与=","title":"1-8 EXISTS谓词的用法"},{"content":"导入篇：集合运算的几个注意事项 注意事项1: SQL能操作具有重复行的集合，可以通过可选项ALL来支持\n一般的集合论不允许集合中存在重复元素 关系数据库允许存在重复行, 称为多重集合（multiset, bag） SQL的集合运算符也提供了允许重复和不允许重复的两种用法。如果直接使用UNION或INTERSECT，结果里就不会出现重复的行。如果想在结果里留下重复行， 可以加上可选项ALL，写作UNION ALL。 集合运算符为了排除掉重复行，默认地会发生排序，而加上可选项ALL之后，就不会再排序，所以性能会有提升。 注意事项2：集合运算符有优先级\n标准SQL规定，INTERSECT比UNION和EXCEPT优先级更高。 注意事项3：各个DBMS提供商在集合运算的实现程度上参差不齐\nSQL Server从2005版开始支持INTERSECT和EXCEPT，而MySQL还都不支持（包含在“中长期计划”里）。 还有像Oracle这样，实现了EXCEPT功能但却命名为MINUS的数据库。 注意事项4：除法运算没有标准定义\n四则运算里的和（UNION）、差（EXCEPT）、积（CROSS JOIN）都被引入了标准SQL。但是很遗憾，商（DIVIDE BY）因为各种原因迟迟没能标准化\n比较表和表：检查集合相等性之基础篇 “相等”指的是行数和列数以及内容都相同\n名字不同但内容相同的两张表\ntbl_A\ntbl_B\n如果这个查询的结果与tbl_A及tbl_B的行数一致，则两张表是相等的\n需要事先确认表tbl_A和表tbl_B的行数是一样的 1 2 3 4 5 6 SELECT COUNT(＊) AS row_cnt FROM ( SELECT ＊ FROM tbl_A UNION SELECT ＊ FROM tbl_B ) TMP; 执行结果\n1 2 3 row_cnt ------- 3 如果集合运算符里不加上可选项ALL，那么重复行就会被排除掉。因此，如果表tbl_A和表tbl_B是相等的，排除掉重复行后，两个集合是完全重合的。\nkey列为B的一行数据不同：结果会变为4\ntbl_A tbl_B\n前面的SQL语句可以用于包含NULL数据的表，而且不需要指定列数、列名和数据类型等就能使用\n对于任意的表S，都有下面的公式成立。\n1 S UNION S = S 同一个集合无论加多少次结果都相同\n1 S UNION S UNION S UNION S …… UNION S = S UNION的这个优雅而强大的幂等性只适用于数学意义上的集合，对SQL中有重复数据的多重集合是不适用的。\n比较表和表：检查集合相等性之进阶篇 在集合论里，判定两个集合是否相等时\n(A ∩ B )且(A ∩ B) ⇔ (A = B) 如果集合A包含集合B，且集合B包含集合A，则集合A和集合B相等 (A ∪ B ) = (A ∩ B) ⇔ (A = B) 除了UNION之外，另一个具有幂等性的运算符就是INTERSECT。\n如果A = B，则(A UNION B) EXCEPT (A INTERSECT B)的结果是空集\n1 2 3 4 5 6 7 8 9 10 11 --两张表相等时返回“相等”，否则返回“不相等” SELECT CASE WHEN COUNT(＊) = 0 THEN ’相等’ ELSE’不相等’END AS result FROM ((SELECT ＊ FROM tbl_A UNION SELECT ＊ FROM tbl_B) EXCEPT (SELECT ＊ FROM tbl_A INTERSECT SELECT ＊ FROM tbl_B)) TMP; 这条SQL语句与上一部分中的SQL语句具有同样的优点，也不需要知道列名和列数，还可以用于包含NULL的表，而且，这个改进版连事先查询两张表的行数这种 准备工作也不需要了。\n虽然功能改进了，却也带来了一些缺陷。由于这里需要进行4次排序（3次集合运算加上1次DISTINCT），所以性能会有所下降（不过这条SQL语句也不需要频繁 执行，所以这点缺陷也不是不能容忍）。\n因为这里使用了INTERSECT和EXCEPT，所以目前这条SQL语句不能在MySQL里执行。\n把不同的行输出\n1 2 3 4 5 6 7 8 --用于比较表与表的diff (SELECT ＊ FROM tbl_A EXCEPT SELECT ＊ FROM tbl_B) UNION ALL (SELECT ＊ FROM tbl_B EXCEPT SELECT ＊ FROM tbl_A); 执行结果\n1 2 3 4 key col_1 col_2 col_3 --- ----- ----- ----- B 0 7 9 B 0 7 8 因为A－B和B－A之间不可能有交集，所以合并这两个结果时使用UNION ALL也没有关系。 在A和B一方包含另一方时，这条SQL语句也是成立的（这时A－B或者B－A有一个会是空集）。 需要注意的是，在SQL中，括号决定了运算的先后顺序，非常重要，如果去掉括号，结果就会不正确。 用差集实现关系除法运算 实现除法的方法\n嵌套使用NOT EXISTS。 使用HAVING子句转换成一对一关系。 把除法变成减法。 本节将介绍一下第三种方法。\n两张员工技术信息管理表\nSkills\nEmpSkills\n问题是，从表EmpSkills中找出精通表Skills中所有技术的员工。也就是说，答案是相田和神崎。\n1 2 3 4 5 6 7 8 9 10 --用求差集的方法进行关系除法运算（有余数） SELECT DISTINCT emp FROM EmpSkills ES1 WHERE NOT EXISTS (SELECT skill FROM Skills EXCEPT SELECT skill FROM EmpSkills ES2 WHERE ES1.emp = ES2.emp); 执行结果\n1 2 3 4 emp --- 相田 神崎 从需求的技术的集合中减去每个员工自己的技术的集合，如果结果是空集，则说明该员工具备所有的需求的技术，否则说明该员工不具备某些需求的技术。\n相田\n平井\n寻找相等的子集 供应商及其经营的零件的表\nSupParts\n我们需要求的是，经营的零件在种类数和种类上都完全相同的供应商组合。\nSQL并没有提供任何用于检查集合的包含关系或者相等性的谓词。IN谓词只能用来检查元素是否属于某个集合（∈），而不能检查集合是否是某个集合的子集 （∪）。\n首先，我们来生成供应商的全部组合。\n1 2 3 4 5 --生成供应商的全部组合 SELECT SP1.sup AS s1, SP2.sup AS s2 FROM SupParts SP1, SupParts SP2 WHERE SP1.sup \u0026lt; SP2.sup GROUP BY SP1.sup, SP2.sup; 执行结果\n1 2 3 4 5 6 7 8 9 10 s1 s2 ---- ---- A B A C A D ： ： ： D E E F 接下来，我们检查一下这些供应组合是否满足以下公式：[插图]且[插图]。这个公式等价于下面两个条件。\n条件1：两个供应商都经营同种类型的零件 条件2：两个供应商经营的零件种类数相同（即存在一一映射） 条件1只需要简单地按照“零件”列进行连接，而条件2需要用COUNT函数来描述。\n1 2 3 4 5 6 7 8 9 10 11 SELECT SP1.sup AS s1, SP2.sup AS s2 FROM SupParts SP1, SupParts SP2 WHERE SP1.sup \u0026lt; SP2.sup --生成供应商的全部组合 AND SP1.part = SP2.part --条件1：经营同种类型的零件 GROUP BY SP1.sup, SP2.sup HAVING COUNT(＊) = (SELECT COUNT(＊) --条件2：经营的零件种类数相同 FROM SupParts SP3 WHERE SP3.sup = SP1.sup) AND COUNT(＊) = (SELECT COUNT(＊) FROM SupParts SP4 WHERE SP4.sup = SP2.sup); 因为要比较任意两个供应商的零件, 所以用笛卡儿积\n执行结果\n1 2 3 4 s1 s2 ---- ---- A C B D 用于删除重复行的高效SQL 1-2节介绍的解法是使用关联子查询\n1 2 3 4 5 6 --删除重复行：使用关联子查询 DELETE FROM Products WHERE rowid \u0026lt; ( SELECT MAX(P2.rowid) FROM Products P2 WHERE Products.name = P2. name AND Products.price = P2.price ) ; 上面这条语句的思路是，按照“商品名，价格”的组合汇总后，求出每个组合的最大rowid，然后把其余的行都删除掉。\n假设表中加上了“rowid”列\n1 2 3 4 5 6 7 8 --用于删除重复行的高效SQL语句(1)：通过EXCEPT求补集 DELETE FROM Products WHERE rowid IN ( SELECT rowid --全部rowid FROM Products EXCEPT --减去 SELECT MAX(rowid) --要留下的rowid FROM Products GROUP BY name, price) ; 使用EXCEPT求补集的逻辑如下面的图表所示。\n把EXCEPT改写成NOT IN也是可以实现的。\n1 2 3 4 5 --删除重复行的高效SQL语句(2)：通过NOT IN求补集 DELETE FROM Products WHERE rowid NOT IN ( SELECT MAX(rowid) FROM Products GROUP BY name, price); ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-7-%E7%94%A8sql%E8%BF%9B%E8%A1%8C%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97/","summary":"导入篇：集合运算的几个注意事项 注意事项1: SQL能操作具有重复行的集合，可以通过可选项ALL来支持 一般的集合论不允许集合中存在重复元素 关系数","title":"1-7 用SQL进行集合运算"},{"content":"使用SQL进行行间比较时，发挥主要作用的技术是关联子查询，特别是与自连接相结合的“自关联子查询”\n增长、减少、维持现状 Sales\n年营业额的趋势\n使用SQL输出与上一年相比营业额是增加了还是减少了，抑或是没有变化。\n先试试求出“不变”这种情况\n1993 1995 用面向过程语言来解决，应该是下面这样的思路\n按年份递增的顺序排序。 循环地将每一行与前一行的“sale”列进行比较。 使用SQL时的解题思路需要用面向集合的方式进行思考\n在表Sales的基础上，再加一个存储了上一年数据的集合（S2） 1 2 3 4 5 6 7 --求与上一年营业额一样的年份(1)：使用关联子查询 SELECT year, sale FROM Sales S1 WHERE sale = (SELECT sale FROM Sales S2 WHERE S2.year = S1.year -1) ORDER BY year; 今年的sale==去年的sale\n执行结果\n1 2 3 4 year sale ----- ---- 1993 52 1995 50 使用自连接\n1 2 3 4 5 6 7 --求与上一年营业额一样的年份(2)：使用自连接 SELECT S1.year, S1.sale FROM Sales S1, Sales S2 WHERE S2.sale = S1.sale AND S2.year = S1.year -1 ORDER BY year; 接下来请将这个例子扩展一下，求出每一年相比上一年营业额是增加了还是减少了，抑或是没有变化。\n用列表展示与上一年的比较结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --求出是增长了还是减少了，抑或是维持现状(1)：使用关联子查询 SELECT S1.year, S1.sale, CASE WHEN sale = (SELECT sale FROM Sales S2 WHERE S2.year = S1.year -1) THEN\u0026#39;→\u0026#39;--持平 WHEN sale \u0026gt; (SELECT sale FROM Sales S2 WHERE S2.year = S1.year -1) THEN\u0026#39;↑\u0026#39;--增长 WHEN sale \u0026lt; (SELECT sale FROM Sales S2 WHERE S2.year = S1.year -1) THEN\u0026#39;↓\u0026#39;--减少 ELSE\u0026#39;—\u0026#39;END AS var FROM Sales S1 ORDER BY year; 执行结果\n1 2 3 4 5 6 7 8 9 10 year sale var ------ ---- --- 1990 50 — 1991 51 ↑ 1992 52 ↑ 1993 52 → 1994 50 ↓ 1995 50 → 1996 49 ↓ 1997 55 ↑ 用自连接来实现\n1 2 3 4 5 6 7 8 9 --求出是增长了还是减少了，抑或是维持现状(2)：使用自连接查询（最早的年份不会出现在结果里） SELECT S1.year, S1.sale, CASE WHEN S1.sale = S2.sale THEN\u0026#39;→\u0026#39; WHEN S1.sale \u0026gt; S2.sale THEN\u0026#39;↑\u0026#39; WHEN S1.sale \u0026lt; S2.sale THEN\u0026#39;↓\u0026#39; ELSE\u0026#39;—\u0026#39;END AS var FROM Sales S1, Sales S2 WHERE S2.year = S1.year -1 ORDER BY year; 结果没有1990年之前的数据\n时间轴有间断时：和过去最临近的时间进行比较 Sales2：有年份缺失\n“过去最临近的年份”需要满足下面两个条件\n与该年份相比是过去的年份。 在满足条件1的年份中，年份最早的一个。 1 2 3 4 5 6 7 8 9 10 11 --查询与过去最临近的年份营业额相同的年份 SELECT year, sale FROM Sales2 S1 WHERE sale = (SELECT sale FROM Sales2 S2 WHERE S2.year = (SELECT MAX(year) --条件2：在满足条件1的年份中，年份最早的一个 FROM Sales2 S3 WHERE S1.year \u0026gt; S3.year)) --条件1：与该年份相比是过去的年份 ORDER BY year; 执行结果\n1 2 3 4 year sale ----- ---- 1992 50 1997 55 查询与过去最临近的年份营业额相同的年份：同时使用自连接\n1 2 3 4 5 6 7 8 SELECT S1.year AS year, S1.year AS year FROM Sales2 S1, Sales2 S2 WHERE S1.sale = S2.sale AND S2.year = (SELECT MAX(year) FROM Sales2 S3 WHERE S1.year \u0026gt; S3.year) ORDER BY year; 查询每一年与过去最临近的年份之间的营业额之差\n1 2 3 4 5 6 7 8 9 10 11 --求每一年与过去最临近的年份之间的营业额之差(1)：结果里不包含最早的年份 SELECT S2.year AS pre_year, S1.year AS now_year, S2.sale AS pre_sale, S1.sale AS now_sale, S1.sale - S2.sale AS diff FROM Sales2 S1, Sales2 S2 WHERE S2.year = (SELECT MAX(year) FROM Sales2 S3 WHERE S1.year \u0026gt; S3.year) ORDER BY now_year; 执行结果\n1 2 3 4 5 6 pre_year now_year pre_sale now_sale diff -------- -------- -------- -------- ---- 1990 1992 50 50 0 --50-50 = 0 1992 1993 50 52 2 --52-50 = 2 1993 1994 52 55 3 --55-52 = 3 1994 1997 55 55 0 --55-55 = 0 如果想让结果里出现1990年的数据，可以使用“自外连接”来实现。\n1 2 3 4 5 6 7 8 9 --求每一年与过去最临近的年份之间的营业额之差(2)：使用自外连接。结果里包含最早的年份 SELECT S2.year AS pre_year, S1.year AS now_year, S2.sale AS pre_sale, S1.sale AS now_sale, S1.sale - S2.sale AS diff FROM Sales2 S1 LEFT OUTER JOIN Sales2 S2 ON S2.year = (SELECT MAX(year) FROM Sales2 S3 WHERE S1.year \u0026gt; S3.year) ORDER BY now_year; 执行结果\n1 2 3 4 5 6 7 pre_year now_year pre_sale now_sale diff -------- -------- -------- -------- ----- 1990 50 --1990年也会出现 1990 1992 50 50 0 1992 1993 50 52 2 1993 1994 52 55 3 1994 1997 55 55 0 移动累计值和移动平均值 Accounts\n求截止到那个时间点的账户余额。我们首先可以使用窗口函数来实现。\n1 2 3 4 --求累计值：使用窗口函数 SELECT prc_date, prc_amt, SUM(prc_amt) OVER (ORDER BY prc_date) AS onhand_amt FROM Accounts; 如果使用标准SQL-92，我们可以像下面这样写SQL语句。\n1 2 3 4 5 6 7 --求累计值：使用冯·诺依曼型递归集合 SELECT prc_date, A1.prc_amt, (SELECT SUM(prc_amt) FROM Accounts A2 WHERE A1.prc_date \u0026gt;= A2.prc_date ) AS onhand_amt FROM Accounts A1 ORDER BY prc_date; 执行结果\n1 2 3 4 5 6 7 8 9 prc_date prc_amt onhand_amt ---------- ------- ---------- 2006-10-26 12000 12000 --12000 2006-10-28 2500 14500 --12000 + 2500 2006-10-31 -15000 -500 --12000 + 2500 + (-15000) 2006-11-03 34000 33500 --12000 + 2500 + (-15000) + 34000 2006-11-04 -5000 28500 -- 下同 2006-11-06 7200 35700 -- ： 2006-11-11 11000 46700 -- ： 移动累计值。所谓移动，指的是将累计的数据行数固定（本例中为3行），一行一行地偏移，如下表所示。\n滑动窗口, 窗口大小为3行\n目标区间一行一行地偏移\n如果使用窗口函数，可以像下面这样通过指定ROWS关键字来指定数据行数。\n1 2 3 4 5 --求移动累计值(1)：使用窗口函数 SELECT prc_date, prc_amt, SUM(prc_amt) OVER (ORDER BY prc_date ROWS 2 PRECEDING) AS onhand_amt FROM Accounts; 如果使用关联子查询，我们还可以像下面这样用标量子查询来计算行数。\n1 2 3 4 5 6 7 8 9 10 11 12 --求移动累计值(2)：不满3行的时间区间也输出 SELECT prc_date, A1.prc_amt, (SELECT SUM(prc_amt) FROM Accounts A2 WHERE A1.prc_date \u0026gt;= A2.prc_date AND (SELECT COUNT(＊) FROM Accounts A3 WHERE A3.prc_date BETWEEN A2.prc_date AND A1.prc_date ) \u0026lt;= 3 ) AS mvg_sum FROM Accounts A1 ORDER BY prc_date; 执行结果\n1 2 3 4 5 6 7 8 9 prc_date prc_amt mvg_sum ---------- ------- ------- 2006-10-26 12000 12000 --12000 2006-10-28 2500 14500 --12000 + 2500 2006-10-31 -15000 -500 --12000 + 2500 + (-15000) 2006-11-03 34000 21500 --2500 + (-15000) + 34000 2006-11-04 -5000 14000 --下同 2006-11-06 7200 36200 -- ： 2006-11-11 11000 13200 -- ： 使用HAVING子句找出元素数刚好为3行的集合\n1 2 3 4 5 6 7 8 9 10 11 12 --移动累计值(3)：不满3行的区间按无效处理 SELECT prc_date, A1.prc_amt, (SELECT SUM(prc_amt) FROM Accounts A2 WHERE A1.prc_date \u0026gt;= A2.prc_date AND (SELECT COUNT(＊) FROM Accounts A3 WHERE A3.prc_date BETWEEN A2.prc_date AND A1.prc_date ) \u0026lt;= 3 HAVING COUNT(＊) =3) AS mvg_sum --不满3行数据的不显示 FROM Accounts A1 ORDER BY prc_date; 执行结果\n1 2 3 4 5 6 7 8 9 prc_date prc_amt mvg_sum ---------- ------- ------- 2006-10-26 12000 --不满3行数据，所以不显示 2006-10-28 2500 --不满3行数据，所以不显示 2006-10-31 -15000 -500 --凑够了3行，所以输出 2006-11-03 34000 21500 2006-11-04 -5000 14000 2006-11-06 7200 36200 2006-11-11 11000 13200 去掉聚合后的明细数据\n1 2 3 4 5 6 7 8 9 10 --去掉聚合并输出 SELECT A1.prc_date AS A1_date, A2.prc_date AS A2_date, A2.prc_amt AS amt FROM Accounts A1, Accounts A2 WHERE A1.prc_date \u0026gt;= A2.prc_date AND (SELECT COUNT(＊) FROM Accounts A3 WHERE A3.prc_date BETWEEN A2.prc_date AND A1.prc_date ) \u0026lt;= 3 ORDER BY A1_date, A2_date; 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 A1_date A2_date amt ---------- ---------- ------- 2006-10-26 2006-10-26 12000 2006-10-28 2006-10-26 12000 2006-10-28 2006-10-28 2500 2006-10-31 2006-10-26 12000 2006-10-31 2006-10-28 2500 …S1:-500 2006-10-31 2006-10-31 -15000 2006-11-03 2006-10-28 2500 2006-11-03 2006-10-31 -15000 …S2:21500 2006-11-03 2006-11-03 34000 2006-11-04 2006-10-31 -15000 2006-11-04 2006-11-03 34000 …S3:14000 2006-11-04 2006-11-04 -5000 2006-11-06 2006-11-03 34000 2006-11-06 2006-11-04 -5000 …S4:36200 2006-11-06 2006-11-06 7200 2006-11-11 2006-11-04 -5000 2006-11-11 2006-11-06 7200 …S5:13200 2006-11-11 2006-11-11 11000 存在部分交集的集合簇\n到目前为止，我们主要思考了累计值的求法，所以使用的是SUM函数。如果求移动平均值（moving average），那么将SUM函数改写成AVG函数就可以了。\n查询重叠的时间区间 Reservations\n日期的重叠类型\n1 2 3 4 5 6 7 8 9 10 11 12 --求重叠的住宿期间 SELECT reserver, start_date, end_date FROM Reservations R1 WHERE EXISTS (SELECT ＊ FROM Reservations R2 WHERE R1.reserver \u0026lt;\u0026gt; R2.reserver --与自己以外的客人进行比较 AND ( R1.start_date BETWEEN R2.start_date AND R2.end_date --条件(1)：自己的入住日期在他人的住宿期间内 OR R1.end_date BETWEEN R2.start_date AND R2.end_date)); --条件(2)：自己的离店日期在他人的住宿期间内 执行结果\n1 2 3 4 5 6 reserver start_date end_date -------- ---------- ---------- 荒木 2006-10-28 2006-10-31 堀 2006-10-31 2006-11-01 山本 2006-11-03 2006-11-04 内田 2006-11-03 2006-11-05 如果想求“与任何住宿期间都不重叠的日期”，我们只需要把EXISTS谓词改写成NOT EXISTS谓词就可以了。\n如果山本的入住日期不是11月3号，而是推迟了一天，即11月4号，那么查询结果里将不会出现内田。这是因为，内田的入住日期和离店日期都不再与任何人重叠， 于是条件(1)和条件(2)就都不满足了。换句话说，像内田这种自己的住宿期间完全包含了他人的住宿期间的情况，会被这条SQL语句排除掉。如果想把这样的住 宿期间也输出，我们需要追加条件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --升级版：把完全包含别人的住宿期间的情况也输出 SELECT reserver, start_date, end_date FROM Reservations R1 WHERE EXISTS (SELECT ＊ FROM Reservations R2 WHERE R1.reserver \u0026lt;\u0026gt; R2.reserver AND ( ( R1.start_date BETWEEN R2.start_date AND R2.end_date OR R1.end_date BETWEEN R2.start_date AND R2.end_date) OR ( R2.start_date BETWEEN R1.start_date AND R1.end_date AND R2.end_date BETWEEN R1.start_date AND R1.end_date))); ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-6-%E7%94%A8%E5%85%B3%E8%81%94%E5%AD%90%E6%9F%A5%E8%AF%A2%E6%AF%94%E8%BE%83%E8%A1%8C%E4%B8%8E%E8%A1%8C/","summary":"使用SQL进行行间比较时，发挥主要作用的技术是关联子查询，特别是与自连接相结合的“自关联子查询” 增长、减少、维持现状 Sales 年营业额的趋势 使用SQ","title":"1-6 用关联子查询比较行与行"},{"content":"本节将以集合论和群论中的“类”这一重要概念为核心，阐明GROUP BY和PARTITION BY的意义。\nSQL的语句中具有分组功能的是GROUP BY和PARTITION BY，它们都可以根据指定的列为表分组。区别仅仅在于，GROUP BY在分组之后会把每个分组聚合成一 行数据。\nTeams\n1 2 3 4 5 6 SELECT member, team, age , RANK() OVER(PARTITION BY team ORDER BY age DESC) rn, DENSE_RANK() OVER(PARTITION BY team ORDER BY age DESC) dense_rn, ROW_NUMBER() OVER(PARTITION BY team ORDER BY age DESC) row_num FROM Members ORDER BY team, rn; 执行结果\n分割后的子集\n重点关注一下划分出的子集\n它们全都是非空集合。 所有子集的并集等于划分之前的集合。 任何两个子集之间都没有交集。 对3取余给自然数集合N分类\n余0的类：M1 = {0, 3, 6, 9, …} 余1的类：M2 = {1, 4, 7, 10, …} 余2的类：M2 = {2, 5, 8, 11, …} 从类的第2个性质我们知道，这3个类涵盖了全部自然数。\nM1 + M2 + M3 = N MOD函数\n1 2 3 4 5 --对从1到10的整数以3为模求剩余类 SELECT MOD(num, 3) AS modulo, num FROM Natural ORDER BY modulo, num; 执行结果\n随机地将数据减为原来的五分之一\n1 2 3 4 5 6 7 8 9 10 11 12 --从原来的表中抽出（大约）五分之一行的数据 SELECT ＊ FROM SomeTbl WHERE MOD(seq, 5) = 0; --表中没有连续编号的列时，使用ROW_NUMBER函数就可以了 SELECT ＊ FROM (SELECT col, ROW_NUMBER() OVER(ORDER BY col) AS seq FROM SomeTbl) WHERE MOD(seq, 5) = 0; ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-5-group-by%E5%92%8Cpartition-by/","summary":"本节将以集合论和群论中的“类”这一重要概念为核心，阐明GROUP BY和PARTITION BY的意义。 SQL的语句中具有分组功能的是GROUP","title":"2-5 GROUP BY和PARTITION BY.md"},{"content":"用外连接进行行列转换(1)（行→列）：制作交叉表 员工学习过的培训课程的表Courses\n课程学习记录一览表（表头：课程；侧栏：员工姓名）\n用外连接的思路来思考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --水平展开求交叉表(1)：使用外连接 SELECT C0.name, CASE WHEN C1.name IS NOT NULL THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;SQL入门\u0026#34;, CASE WHEN C2.name IS NOT NULL THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;UNIX基础\u0026#34;, CASE WHEN C3.name IS NOT NULL THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;Java中级\u0026#34; FROM (SELECT DISTINCT name FROM Courses) C0 --这里的C0是侧栏 LEFT OUTER JOIN (SELECT name FROM Courses WHERE course = \u0026#39;SQL入门’) C1 ON C0.name = C1.name LEFT OUTER JOIN (SELECT name FROM Courses WHERE course = \u0026#39;UNIX基础’) C2 ON C0.name = C2.name LEFT OUTER JOIN (SELECT name FROM Courses WHERE course = \u0026#39;Java中级’) C3 ON C0.name = C3.name; C0：主表\nC1:SQL\nC2:UNIX\nC3:Java\n一般情况下，外连接都可以用标量子查询替代\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --水平展开(2)：使用标量子查询 SELECT C0.name, (SELECT \u0026#39;○\u0026#39; FROM Courses C1 WHERE course = \u0026#39;SQL入门’ AND C1.name = C0.name) AS \u0026#34;SQL入门\u0026#34;, (SELECT \u0026#39;○\u0026#39; FROM Courses C2 WHERE course = \u0026#39;UNIX基础’ AND C2.name = C0.name) AS \u0026#34;UNIX基础\u0026#34;, (SELECT \u0026#39;○\u0026#39; FROM Courses C3 WHERE course = \u0026#39;Java中级’ AND C3.name = C0.name) AS \u0026#34;Java中级\u0026#34; FROM (SELECT DISTINCT name FROM Courses) C0; --这里的C0是表侧栏 例如想加入第4列“PHP入门”时，只需要在SELECT子句的最后加上下面这条语句就可以了（如果采用前面的写法，则必需修改SELECT子句和FROM子句两个地方）。\n1 2 3 4 (SELECT \u0026#39;○\u0026#39; FROM Courses C4 WHERE course = \u0026#39;PHP入门’ AND C4.name = C0.name ) AS \u0026#34;PHP入门\u0026#34; 这种做法不仅利于应对需求变更，对于需要动态生成SQL的系统也是很有好处的。缺点是性能不太好，目前在SELECT子句中使用标量子查询（或者关联子查询） 的话，性能开销还是相当大的。\n嵌套使用CASE表达式\n1 2 3 4 5 6 7 8 9 10 --水平展开(3)：嵌套使用CASE表达式 SELECT name, CASE WHEN SUM(CASE WHEN course = \u0026#39;SQL入门’THEN 1 ELSE NULL END) = 1 THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;SQL入门\u0026#34;, CASE WHEN SUM(CASE WHEN course = \u0026#39;UNIX基础’THEN 1 ELSE NULL END) = 1 THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;UNIX基础\u0026#34;, CASE WHEN SUM(CASE WHEN course = \u0026#39;Java中级’THEN 1 ELSE NULL END) = 1 THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;Java中级\u0026#34; FROM Courses GROUP BY name; 用外连接进行行列转换(2)（列→行）：汇总重复项于一列 一张让数据库工程师想哭的表Personnel：员工子女信息\n使用UNION ALL来实现。\n1 2 3 4 5 6 --列数据转换成行数据：使用UNION ALL SELECT employee, child_1 AS child FROM Personnel UNION ALL SELECT employee, child_2 AS child FROM Personnel UNION ALL SELECT employee, child_3 AS child FROM Personnel; 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 employee child ---------- ------- 赤井 一郎 赤井 二郎 赤井 三郎 工藤 春子 工藤 夏子 工藤 铃木 夏子 铃木 铃木 吉田 吉田 吉田 希望得到员工子女列表\n来生成一个存储子女列表的视图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 CREATE VIEW Children(child) AS SELECT child_1 FROM Personnel UNION SELECT child_2 FROM Personnel UNION SELECT child_3 FROM Personnel; child ----- 一郎 二郎 三郎 春子 夏子 员工列表为主表进行外连接操作\n1 2 3 4 5 --获取员工子女列表的SQL语句（没有孩子的员工也要输出） SELECT EMP.employee, CHILDREN.child FROM Personnel EMP LEFT OUTER JOIN Children ON CHILDREN.child IN (EMP.child_1, EMP.child_2, EMP.child_3); 在交叉表里制作嵌套式表侧栏 年龄层级主表：TblAge\n性别主表：TblSex\n人口分布表：TblPop\n包含嵌套式表侧栏的统计表\n目标表的侧栏是年龄层级和性别，所以我们需要使用表TblAge和表TblSex作为主表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --使用外连接生成嵌套式表侧栏：错误的SQL语句 SELECT MASTER1.age_class AS age_class, MASTER2.sex_cd AS sex_cd, DATA.pop_tohoku AS pop_tohoku, DATA.pop_kanto AS pop_kanto FROM (SELECT age_class, sex_cd, SUM(CASE WHEN pref_name IN (’青森’, ’秋田’) THEN population ELSE NULL END) AS pop_tohoku, SUM(CASE WHEN pref_name IN (’东京’, ’千叶’) THEN population ELSE NULL END) AS pop_kanto FROM TblPop GROUP BY age_class, sex_cd) DATA RIGHT OUTER JOIN TblAge MASTER1--外连接1：和年龄层级主表进行外连接 ON MASTER1.age_class = DATA.age_class RIGHT OUTER JOIN TblSex MASTER2--外连接2：和性别主表进行外连接 ON MASTER2.sex_cd = DATA.sex_cd; 内部的sql先生成age_class, sex_cd, pop_tohoku, pop_kanto, 之后再关联名称\n执行结果\n1 2 3 4 5 6 age_class sex_cd pop_tohoku pop_kanto --------- ------ ---------- --------- 1 m 1100 1800 1 f 1300 2500 3 m 1000 3 f 1800 2100 结果里没有年龄层为2的原因是TblPop没有数据.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --停在第1个外连接处时：结果里包含年龄层级为2的数据 SELECT MASTER1.age_class AS age_class, DATA.sex_cd AS sex_cd, DATA.pop_tohoku AS pop_tohoku, DATA.pop_kanto AS pop_kanto FROM (SELECT age_class, sex_cd, SUM(CASE WHEN pref_name IN (’青森’, ’秋田’) THEN population ELSE NULL END) AS pop_tohoku, SUM(CASE WHEN pref_name IN (’东京’, ’千叶’) THEN population ELSE NULL END) AS pop_kanto FROM TblPop GROUP BY age_class, sex_cd) DATA RIGHT OUTER JOIN TblAge MASTER1 ON MASTER1.age_class = DATA.age_class; 执行结果\n1 2 3 4 5 6 7 age_class sex_cd pop_tohoku pop_kanto --------- ------ ---------- --------- 1 m 1100 1800 1 f 1300 2500 2 --存在年龄层级为2的数据 3 m 1000 3 f 1800 2100 原因也不难理解。表TblPop里本来就没有年龄层级为2的数据，自然也没有相应的性别信息m或f，于是“性别编号”列只能是NULL。因此与性别主表进行外连接时， 连接条件会变成ON MASTER2.sex_cd =NULL，结果是unknown\n如果不允许进行两次外连接，那么调整成一次就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --使用外连接生成嵌套式表侧栏：正确的SQL语句 SELECT MASTER.age_class AS age_class, MASTER.sex_cd AS sex_cd, DATA.pop_tohoku AS pop_tohoku, DATA.pop_kanto AS pop_kanto FROM (SELECT age_class, sex_cd FROM TblAge CROSS JOIN TblSex ) MASTER --使用交叉连接生成两张主表的笛卡儿积 LEFT OUTER JOIN (SELECT age_class, sex_cd, SUM(CASE WHEN pref_name IN (’青森’, ’秋田’) THEN population ELSE NULL END) AS pop_tohoku, SUM(CASE WHEN pref_name IN (’东京’, ’千叶’) THEN population ELSE NULL END) AS pop_kanto FROM TblPop GROUP BY age_class, sex_cd) DATA ON MASTER.age_class = DATA.age_class AND MASTER.sex_cd = DATA.sex_cd; 执行结果\n1 2 3 4 5 6 7 8 age_class sex_cd pop_tohoku pop_kanto --------- ------ ---------- --------- 1 m 1100 1800 1 f 1300 2500 2 m 2 f 3 m 1000 3 f 1800 2100 作为乘法运算的连接 交叉连接相当于乘法运算\nItems\nSalesHistory\n先使用这两张表生成一张统计表，以商品为单位汇总出各自的销量。我们期望的结果是像下面这样的。\n1 2 3 4 5 6 item_no total_qty ------- --------- 10 36 20 32 30 22 40 恐怕很多人会想到下面这种做法。\n1 2 3 4 5 6 7 --解答(1)：通过在连接前聚合来创建一对一的关系 SELECT I.item_no, SH.total_qty FROM Items I LEFT OUTER JOIN (SELECT item_no, SUM(quantity) AS total_qty FROM SalesHistory GROUP BY item_no) SH ON I.item_no = SH.item_no; 以商品编号为主键的临时视图（SH）\n1 2 3 4 5 --解答(2)：先进行一对多的连接再聚合 SELECT I.item_no, SUM(SH.quantity) AS total_qty FROM Items I LEFT OUTER JOIN SalesHistory SH ON I.item_no = SH.item_no 一对多的连接 GROUP BY I.item_no; 一对一或一对多关系的两个集合，在进行连接操作后行数不会（异常地）增加。\n全外连接 标准SQL里定义了外连接的三种类型\n左外连接（LEFT OUTER JOIN） 右外连接（RIGHT OUTER JOIN） 全外连接（FULL OUTER JOIN） 左外连接和右外连接没有功能上的区别。用作主表的表写在运算符左边时用左外连接，写在运算符右边时用右外连接。\n全外连接\nClass_A\nClass_B\n可以理解成“把两张表都当作主表来使用”的连接。\n1 2 3 4 5 6 --全外连接保留全部信息 SELECT COALESCE(A.id, B.id) AS id, A.name AS A_name, B.name AS B_name FROM Class_A A FULL OUTER JOIN Class_B B ON A.id = B.id; 执行结果\n1 2 3 4 5 6 id A_name B_name ---- ------ ------ 1 田中 田中 2 铃木 铃木 3 伊集院 4 西园寺 COALESCE是SQL的标准函数，可以接受多个参数，功能是返回第一个非NULL的参数。\n如果所用的数据库不支持全外连接，可以分别进行左外连接和右外连接，再把两个结果通过UNION合并起来，也能达到同样的目的\n1 2 3 4 5 6 7 8 9 --数据库不支持全外连接时的替代方案 SELECT A.id AS id, A.name, B.name FROM Class_A A LEFT OUTER JOIN Class_B B ON A.id = B.id UNION SELECT B.id AS id, A.name, B.name FROM Class_A A RIGHT OUTER JOIN Class_B B ON A.id = B.id; 我们还可以换个角度，把表连接看成集合运算。内连接相当于求集合的积（INTERSECT，也称交集），全外连接相当于求集合的和（UNION，也称并集）。\n内连接相当于求集合的积（INTERSECT）\n全外连接相当于求集合的和（UNION）\n用外连接进行集合运算 用外连接求差集：A－B 1 2 3 4 SELECT A.id AS id, A.name AS A_name FROM Class_A A LEFT OUTER JOIN Class_B B ON A.id = B.id WHERE B.name IS NULL; 执行结果\n1 2 3 id A_name ---- ------ 3 伊集院 用外连接求差集（A-B）\n用外连接求差集：B－A 1 2 3 4 SELECT B.id AS id, B.name AS B_name FROM Class_A A RIGHT OUTER JOIN Class_B B ON A.id = B.id WHERE A.name IS NULL; 执行结果\n1 2 3 id B_name ---- ------ 4 西园寺 用外连接求差集（B-A）\n用全外连接求异或集 SQL没有定义求异或集的运算符，如果用集合运算符，可以有两种方法。\n一种是(A UNION B) EXCEPT (A INTERSECT B) 另一种是(A EXCEPT B) UNION (B EXCEPT A)。两种方法都比较麻烦，性能开销也会增大。 1 2 3 4 5 6 SELECT COALESCE(A.id, B.id) AS id, COALESCE(A.name , B.name ) AS name FROM Class_A A FULL OUTER JOIN Class_B B ON A.id = B.id WHERE A.name IS NULL OR B.name IS NULL; 执行结果\n1 2 3 4 id name ---- ----- 3 伊集院 4 西园寺 用全外连接求异或集\n关系除法运算也可以通过外连接来实现。使用1-4节里的表Items和表ShopItems\n1 2 3 4 5 6 7 8 9 --用外连接进行关系除法运算：差集的应用 SELECT DISTINCT shop FROM ShopItems SI1 WHERE NOT EXISTS (SELECT I.item FROM Items I LEFT OUTER JOIN ShopItems SI2 ON I.item = SI2.item AND SI1.shop = SI2.shop WHERE SI2.item IS NULL) ; 执行结果\n1 2 3 4 shop ---- 仙台 东京 本节小结 SQL不是用来生成报表的语言，所以不建议用它来进行格式转换。 必要时考虑用外连接或CASE表达式来解决问题。 生成嵌套式表侧栏时，如果先生成主表的笛卡儿积再进行连接，很容易就可以完成。 从行数来看，表连接可以看成乘法。因此，当表之间是一对多的关系时，连接后行数不会增加。 外连接的思想和集合运算很像，使用外连接可以实现各种集合运算。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-5-%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%94%A8%E6%B3%95/","summary":"用外连接进行行列转换(1)（行→列）：制作交叉表 员工学习过的培训课程的表Courses 课程学习记录一览表（表头：课程；侧栏：员工姓名） 用外连","title":"1-5 外连接的用法"},{"content":"sql是面向集合的语言\n寻找缺失的编号 SeqTbl\n用面向过程语言查询缺失的编号的过程\n对“连续编号”列按升序或者降序进行排序。 循环比较每一行和下一行的编号。 将表整体看作一个集合\n1 2 3 4 -- 如果有查询结果，说明存在缺失的编号 SELECT’存在缺失的编号’AS gap FROM SeqTbl HAVING COUNT(＊) \u0026lt;\u0026gt; MAX(seq); 执行结果\n1 2 3 gap ---------- \u0026#39;存在缺失的编号’ 上面的SQL语句里没有GROUP BY子句，此时整张表会被聚合为一行。这种情况下HAVING子句也是可以使用的。\n再来查询一下缺失编号的最小值。\n1 2 3 4 -- 查询缺失编号的最小值 SELECT MIN(seq + 1) AS gap FROM SeqTbl WHERE (seq+ 1) NOT IN ( SELECT seq FROM SeqTbl); 执行结果\n1 2 3 gap --- 4 上面展示了通过SQL语句查询缺失编号的最基本的思路，然而这个查询还不够周全，并不能涵盖所有情况。例如，如果表SeqTbl里没有编号1，那么缺失编号的 最小值应该是1，但是这两条SQL语句都不能得出正确的结果\n用HAVING子句进行子查询：求众数 Graduates（毕业生表）\n从这个例子可以看出，简单地求平均值有一个缺点，那就是很容易受到离群值（outlier）的影响。这种时候就必须使用更能准确反映出群体趋势的指标—— 众数（mode）就是其中之一。\n1 2 3 4 5 6 7 --求众数的SQL语句(1)：使用谓词 SELECT income, COUNT(＊) AS cnt FROM Graduates GROUP BY income HAVING COUNT(＊) \u0026gt;= ALL ( SELECT COUNT(＊) FROM Graduates GROUP BY income); 执行结果\n1 2 3 4 income cnt ------ --- 10000 3 20000 3 1-3节提到过ALL谓 词用于NULL或空集时会出现问题，可以用极值函数来代替。\n1 2 3 4 5 6 7 8 --求众数的SQL语句(2)：使用极值函数 SELECT income, COUNT(＊) AS cnt FROM Graduates GROUP BY income HAVING COUNT(＊) \u0026gt;= ( SELECT MAX(cnt) FROM ( SELECT COUNT(＊) AS cnt FROM Graduates GROUP BY income) TMP ) ; 用HAVING子句进行自连接：求中位数 用面向集合的方式，来查询位于集合正中间的元素。\n将集合里的元素按照大小分为上半部分和下半部分两个子集，同时让这2个子集共同拥有集合正中间的元素。 中位数求法的思路\n1 2 3 4 5 6 7 8 9 10 11 12 --求中位数的SQL语句：在HAVING子句中使用非等值自连接 SELECT AVG(DISTINCT income) FROM (SELECT T1.income FROM Graduates T1, Graduates T2 GROUP BY T1.income --S1的条件 HAVING SUM(CASE WHEN T2.income \u0026gt;= T1.income THEN 1 ELSE 0 END) \u0026gt;= COUNT(＊) / 2 --S2的条件 AND SUM(CASE WHEN T2.income \u0026lt;= T1.income THEN 1 ELSE 0 END) \u0026gt;= COUNT(＊) / 2 ) TMP; 查询不包含NULL的集合 count(*)和count(column)的区别\n第一个是性能上的区别；第二个是COUNT（＊）可以用于NULL，而COUNT（列名）与其他聚合函数一样，要先排除掉NULL的行再进行统计。 第二个区别也可以这么理解：COUNT（＊）查询的是所有行的数目，而COUNT（列名）查询的则不一定是。 一张全是NULL的表NullTbl\n1 2 3 --在对包含NULL的列使用时，COUNT（＊）和COUNT（列名）的查询结果是不同的 SELECT COUNT(＊), COUNT(col_1) FROM NullTbl; 执行结果\n1 2 3 count(＊) count(col_1) -------- ------------ 3 0 Students\n所有学生都提交了报告的学院有哪些\n1 2 3 4 5 --查询“提交日期”列内不包含NULL的学院(1)：使用COUNT函数 SELECT dpt FROM Students GROUP BY dpt HAVING COUNT(＊) = COUNT(sbmt_date); 执行结果\n1 2 3 4 dpt -------- 理学院 经济学院 使用CASE表达式也可以实现同样的功能\n1 2 3 4 5 6 7 --查询“提交日期”列内不包含NULL的学院(2)：使用CASE表达式 SELECT dpt FROM Students GROUP BY dpt HAVING COUNT(＊) = SUM(CASE WHEN sbmt_date IS NOT NULL THEN 1 ELSE 0 END); 用关系除法运算进行购物篮分析 我们假设有这样两张表：全国连锁折扣店的商品表Items，以及各个店铺的库存管理表ShopItems。\nItems\nShopItems\n查询囊括了表Items中所有商品的店铺\n1 2 3 4 --查询啤酒、纸尿裤和自行车同时在库的店铺：错误的SQL语句 SELECT DISTINCT shop FROM ShopItems WHERE item IN (SELECT item FROM Items); 执行结果\n1 2 3 4 5 shop ---- 仙台 东京 大阪 1 2 3 4 5 6 --查询啤酒、纸尿裤和自行车同时在库的店铺：正确的SQL语句 SELECT SI.shop FROM ShopItems SI, Items I WHERE SI.item = I.item GROUP BY SI.shop HAVING COUNT(SI.item) = (SELECT COUNT(item) FROM Items); 执行结果\n1 2 3 4 shop ---- 仙台 东京 请注意，如果把HAVING子句改成HAVING COUNT(SI.item)=COUNT(I.item)，结果就不对了。\n1 2 3 4 5 -- COUNT(I.item)的值已经不一定是3了 SELECT SI.shop, COUNT(SI.item), COUNT(I.item) FROM ShopItems SI, Items I WHERE SI.item = I.item GROUP BY SI.shop; 执行结果\n1 2 3 4 5 shop COUNT(SI.item) COUNT(I.item) ----- --------------- -------------- 仙台 3 3 东京 3 3 大阪 2 2 如何排除掉仙台店（仙台店的仓库中存在“窗帘”，但商品表里没有“窗帘”），让结果里只出现东京店。\n这类问题被称为“精确关系除法”（exact relational division），即只选择没有剩余商品的店铺 与此相对，前一个问题被称为“带余除法”（division with a remainder）。 1 2 3 4 5 6 7 --精确关系除法运算：使用外连接和COUNT函数 SELECT SI.shop FROM ShopItems SI LEFT OUTER JOIN Items I ON SI.item=I.item GROUP BY SI.shop HAVING COUNT(SI.item) = (SELECT COUNT(item) FROM Items) --条件1 AND COUNT(I.item) = (SELECT COUNT(item) FROM Items); --条件2 执行结果\n1 2 3 shop ---- 东京 表ShopItems和表Items外连接后的结果\n一般来说，使用外连接时，大多会用商品表Items作为主表进行外连接操作，而这里颠倒了一下主从关系，表使用ShopItems作为了主表，这一点比较有趣。\n本节小结 表不是文件，记录也没有顺序，所以SQL不进行排序。 SQL不是面向过程语言，没有循环、条件分支、赋值操作。 SQL通过不断生成子集来求得目标集合。SQL不像面向过程语言那样通过画流程图来思考问题，而是通过画集合的关系图来思考。 GROUP BY子句可以用来生成子集。 WHERE子句用来调查集合元素的性质，而HAVING子句用来调查集合本身的性质。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-4-having%E5%AD%90%E5%8F%A5%E7%9A%84%E5%8A%9B%E9%87%8F/","summary":"sql是面向集合的语言 寻找缺失的编号 SeqTbl 用面向过程语言查询缺失的编号的过程 对“连续编号”列按升序或者降序进行排序。 循环比较每一行和下一行的编号","title":"1-4 HAVING子句的力量"},{"content":"7.1 定价能力是衡量品牌力的重要标准 既然不赚钱，为何商家要花大力气宣传、促销、做销售额、发战报呢？\n答案是：“卖货”和“卖价格带”是品牌经营的两大目标。卖货即提高销量获取利润，卖价格带即维持知名度和品牌价格带。品牌商家在大促中行动的主要目的是提 升知名度和价格带，更多是营销维度的考量，而非获利行为。\n卖货赚钱关乎品牌的生存和短期业绩表现，保持一定的销量和规模是品牌的生存基础。 品牌认知建立在销售规模之上，若商家达不到一定的规模，就很难被称为“品牌”。 而卖价格带则关乎品牌商长期的定位、形象与价值。 比如我们常见的许多消费品品牌，毛利率可高达40%以上，它们为什么不降价20%～30%，在保证毛利为正的前提下薄利多销、抢占更多市场？\n因为价格带一旦降下去，就很难重新抬起来了。降价在短期能带来丰厚的业绩，但长期来看，却是一种毁灭品牌价值的行为。 这也是为何有一部分大品牌会抵制新兴渠道。部分新兴渠道（如拼多多、早期的淘宝等）以低价位为核心竞争力，并没有渠道管控、帮助大品牌稳住价格带的 能力。 品牌的定价能力有时体现在产品售价的稳定性上\n定价能力强的品牌，其产品的价格一般比较稳定，很少打折，打折幅度也不大； 反之，若产品上市一段时间后总通过大幅打折出货，则体现出产品定价能力不足。 图7-1 部分国内外美妆护肤品牌大单品2020年11～12月天猫旗舰店价格\n任何一个优秀的品牌，都应该具备定价能力（不打折）、溢价能力、涨价能力。我们可以通过品牌对于价格的掌控能力找到品牌力出众的优秀企业。\n7.2 品牌分级体系：从1.0到4.0，提价能力逐级增强 不同消费品品牌的经营壁垒和品牌价值天差地别。其中，溢价能力是一个非常重要的指标，它能够直接反映品牌的质地以及未来发展潜力。\n根据定价能力的不同，消费品品牌可分为1.0到4.0四个阶段：\n品牌1.0是“品牌即认知”，代表品牌提供了基础的质量保障，并做到了规模化生产； 品牌2.0是“品牌即优选”，代表品牌具备基础的溢价能力； 品牌3.0是“品牌即品类”，行业大部分自然流量导向少数品牌； 品牌4.0是“品牌即身份”，这类品牌拥有极高的溢价，其定价几乎完全脱离成本。 品牌1.0对应第4章中提到的省心型品牌，品牌2.0到品牌4.0对应悦己型品牌。省心型品牌面向只想快速找到具备基础质量保障且价格公道的商品的消费者，而 悦己型品牌则面向以购物为乐趣，期望买到高品质商品，或期望彰显身份与格调的消费者。\n品牌1.0：品牌即认知 我们生活中接触的大多数大众消费品品牌，属于品牌1.0的范畴。这类品牌的核心价值是组织生产，实现规模化降本增效，并且保证产品质量合格。这些品牌的存 在大幅提升了消费品产业的运转效率，并提供了质量背书，降低了消费者的搜索成本。\n怡宝 优衣库 从如此多的工厂中采购商品，同时保证各个型号和尺码的产品的质量与库存，这体现了优衣库作为一个省心型品牌所起到的组织生产功能。\n表7-1 优衣库部分核心代工厂\n优衣库在国内市场取得成功的原因包括：\n拥有领先的分销渠道 一方面是门店数量, 767家 另一方面是线上线下渠道的协同优衣库提供无缝的购物体验，其天猫旗舰店支持下单后到附近门店自提，这极大满足了顾客对即时性的需求。 品质稳定、性价比高 接地气，快反（快速反应），对本土文化理解度高 能做到快反的原因则是强大的供应链管理和库存管控能力。 品牌2.0：品牌即优选 这个层级以上的品牌，都具备较为突出的溢价能力。换句话说，“是否具备溢价能力”这一要素决定了品牌能否进入2.0以上的层级。当然，品牌在具备一定销量 和认知的基础上产生的溢价才有意义。如果一个品牌没有达到一定的规模，那就连品牌1.0都算不上。\n品牌溢价不会凭空产生，大多数产品产生溢价的原因可归结为：①文化属性认同感；②功能性区隔差异性。\n文化属性认同感来自品牌，每个品牌背后都代表一种精神，比如“Just do it”“Nothing is impossible”“一切皆有可能”“永不止步”等，对于精神文化 的认可会转为对于品牌的忠诚度。 功能性区隔差异性来自产品本身，运动鞋可以分成篮球鞋、跑步鞋等多个品种，每个品种下又有多种细分，比如跑步鞋分成缓冲、支撑、控制等条线。这样的 细分带来了功能性区隔差异性，不同的人、不同的用途，适用不同的产品。 图7-2 溢价来自文化属性认同感和功能性区隔差异性\n跻身2.0阶段的一个国货品牌是安踏旗下的FILA。\n图7-3 FILA、耐克、阿迪达斯运动产品价格带对比（2021年7月）\n品牌3.0：品牌即品类 如何简单地理解“品牌即品类”？\n一想到某些细分品类、特定功能，就自然而然地想到某个品牌。比如很多消费者提起羽绒服就想到波司登，提起智能手机就想到苹果和华为，提起电动车就想到 特斯拉，这都是品牌3.0的体现。这类品牌的特点是与品类强绑定，并且具备较高的溢价。\n有一些品牌有很高的市占率，却没有涨价空间，它们并不属于3.0品牌，可以称其为“伪3.0品牌”。事实上，这类品牌很容易陷入“价格涨不动、市占率已经饱和、 行业规模没有扩张空间”的增长瓶颈。区分伪3.0品牌和真3.0品牌的核心要素，是品牌的涨价能力。\n2020年，我国功能性护肤品龙头品牌薇诺娜牢牢占据国内功能性护肤品市场份额第一的地位，其品牌在一定程度上代表了针对敏感肌的功能性护肤品品类。\n图7-4 薇诺娜在功能性护肤品中的市占率逐年提升\n薇诺娜的一部分产品是先由合作医院的医生提出临床需求，之后联合当地高校共同研发的。新品诞生后，由合作医院用于临床辅助治疗，结合临床的良好反馈将 产品推向市场。\n图7-5 薇诺娜的“产学研”合作机制\n总而言之，品牌3.0的核心在于通过与品类实现强绑定，得到较高的溢价能力。我们可以在日常生活中留意这类“提起品类想到品牌”的现象，在这类品牌里不乏 具备独特壁垒和较强涨价能力的重要标的。\n品牌4.0：品牌即身份 “品牌即身份”指的是拥有或使用某个品牌的商品，就能够拥有某种身份。此类现象常见于奢侈品品牌以及某些品牌的限量产品\n品牌要达到4.0阶段，文化属性认同感可能会比功能性区隔差异性更为重要。\n拥有极高溢价的品类往往集合了社交属性和彰显格调两个因素，因为具备这两个因素的产品更容易形成文化属性认同感。 当然大多数4.0品牌仍然拥有功能性区隔差异性。如很多奢侈品品牌都有其精通的领域： 爱马仕之于皮具，劳力士之于手表，巴宝莉之于大衣，等等。 功能性区隔差异性一定程度上也是品牌打造文化属性认同感的一个基础条件。 4.0品牌的产品通常会形成稳定交易的二级市场。\n对于一般的消费品，二手商品的价格相比原价会有明显折让，且流动性不佳； 但某些强势品牌的产品却能够产生广泛流通的二级市场（即玩家间相互交易），甚至产生做市商（比如二手奢侈品专卖店）。这意味着这些产品已经具备 “通货”属性，具备极强的价格认知。随着时间的推移，一部分产品在二级市场上的流通价格甚至可能超过产品的原始定价。我们将这类现象称为“品牌4.0+”。 7.3 案例一：直播电商带来了什么 直播电商的规模有多大？根据艾瑞咨询的预测，2021年我国直播电商市场规模约为2.27万亿元（见图7-7），在整个线上消费市场中的渗透率约为15.5%。这意 味着每6～7个包裹中，可能就有一个来自直播电商渠道。\n图7-7 中国直播电商市场规模\n很多人会认为直播电商的火热仅仅是因为直播平台的流量大，这是一个非常典型的误解。在分析直播电商的时候，我们要放下“销售量=流量×转化率”的思路。这 个思路过于简单，会让我们忽略很多重要的问题，进而得到错误的结论。在商品销售的商业模型中，曝光次数、转化率、价格、毛利率、复购次数都是关键的指 标，只关注流量（曝光次数）而忽略了价格和复购，是常见的误区。定价格带、通过品牌宣传带来自然流量乃至复购，都是品牌经营中的重要环节。商家对价格 带和复购的追求，会在相当大的程度上影响其商业行为。事实上，很多直播电商的商家不赚钱（甚至亏本），他们参与直播电商的原因是希望提升知名度，并最 终通过复购和自然流量赚钱。\n图7-8 2020～2021年各大主要直播电商品平台GMV\n淘宝直播的特点是头部主播占据极高的话语权，品牌商家几乎难以通过头部主播赚钱。 快手主播的头部化也比较明显，主播通过私域流量销售亲民品牌或产业带品牌； 抖音的特色则在于品牌自播，品牌通过自播实现营销和变现是相对比较容易的，没有特别突出的头部主播。 淘宝头部主播带货：商家核心诉求是品宣而非盈利 为什么这些主播能够拥有如此之强的议价能力？\n播之间“强者愈强”的马太效应循环就此形成：主播成交额高—议价能力强—品牌给的折扣低—成交额更高。 图7-9 2021年9月淘宝直播平台前10名主播带货GMV\n商家请淘宝头部主播带货很难直接盈利，一方面是因为头部主播要求的折扣力度大，另一方面是这些头部主播通常会向品牌方收取高额的佣金。\n头部主播通常通过“坑位费+佣金”的形式向品牌商家收费。\n坑位费是只要开播上架了商品就会收取的费用，而不论实际成交额的多少； 佣金则按实际成交额的百分比来收取。 那么品牌商家为何还要让主播来帮他们带货？主要还是品宣的考量。\n淘宝店铺自播：主要作用是转化而非引流 图7-10 在截至2021年9月的12个月内，淘宝直播的商家自播占比达60%\n引流和转化有什么区别？核心在于是否能够让用户产生计划以外的选择。\n比如某消费者计划在A和B两个品牌的产品中购买其一，最终不论买了A还是B，都属于这两个品牌的“转化”。但若是发现并购买了C，就相当于品牌C做了一次 成功的“引流”。 一个渠道是否有这样的引流功能，会直接决定渠道的获利空间，引流功能越强的渠道，通常盈利能力也越强。 淘宝的店铺自播如何促进转化？\n第一，直播能比图文带来更好的展示效果，从而促进用户下单。 第二，直播互动能起到一部分“客服”的职能，效果也优于传统的客服。 第三，有的店家会在直播间中发放专属的直播优惠，这也能起到促进转化的效果。 淘宝店铺自播和抖音、快手自播的最大区别在于引流的能力。\n大多数用户点进自播间之前就应进入了相应品牌或店铺的首页，这意味着其实淘宝的店铺自播引流能力并不强。 而抖音、快手的店铺自播则是用户“刷”出来的，用户在进入直播间之前可能并不认识这些品牌或店家，这类店铺自播能帮助商家起到较强的引流效果。 快手直播：头部主播帮助亲民品牌和产业带品牌卖货 在前文中，我们就提到了消费产业链有三个主要环节：供应链（提供商品）、品牌（提供认知和信任）、渠道（提供流通和触达）。\n快手直播的特殊之处在于：快手头部主播充当的是品牌环节 而淘宝、抖音等平台上的主播主要属于渠道环节。 首先，快手是一个以主播带货为主、主播头部化程度较高的平台。\n快手的调性和文化是比较独特的，对比过快手、抖音、淘宝直播的人会很容易发现，快手直播的内容给人的感觉是很不一样的。很多商家难以把握快手的口味 和调性，很难做好自播，他们只能依靠达人带货来进驻快手。 快手的主播集中程度似乎远低于淘宝平台，但我们要注意，其中很多大主播都属于“辛巴家族”, 如果把“辛巴家族”所有主播的成交额都算到一起，那么快手带 货主播的集中程度非常之高。 图7-11 2021年9月快手直播平台前10名主播带货GMV\n其次，快手直播下单用户的流量来源主要是私域流量，这和淘宝、抖音等平台有很大不同。如果消费者下单之前就已经是主播的粉丝了，那就将其归为私域流量， 否则是公域流量。\n快手直播达人的下单客户大多是其粉丝，这是由：\n①快手主播充当了“品牌”这件事情导致的，消费者一般都会是其信任的主播的粉丝； ②快手平台的页面设计导致的，在快手App里通过“关注”页面进入直播间是最方便的方法，而在用户离开某个直播间时，系统也会弹出窗口提醒用户关注主播， 这样的设计增加了用户关注他们感兴趣的主播的概率。 最后，快手头部主播销售的很多商品是亲民品牌的商品，或产业带品牌的商品。\n对于很多产业带品牌而言，其在品牌认知上是有所欠缺的。这些品牌的产品可能拥有不错的质量，但由于缺乏品牌认知，很多消费者没有足够的信心去购买这 些商品。快手的主播在直播过程中充当了“品牌”，用其自身的名誉为这些产品提供了背书。 这个环境并不适合大多数品牌\n一是因为其去品牌化的平台调性 二是因为品牌自身也很难在这样的生态中展开自播带货（公域流量池小，难以和主播私域流量竞争）。 抖音直播：品牌化+去中心化的直播平台，是品牌崛起的好土壤 抖音是三大直播电商平台中中心化程度最低的。平衡的主播生态使得每个主播相对品牌的议价权都比较适中，因此品牌商家找抖音主播带货的费用率显著低于淘 宝电商的头部主播，这样就有了更好的盈利能力。\n图7-12 2021年9月抖音直播平台前10名主播带货GMV\n店铺自播是抖音平台的亮点所在，也是抖音平台的重点发展方向。\n对于平台而言，直接向商家收费、绕开达人这个中间环节有利于提升盈利能力； 对于商家而言，摆脱达人意味着其将能够完全拥有直播带来的流量，并可以随心所欲地定制直播内容，甚至可起到提升品牌形象的效果。 未来抖音平台内的自播不会完全取代达人播，达人播的趣味性一般强于自播，达人播的存在有助于平衡平台的内容生态和商业生态，是连接内容与商业的一座桥 梁。\n图7-13 抖音自播与达人播的市场份额（以GMV计）\n抖音直播的环境使其成为上佳的品牌化舞台。\n第一，品牌有直接盈利的可能，这一方面源于达人播较为平衡的费率，另一方面源于自播生态的完善。 第二，在抖音开设自播间并实现冷启动并不难，抖音有公平高效的付费推广系统，同时拥有较为完善的代运营体系（品牌商家很难独自完成直播的相关事务， 很多工作需要在代运营商的帮助之下完成）。 第三，抖音具备品牌化的心智，平台的调性和主要受众适合大多数的知名品牌。 同样作为品牌化的直播电商平台，抖音和淘宝的区别在何处？本质上在于用户的目的性。\n淘宝的用户通常带有较强的购物目的，他们上淘宝的目的就是买东西，所以能够接受头部主播“报价格”的直播方式； 抖音更注重内容，很多用户上抖音的最初目的是找乐子，因此若想要获得成交，销售的内容就要足够吸引人。 直播电商的增长驱动力之一：用户数量的增长 直播电商用户数还有很大的提升空间\n图7-14 2021年6月中国网民、直播电商用户数结构\n直播电商的增长驱动力之二：核心品类渗透率提升 直播电商聚焦的品类有如下特点：①毛利润高；②需要一定的展示效果。这些品类包括服装、化妆品、珠宝、零食酒水等。只有毛利润足够高的产品，才能支撑 得起直播带来的相关费用。而需要展示效果的产品，更能够发挥视频直播在商品展示效果上的优势。\n图7-15 2021年四季度抖音品类结构（按成交额）\n总之，从品类的视角看，直播电商的增长逻辑在于提升了线上购物的体验感，从而拿到了一些本来属于线下渠道的市场份额。从这个角度看，随着人们对直播电 商接受程度的提升和用户习惯的养成，未来直播电商的市场还有很大的增长空间。\n拆解各方诉求，分析渠道影响，发掘投资机会 对新渠道的分析，最重要的是对各个参与方的分析。了解各个参与方之间的联系与诉求，是理解渠道、发现投资机会的关键所在。\n红人环节：很难产生明显的机会 主播环节主要包括红人本身、MCN机构、相关中介机构等。\nMCN机构真的能成为好的长期投资标的吗？恐怕很难。\n直播电商行业主播的马太效应是很强的，主播的体量和议价权呈两极分化的态势。 MCN机构基本可以分为两类：\n一类是绑定了头部主播的MCN机构，另一类是服务中腰部主播的MCN机构。 前者在头部主播之下，基本上没有像样的话语权；而后者手中的主播在行业中的地位不强，因此也不具备显著的投资价值，且如果后者手中的中小主播长成了 头部主播，MCN机构将很可能失去话语权，沦为头部主播的依附。 平台与产业工厂环节：选择有限 平台有可能成为非常好的投资方向，但主要问题在于选择有限。\n2021年直播电商行业的三巨头是淘宝、快手、抖音。\n对于阿里巴巴，看好淘宝直播的发展不构成投资阿里巴巴的直接理由，淘宝直播在阿里巴巴集团中占据的体量比较小，远不如天猫的分量大。此外，淘宝头部 主播话语权过强、经营生态一般的事实，也给淘宝直播的投资价值打了折扣。 对于快手而言，中国强大的消费品供应链是其稳定发展的坚实后盾，而足够接地气的平台氛围也使其成为足够独特的资产。但商业化内容与平台体验之间的天 然冲突如何处理，以及头部主播群体如何提高抽佣率，都会是未来的重要问题。 字节跳动的抖音各方面都非常优秀，可惜并没有上市。 快手直播电商的崛起给优秀的产业带工厂带来了重要的发展机遇，不过这里也很难产生投资机会。一般而言，找主播带货的企业大多为中小型的产业工厂，绝大 部分没有上市；而成功上市的头部代工企业（如申洲国际、华利集团等）都绑定了稳定的大客户，它们一般不会把自己的产品放到快手上销售，因此不构成直播 电商的直接受益对象。\n品牌：重要的投资机会所在 总之，国产品牌通过各方面竞争实力的逐渐释放逐渐蚕食国外传统大牌的份额，将会是未来数年服装、化妆品等消费品领域的发展大趋势，而像直播电商这样的 新兴渠道，将会成为这一趋势的重要加速器。未来，我们不但要关注国产品牌在各个渠道，尤其是直播电商这样的新兴渠道中的发展情况，也要关注其他重要渠 道变革带来的品牌投资机会。\n7.4 案例二：为何拼多多难跑出新品牌 拼多多还是一个社交电商吗 从商业模式、运营模式、流量分发、营销工具、品类结构等方面来看，拼多多都在向淘系电商靠近。可以认为，拼多多并没有成为多年前人们想象的“社交电商”， 而是逐渐变成了另一个“货架电商”。\n什么是社交电商，什么是货架电商 零售生意可以简单划归为流量获取和转化、成交履约、形成复购三个环节\n社交电商中的“社交”二字主要体现在流量获取和转化上，即通过熟人之间的分享介绍促成交易。 货架电商会把商品摆在各种展示位, 在购物决策的过程中，货架电商的消费者一般较少依赖他们的社交关系。 淘宝、天猫、京东显然不属于社交电商，我们一般称之为“货架电商”或“搜索电商”。 拼多多平台内的流量结构与淘宝越来越相似，以搜索为主导 一般判断电商平台流量来源的方式是看用户如何进入“商品详情”页面。\n与其说拼多多是个社交电商，不如说它也是一个搜索电商。\n图7-18 2020年拼多多流量结构\n拼多多的流量结构与淘宝已经非常相似，两个平台自然流量的前两大来源都是搜索和推荐。\n图7-19 2018～2020年淘宝流量结构\n从流量结构上看，拼多多和淘宝相比，最大的差异在于活动流量。\n淘宝和拼多多拥有相似的运营逻辑 淘宝和拼多多在运营上的相似之处在于：\n第一，二者都看重商品的展现排位，都采用通过付费流量提权重、通过免费流量以及复购盈利的模式； 第二，二者的投放工具大体上比较相似； 第三，付费流量投放的计价方式比较相似。 在中心化的电商平台里，商品在搜索和推荐结果中的排位越靠前，曝光量就越高。\n图7-20 电商平台中的商品展现排位影响其点击率\n自然流量（免费展位）的排位主要由“期望展现收益”决定。\n期望收益可以是GMV、广告收入（针对付费流量），也可以是顾客停留时间、访问深度、购物体验等。 在不同的阶段，平台会根据自身需求动态调整各项指标的权重，并把“期望展现收益”高的商品放在前排增加展示，从而实现平台综合效用的最大化。 图7-21 做投放是在淘宝、拼多多这类平台上经营的必选项\n投放的核心目的是改善权重，进而使自然流量占比提升，最终通过免费的自然流量获利。\n以手机搜索为例，在淘宝和拼多多搜索结果中，一般每5～7个会有一个广告，这意味着投放流量占比最高仅为20%，可见自然流量带来的销售额总量是远远高 于付费流量的。 因此，对于淘宝和拼多多而言，其运营投放的共性是：通过付费投放积攒数据，提升商品在自然展位中的排位，最后通过自然流量的提升赚钱。\n拼多多和淘宝的投放工具比较类似 拼多多主要的底层投放工具包括多多搜索、多多场景、多多进宝、明星店铺、合约推广等。\n多多搜索提供付费搜索信息服务，和淘系的直通车较为相似； 多多场景相当于淘系的超级推荐，对应信息流推荐位中的流量； 多多进宝相当于淘宝客，是达人使用平台外链分享带来的流量； 淘宝和拼多多都有明星店铺，用于在搜索结果的上方展示店铺及热销商品。 这些主要的投放工具在两大平台上的收费方式也基本相同：\n搜索和信息流广告的收费方式都按用户点击次数收费（CPC） 淘宝客和多多进宝都按照成交额百分比收费（CPS） 明星店铺都按千次展示收费（CPM）。 两个平台CPC类投放（搜索、信息流）的定价方式是相似的，都是竞价\n图7-22 淘宝直通车计费方式\n在这套竞价体系下：\n①流量的价格在商家之间的博弈中产生，取决于商家的付费意愿，而非由平台直接掌控，流量价格将随着商家之间竞争的激烈程度而水涨船高； ②不是出价高就一定能获得展现，平台通过质量分把控投放商品的质量，保证用户体验，质量分体系使得积淀较少的新商品、新商家的投放费用更高，加剧了 马太效应； ③CPC广告是点击了才扣费，质量分能确保较稳定的广告点击率，维持平台广告消耗的平稳。 两个平台主要的不同在于一些级别更高的自动投放工具。拼多多的OCPX工具有自动投放的功能，会自动帮助商家调整投放的参数，尝试出比较好的投放方案。\n淘宝、拼多多的商品构成大同小异 二者的核心差异点在于，淘系电商（尤其是天猫平台）拥有极强的品牌化能力，而拼多多几乎没有品牌化能力。因此，品牌认知较为重要的品类（如化妆品等） 在天猫上占比更高，而品牌认知不那么重要的品类（比如家纺、日用品等）在拼多多上的占比较高。\n数码电器在拼多多上占比较高的原因，在于拼多多“百亿补贴”重点补贴大牌数码类产品\n图7-23 2021年四季度拼多多品类结构\n我们知道化妆品是一个非常看重品牌的品类，中高端化妆品的出厂价可能只有售价的10%，溢价主要来自品牌。化妆品占比的差异，一定程度上反映了两个平台品 牌化能力的差异。\n图7-24 天猫2020年“双11”大促品类结构\n在分析这两大电商平台的时候，我们基本上可以套用同样的分析框架，即把分析的重心放在对成交额、用户数、货币化率等关键指标，以及平台整体生态和活力 等重要的经营细节的跟踪上。\n平台排名机制解析：为何拼多多的商品看上去比淘宝的便宜 主要原因在于：\n①我国拥有强大的商品供应链，能提供大量物美价廉的消费品； ②拼多多的排序机制使得低价爆款商品更容易获得前排展示； ③拼多多的补贴和商家的主动让利进一步拉低了价格。 其中最核心的一条在于，拼多多和淘系电商在排位权重的分配上有所不同，拼多多更看重“品”，而淘系电商更看重“店”，因此拼多多上的高性价比爆品有更大的 机会拿到高排位。\n淘宝上不是没有便宜的商品，但是有些低价商品在平台中得不到前排展示。在一些“埋得更深”的地方，常常会出现更具性价比的商品。 图7-25 在淘宝上排名靠后的商品也有好价格\n造成天猫品牌化能力强、拼多多难跑出新品牌这个差异的直接原因，在于平台的排序机制。\n拼多多上的便宜商品能够很快得到前排展现，而淘系电商的头部商家在平台上的展现排序更为稳固。 拼多多上的头部商家如果失去了价格优势，就有可能很快被新的商家挤下去； 而淘宝上的头部商家就算涨价，也能维持其在平台中的展现排位。 这不但使拼多多前排展示的商品看起来比淘宝的更便宜，也使两个平台的用户心智出现较大差异。 这对我们的消费品投资分析有何影响？\n首先，要判断一个品牌在电商上经营得是否成功，我们会更重视其在天猫、抖音等品牌化平台上的表现，而不怎么关注其在拼多多、社区团购乃至快手这类非 品牌化平台上的表现。 其次，在分析拼多多等这类平台上的大品牌时，我们更关注其在组织效率、基础质量保障等方面的实力，而非溢价能力。 最后，拼多多品牌化能力弱并不意味着平台变现能力差，向产业带品牌和经销商收费，也可实现较高的货币化率。 7.5 案例三：波司登的品牌升级之路 波司登是如何成功实现品牌升级的？\n第一，国货崛起的核心是“国”崛起，其次才是“货”崛起，我国国力日趋强盛，这使消费者对国产品牌的倾向性持续提升； 第二，羽绒服这类功能性服饰是一个天然的好赛道，容易出现市占率高、品牌溢价高的品牌； 第三，Moncler、加拿大鹅等品牌进驻中国，成功提升了消费者对于羽绒服的价格认知，这为波司登的品牌跃升打开了空间； 第四，波司登本身具备超凡的品牌运营能力，在适当的时机通过明星代言、登山队科考队背书等宣传，配合完成度高、实力强的产品，成功实现品牌跃迁。 国牌崛起的两条典型路径是功能性路径和效率性路径，波司登很明显走的是功能性路径。\n功能性路径专注于细分领域，给产品打上的标签，让消费者感受到品牌的专业度，从而抢占消费者的心智。 效率性路径则强调高周转、高性价比、快速反映用户需求、良好的终端触达等，让消费者能够省力放心地买到中意的商品。 波司登所在的功能性服饰赛道，是一个容易走出好品牌的优质赛道。所谓功能性服饰就是有特殊用途、特殊要求的服饰，比如羽绒服、运动服等。羽绒服赛道兼 具功能性和社交属性两个优质特性，容易诞生大品牌。\n2016～2017年，国际羽绒服大品牌Moncler、加拿大鹅在中国市场吸引了众多的消费者认购，中高端羽绒服消费开始崛起，波司登适时完成提价。\n图7-27 波司登在国内中高端羽绒服市场中一枝独秀\n波司登成功实现品牌升级和其自身的品牌实力也有脱不开的关系。\n第一，波司登有自己的羽绒服工厂，可从源头上把控生产工艺的每一个细节，实现精益求精。依托领先的制造工艺，波司登的产品在用料和做工上无可挑剔。 第二，波司登多年深耕羽绒服，其服装面料和工艺经历了多轮迭代，技术专业程度处于业内领先水平，产品质量的优异性久经考验。 第三，波司登的设计做得非常到位。 一是与迪士尼、漫威等大IP联名推出时尚羽绒服，获得年轻消费者的青睐； 二是与国际知名设计师合作，推出“高定羽绒服”“新一代羽绒服”系列，合作的设计师包括爱马仕黄金时代的缔造者让·保罗·戈尔捷。 第四，波司登在品牌宣传上也下了大功夫。一方面邀请杨幂等头部明星代言，另一方面积极赞助登山、科考等专业团队。 7.6 结语 品牌力就是品牌对其价格带的控制能力，包括定价能力、溢价能力、涨价能力。价格带就是品牌的生命线，降价容易提价难，品牌在保证一定销售规模的前提下， 保持价格带稳定要远远比多卖些货重要。历史上成功实现品牌升级、价格带提升的案例非常少，而能够持续实现价格提升的消费品更为稀缺，这些具备提价能力 的公司，都是消费行业中一等一的优秀公司。\n","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC7%E7%AB%A0-%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%81%E7%89%8C%E5%8A%9B/","summary":"7.1 定价能力是衡量品牌力的重要标准 既然不赚钱，为何商家要花大力气宣传、促销、做销售额、发战报呢？ 答案是：“卖货”和“卖价格带”是品牌经营的两大","title":"第7章 什么是品牌力"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/commerce/","summary":"主页","title":"U.S. Department of Commerce"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/iresearch/","summary":"主页","title":"艾瑞咨询"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/zhiyan/","summary":"主页","title":"智研咨询"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/swsresearch/","summary":"主页","title":"申万宏源研究"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/frost/","summary":"主页","title":"FROST \u0026 SULLIVAN"},{"content":"SQL是三值逻辑(three-valued logic)\n理论篇 两种NULL、三值逻辑还是四值逻辑\n未知(unknown). 以“不知道戴墨镜的人眼睛是什么颜色”这种情况为例，这个人的眼睛肯定是有颜色的，但是如果他不摘掉眼镜，别人就不知道他的眼睛是什 么颜色。 不适用(not applicable, inapplicable). 而“不知道冰箱的眼睛是什么颜色”则属于“不适用”。因为冰箱根本就没有眼睛 关系数据库中“丢失的信息”的分类\n四值逻辑真值表\n为什么必须写成“IS NULL”，而不是“＝NULL”\n对NULL使用比较谓词后得到的结果总是unknown。 1 2 3 4 5 6 --以下的式子都会被判为 unknown 1 = NULL 2 \u0026gt; NULL 3 \u0026lt; NULL 4 \u0026lt;\u0026gt; NULL NULL = NULL 为什么对NULL使用比较谓词后得到的结果永远不可能为真呢？\n因为NULL既不是值也不是变量。NULL只是一个表示“没有值”的标记，而比较谓词只适用于值。因此，对并非值的NULL使用比较谓词本来就是没有意义的 unknown、第三个真值\n书中用unknown表示三值逻辑的第三个值 书中用UNKNOWN表示NULL 1 2 3 4 5 --这个是明确的真值的比较 unknown = unknown → true --这个相当于NULL = NULL UNKNOWN = UNKNOWN → unknown 三值逻辑的真值表（NOT）\n三值逻辑的真值表（AND）\n三值逻辑的真值表（OR）\n记忆方法\nAND的情况： false ＞ unknown ＞ true OR的情况： true ＞ unknown ＞ false 优先级高的真值会决定计算结果。例如true AND unknown，因为unknown的优先级更高，所以结果是unknown。而true OR unknown的话，因为true优 先级更高，所以结果是true。 特别需要记住的是，当AND运算中包含unknown时，结果肯定不会是true（反之，如果AND运算结果为true，则参与运算的双方必须都为true）。 实践篇 1. 比较谓词和NULL(1)：排中律不成立 “把命题和它的否命题通过‘或者’连接而成的命题全都是真命题”这个命题在二值逻辑中被称为排中律（Law of Excluded Middle）。顾名思义，排中律就是 指不认可中间状态，对命题真伪的判定黑白分明，是古典逻辑学的重要原理。“是否承认这一原理”被认为是古典逻辑学和非古典逻辑学的分界线。\n如果排中律在SQL里也成立，那么下面的查询应该能选中表里的所有行。\n1 2 3 4 5 --查询年龄是20岁或者不是20岁的学生 SELECT ＊ FROM Students WHERE age = 20 OR age \u0026lt;\u0026gt; 20; 遗憾的是，在SQL的世界里，排中律是不成立的。假设表Students里的数据如下所示。\nStudents\n这条SQL语句无法查询到约翰，因为约翰年龄不详。\nSQL语句的查询结果里只有判断结果为true的行。要想让约翰出现在结果里，需要添加下面这样的“第3个条件”。\n1 2 3 4 5 6 --添加第3个条件：年龄是20岁，或者不是20岁，或者年龄未知 SELECT ＊ FROM Students WHERE age = 20 OR age \u0026lt;\u0026gt; 20 OR age IS NULL; 2. 比较谓词和NULL(2):CASE表达式和NULL 1 2 3 4 5 --col_1为1时返回○、为NULL时返回×的CASE表达式？ CASE col_1 WHEN 1 THEN\u0026#39;○\u0026#39; WHEN NULL THEN\u0026#39;×\u0026#39; END 这个CASE表达式一定不会返回×。这是因为，第二个WHEN子句是col_1 = NULL的缩写形式。这个式子的真值永远是unknown。\n正确写法\n1 2 3 CASE WHEN col_1 = 1 THEN\u0026#39;○\u0026#39; WHEN col_1 IS NULL THEN\u0026#39;×\u0026#39; END 3. NOT IN和NOT EXISTS不是等价的 Class_A\nClass_B\n考虑一下如何根据这两张表查询“与B班住在东京的学生年龄不同的A班学生”。\n希望查询到的是拉里和伯杰。因为布朗与齐藤年龄相同，所以不是我们想要的结果。 如果单纯地按照这个条件去实现，则SQL语句如下所示。 1 2 3 4 5 6 --查询与B班住在东京的学生年龄不同的A班学生的SQL语句？ SELECT ＊ FROM Class_A WHERE age NOT IN ( SELECT age FROM Class_B WHERE city =’东京’); 上面的sql查不到任何数据\n分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 --1．执行子查询，获取年龄列表 SELECT ＊ FROM Class_A WHERE age NOT IN (22, 23, NULL); --2．用NOT和IN等价改写NOT IN SELECT ＊ FROM Class_A WHERE NOT age IN (22, 23, NULL); --3．用OR等价改写谓词IN SELECT ＊ FROM Class_A WHERE NOT ( (age = 22) OR (age = 23) OR (age = NULL) ); --4．使用德·摩根定律等价改写 SELECT ＊ FROM Class_A WHERE NOT (age = 22) AND NOT(age = 23) AND NOT (age = NULL); --5．用\u0026lt;\u0026gt;等价改写NOT和= SELECT ＊ FROM Class_A WHERE (age \u0026lt;\u0026gt; 22) AND (age \u0026lt;\u0026gt; 23) AND (age \u0026lt;\u0026gt; NULL); --6．对NULL使用\u0026lt;\u0026gt;后，结果为unknown SELECT ＊ FROM Class_A WHERE (age \u0026lt;\u0026gt; 22) AND (age \u0026lt;\u0026gt; 23) AND unknown; --7．如果AND运算里包含unknown，则结果不为true（参考“理论篇”中的矩阵） SELECT ＊ FROM Class_A WHERE false或unknown; 如果NOT IN子查询中用到的表里被选择的列中存在NULL，则SQL语句整体的查询结果永远是空。\n为了得到正确的结果，我们需要使用EXISTS谓词。\n1 2 3 4 5 6 7 --正确的SQL语句：拉里和伯杰将被查询到 SELECT ＊ FROM Class_A A WHERE NOT EXISTS ( SELECT ＊ FROM Class_B B WHERE A.age = B.age AND B.city = ’东京’); 执行结果\n1 2 3 4 name age city ----- ---- ---- 拉里 19 埼玉 伯杰 21 千叶 分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 --1．在子查询里和NULL进行比较运算 SELECT ＊ FROM Class_A A WHERE NOT EXISTS ( SELECT ＊ FROM Class_B B WHERE A.age = NULL AND B.city =’东京’); --2．对NULL使用“=”后，结果为 unknown SELECT ＊ FROM Class_A A WHERE NOT EXISTS ( SELECT ＊ FROM Class_B B WHERE unknown AND B.city =’东京’); --3．如果AND运算里包含unknown，结果不会是true SELECT ＊ FROM Class_A A WHERE NOT EXISTS ( SELECT ＊ FROM Class_B B WHERE false或unknown); --4．子查询没有返回结果，因此相反地，NOT EXISTS为true SELECT ＊ FROM Class_A A WHERE true; 4. 限定谓词和NULL any与in等价\nClass_A\nClass_B\n思考一下用于查询“比B班住在东京的所有学生年龄都小的A班学生”的SQL语句。\n1 2 3 4 5 6 --查询比B班住在东京的所有学生年龄都小的A班学生 SELECT ＊ FROM Class_A WHERE age \u0026lt; ALL ( SELECT age FROM Class_B WHERE city =’东京’); 执行结果\n1 2 3 name age city ----- ---- ---- 拉里 19 埼玉 如果山田的年龄仍是NULL时的分析\nALL谓词其实是多个以AND连接的逻辑表达式的省略写法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --1．执行子查询获取年龄列表 SELECT ＊ FROM Class_A WHERE age \u0026lt; ALL ( 22, 23, NULL ); --2．将ALL谓词等价改写为AND SELECT ＊ FROM Class_A WHERE (age \u0026lt; 22) AND (age \u0026lt; 23) AND (age \u0026lt; NULL); --3．对NULL使用“\u0026lt;”后，结果变为 unknown SELECT ＊ FROM Class_A WHERE (age \u0026lt; 22) AND (age \u0026lt; 23) AND unknown; --4. 如果AND运算里包含unknown，则结果不为true SELECT ＊ FROM Class_A WHERE false 或 unknown; 5. 限定谓词和极值函数不是等价的 如果用极值函数重写刚才的SQL\n1 2 3 4 5 6 --查询比B班住在东京的年龄最小的学生还要小的A班学生 SELECT ＊ FROM Class_A WHERE age \u0026lt; ( SELECT MIN(age) FROM Class_B WHERE city =’东京’); 执行结果\n1 2 3 4 name age city ----- ---- ---- 拉里 19 埼玉 伯杰 21 千叶 没有问题。即使山田的年龄无法确定，这段代码也能查询到拉里和伯杰两人。这是因为，极值函数在统计时会把为NULL的数据排除掉。\nALL谓词和极值函数表达的命题含义\nALL谓词：他的年龄比在东京住的所有学生都小——Q1 极值函数：他的年龄比在东京住的年龄最小的学生还要小——Q2 还有一种情况下它们也是不等价的\n谓词（或者函数）的输入为空集的情况 Class_B没有住在东京的学生！\n使用ALL谓词的SQL语句会查询到A班的所有学生 然而用极值函数查询时一行数据都查询不到。 1 2 3 4 5 6 7 8 9 --1．极值函数返回NULL SELECT ＊ FROM Class_A WHERE age \u0026lt; NULL; --2．对NULL使用“\u0026lt;”后结果为 unknown SELECT ＊ FROM Class_A WHERE unknown; 6. 聚合函数和NULL COUNT以外的聚合函数在输入为空表时都返回NULL\n1 2 3 4 5 6 --查询比住在东京的学生的平均年龄还要小的A班学生的SQL语句？ SELECT ＊ FROM Class_A WHERE age \u0026lt; ( SELECT AVG(age) FROM Class_B WHERE city =’东京’); 本节小结 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-3-%E4%B8%89%E5%80%BC%E9%80%BB%E8%BE%91%E5%92%8Cnull/","summary":"SQL是三值逻辑(three-valued logic) 理论篇 两种NULL、三值逻辑还是四值逻辑 未知(unknown). 以“不知道戴墨镜的人眼睛是什么颜","title":"1-3 三值逻辑和NULL"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/moffatt/sql-joins/","summary":"原文","title":"Visual Representation of SQL Joins"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/codinghorror/sql-joins/","summary":"原文","title":"A Visual Explanation of SQL Joins"},{"content":"可重排列、排列、组合 Products\n有序对(排列)\n\u0026lt;1, 2\u0026gt; != \u0026lt;2, 1\u0026gt; 无序对(组合)\n{1, 2} == {2, 1} 通过交叉连接生成笛卡儿积（直积）生成有序对\n1 2 3 --用于获取可重排列的SQL语句 SELECT P1.name AS name_1, P2.name AS name_2 FROM Products P1, Products P2; 执行结果\n1 2 3 4 5 6 7 8 9 10 11 name_1 name_2 ------ ------ 苹果 苹果 苹果 橘子 苹果 香蕉 橘子 苹果 橘子 橘子 橘子 香蕉 香蕉 苹果 香蕉 橘子 香蕉 香蕉 去掉\u0026lt;苹果, 苹果\u0026gt;这种\n1 2 3 4 --用于获取排列的SQL语句 SELECT P1.name AS name_1, P2.name AS name_2 FROM Products P1, Products P2 WHERE P1.name \u0026lt;\u0026gt; P2.name; 执行结果\n1 2 3 4 5 6 7 8 name_1 name_2 ------ ------ 苹果 橘子 苹果 香蕉 橘子 苹果 橘子 香蕉 香蕉 苹果 香蕉 橘子 不能有（苹果，苹果）这样的组合\n去掉\u0026lt;苹果, 橘子\u0026gt;, \u0026lt;橘子, 苹果\u0026gt;这种\n1 2 3 4 --用于获取组合的SQL语句 SELECT P1.name AS name_1, P2.name AS name_2 FROM Products P1, Products P2 WHERE P1.name \u0026gt; P2.name; 执行结果\n1 2 3 4 5 name_1 name_2 ------ ------ 苹果 橘子 香蕉 橘子 香蕉 苹果 获取3个以上元素的组合\n1 2 3 4 5 --用于获取组合的SQL语句：扩展成3列 SELECT P1.name AS name_1, P2.name AS name_2, P3.name AS name_3 FROM Products P1, Products P2, Products P3 WHERE P1.name \u0026gt; P2.name AND P2.name \u0026gt; P3.name; 执行结果\n1 2 3 name_1 name_2 name_3 ------- -------- -------- 香蕉 苹果 橘子 删除重复行 删除重复行\n使用由数据库独自实现的行ID\n只有Oracle(rowid)和PostgreSQL(oid)才能使用, 其他数据库需要自己创建主键 1 2 3 4 5 6 --用于删除重复行的SQL语句(1)：使用极值函数 DELETE FROM Products P1 WHERE rowid \u0026lt; ( SELECT MAX(P2.rowid) FROM Products P2 WHERE P1.name = P2. name AND P1.price = P2.price ) ; 1 2 3 4 5 6 7 --用于删除重复行的SQL语句(2)：使用非等值连接 DELETE FROM Products P1 WHERE EXISTS ( SELECT ＊ FROM Products P2 WHERE P1.name = P2.name AND P1.price = P2.price AND P1.rowid \u0026lt; P2.rowid ); 查找局部不一致的列 假设有下面这样一张住址表，主键是人名\nAddresses\n前田夫妇。这两个人并没有分居，只是夫人的住址写错了而已, 需要修改一下\n所以这个表结构设计的不对\n找出像前田夫妇这样的“是同一家人但住址却不同的记录”, 用非等值自连接来实现，代码会非常简洁\n1 2 3 4 5 --用于查找是同一家人但住址却不同的记录的SQL语句 SELECT DISTINCT A1.name, A1.address FROM Addresses A1, Addresses A2 WHERE A1.family_id = A2.family_id AND A1.address \u0026lt;\u0026gt; A2.address ; 感觉这里的DISTINCT没什么用.\n从下面这张商品表里找出价格相等的商品的组合。\nProducts\n1 2 3 4 5 --用于查找价格相等但商品名称不同的记录的SQL语句 SELECT DISTINCT P1.name, P1.price FROM Products P1, Products P2 WHERE P1.price = P2.price AND P1.name \u0026lt;\u0026gt; P2.name; 执行结果\n1 2 3 4 5 6 7 name price ------ ------ 苹果 50 葡萄 50 草莓 100 橘子 100 香蕉 100 这里确实应该用DISTINCT.\n排序 按照价格从高到低的顺序, 让价格相同的商品位次也一样\nProducts\n使用窗口函数\n1 2 3 4 5 --排序：使用窗口函数 SELECT name, price, RANK() OVER (ORDER BY price DESC) AS rank_1, DENSE_RANK() OVER (ORDER BY price DESC) AS rank_2 FROM Products; 商品则有两种排序方法，一种是跳过之后的位次，另一种是不跳过之后的位次。\nrank_1跳过了之后的位次，rank_2没有跳过 MySQL8支持窗口函数 执行结果\n1 2 3 4 5 6 7 8 name price rank_1 rank_2 ------- ------ ------- ------- 橘子 100 1 1 西瓜 80 2 2 苹果 50 3 3 香蕉 50 3 3 葡萄 50 3 3 柠檬 30 6 4 不依赖于具体数据库来实现的方法\n1 2 3 4 5 6 7 8 --排序从1开始。如果已出现相同位次，则跳过之后的位次 SELECT P1.name, P1.price, (SELECT COUNT(P2.price) FROM Products P2 WHERE P2.price \u0026gt; P1.price) + 1 AS rank_1 FROM Products P1 ORDER BY rank_1; 查询比当前水果价格还要大的水果数n, n+1就是rank\n执行结果\n1 2 3 4 5 6 7 8 name price rank ----- ------ ------ 橘子 100 1 西瓜 80 2 苹果 50 3 葡萄 50 3 香蕉 50 3 柠檬 30 6 如果使用COUNT(DISTINCT P2.price)可以实现不跳过之后的位次\n自连接的写法\n1 2 3 4 5 6 7 8 --排序：使用自连接 SELECT P1.name, MAX(P1.price) AS price, COUNT(P2.name) +1 AS rank_1 FROM Products P1 LEFT OUTER JOIN Products P2 ON P1.price \u0026lt; P2.price GROUP BY P1.name ORDER BY rank_1; 查询当前水果价格能连接多少个n(p1.price\u0026lt;p2.price), n+1就是排名.\n本节小结 与多表之间进行的普通连接相比，自连接的性能开销更大（特别是与非等值连接结合使用的时候），因此用于自连接的列推荐使用主键或者在相关列上建立索引。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-2-%E8%87%AA%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%94%A8%E6%B3%95/","summary":"可重排列、排列、组合 Products 有序对(排列) \u0026lt;1, 2\u0026gt; != \u0026lt;2, 1\u0026gt; 无序对(组合) {1, 2} == {2, 1} 通过交叉连接生成笛卡儿积（直积）生成有序对 1 2 3 --用于获取可重排列的","title":"1-2 自连接的用法"},{"content":"CASE表达式概述 CASE表达式的写法\n1 2 3 4 5 6 7 8 9 10 --简单CASE表达式 CASE sex WHEN \u0026#39;1\u0026#39; THEN ’男’ WHEN \u0026#39;2\u0026#39; THEN ’女’ ELSE ’其他’ END --搜索CASE表达式 CASE WHEN sex =\u0026#39;1\u0026#39;THEN’男’ WHEN sex =\u0026#39;2\u0026#39;THEN’女’ ELSE ’其他’ END 剩余的WHEN子句被忽略的写法示例\n1 2 3 4 --例如，这样写的话，结果里不会出现“第二” CASE WHEN col_1 IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) THEN’第一’ WHEN col_1 IN (\u0026#39;a\u0026#39;) THEN’第二’ ELSE ’其他’ END 注意\n注意事项1：各分支返回的数据类型要一致, 否则报错 注意事项2：不要忘了写END 注意事项3：养成写ELSE子句的习惯 不写可能会造成“语法没有错误，结果却不对”这种不易追查原因的麻烦 养成这样的习惯后，我们从代码上就可以清楚地看到这种条件下会生成NULL，而且将来代码有修改时也能减少失误。 将已有编号方式转换为新的方式并统计 统计数据源表PopTbl\n统计结果\n用县名（pref_name）代替编号作为GROUP BY的列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 --把县编号转换成地区编号(1) SELECT CASE pref_name WHEN ’德岛’ THEN ’四国’ WHEN ’香川’ THEN ’四国’ WHEN ’爱媛’ THEN ’四国’ WHEN ’高知’ THEN ’四国’ WHEN ’福冈’ THEN ’九州’ WHEN ’佐贺’ THEN ’九州’ WHEN ’长崎’ THEN ’九州’ ELSE’其他’END AS district, SUM(population) FROM PopTbl GROUP BY CASE pref_name WHEN ’德岛’ THEN ’四国’ WHEN ’香川’ THEN ’四国’ WHEN ’爱媛’ THEN ’四国’ WHEN ’高知’ THEN ’四国’ WHEN ’福冈’ THEN ’九州’ WHEN ’佐贺’ THEN ’九州’ WHEN ’长崎’ THEN ’九州’ ELSE ’其他’ END; 将数值按照适当的级别进行分类统计\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 --按人口数量等级划分都道府县 SELECT CASE WHEN population \u0026lt; 100 THEN\u0026#39;01\u0026#39; WHEN population \u0026gt;= 100 AND population \u0026lt; 200 THEN\u0026#39;02\u0026#39; WHEN population \u0026gt;= 200 AND population \u0026lt; 300 THEN\u0026#39;03\u0026#39; WHEN population \u0026gt;= 300 THEN\u0026#39;04\u0026#39; ELSE NULL END AS pop_class, COUNT(＊) AS cnt FROM PopTbl GROUP BY CASE WHEN population \u0026lt; 100 THEN\u0026#39;01\u0026#39; WHEN population \u0026gt;= 100 AND population \u0026lt; 200 THEN\u0026#39;02\u0026#39; WHEN population \u0026gt;= 200 AND population \u0026lt; 300 THEN\u0026#39;03\u0026#39; WHEN population \u0026gt;= 300 THEN\u0026#39;04\u0026#39; ELSE NULL END; pop_class cnt --------- ---- 01 1 02 3 03 3 04 2 上面两种方式都要在select和group by中写相同的case, 在变更时可能会忘记同步, 下面的写法更方便\n严格来说，这种写法是违反标准SQL的规则的。因为GROUP BY子句比SELECT语句先执行，所以在GROUP BY子句中引用在SELECT子句里定义的别称是不被允 许的。事实上，在Oracle、DB2、SQL Server等数据库里采用这种写法时就会出错。 不过也有支持这种SQL语句的数据库，例如在PostgreSQL和MySQL中，这个查询语句就可以顺利执行。这是因为，这些数据库在执行查询语句时，会先对 SELECT子句里的列表进行扫描，并对列进行计算。 用一条SQL语句进行不同条件的统计 统计源表PopTbl2\n统计结果\n通常的做法是写两个sql, 可能然后再用union合并\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 男性人口 SELECT pref_name, SUM(population) FROM PopTbl2 WHERE sex =\u0026#39;1\u0026#39; GROUP BY pref_name; -- 女性人口 SELECT pref_name, SUM(population) FROM PopTbl2 WHERE sex =\u0026#39;2\u0026#39; GROUP BY pref_name; 用一条sql实现\n1 2 3 4 5 6 7 SELECT pref_name, --男性人口 SUM( CASE WHEN sex =\u0026#39;1\u0026#39;THEN population ELSE 0 END) AS cnt_m, --女性人口 SUM( CASE WHEN sex =\u0026#39;2\u0026#39;THEN population ELSE 0 END) AS cnt_f FROM PopTbl2 GROUP BY pref_name; 用CHECK约束定义多个列的条件关系 假设某公司规定“女性员工的工资必须在20万日元以下”，而在这个公司的人事表中，这条无理的规定是使用CHECK约束来描述的\n1 2 3 4 5 6 7 8 9 CONSTRAINT check_salary CHECK ( CASE WHEN sex =\u0026#39;2\u0026#39; THEN CASE WHEN salary \u0026lt;= 200000 THEN 1 ELSE 0 END ELSE 1 END = 1 ) 用逻辑与改写的CHECK约束如下所示。\n1 2 CONSTRAINT check_salary CHECK ( sex =\u0026#39;2\u0026#39;AND salary \u0026lt;= 200000 ) 这两个约束的程序行为不一样(第二个如果是男雇员也返回false了, 不符合命题)\n逻辑与和蕴含式的真值表\nU表示unknown 在UPDATE语句里进行条件分支 Salaries\n假设现在需要根据以下条件对该表的数据进行更新。\n对当前工资为30万日元以上的员工，降薪10%。 对当前工资为25万日元以上且不满28万日元的员工，加薪20%。 按照这些要求更新完的数据应该如下表所示。\n乍一看，分别执行下面两个UPDATE操作好像就可以做到，但这样的结果却是不正确的。\n1 2 3 4 5 6 7 8 9 --条件1 UPDATE Salaries SET salary = salary ＊ 0.9 WHERE salary \u0026gt;= 300000; --条件2 UPDATE Salaries SET salary = salary ＊ 1.2 WHERE salary \u0026gt;= 250000 AND salary \u0026lt; 280000; 正确的写法\n注意最后的else必须写, 否则返回null 1 2 3 4 5 6 7 --用CASE表达式写正确的更新操作 UPDATE Salaries SET salary = CASE WHEN salary \u0026gt;= 300000 THEN salary ＊ 0.9 WHEN salary \u0026gt;= 250000 AND salary \u0026lt; 280000 THEN salary ＊ 1.2 ELSE salary END; 调换主键值的方便写法\nSomeTable\n不使用case\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --1．将a转换为中间值d UPDATE SomeTable SET p_key =\u0026#39;d\u0026#39; WHERE p_key =\u0026#39;a\u0026#39;; --2．将b调换为a UPDATE SomeTable SET p_key =\u0026#39;a\u0026#39; WHERE p_key =\u0026#39;b\u0026#39;; --3．将d调换为b UPDATE SomeTable SET p_key =\u0026#39;b\u0026#39; WHERE p_key =\u0026#39;d\u0026#39;; 使用case\n适用于Oracle, DB2, SQL Server 不适用于PostgreSQL, MySQWL 1 2 3 4 5 6 7 8 --用CASE表达式调换主键值 UPDATE SomeTable SET p_key = CASE WHEN p_key =\u0026#39;a\u0026#39; THEN \u0026#39;b\u0026#39; WHEN p_key =\u0026#39;b\u0026#39; THEN \u0026#39;a\u0026#39; ELSE p_key END WHERE p_key IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;); 表之间的数据匹配 课程一览 CourseMaster\n开设的课程 OpenCourses\n我们要用这两张表来生成下面这样的交叉表\ncourse_name 6月 7月 8月 ----------- ---- ---- ---- 会计入门 ○ × × 财务知识 × × ○ 簿记考试 ○ × × 税务师 ○ ○ ○ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 --表的匹配：使用IN谓词 SELECT course_name, CASE WHEN course_id IN (SELECT course_id FROM OpenCourses WHERE month = 200706) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;6月\u0026#34;, CASE WHEN course_id IN (SELECT course_id FROM OpenCourses WHERE month = 200707) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;7月\u0026#34;, CASE WHEN course_id IN (SELECT course_id FROM OpenCourses WHERE month = 200708) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;8月\u0026#34; FROM CourseMaster; --表的匹配：使用EXISTS谓词 SELECT CM.course_name, CASE WHEN EXISTS (SELECT course_id FROM OpenCourses OC WHERE month = 200706 AND OC.course_id = CM.course_id) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;6月\u0026#34;, CASE WHEN EXISTS (SELECT course_id FROM OpenCourses OC WHERE month = 200707 AND OC.course_id = CM.course_id) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;7月\u0026#34;, CASE WHEN EXISTS (SELECT course_id FROM OpenCourses OC WHERE month = 200708 AND OC.course_id = CM.course_id) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;8月\u0026#34; FROM CourseMaster CM; 无论使用IN还是EXISTS，得到的结果是一样的，但从性能方面来说，EXISTS更好。通过EXISTS进行的子查询能够用到“month, course_id”这样的主键索引， 因此尤其是当表OpenCourses里数据比较多的时候更有优势。\n在CASE表达式中使用聚合函数 假设这里有一张显示了学生及其加入的社团的一览表。如表StudentClub所示，这张表的主键是“学号、社团ID”，存储了学生和社团之间多对多的关系。\nStudentClub\n我们按照下面的条件查询这张表里的数据。\n获取只加入了一个社团的学生的社团ID。 获取加入了多个社团的学生的主社团ID。 条件1的SQL\n1 2 3 4 5 --条件1：选择只加入了一个社团的学生 SELECT std_id, MAX(club_id) AS main_club FROM StudentClub GROUP BY std_id HAVING COUNT(＊) = 1; 执行结果1\n1 2 3 4 5 std_id main_club ------ ---------- 300 4 400 5 500 6 条件2的SQL\n1 2 3 4 --条件2：选择加入了多个社团的学生 SELECT std_id, club_id AS main_club FROM StudentClub WHERE main_club_flg =\u0026#39;Y\u0026#39;; 执行结果2\n1 2 3 4 std_id main_club ------ ---------- 100 1 200 3 如果使用CASE表达式，下面这一条SQL语句就可以了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 SELECT std_id, CASE WHEN COUNT(＊) = 1 --只加入了一个社团的学生 THEN MAX(club_id) ELSE MAX(CASE WHEN main_club_flg =\u0026#39;Y\u0026#39; THEN club_id ELSE NULL END) END AS main_club FROM StudentClub GROUP BY std_id; std_id main_club ------ ---------- 100 1 200 3 300 4 400 5 500 6 本节小结 最后说一点细节的东西。CASE表达式经常会因为同VB和C语言里的CASE“语句”混淆而被叫作CASE语句。但是准确来说，它并不是语句，而是和1+1或者a/b一样 属于表达式的范畴。结束符END确实看起来像是在标记一连串处理过程的终结，所以初次接触CASE表达式的人容易对这一点感到困惑。“表达式”和“语句”的名称 区别恰恰反映了两者在功能处理方面的差异。\n作为表达式，CASE表达式在执行时会被判定为一个固定值，因此它可以写在聚合函数内部；也正因为它是表达式，所以还可以写在SELECE子句、GROUP BY 子句、WHERE子句、ORDER BY子句里。简单点说，在能写列名和常量的地方，通常都可以写CASE表达式。从这个意义上来说，与CASE表达式最接近的不是面向 过程语言里的CASE语句，而是Lisp和Scheme等函数式语言里的case和cond这样的条件表达式。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-1-case%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"CASE表达式概述 CASE表达式的写法 1 2 3 4 5 6 7 8 9 10 --简单CASE表达式 CASE sex WHEN \u0026#39;1\u0026#39; THEN ’男’ WHEN \u0026#39;2\u0026#39; THEN ’女’ ELSE ’其他’ END --搜索CASE表达","title":"1-1 CASE表达式"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/smantic/","summary":"主页","title":"Smantic"},{"content":"8.1 内存分配 在Go的runtime中，有一系列函数被用来分配内存。\n例如与new语义相对应的有newobject()函数和newarray()函数，分别负责单个对象的分配和数组的分配。 与make语义相对应的有makeslice()函数、makemap()函数及makechan()函数及一些变种，分别负责分配和初始化切片、map和channel。 无论是new系列还是make系列，这些函数的内部无一例外都会调用runtime.mallocgc()函数，它就是Go语言堆分配的关键函数。\n8.1.1 sizeclasses Go的堆分配采用了与tcmalloc内存分配器类似的算法，tcmalloc是谷歌公司开发的一款针对C/C++的内存分配器，在对抗内存碎片化和多核性能方面非常优秀\n参考tcmalloc实现的内存分配器，内部针对小块内存的分配进行了优化。这类分配器会按照一组预置的大小规格把内存页划分成块，然后把不同规格的内存块放 入对应的空闲链表中\n图8-1 tcmalloc内存分配器预置不同规格的链表\n在Go源代码runtime包的sizeclasses.go文件中，给出了一组预置的大小规格。\n表8-1 sizeclasses预置的大小规格\n续表\nsizeclasses.go\n第一列是所谓的sizeclass，实际上就是所有规格按空间大小升序排列的序号。 第二列是规格的空间大小，单位是字节。 第三列表示需要申请多少字节的连续内存，目的是保证划分成目标大小的内存块以后，尾端因不能整除而剩余的空间要小于12.5%。Go使用8192字节作为页面 大小，底层内存分配的时候都是以整页面为单位的，所以第三列都是8192的整数倍。 第四列是第三列与第二列做整数除法得到的商 第五列则是余数，分别表示申请的连续内存能划分成多少个目标大小的内存块，以及尾端因不能整除而剩余的空间，也就是在内存块划分的过程中浪费掉的空 间。 最后一列表示的是最大浪费百分比，结合了内存块划分时造成的尾端浪费和内存分配时向上对齐到最接近的块大小造成的块内浪费。 sizeclasses.go文件是被程序生成出来的，源码就在 mksizeclasses.go文件中\n8.1.2 heapArena Go语言的runtime将堆地址空间划分成多个arena，在amd64架构的Linux环境下，每个arena的大小是64MB，起始地址也是对齐到64MB的。每个arena都有一 个与之对应的heapArena结构，用来存储arena的元数据\n图8-2 area与heapArena的关系\nheapArena是在Go的堆之外分配和管理的\nbitmap字段是个位图\n它用两个二进制位来对应arena中一个指针大小的内存单元，所以对于64MB大小的arena来讲，heapArenaBitmapBytes的值是 64MB/8/8×2＝2MB(64MB/8B=8M, 8M*2b/8=2MB)，这个位图在GC扫描阶段会被用到。 bitmap第一字节中的8个二进制位，对应的就是arena起始地址往后32字节的内存空间。 用来描述一个内存单元的两个二进制位当中，低位用来区分内存单元中存储的是指针还是标量，1表示指针，0表示标量，所以也被称为指针／标量位。 高位用来表示当前分配的这块内存空间的后续单元中是否包含指针，例如在堆上分配了一个结构体，可以知道后续字段中是否包含指针，如果没有指针就不需 要继续扫描了，所以也被称为扫描／终止位。 为了便于操作，一个位图字节中的指针／标量位和扫描／终止位被分开存储，高4位存储4个扫描／终止位，低4位存储4个指针／标量位。 图8-3 arena起始处分配一个slice对应的bitmap标记\nspans数组用来把当前arena中的页面映射到对应的mspan，暂时先认为一个mspan管理一组连续的内存页面\npagesPerArena表示arena中共有多少个页面，用arena大小(64MB)除以页面大小(8KB)得到的结果是8192\n图8-4 arena中的页面到mspan的映射\npageInUse是个长度为1024的uint8数组，实际上被用作一个8192位的位图\n通过它和spans可以快速地找到那些处于mSpanInUse状态的mspan。 虽然pageInUse位图为arena中的每个页面都提供了一个二进制位，但是对于那些包含多个页面的mspan，只有第1个页面对应的二进制位会被用到，标记的 是整个span。 图8-5 pageInUse位图标记使用中的span\npageMarks表示哪些span中存在被标记的对象\n与pageInUse一样用与起始页面对应的一个二进制位来标记整个span。 在GC的标记阶段会原子性地修改这个位图，标记结束之后就不会再进行改动了。 清扫阶段如果发现某个span中不存在任何被标记的对象，就可以释放整个span了。 不是被标记的才释放吗?\npageSpecials又是一个与pageInUse类似的位图，只不过标记的是哪些span包含特殊设置，目前主要指的是包含finalizers，或者runtime内部用来存储 heap profile数据的bucket。\ncheckmarks是一个大小为1MB的位图，其中每个二进制位对应arena中一个指针大小的内存单元。当开启调试debug.gccheckmark的时候，checkmarks位图 用来存储GC标记的数据。该调试模式会在STW的状态下遍历对象图，用来校验并发回收器能够正确地标记所有存活的对象。\nzeroedBase记录的是当前arena中下个还未被使用的页面的位置，相对于arena起始地址的偏移量。页面分配器会按照地址顺序分配页面，所以zeroedBase之 后的页面都还没有被用到，因此还都保持着清零的状态。通过它可以快速判断分配的内存是否还需要进行清零。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC8%E7%AB%A0-%E5%A0%86/","summary":"8.1 内存分配 在Go的runtime中，有一系列函数被用来分配内存。 例如与new语义相对应的有newobject()函数和newarray()函","title":"第8章 堆"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/docs/keepachangelog/","summary":"原文","title":"如何维护更新日志"},{"content":"代码地址\n","permalink":"https://jdxj.github.io/posts/docs/syslist/","summary":"代码地址","title":"Go交叉编译支持的系统与架构"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/karllhughes/the-best-golang-blogs/","summary":"原文","title":"The Best Golang Blogs"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/cch123/plan9/","summary":"原文","title":"Plan9 Assembly"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/docs/conventionalcommits/","summary":"原文","title":"约定式提交"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/fillmem/intellij-ideavim-repeat-key/","summary":"ideavim中没法长按按键重复字符解决办法","title":"Intellij Ideavim Repeat Key"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/alikhll/golang-developer-roadmap/","summary":"原文","title":"Golang Developer Roadmap"},{"content":"7.1 Happens Before 多核情况下避免并发读写的条件\nw happens before r。 没有其他针对v的写操作happens after w且before r。 图7-1 多线程并发事件示意图\n7.1.1 并发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 第7章 package main import ( \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { var data int var ok bool someValue := rand.Int() // 第7章 code_7_1 go func() { for { if !ok { data = someValue ok = true } } }() var sum int // 第7章 code_7_2 go func() { for { if ok { sum += data ok = false } } }() time.Sleep(time.Second * 10) } 如果编译器生成的指令与源码中语句的顺序严格一致，上述生产者协程和消费者协程在单核CPU上并发执行是可以保证结果正确的。一旦编译器对生成指令的顺序 进行优化调整，或者程序在多核CPU上执行，就不能保证结果正确了\n7.1.2 并行 抽象地解释并发，指的是多个事件在宏观上是同时发生的，但是并不一定要在同一时刻发生，而并行就不一样了，从微观角度来看，并行的两个事件至少有某一 时刻是同时发生的，所以在单核CPU上的多线程只存在并发，不存在并行。只有在多核CPU上，线程才有可能并行执行。\n7.2 内存乱序 处理器普遍具有乱序执行的特性，目的都是为了更优的性能。 编译器和CPU都会考虑指令间的依赖关系，在不会改变当前线程行为的前提下进行顺序调整，因此在单个线程内依然是逻辑有序的，语句间原本满足的 happens before条件不会被破坏，但这种有序性只是在单个线程内，并不会保证线程间的有序性。 7.2.1 编译期乱序 指的是编译器对最终生成的机器指令进行了顺序调整\n7.2.2 执行期乱序 CPU在执行期间也可能会对指令的顺序进行调整\n协程一和协程二中的两条赋值语句形式相似，对应到x86汇编就是三条内存操作指令，按照顺序及分类分别是Store、Load、Store\n图7-2 协程一和协程二的赋值语句对应的汇编指令\n一般的内存属于write-back cacheable内存，简称WB内存。对于WB内存而言，Store和Load指令并不是直接操作内存中的数据的，而是先把指定的内存单元 填充到高速缓存中，然后读写高速缓存中的数据。\nLoad指令的大致流程是，先尝试从高速缓存中读取，如果缓存命中，则读操作就完成了。如果缓存未命中，则先填充对应的Cache Line， 然后从Cache Line中读取\n图7-3 Load指令的执行流程\nStore指令的大致流程类似，先尝试写高速缓存，如果缓存命中，则写操作就完成了。如果缓存未命中，则先填充对应的Cache Line，然后写到Cache Line中\n图7-4 Store指令执行流程\n在多核心的CPU上，Store操作会变得更复杂一些。\n每个CPU核心都拥有自己的高速缓存，例如x86的L1 Cache。写操作会修改当前核心的高速缓存, 被修改的数据可能存在于多个核心的高速缓存中，CPU需要 保证各个核心间的缓存一致性。 目前主流的缓存一致性协议是MESI协议，MESI这个名字取自缓存单元可能的4种状态，分别是已修改的Modified，独占的Exclusive，共享的Shared和无 效的Invalid。 当一个CPU核心要对自身高速缓存的某个单元进行修改时，它需要先通知其他CPU核心把各自高速缓存中对应的单元置为Invalid，再把自己的这个单元置为 Exclusive，然后就可以进行修改了。\n图7-5 一个CPU核心修改高速缓存数据单元的过程\n这个过程涉及多核间的内部通信，是一个相对较慢的过程，为了避免当前核心因为等待而阻塞，CPU在设计上又引入了Store Buffer。当前核心向其他核心发出 通知以后，可以先把要写的值放在Store Buffer中，然后继续执行后面的指令，等到其他核心完成响应以后，当前核心再把Store Buffer中的值合并到高速 缓存中\n图7-6 引入Store Buffer后CPU修改高速缓存数据单元的过程\n虽然高速缓存会保证多核一致性，但是Store Buffer却是各个核心私有的，因此对其他核心不可见。在Store-Load乱序中，从微观时序上，Load指令可能是 在另一个线程的Store之后执行，但此时多核间通信尚未完成，对应的缓存单元还没有被置为Invalid，Store Buffer也没有被合并到高速缓存中，所以Load 读到的是修改前的值。\n图7-7 写入Store Buffer后合并到高速缓存前Load数据\n当协程一执行最后一条Store指令时，b就被赋值为0。同样地，协程二会将a赋值为0。即使Store Buffer合并到高速缓存，x和y都被修改为新值，也已经晚了\n图7-8 合并到高速缓存后的数据状态\n理论上可能出现的乱序有4种\nLoad-Load，相邻的两条Load指令，后面的比前面的先读到数据。 Load-Store，Load指令在前，Store指令在后，但是Store操作先变成全局可见，Load指令在此之后才读到数据。 Store-Load，Store指令在前，Load指令在后，但是Load指令先读到了数据，Store操作在此之后才变成全局可见。这个我们已经在x86平台见证过了。 Store-Store，相邻的两条Store指令，后面的比前面的先变成全局可见。 所谓的全局可见，指的是在多核CPU上对所有核心可见。\n7.2.3 内存排序指令 执行期乱序会给结果带来很大的不确定性，这对于应用程序来讲是不能接受的，完全按照指令顺序执行又会使性能变差。为了解决这一问题，CPU提供了内存排序 指令，应用程序在必要的时候能够通过这些指令来避免发生乱序。以目前的Intel x86处理器为例，提供了LFENCE、SFENCE和MFENCE这3条内存排序指令\n难以理解\n7.3 常见的锁 锁需要将所有线程（或协程）对临界区的访问进行串行化处理，需要同时保证两点要求：\n同时只能有一个线程获得锁，持有锁才能进入临界区。 当线程离开临界区释放锁后，线程在临界区内做的所有操作都要全局可见。 7.3.1 原子指令 如果CMP, JNE, MOV不在一条指令中执行, 那么加锁会出问题\n图7-9 同步问题\nx86就提供了CMPXCHG指令, 是Compare and Exchange的缩写，该指令有两个操作数，用于实现锁的时候，第一操作数通常是个内存地址，也称为目的操作 数，第二操作数是个通用寄存器。CMPXCHG会将AX寄存器和第一操作数进行比较，如果相等就把第二操作数复制到目的操作数中，若不相等就把目的操作数复制 到AX寄存器中。\n在多核环境下，运行在不同CPU核心上的线程可能会并行加锁，不同核心同时执行CMPXCHG又会造成多个线程同时获得锁。\n如何解决这个问题呢？\n一种思路是，在当前核心执行CMPXCHG时，阻止其他核心执行CMPXCHG，x86汇编中的LOCK前缀用于实现这一目的。\nLOCK前缀能够应用于部分内存操作指令，最简单的解释就是LOCK前缀会让当前CPU核心在当前指令执行期间独占总线，这样其他的CPU核心就不能同时操作内 存了。 事实上，只有对于不在高速缓存中的数据才会这样，对于高速缓存中的数据，LOCK前缀会通过MESI协议处理多核间缓存一致性。 在多核环境下，这种带有LOCK前缀的指令也被称为原子指令。 在x86CPU上，LOCK前缀同时具有内存排序的作用，相当于在应用LOCK前缀的指令之后紧接着执行了一条MFENCE指令。综上所述，原子指令既能保证只允许一个 线程进入临界区，又具有内存排序的作用，能够保证在锁的状态发生变化时，临界区中所有的修改随锁的状态一起变成全局可见。\n7.3.2 自旋锁 自旋锁得以实现的基础是原子性的CAS操作，CAS即Compare And Swap，在x86平台上对应带有LOCK前缀的CMPXCHG指令。之所以称作自旋锁，是因为它会一 直循环尝试CAS操作直到成功，看起来就像是一直在自旋等待。\n尝试一下用汇编语言基于CMPXCHG指令实现一把自旋锁\nlock()和unlock()这两个函数用汇编实现\nlock()函数把锁的地址放在了BX寄存器中，把用来比较的旧值old放到了DX寄存器中，把要写入的新值new放到了CX寄存器中。 从标签again处开始是一个循环，每次循环开始前，把DX寄存器的值复制给AX寄存器，因为CMPXCHG隐含使用AX寄存器中的值作为比较用的旧值，并且可能会 修改AX寄存器，所以每次循环需要重新赋值 这个循环不断尝试通过CMPXCHG进行加锁，成功后会通过JE指令跳出循环。能够通过JE跳出循环，这是因为CMP操作会影响标志寄存器。 unlock()函数通过XCHG指令将锁清零，实现了解锁操作。细心的读者可能会注意到这里没有LOCK前缀，根据Intel开发者手册所讲，XCHG指令隐含了LOCK 前缀，所以代码中不用写，依然能够起到独占总线和内存排序的作用。 事实上，atomic包中的CompareAndSwapInt32()函数和StoreInt32()函数是基于CMPXCHG和XCHG这两条汇编指令实现的，所以上述的自旋锁可以改成完全 用Go实现\n在锁竞争比较激烈的场景下，这种自旋会造成CPU使用率很高，所以还要进行优化。x86专门为此提供了PAUSE指令，它一方面能够提示处理器当前正处于自旋循 环中，从而在退出循环的时候避免因检测到内存乱序而造成性能损失。另一方面，PAUSE能够大幅度减小自旋造成的CPU功率消耗，从而达到节能和减少发热的效 果。\n可以把PAUSE指令加入我们汇编版本的lock()函数实现中\n可以把PAUSE指令单独放在一个函数中，这样就能够跟atomic包中的函数结合使用了\n自旋锁的适用场景\n不适用于单核, 因为单核系统上任一时刻只能有一个线程在运行，当前线程一直在自旋等待，而持有锁的线程得不到运行，锁就不可能被释放 即使是在多核环境下, 在持有锁的时间占比很小，并且活跃线程数接近CPU核心数量时，自旋锁比较高效，也就是自旋的代价小于线程切换的代价。 7.3.3 调度器对象 指操作系统提供的线程间同步原语\n这些调度器对象与自旋锁的不同主要是有一个等待队列。 当线程获取锁失败时不会一直在那里自旋，而是挂起后进入等待队列中等待，然后系统调度器会切换到下一个可运行的线程。 等到持有锁的线程释放锁的时候，会按照一定的算法从等待队列中取出一个线程并唤醒它，被唤醒的线程会获得所有权，然后继续执行。 这些同步原语是由内核提供的，直接与系统的调度器交互，能够挂起和唤醒线程，这一点是自旋锁做不到的。 等待队列可以实现支持FIFO、FILO，甚至支持某种优先级策略，但是也正是由于是在内核中实现的，所以应用程序需要以系统调用的方式来使用它，这就造 成了一定的开销。在获取锁失败的情况下还会发生线程切换，进一步增大开销。 7.3.4 优化的锁 将自旋锁和调度器对象结合，理论上就可以得到一把优化的锁了。加锁时首先经过自旋锁，但是需限制最大自旋次数，如果在有限次数内加锁成功也就成功了， 否则就进一步通过调度器对象将当前线程挂起。等到持有锁的线程释放锁的时候，会通过调度器对象将挂起的线程唤醒。这样就结合了二者的优点，既避免了加 锁失败立即挂起线程造成过多的上下文切换，又避免了无限制地自旋而空耗CPU，这也是如今主流的锁实现思路。\n7.4 Go语言的同步 推荐看极客时间的Go并发编程实战课\n7.5 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC7%E7%AB%A0-%E5%90%8C%E6%AD%A5/","summary":"7.1 Happens Before 多核情况下避免并发读写的条件 w happens before r。 没有其他针对v的写操作happens after w且before r。 图7-1 多线程并发事件示意图 7.1.1 并发 1 2","title":"第7章 同步"},{"content":"COUNT函数用于统计在符合搜索条件的记录中，指定的表达式expr不为NULL的行数有多少。\n对于COUNT(*)、COUNT(常数)、COUNT(主键)形式的COUNT函数来说，优化器可以选择最小的索引执行查询，从而提升效率，它们的执行过程是一样的，只不 过在判断表达式是否为NULL时选择不同的判断方式，这个判断为NULL的过程的代价可以忽略不计，所以我们可以认为COUNT(*)、COUNT(常数)、COUNT(主键) 所需要的代价是相同的。\n而对于COUNT(非主键列)来说，server层必须要从InnoDB中读到包含非主键列的记录，所以优化器并不能随心所欲的选择最小的索引去执行。\n原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/mysql%E7%9A%84count%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/","summary":"COUNT函数用于统计在符合搜索条件的记录中，指定的表达式expr不为NULL的行数有多少。 对于COUNT(*)、COUNT(常数)、COU","title":"MySQL的COUNT是怎么执行的"},{"content":"6.1 数解中国供应链 在我国强大的商品供应链之下，质量过硬的商品能以低廉的成本大量产出。\n图6-1 拼多多、1688上有许多高性价比的消费品\n图6-2 2010年全球奢侈品皮具代工市场份额（以销售额计）\n在效率方面，我国供应链工厂“小单快反”的响应能力领先世界。\n我国制造业具备较高的完善程度，形成了多个发达的产业集群，大部分原料都能在国内完成采购。\n图6-3 2016年各国制造业海外增加值占总出口之比\n图6-4 2016年中外制造业上游原材料能在国内购买的比重对比\n国内完备的制造业体系和稳定的经营环境，使得我国制造业具备无与伦比的韧性和抗打击能力。\n图6-5 疫情期间中外制造业PMI对比（以50%作为经济强弱的分界点，越高越好）\n我国拥有多个成型的产业集群，多个细分产品的产量世界领先。\n图6-6 2019年世界鞋类产量份额前10的国家\n图6-7 2019年全球家电出口额占比前六的国家\n6.2 亲临中国制造一线：南通家纺调研实录 叠石桥简介 叠石桥的支柱产业是制造与销售家纺产品，即大家通常所说的“床上四件套”，主要包括枕头和抱枕、床单、被单、被芯等。整个地方几乎就是一个家纺产业链集 群，差不多所有人都围着家纺产业链上下游工作，从各类原材料的供给、成品加工，到展示招商、快递收发，乃至线上店铺的经营培训，一应俱全。\n图6-8 叠石桥地理位置\n全球大约60%的家纺产品产自这个地方。可以认为，在全球家纺领域，“中国制造”几乎等价为“叠石桥制造”。\n叠石桥具备完整的家纺产业链 几乎整个叠石桥都围绕着家纺产业。从上游原料，到整件制造批发，再到与家纺制造销售有关的配套服务，五脏俱全。\n比“制造”更难的事情是“销售”，销售所需要的“品牌”具备护城河 能制造、缺品牌、卖不掉，是叠石桥最常见的问题。\n在叠石桥，我们能看到很多“贴牌加工、一件代发”的牌子。\n什么是贴牌加工？是我能设计，能制造，但是没有品牌，没有销路。谁如果有品牌、有渠道，那可以直接在我的产品上贴牌销售。 什么是一件代发？这是一个电商术语，如果你能够在电商平台上开店找到买家，你就不用进货，不用备库存，而是和我签协议，在你收到订单之后，我直接帮 你发货，这类似于线下零售的“代销”模式。 做品牌是一件风险相对较高的事情，品牌商品的库存会占用大量的现金流，也有失败的风险。因此对于很多工厂主而言，做一个新品牌是一件吃力不讨好的事情。\n总之，家纺产业链的难点不在于造，而在于卖。拥有好的品牌和销售渠道，比制造更重要。这也说明，在服装等产业中，销路往往比生产能力更值钱。\n6.3 如何兑现中国消费品供应链的真正价值 优质供应链品牌化或是未来消费行业的重要机会 产业链里的大多数工厂主，对于自己做品牌这件事热情并不大，他们一方面垂涎大品牌丰厚的利润，另一方面希望能够安安心心地搞生产，希望能够得到大品牌 的垂青。做出一个大品牌比生产出质量过硬的商品更难，因为品牌的经营涉及品牌营销、渠道管理、供应链管理等多方面的细节，对于中小企业主而言是一件比 较难的事情，同时也会占用较大的资金，带来较高的经营风险。\n成为大品牌的核心供应商，是供应链企业的重要成长方向 大品牌对其供应商的要求更高\n第一，代工厂要保证稳定的质量和足够的合格率，因为质量低下的产品有可能会一夜之间毁掉大品牌多年以来积累的口碑。 第二，代工厂要保证出货的效率，天下武功唯快不破，在互联网时代，品牌方也需要快速响应市场动态以保持竞争力。 第三，代工厂也要保证其经营的正规性，因为品牌方一定不会希望因为代工厂的经营和管理问题而使得自己的口碑受到影响。 管理能力是供应商的一个核心壁垒。\n供应商通常需要聘用大量的员工作为制造人员，而为了保证成本，大部分制造人员的学历并不高。 考虑到工人的熟练度会随着生产逐渐提升，企业不但要打造完善的员工培训体系，还要尽可能保证工人的留存率。如果工人流动太快，熟练度不高，生产效率 和质量将会受到影响。 品牌方构建的合作关系也是一个重要壁垒。\n为了保障质量的稳定和管理的便利，大品牌的供应商构成会相对比较稳定。有时候品牌方甚至会主动向供应商输出管理方法和制造工艺，以提升产品的总体质 量。 因此，在没有出现重大问题的情况下，品牌方通常较少更换其核心供应商。这样一来，与品牌方建立的合作关系就成了供应商的重要经营壁垒：稳定的合作关 系意味着稳定的订单，同时这种关系也为供应商挡住了部分潜在竞争对手。 跨境电商是我国优质供应链突围的另一个重要方向 图6-10 中国跨境电商市场规模与增长率\n为什么是电商，而非传统的线下渠道？第一，海外的电商渠道尚未成型，存在弯道超车的空间；第二，线上渠道的开店成本低，且我国商家在电商渠道上具备更 强大的竞争优势。\n国内商家在对互联网和电商的理解上具备领先优势。我国的电商规模和电商渗透率在世界范围内处于领先地位，也拥有大量经过激烈竞争后沉淀下来的电商从 业人员，他们在剖析平台规则的方法论、对电商消费者心理的把控、对互联网的理解等方面，都展现出一定的优势。 国外电商渠道里的机会更大。它们的线下渠道发展已经基本进入成熟期，而线上渠道仍在发展过程中。 图6-11 美国电商渗透率\n跨境电商大致分为三类，从出现的先后顺序上来说：第一类是只做渠道的“大卖家”，这是跨境电商初期的形式；第二类是做跨境品牌的“品牌商”；第三类是同时 做品牌和线上渠道的“独立站”。品牌商和独立站是现阶段的主流形式\n表6-1 跨境电商的主要形式\n海外电商行业的市场格局和我国的最大不同，在于独立站的份额比较大。在美国，除了亚马逊之外，其他平台的份额都不高，用户也习惯于在各个品牌的官 方网站上购买产品，因此在国外，独立站有较大发展空间。\n做独立站还有一个好处，就是可以做出更加精美的展示页面，这对于服饰类商家来说是比较重要的。亚马逊、eBay的展现页面总体上比较简约，展现服饰类商品 时有所不足，而海外用户2021年也暂时没有养成在社交媒体上下单的购物习惯（事实上他们非常在意购物的隐私，因此海外用户是否会像我国用户一样在抖音上 下单，需要多久养成这个习惯，都需要时间观察）。因此，独立站对于服装等一些品类而言，是一个非常好的选择。\n独立站的启动难度和经营风险都是最高的。\n第一，海外网购的主要支付方式是信用卡的安全码，用户由于害怕卡片被盗刷，因此很少在自己不信任的平台上下单。 第二，亚马逊等平台上的大卖家和品牌商可以直接使用平台提供的仓储服务，但独立站通常需要自建海外仓库，所有的东西都从国内跨境发货，时效性和用户 体验都会很差。由于难度大、风险高，独立站在最近几年才逐渐发展起来。 6.4 结语 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC6%E7%AB%A0-%E4%BE%9B%E5%BA%94%E9%93%BE-%E4%B8%AD%E5%9B%BD%E6%B6%88%E8%B4%B9%E7%9A%84%E5%BA%95%E6%B0%94/","summary":"6.1 数解中国供应链 在我国强大的商品供应链之下，质量过硬的商品能以低廉的成本大量产出。 图6-1 拼多多、1688上有许多高性价比的消费品 图6-2 2","title":"第6章 供应链 中国消费的底气"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/cnnic/","summary":"主页","title":"中国互联网络信息中心"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/euromonitor/","summary":"主页","title":"Euromonitor"},{"content":"6.1 进程、线程与协程 6.1.1 进程 现代操作系统利用硬件提供的页表机制，通过为不同进程分配独立的页表，实现进程间地址空间的隔离。\n图6-1 进程间地址空间的隔离\nLinux通过clone系统调用来创建新的进程。\n6.1.2 线程 为什么要有一个用户栈和一个内核栈呢？\n因为我们的线程在执行过程中经常需要在用户态和内核态之间切换，通过系统调用进入内核态使用系统资源。 对于内核来讲，任何的用户代码都被视为不安全的，可能有Bug或者带有恶意的代码，所以操作系统不允许用户态的代码访问内核数据。 图6-2 线程的用户栈和内核栈\n调度系统切换线程时，如果两个线程属于同一个进程，开销要比属于不同进程时小得多\n因为不需要切换页表，相应地，TLB缓存也就不会失效。 同一个进程中的多个线程，因为共享同一个虚拟地址空间，所以线程间数据共享变得十分简单高效 图6-3 同进程间线程切换\n在线程切换频繁时，调度本身的开销会占用大量CPU资源，造成系统吞吐量严重下降。\n6.1.3 协程 从具体实现来看，纤程就是一个由入口函数地址、参数和独立的用户栈组成的任务，相当于让线程可以有多个用户栈\n图6-4 纤程概念示意图\n6.2 IO多路复用 6.2.1 3种网络IO模型 把一个常见的TCP socket的recv请求分成两个阶段：一是等待数据阶段，等待网络数据就绪；二是数据复制阶段，把数据从内核空间复制到用户空间。\n对于阻塞式IO来讲，整个IO过程是一直阻塞的，直至这两个阶段都完成。\n图6-5 经典的阻塞式网络IO模型\n如果想要启用非阻塞式IO，需要在代码中使用fcntl()函数将对应socket的描述符设置成O_NONBLOCK模式。\n在非阻塞模式下，线程等待数据的时候不会阻塞，从编程角度来看就是recv()函数会立即返回，并返回错误代码EWOULDBLOCK（某些平台的SDK也可能是 EAGAIN），表明此时数据尚未就绪，可以先去执行别的任务。 程序一般会以合适的频率重复调用recv()函数，也就是进行轮询操作。在数据就绪之前，recv()函数会一直返回错误代码EWOULDBLOCK。 等到数据就绪后，再进入复制数据阶段，从内核空间到用户空间。 因为非阻塞模式下的数据复制也是同步进行的，所以可以认为第二阶段也是阻塞的。 图6-6 非阻塞式网络IO模型\n有了非阻塞式IO是不是就万事大吉了呢？\n虽然第一阶段不会阻塞，但是需要频繁地进行轮询。一次轮询就是一次系统调用，如果轮询的频率过高就会空耗CPU，造成大量的额外开销 如果轮询频率过低，就会造成数据处理不及时，进而使任务的整体耗时增加。 IO多路复用技术就是为解决上述问题而诞生的\n与非阻塞式IO相似，从socket读写数据不会造成线程挂起。 在此基础之上把针对单个socket的轮询改造成了批量的poll操作，可以通过设置超时时间选择是否阻塞等待。 只要批量socket中有一个就绪了，阻塞挂起的线程就会被唤醒，进而去执行后续的数据复制操作。 图6-7 IO多路复用\n6.2.2 示例对比 6.3 巧妙结合 把每个网络请求放到一个单独的协程中去处理，底层的IO事件循环在处理不同的socket时直接切换到与之关联的协程栈\n图6-10 协程与IO多路复用的结合\n这样一来，就把IO事件循环隐藏到了runtime内部，开发者可以像阻塞式IO那样平铺直叙地书写代码逻辑，尽情地把数据存放在栈帧上的局部变量中，代码执行 网络IO时直接触发协程切换，切换到下一个网络数据已经就绪的协程。当底层的IO事件循环完成本轮所有协程的处理后，再次执行netpoll，如此循环往复，开 发者不会有任何感知，程序却得以高效执行。\n6.4 GMP模型 6.4.1 基本概念 G指的就是goroutine；M是Machine的缩写，指的是工作线程；P则是指处理器Processor，代表了一组资源，M要想执行G的代码，必须持有一个P才行。\n6.4.2 从GM到GMP 在早期版本的Go实现中（1.1版本之前），是没有P的，只有G和M\n图6-11 GM调度模型\nGM调度模型有几个明显的问题\n用一个全局的mutex保护着一个全局的runq（就绪队列），所有goroutine的创建、结束，以及调度等操作都要先获得锁，造成对锁的争用异常严重。 G的每次执行都会被分发到随机的M上，造成在不同M之间频繁切换，破坏了程序的局部性 每个M都会关联一个内存分配缓存mcache，造成了大量的内存开销，进一步使数据的局部性变差。 在存在系统调用的情况下，工作线程经常被阻塞和解除阻塞，从而增加了很多开销。 为了解决上述这些问题，新的调度器被设计出来。\n总体的优化思路就是将处理器P的概念引入runtime，并在P之上实现工作窃取调度程序。 M仍旧是工作线程，P表示执行Go代码所需的资源。当一个M在执行Go代码时，它需要有一个关联的P，当M执行系统调用或者空闲时，则不需要P。 图6-12 GMP调度模型\n本地runq和全局runq 当一个G从等待状态变成就绪状态后，或者新创建了一个G的时候，这个G会被添加到当前P的本地runq。 当M执行完一个G后，它会先尝试从关联的P的本地runq中取下一个，如果本地runq为空，则到全局runq中去取 如果全局runq也为空，就会去其他的P那里窃取一半的G过来。 图6-13 本地runq为空到全局runq获取G\n图6-14 全局runq也为空窃取其他P的G\nM的自旋 当一个M进入系统调用时，它必须确保有其他的M来执行Go代码。新的调度器设计引入了一定程度的自旋，就不用再像之前那样过于频繁地挂起和恢复M了，这 会多消耗一些CPU周期，但是对整体性能的影响是正向的。 自旋分两种：第一种是一个有关联P的M，自旋寻找可执行的G；第二种是一个没有P的M，自旋寻找可用的P。这两种自旋的M的个数之和不超过GOMAXPROCS， 当存在第二种自旋的M时，第一种自旋的M不会被挂起(因为P不够)。 当一个新的G被创建出来或者M即将进行系统调用，或者M从空闲状态变成忙碌状态时，它会确保至少有一个处于自旋状态的M（除非所有的P都忙碌），这样保 证了处于可执行状态的G都可以得到调度，同时还不会频繁地挂起、恢复M。 6.5 GMP主要数据结构 6.5.1 runtime.g runtime.g部分字段\n表6-1 runtime.g部分字段的用途\nstack是个结构体类型, 用来描述goroutine的栈空间的，对应的内存区间是一个左闭右开区间[lo，hi]。\n1 2 3 4 type stack struct { lo uintptr hi uintptr } sched用来存储goroutine执行上下文, 它与goroutine协程切换的底层实现直接相关，其对应的gobuf结构代码如下\nsp字段存储的是栈指针 pc字段存储的是指令指针 g用来反向关联到对应的G ctxt指向闭包对象，也就是说用go关键字创建协程的时候传递的是一个闭包，这里会存储闭包对象的地址 ret用来存储返回值，实际上是利用AX寄存器实现类似C函数的返回值，目前只发现panic-recover机制用到了该字段。lr在arm等架构上用来存储返回地址， x86没有用到该字段 bp用来存储栈帧基址。 atomicstatus描述了当前G的状态\n表6-2 atomicstatus的取值及其含义\nwaiting对应的sudog结构\n6.5.2 runtime.m runtime.m部分字段\n表6-3 runtime.m部分字段的用途\n6.5.3 runtime.p runtime.p部分字段\n表6-4 runtime.p各个字段的主要用途\nstatus字段有5种不同的取值，分别表示P所处的不同状态\n表6-5 P的不同状态\n6.5.4 schedt Go 1.16版源代码中的schedt结构定义\n表6-6 schedt部分字段的主要用途\n","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC6%E7%AB%A0-goroutine/","summary":"6.2 IO多路复用写的不是特别详细","title":"第6章 Goroutine"},{"content":" ","permalink":"https://jdxj.github.io/posts/hello/","summary":"用于测试hugo特性.","title":"Hello Hugo!"},{"content":"5.1 中国零售渠道概览 我国的零售渠道分布情况在世界范围内都很独特，其独特性主要归为两点。\n我国电商渠道无比发达。 我国传统零售渠道的占比仍然很高。 图5-1 2021年我国零售渠道份额分布, 注：由于四舍五入，相加不为100%\n电商已经成为我国零售商业的一个重要成长来源。\n我国零售商业与西方国家非常大的一个差异在于线下零售的发达程度\n西方国家在线下发展完善之后才出现了电商，因此电商的推进速度并不快 我国线下零售在发展到一半的时候就受到了电商崛起的冲击，在电商逐渐趋于成熟之后，线下零售的发展遭受到了一定的压制。 图5-2 我国各零售渠道规模增速\n目前我国零售商业的形态是比较割裂的。\n一边是先进高效、已经具备世界领先水平的电商渠道，另一边则是仍然占据较大市场份额的传统零售渠道 我国拥有复杂的城市层级结构，这些传统零售渠道遍布在广大的市井之中。这种割裂的环境未来可能仍将伴随中国消费行业不断前行。 思考零售渠道，就是思考“人”“货”“场”之间的关系。\n“人-货-场”是零售商业中一个经典的分析模型。零售生意的本质，就是把“人”和“货”通过“场”连接起来。\n具体来说，“人”指的就是消费者，对应的是消费者的画像和其消费诉求； “货”指的选品，对应的是商场中的品类结构、产品价格带、品牌阶层等； “场”指的是消费者购物的场所，场所的位置在哪儿、商品如何陈列、要放多少个SKU，都是这个环节的核心问题。 渠道需求分析框架：多快好省\n对人的分析，其实就是对消费者需求的分析。人物画像、用户层级等数据，其实最后都要归到多、快、好、省这四个维度中来。\n其中，“多”代表可选择的商品多，消费者能够找到所需要的所有商品； “快”代表方便快捷，包括购物所需时间短、门店离消费者近，以及网购时配送速度快； “好”不但代表商品的质量又好又稳定，也代表购物体验的优势； “省”则是价格便宜。 图5-3 不同渠道在多、快、好、省上有不同侧重点\n处于不同位置的渠道，分析时有不同的侧重点。\n比如，对于超市这种品类“多”的渠道，我们要考量其动销情况，并且要重点关注其经营效率； 对于便利店这种注重“快”的渠道，要密切关注门店的数量和密度； 对于京东这样通过自营物流做到“快”和“好”的渠道，则要密切关注物流的覆盖面和经营效率。 货：不同的渠道适合不同的品类，区分盈利品类和引流品类\n在渠道商业中，品类的聚集效应是一个非常重要的规律。同一类商品的门店聚集在一起，能够汇聚更多的人流量，实现相互引流，使得彼此的生意都变得更好。\n从线下线上渠道的对比上看，线上渠道适合标准化、重复消费的商品，线下渠道则适合注重体验感和即时性的品类。\n图5-4 2021年各大消费品品类的线上渗透率\n我们在分析渠道品类结构的时候，也要注意区分引流品类和利润品类。\n有的品类能够吸引很多的人流量，但不一定能够产生太高的利润； 另外一些品类不具备引流的能力，却是渠道的利润中心。 场：经销、代销、联营、租赁的商业模式解析\n租赁就是把自己的地盘租给别人经营，并收取一定的租金，业主基本不会介入太多日常经营。 经销就是自己选品，以自有资金大批量进货，赚取批发和零售之间的差价，并承担商品滞销、贬值等风险。总的来说，租赁是风险最低、介入经营程度最低的 模式，而经销是风险最高、介入经营程度最高的模式。 代销和联营是比较难以理解的两个模式，处于经销和租赁的中间。代销是指把商品放在他人的店铺中，由他人代为销售，存货风险由自己承担。 联营是指与他人联合经营，比如由他人负责提供场地，并负责装修和固定资产的购置，而己方负责进货、生产、销售等环节，并按照事先约定进行利润分成。 具体的例子, 假设小明同学要卖面包，他有如下经营方式可选\n①租下一个门店，自己装修开业，成为面包店店主，这是经销模式，而出租这家门店的业主，则以租赁模式参与了零售商业； ②把自己手中的面包放在由他人运营的超市货架上，由超市帮忙出售，每卖出一个面包就与超市分成结算，所有卖不出去的都算在小明头上，这是代销； ③盘下楼下超市的一个面包柜台，自己站在柜台前销售自己的面包，并以固定租金或扣点的形式与超市分账，这是联营。 有时我们也会简化以上分类，而用“1P”和“3P”来区分零售商业公司的经营业态。1P指的是自营，3P指的是平台。\n1P就是“1st-Party”，指的是销售商品的货值会呈现在企业报表的收入和营业成本之中；京东 3P是“3rd-Party”，指的是企业销售商品的货值不会呈现在报表的收入和成本项中。天猫 5.2 中国电商，世界第一 图5-5 2019年各国零售电商销售额\n电商也已经渗入我国居民生活的方方面面。\n图5-6 中国历年电商渗透率\n发达便利的快递网络、扎实的移动网络建设，使得身处中小城镇乃至乡村的居民，也能享受到网购带来的实惠与便利。\n图5-7 中国网购用户已突破8亿人, 注：2021H1表示2021年上半年\n新冠肺炎疫情期间，电商是国民经济的压舱石，是居民日常消费的诺亚舟。\n图5-8 电商是我国社会零售额增长的重要引擎\n我们在分析消费品品牌时，必须重点关注其互联网运营能力以及在电商渠道上的表现。\n线上营销能力强、线上渠道建设较好的商家通常具备更好的发展前景； 而不重视线上化趋势的商家则有被时代淘汰的可能。 5.3 阿里巴巴、京东、拼多多：卖货还是卖流量 阿里巴巴、京东、拼多多是我国市场份额前三的电商平台。尽管它们都被消费者称为“平台”，但盈利方式和商业实质却存在着根本上的不同。\n图5-9 2020年中国电商平台市场份额\n线下零售生意分为买卖和收租，前者卖货，后者卖流量\n平台电商≈购物中心或小商品城，自营电商≈百货商超\n简单对比平台电商和自营电商：\n平台电商更轻，自营电商更重。平台电商的核心资产在于流量本身，重点是要做好流量的聚合与分发。这些平台的实物资产可能只是一些服务器，但平台自有 流量的价值远远高于这些服务器的价值。 自营电商的核心资产是履约体系，通常包括大量的仓库、运输车辆、配送人员等。履约体系是其保证大规模、高效率、好体验的根基所在。 平台电商：更应关注GMV和货币化率\nGMV指用户下单的总金额 货币化率等于平台收入除以GMV，这是反映平台盈利能力的重要指标。 自营电商：关注收入、利润率、周转率\n一般而言，我们需要关注毛利率、履约毛利率、营业利润率等指标：\n①毛利率直接反映了平台进销差价及其变化幅度。 ②履约毛利率是毛利率减去仓储、物流的费用率，这个指标直接反映了平台的边际利润率，即每一笔订单能够赚到的钱。对于一个健康的平台而言，履约毛利 率最好为正数，否则将“做一单亏一单”。 ③营业利润率是在履约毛利率的基础上，进一步扣减营销、管理、研发费用率得来的，反映了平台的整体盈利水平。 5.4 淘宝、天猫、拼多多的利润实质是广告收入 阿里巴巴本质上是一家以广告费和佣金为主要收入来源的“线上商业地产公司”\n佣金是如何产生的？\n在交易环节，淘宝平台的商家是免佣金的；天猫平台的商家需要向阿里巴巴支付固定金额的年费，以及占成交额一定比例的佣金。佣金率主要根据品类而定，平 时很少调整，大多数品类的佣金率介于0.3%～5%之间。其中，服装、化妆品的佣金率较高，充值、3C数码产品的佣金率较低。\n表5-1 天猫平台2020年各经营类目佣金率及年费\n淘系电商有着多种多样的广告投放工具\n阿里巴巴佣金货币化率的小幅提升主要来自\n①天猫平台成交额占比的提升，淘宝平台不收取佣金，天猫占比越高，佣金货币化率越高； ②天猫高佣金货币化率品类的成交额占比提升。广告费货币化率的提升是平台货币化率增长的核心驱动力。 图5-10 阿里巴巴货币化率及构成\n为何阿里巴巴的广告费货币化率能够连续多年实现增长？\n阿里巴巴推出了B2C平台“天猫”，直接与品牌商合作。 增加移动端广告库存。广告库存可以直接理解为广告位的数量，这个指标与广告收入、货币化率都有较强的相关性。 上线“千人千面”的推荐机制。个性化算法 拼多多也是一个“卖流量”的平台\n从平台经营实质上来看，如今的拼多多与阿里巴巴差异不大，都是通过商家的投放来盈利。拼多多和阿里巴巴的主要区别在于平台上的商家构成不同，以及用户 对于这两个平台的心智定位不同，即淘宝天猫代表品牌商品，而拼多多代表非品牌商品或折扣商品。\n拼多多如果不能实现品牌化，那未来的潜在盈利能力还高吗？\n高。去品牌化不意味着没有盈利能力，拼多多的货币化率已经接近阿里巴巴了。我国的消费品制造业世界领先，在多个地区拥有多类消费品产业集群，如浙 江小商品、江苏家纺等，这些集群的产品物美价廉却缺乏销路，而拼多多是一个好的去处。\n5.5 结语 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC5%E7%AB%A0-%E6%B8%A0%E9%81%93-%E4%BA%92%E8%81%94%E7%BD%91%E5%92%8C%E7%94%B5%E5%95%86%E6%98%AF%E4%B8%AD%E5%9B%BD%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%98%E9%87%8F/","summary":"5.1 中国零售渠道概览 我国的零售渠道分布情况在世界范围内都很独特，其独特性主要归为两点。 我国电商渠道无比发达。 我国传统零售渠道的占比仍然很高。 图","title":"第5章 渠道 互联网和电商是中国消费行业的核心变量"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/news/bloomberg/","summary":"主页","title":"Bloomberg"},{"content":"多线程并发读/写同一个TCP socket是线程安全的，因为TCP socket的读/写操作都上锁了。虽然线程安全，但依然不建议你这么做，因为TCP本身是基于数据流的协 议，一份完整的消息数据可能会分开多次去写/读，内核的锁只保证单次读/写socket是线程安全，锁的粒度并不覆盖整个完整消息。因此建议用一个线程去 读/写TCP socket。\n多线程并发读/写同一个UDP socket也是线程安全的，因为UDP socket的读/写操作也都上锁了。UDP写数据报的行为是\u0026quot;原子\u0026quot;的，不存在发一半包或收一半包的问题， 要么整个包成功，要么整个包失败。因此多个线程同时读写，也就不会有TCP的问题。虽然如此，但还是建议用一个线程去读/写UDP socket。\n原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/socket%E6%98%AF%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97/","summary":"多线程并发读/写同一个TCP socket是线程安全的，因为TCP socket的读/写操作都上锁了。虽然线程安全，但依然不建议你这么做，因为T","title":"Socket是并发安全的吗"},{"content":"主要看下模型对比.\n原文\n","permalink":"https://jdxj.github.io/posts/articles/cnblogs/skychen1218/rabbitmq%E4%B8%8Ekafka%E9%80%89%E5%9E%8B%E5%AF%B9%E6%AF%94/","summary":"主要看下模型对比. 原文","title":"RabbitMQ与Kafka选型对比"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/cnblogs/rude3knife/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/","summary":"原文","title":"缓存与数据库一致性问题深度剖析"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/cnblogs/duck-and-duck/%E8%80%81%E6%9D%BF%E8%A6%81%E6%88%91%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%BC%95%E6%93%8E/","summary":"原文","title":"老板要我开发一个简单的工作流引擎"},{"content":"DDD 是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。\n原文\n","permalink":"https://jdxj.github.io/posts/articles/cnblogs/courage129/ddd%E5%85%B4%E8%B5%B7%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB/","summary":"DDD 是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。 原文","title":"DDD兴起的原因以及与微服务的关系"},{"content":"5.1 空接口 是指不包含任何方法的接口interface{}\n5.1.1 一个更好的void∗ 如果用unsafe.Sizeof()函数获取一个interface{}类型变量的大小，在64位平台上是16字节，在32位平台上是8字节。interface{}类型本质上是个 struct，由两个指针类型的成员组成，在runtime中可以找到对应的struct定义\n1 2 3 4 type eface struct { _type *_type data unsafe.Pointer } 还有一个专门的类型转换函数efaceOf()，该函数接受的参数是一个interface{}类型的指针，返回值是一个eface类型的指针，内部实际只进行了一下指针类 型的转换，也就说明interface{}类型在内存布局层面与eface类型完全等价。\n1 2 3 func efaceOf(ep *interface{}) *eface { return (*eface)(unsafe.Pointer(ep)) } data字段是一个unsafe.Pointer类型的指针，用来存储实际数据的地址。 unsafe.Pointer在含义上和C语言中的void∗有些类似，只用来表明这是一个指针，并不限定指向的目标数据的类型，可以接受任意类型的地址。 _type字段用来描述data的类型元数据 1 2 3 // 第5章 code_5_1.go var n int var e interface{} = \u0026amp;n 图5-1 空接口变量e与赋值变量n的关系\n就变量n本身而言，它的类型信息只会被编译器使用，编译阶段参考这种类型信息来分配存储空间、生成机器指令，但是并不会把这种类型信息写入最终生成的 可执行文件中。从内存布局的角度来讲，变量n在64位和32位平台分别占用8字节和4字节，占用的这些空间全部用来存放整型的值，没有任何空间被用来存放整 型类型信息。\n把变量n的地址赋值给interface{}类型的变量e的这个操作，意味着编译器要把∗int的类型元数据生成出来，并把其地址赋给变量e的_type字段，这些类型元 数据会被写入最终的可执行文件\n1 2 3 4 5 // 第5章 code_5_2.go func p2e(p *int) (e interface{}) { e = p return } 反编译p2e()\n等价伪代码\n对于interface{}类型的变量e，它的声明类型是interface{}, _type会随着变量e装载不同类型的数据而发生改变，所以后文中将它称为变量e的动态类型， 并相应地把变量e的声明类型称为静态类型。\n5.1.2 类型元数据 在C语言中类型信息主要存在于编译阶段，编译器从源码中得到具体的类型定义，并记录到相应的内存数据结构中，然后根据这些类型信息进行语法检查、生成 机器指令等。例如x86整数加法和浮点数加法采用完全不同的指令集，编译器根据数据的类型来选择。这些类型信息并不会被写入可执行文件，即使作为符号数 据被写入，也是为了方便调试工具，并不会被语言本身所使用。\nGo与C语言不同的是，在设计之初就支持面向对象编程，还有其他一些动态语言特征，这些都要求运行阶段能够获得类型信息，所以语言的设计者就把类型信息 用统一的数据结构来描述，并写入可执行文件中供运行阶段使用，这就是所谓的类型元数据。\nGo 1.15版本的runtime源码\n表5-1 _type各字段的含义及主要用途\n_type提供了适用于所有类型的最基本的描述，对于一些更复杂的类型，例如复合类型slice和map等，runtime中分别定义了maptype、slicetype等对应的 结构。\n1 2 3 4 type slicetype struct { typ _type elem *_type } Go语言允许为自定义类型实现方法，这些方法的相关信息也会被记录到自定义类型的元数据中，一般称为类型的方法集信息。\n1 type Integer int 图5-2 自定义类型Integer的类型元数据结构\n_type结构的tflag字段是几个标志位，当tflagUncommon这一位为1时，表示类型为自定义类型。从runtime的源码可以发现，_type类型有一个 uncommon()方法，对于自定义类型可以通过此方法得到一个指向uncommontype结构的指针\nuncommontype结构的定义代码如下：\n通过pkgpath可以知道定义该类型的包名称 mcount表示该类型共有多少个方法 xcount表示有多少个方法被导出 moff是个偏移值，那里就是方法集的元数据，也就是一组method结构构成的数组。 例如，若为自定义类型Integer定义两个方法，它的类型元数据及其method数组的内存布局如图5-3所示。\n图5-3 Integer类型元数据及其method数组的内存布局\n可以将type method struct理解为tcp封包中的header.\n图5-4 method数组排序\n通过name偏移能够找到方法的名称字符串 mtyp偏移处是方法的类型元数据，进一步可以找到参数和返回值相关的类型元数据。 ifn是供接口调用的方法地址 tfn是正常的方法地址，这两个方法地址有什么不同呢？ifn的接收者类型一定是指针，而tfn的接收者类型跟源代码中的实现一致 以上这些类型元数据都是在编译阶段生成的，经过链接器的处理后被写入可执行文件中，runtime中的类型断言、反射和内存管理等都依赖于这些元数据.\n5.1.3 逃逸与装箱 data字段是个指针，那么它是如何接收来自一个值类型的赋值的呢？\n1 2 3 // 第5章 code_5_3.go n := 10 var e interface{} = n 图5-5 interface{}类型的变量e的数据结构\n把第5章/code_5_3.go放到一个函数中\n1 2 3 4 5 // 第5章 code_5_4.go func v2e(n int) (e interface{}) { e = n return } 反汇编\n等价的伪代码\nruntime.convT64()函数的源代码\nstaticuint64s是个长度为256的uint64数组，每个元素的值都跟下标一致，存储了0～255这256个值，主要用来避免常用数字频繁地进行堆分配。\n图5-6 staticuint64s数组\n图5-7 变量e的数据结构\n值类型装箱就一定会进行堆分配吗？\n1 2 3 4 5 6 7 8 // 第5章 code_5_5.go func fn(n int) bool { return notNil(n) } func notNil(a interface{}) bool { return a != nil } 编译时需要禁止内联优化，编译器还能够通过notNil()函数的代码实现判定有没有发生逃逸，反编译fn()函数得到的汇编代码如下\n转换为等价的伪代码\n图5-8 fn()函数的调用栈\n注意局部变量v，它实际上是被编译器采用隐式方式分配的，被用作变量n的值的副本，却并没有分配到堆上。\ninterface{}在装载值的时候必须单独复制一份，而不能直接让data存储原始变量的地址，因为原始变量的值后续可能会发生改变，这就会造成逻辑错误。\n5.2 非空接口 5.2.1 动态派发 多态\n方法地址静态绑定 要进行方法（函数）调用，有两点需要确定：\n一是方法的地址，也就是在代码段中的指令序列的起始地址； 二是参数及调用约定，也就是要传递什么参数及如何传递的问题（通过栈或者寄存器），返回值的读取也包含在调用约定范畴内。 不使用接口而直接通过自定义类型的对象实例调用其方法的例子\n1 2 3 4 //go:noinline func ReadFile(f *os.File, b[]byte) (n int, err error) { return f.Read(b) } 反编译\n伪代码\n从汇编语言的角度来看，上述方法的调用是通过CALL指令＋相对地址实现的，方法地址在可执行文件构建阶段就确定了，一般将这种情况称为 方法地址的静态绑定。\n对于动态派发来讲，编译阶段能够确定的是要调用的方法的名字，以及方法的原型（参数与返回值列表）。\n动态查询类型元数据 让我门设计动态派发\n例子代码\n1 2 var r io.Reader = f n, err := r.Read(buf) 首先，可以通过变量r得到∗os.File的类型元数据 然后根据方法名称Read以二分法查找匹配的method结构 找到后再根据method.mtyp得到方法本身的类型元数据 最后对比方法原型是否一致（参数和返回值的类型、顺序是否一致）。 如果原型一致，就找到了目标方法，通过method.ifn字段得到方法的地址，然后就像调用普通函数一样调用就可以了。 图5-9 ∗os.File的类型元数据\n单就动态派发而言，这种方式确实可以实现，但是有一个明显的问题，那就是效率低，或者说性能差。\n跟地址静态绑定的方法调用比起来，原本一条CALL指令完成的事情，这里又多出了一次二分查找加方法原型匹配，增加的开销不容小觑，可能会造成动态派发 的方法比静态绑定的方法多一倍开销甚至更多，所以必须进行优化。 不能在每次方法调用前都到元数据中去查找，尽量做到一次查找、多次使用，这里可以一定程度上参考C++的虚函数表实现。 C++虚函数机制 C++中的虚函数机制跟接口的思想很相似，编程语言允许父类指针指向子类对象，当通过父类的指针来调用虚函数时，就能实现动态派发。\n具体实现原理就是\n编译器为每个包含虚函数的类都生成一张虚函数表，实际上是个地址数组，按照虚函数声明的顺序存储了各个虚函数的地址。 此外还会在类对象的头部安插一个虚指针（GCC安插在头部，其他编译器或有不同），指向类型对应的虚函数表。 运行阶段通过类对象指针调用虚函数时，会先取得对象中的虚指针，进一步找到对象类型对应的虚函数表，然后基于虚函数声明的顺序，以数组下标的方式从 表中取得对应函数的地址，这样整个动态派发过程就完成了。 测试代码\n输出\nA,8 B,16 图5-10 C++虚函数动态派发示例\n参考C++的虚函数表思想，再回过头来看Go语言中接口的设计，如果把这种基于数组的函数地址表应用在接口的实现中，基本就能消除每次查询地址造成的性能 开销。显然这里需要对eface结构进行扩展，加入函数地址表相关字段，经过扩展的eface姑且称作efacex\n怪不得叫tab (table)\n图5-11 参照C++虚函数机制修改后的非空接口数据结构\n什么时候为fun数组赋值呢？当然是在为整个efacex结构赋值的时候最合适\n1 2 3 4 // 第5章 code_5_9.go f, _ := os.Open(\u0026#34;gom.go\u0026#34;) var rw io.ReadWriter rw = f 从f到rw这个看似简单的赋值，至少要展开成如下几步操作：\n①根据rw接口中方法的个数动态分配tab结构，这里有两个方法，fun数组的长度是2。 ②从∗os.File的方法集中找到Read()方法和Write()方法，把地址写入fun数组对应下标。 ③把∗os.File的元数据地址赋值给tab._type。 ④把f赋值给data，也就是数据指针。 图5-12 基于efacex设计的非空接口变量rw赋值后的数据结构\n实际上，fun数组也不用每次都重新分配和初始化，从指定具体类型到指定接口类型变量的赋值，运行阶段无论发生多少次，每次生成的fun数组都是相同的。例 如从∗os.File到io.ReadWriter的赋值，每次都会生成一个长度为2的fun数组，数组的两个元素分别用于存储(∗os.File).Read和(∗os.File).Write的 地址。也就是说通过一个确定的接口类型和一个确定的具体类型，就能够唯一确定一个fun数组，因此可以通过一个全局的map将fun数组进行缓存，这样就能进 一步减少方法集的查询，从而优化性能。\n5.2.2 具体实现 实际上在Go语言的runtime中与非空接口对应的结构类型是iface\n因为也是通过数据指针data来装载数据的，所以也会有逃逸和装箱发生。其中的itab结构就包含了具体类型的元数据地址_type，以及等价于虚函数表的方法地 址数组fun，除此之外还包含了接口本身的类型元数据地址inter\n接口类型元数据 除去最基本的typ字段，pkgpath表示接口类型被定义在哪个包中，mhdr是接口声明的方法列表。\n比自定义类型的method结构少了方法地址，只包含方法名和类型元数据的偏移。\n这些偏移的实际类型为int32，与指针的作用一样，但是64位平台上比使用指针节省一半空间。 以ityp为起点，可以找到方法的参数（包括返回值）列表，以及每个参数的类型信息，也就是说这个ityp是方法的原型信息。 图5-13 io.ReadWriter类型的变量rw的数据结构\n如何获得itab 运行阶段可通过runtime.getitab函数来获得相应的itab，该函数被定义在runtime包中的iface.go文件中\n1 func getitab(inter *interfacetype, typ *_type, canfail bool) *itab 前两个参数inter和typ分别是接口类型和具体类型的元数据，canfail表示是否允许失败。如果typ没有实现inter要求的所有方法，则canfail为true时函 数返回nil，canfail为false时就会造成panic。对应到具体的语法就是comma ok风格的类型断言和普通的类型断言\n1 2 r, ok := a.(io.Reader) // comma ok r := a.(io.Reader) //有可能造成panic getitab()函数的代码摘抄自Go语言runtime源码\n函数的主要逻辑如下：\n①校验inter的方法列表长度不为0，为没有方法的接口生成itab是没有意义的。 ②通过typ.tflag标志位来校验typ为自定义类型，因为只有自定义类型才能有方法集。 ③在不加锁的前提下，以inter和typ作为key查找itab缓存itabTable，找到后就跳转到⑤。 ④加锁后再次查找缓存，如果没有就通过persistentalloc()函数进行持久化分配，然后初始化itab并调用itabAdd添加到缓存中，最后解锁。 ⑤通过itab的fun[0]是否为0来判断typ是否实现了inter接口，如果没实现，则根据canfail决定是否造成panic，若实现了，则返回itab地址。 判断itab.fun[0]是否为零，也就是判断第一个方法的地址是否有效，因为Go语言会把无效的itab也缓存起来，主要是为了避免缓存穿透。缓存中查不到对应 的itab，就会每次都查询元数据的方法列表，从而显著影响性能，所以Go语言会把有效、无效的itab都缓存起来，通过fun[0]加以区分。\nfun[0] 相当于标记.\n图5-14 interfacetype和_type与itab的对应关系\nitab缓存 itabTable就是runtime中itab的全局缓存，它本身是个itabTableType类型的指针\nentries是实际的缓存空间 size字段表示缓存的容量，也就是entries数组的大小 count表示实际已经缓存了多少个itab。 entries的初始大小是通过itabInitSize指定的，这个常量的值为512。当缓存存满以后，runtime会重新分配整个struct，entries数组是 itabTableType的最后一个字段，可以无限增大它的下标来使用超出容量大小的内存，只要在struct之后分配足够的空间就够了，这也是C语言里常用的手法。\nitabTableType被实现成一个散列表。查找和插入操作使用的key是由接口类型元数据与动态类型元数据组合而成的，哈希值计算方式为接口类型元数据哈希值 inter.typ.hash与动态类型元数据哈希值typ.hash进行异或运算。\n图5-15 itabTableType哈希表\n方法find()和add()分别负责实现itabTableType的查找和插入操作，方法add()操作内部不会扩容存储空间，重新分配操作是在外层实现的，因此 对于find()方法而言，已经插入的内容不会再被修改，所以查找时不需要加锁。方法add()操作需要在加锁的前提下进行，getitab()函数是通过调用 itabAdd()函数来完成添加缓存的，itabAdd()函数内部会按需对缓存进行扩容，然后调用add()方法。因为缓存扩容需要重新分配itabTableType结构，为 了并发安全，使用原子操作更新itabTable指针。加锁后立刻再次查询也是出于并发的考虑，避免其他协程已经将同样的itab添加至缓存。\n通过persistentalloc()函数分配的内存不会被回收\nitab类型的init方法\ninit()函数内部就是遍历接口的方法列表和具体类型的方法集，来寻找匹配的方法的地址。 虽然遍历操作使用了两层嵌套循环，但是方法列表和方法集都是有序的，两层循环实际上都只需执行一次。 匹配方法时还会考虑方法是否导出，以及接口和具体类型所在的包。如果是导出的方法则直接匹配成功，如果方法未导出，则接口和具体类型需要定义在同一 个包中，方可匹配成功。 最后需要再次强调的是，对于匹配成功的方法，地址取的是method结构中的ifn字段 5.2.3 接收者类型 具体类型方法元数据中的ifn字段，该字段存储的是专门供接口使用的方法地址。所谓专门供接口使用的方法，实际上就是个接收者类型为指针的方法。\n还记不记得第4章中分析OBJ文件时，发现编译器总是会为每个值接收者方法包装一个指针接收者方法？这也就说明，接口是不能直接使用值接收者方法的， 这是为什么呢？\n5.2.2节已经看过了接口的数据结构iface，它包含一个itab指针和一个data指针，data指针存储的就是数据的地址。对于接口来讲，在调用指针接收者方法 时，传递地址是非常方便的，也不用关心数据的具体类型，地址的大小总是一致的。假如通过接口调用值接收者方法，就需要通过接口中的data指针把数据的值 复制到栈上，由于编译阶段不能确定接口背后的具体类型，所以编译器不能生成相关的指令来完成复制，进而无法调用值接收者方法。\n如果基于reflectcall()函数，能不能实现通过接口调用值接收者方法呢？\n肯定是可以实现的，接口的itab中有具体类型的元数据，确实能够应用reflectcall()函数 但是有个明显的问题，那就是性能太差。跟几条用于传参的MOV指令加一条普通的CALL指令相比，reflectcall()函数的开销太大了，所以Go语言选择为值 接收者方法生成包装方法。 对于代码中的值接收者方法，类型元数据method结构中的ifn和tfn的值是不一样的，指针接收者方法的ifn和tfn是一样的。 从类型元数据来看，T和∗T是不同的两种类型。\n接收者类型为T的所有方法，属于T的方法集。 因为编译器自动包装指针接收者方法的关系，∗T的方法集包含所有方法，也就是所有接收者类型为T的方法加上所有接收者类型为∗T的方法。 第1行输出打印出了Integer类型的方法集，String()和Value()这两个方法各自的IFn和TFn都不相等，这是因为IFn指向接收者为指针类型的方法代码， 而TFn指向接收者为值类型的方法代码。 第2行输出打印出了∗Integer类型的方法集，这两个方法各自的IFn和TFn是相等的，都与第1条指令中同名方法的IFn的值相等。 第3行输出打印出了Number接口itab中fun数组中的两个方法地址，与第1行输出Integer方法集中对应方法的IFn的值一致。 图5-16 Integer和∗Integer类型的方法集\n5.2.4 组合式继承 从方法集的角度进行分析\n看一下B、C、∗B和∗C会继承哪些方法\n表5-2 示例程序中各自定义类型包含的方法的情况\nGo语言不允许为T和∗T定义同名方法，实际上并不是因为不支持函数重载，前面已经看到了A.Value()方法和(∗A).Value()方法是可以区分的。其根本原因就 是编译器要为值接收者方法生成指针接收者包装方法，要保证两者的逻辑一致，所以不允许用户同时实现，用户可能会实现成不同的逻辑。\n5.3 类型断言 5.3.1 E To具体类型 1 2 3 func normal(a interface{}) int { return a.(int) } 反编译\n等价的伪代码\ncomma ok风格的断言\n1 2 3 4 func commaOk(a interface{}) (n int, ok bool) { n, ok = a.(int) return } 反编译\n等价的伪代码\n从interface{}到具体类型的断言基本上就是一个指针比较操作加上一个具体类型相关的复制操作\n图5-17 从interface{}到具体类型的断言\n5.3.2 E To I 1 2 3 func normal(a interface{}) io.ReadWriter { return a.(io.ReadWriter) } 反编译\n伪代码\nruntime.assertE2I()函数代码\n函数先校验了E的具体类型元数据指针不可为空，没有具体类型的元数据是无法进行断言的 然后通过调用getitab()函数来得到对应的itab，data字段直接复制。 注意调用getitab()函数时最后一个参数为false，根据之前的源码分析已知这个参数是canfail。canfail为false时，如果t没有实现inter要求的所有 方法，getitab()函数就会造成panic。 comma ok风格的断言\n1 2 3 4 func commaOk(a interface{}) (i io.ReadWriter, ok bool) { i, ok = a.(io.ReadWriter) return } 反编译\n伪代码\nruntime.assertE2I2()函数代码\nE To I形式的类型断言，主要通过runtime中的assertE2I()和assertE2I2()这两个函数实现，底层的主要任务如图5-18所示，都是通过getitab()函数 完成的方法集遍历及itab分配和初始化。因为getitab()函数中用到了全局的itab缓存，所以性能方面应该也是很高效的。\n图5-18 从interface{}到非空接口的类型断言\n5.3.3 I To具体类型 1 2 3 func normal(i io.ReadWriter) *os.File { return i.(*os.File) } 反汇编\n伪代码\n其中的go.itab.∗os.File，io.ReadWriter指的就是全局itab缓存中与∗os.File和io.ReadWriter这一对类型对应的itab。这个itab是在编译阶段就 被编译器生成的，所以代码中可以直接链接到它的地址。 这个断言的核心逻辑就是比较iface中tab字段的地址是否与目标itab地址相等。如果不相等就调用panicdottypeI，如果相等就把iface的data字段返回。 注意这里因为∗os.File是指针类型，所以不涉及自动拆箱，也就没有与具体类型相关的复制操作，如果具体类型为值类型就不然了。 comma ok风格的断言\n1 2 3 4 func commaOk(i io.ReadWriter) (f *os.File, ok bool) { f, ok = i.(*os.File) return } 反编译\n伪代码\nI To具体类型的断言与E To具体类型的断言在实现上极其相似，核心逻辑如图5-19所示，都是一个指针的相等判断。\n图5-19 从非空接口到具体类型的类型断言\n5.3.4 I To I 1 2 3 func normal(rw io.ReadWriter) io.Reader { return rw.(io.ReadWriter) } 反编译\n伪代码\nruntime.assertI2I()函数代码\n先校验i.tab不为nil，否则就意味着没有类型元数据，类型断言也就无从谈起 然后检测i.tab.inter是否等于inter，相等就意味着源接口和目标接口类型相同，直接复制就可以了。 最后才调用getitab()函数，根据inter和i.tab._type获取对应的itab。canfail参数为false，所以如果getitab()函数失败就会造成panic。 comma ok风格的断言\n1 2 3 4 func commaOk(rw io.ReadWriter) (r io.Reader, ok bool) { r, ok = rw.(io.Reader) return } 反编译\n伪代码\nruntime.assertI2I2()函数代码\n如果i.tab为nil，则直接返回false。 只有在i.tab.inter与inter不相等时才调用getitab()函数，而且canfail为true，如果getitab()函数失败，则不会造成panic，而是返回nil。 I To I的类型断言，实际上是通过runtime.assertI2I()函数和runtime.assertI2I2()函数实现的，底层也都是基于getitab()函数实现的。\n图5-20 从非空接口到非空接口的类型断言\n5.4 反射 5.4.1 类型系统 1. 类型信息的萃取 TypeOf()函数所做的事情如图5-21所示，就是找到传入参数的类型元数据，并以reflect.Type形式返回。\n图5-21 由一个∗_type和一个∗itab组建一个iface\nTypeOf()函数的代码\nemptyInterface类型和5.1节介绍过的eface类型在内存布局上等价，emptyInterface类型定义\n其中的rtype类型与runtime._type类型在内存布局方面也是等价的，只不过因为无法使用其他包中未导出的类型定义，所以需要在reflect包中重新定义一下。 代码中的eface.typ实际上就是从interface{}变量中提取出的类型元数据地址\n先判断了一下传入的rtype指针是否为nil，如果不为nil就把它作为Type类型返回，否则返回nil。 从这里可以知道∗rtype类型肯定实现了Type接口，之所以要加上这个nil判断，需要考虑到Go的接口类型是个双指针结构，一个指向itab，另一个指向实际 的数据对象。只有在两个指针都为nil的时候，接口变量才等于nil。 图5-22 萃取前判断非空\n通过代码说明接口何时为空\n在上述代码中第1个if处判断结果为真，所以会打印出1。第2个if处rw不再为nil，所以不会打印2。\ninterface{}中的类型元数据地址是从哪里来的呢？\n当然是在编译阶段由编译器赋值的，实际的地址可能是由链接器填写的，也就是说源头还是要追溯到最初的源码中。 2.类型系统的初始化 5.5 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC5%E7%AB%A0-%E6%8E%A5%E5%8F%A3/","summary":"5.1 空接口 是指不包含任何方法的接口interface{} 5.1.1 一个更好的void∗ 如果用unsafe.Sizeof()函数获取一个interfac","title":"第5章 接口"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 第4章 code_4_1.go package gom type Point struct { x float64 } func (p Point) X() float64 { return p.x } func (p *Point) SetX(x float64) { p.x = x } 4.1 接收者类型 为了排除编译器内联优化造成的干扰，下面采用只编译不链接的方式来得到OBJ文件，然后对编译得到的OBJ文件进行反编译分析\n1 $ go tool compile -trimpath=\u0026#34;`pwd`=\u0026gt;\u0026#34; -l -p gom point.go 通过go tool nm可以查看该文件中实现了哪些函数，nm会输出OBJ文件中定义或使用到的符号信息\npoint.o中一共实现了3个方法\n第1个是Point的SetX()方法，它的接收者类型是∗Point 第3个是Point的X()方法，它的接收者类型是Point 第二个方法是一个接收者类型为∗Point的X()方法 4.1.1 值类型 反编译Point.X()\n第4行代码用SP作为基址并加上8字节偏移，把该地址处的一个float64复制到X0寄存器中。 第5行代码用SP作为基址并加上16字节偏移，把X0中的float64复制到该地址处。 第6行代码就是普通的返回指令。 图4-1 调用Point.X()方法后的栈帧布局\n值类型的接收者实际上是作为第1个参数通过栈来传递的，与普通的函数调用并没有什么不同。\nGo语言允许通过方法的完全限定名称(Full Qualified Name)把方法当成一个普通函数那样调用，只不过需要把接收者作为第1个参数显式地传递\n1 2 p := Point{x: 10} Point.X(p) 可以认为p.X()这种写法只是编译器提供的语法糖，本质上会被转换为Point.X(p)这种普通的函数调用，而接收者就是隐含的第1个参数。\n4.1.2 指针类型 反编译SetX()\n第4行代码用SP作为基址加上16字节偏移，把该地址处的一个float64复制到X0寄存器中。 第5行代码用SP作为基址加上8字节偏移，把该地址处的一个64位数值复制到AX寄存器中。 第6行代码用AX作为基址，把X0寄存器中的float64复制到该地址处。 第8行是返回指令 图4-2 调用Point.SetX()方法后的栈帧布局\n跟值类型接收者类似，指针类型的接收者也是作为第1个参数来传递的，只不过传递的是一个地址。\n可以通过完全限定名称把指针接收者方法作为一个普通函数那样调用\n1 2 p := \u0026amp;Point{} (*Point).SetX(p, 10) 4.1.3 包装方法 查看自动生成的(*Point).X方法的汇编\n有autogenerated字样\n汇编(*Point).X的伪代码\n第1个if语句块通过比较栈指针SP和gp.stackguard0来判断是否需要栈增长。 第2个if用于检测是否正处于panic流程中，这种情况下当前方法应该是被某个defer直接或间接地调用了，要按需修改gp._panic.argp的值，因为当前方 法是编译器自动包装的，通过修改argp来跳过包装方法的栈帧，使后面调用的原始方法中的recover能够生效。 第3个if用于检测p是否为nil，因为包装方法需要根据p的地址得到∗p的值，如果地址为nil就调用runtime.panicwrap。 最后一步才是调用原始的Point.X()方法并传递∗p的值作为参数。 编译器会为代码中定义的值接收者方法生成指针接收者的包装方法，这在语义上是可行的，但反过来却不可以，因为通过传递的值是无法得到原始变量的地址的。\n看一下实际调用的是不是包装方法, 先添加一个函数\n1 2 3 func PointX(p *Point) float64 { return p.X() } 反编译\n可以看到p.X()实际上会在调用端对指针解引用，然后调用值接收者方法，并没有调用编译器生成的包装方法。\n栈分析\n28 return value of PointX (float64) 20 arg of PointX (address of p) 18 return address of PointX 10 bp -| 08 return value of X (float64) | stack of PointX 00 arg of X (p) -| 4.2 Method Value 把一个函数存储在一个变量中，这个变量就是一个Function Value。相应地，把一个方法存储在一个变量中，这个变量就是个Method Value。\n4.2.1 基于类型 1 x := Point.X 方法其实就是个普通的函数，接收者是隐含的第1个参数，所以这里可以推断，基于类型的Method Value就是个普通的Function Value，本质上是个两级指 针，而且第二级的指针是在编译阶段静态分配的。\n1 2 3 func GetX() func(Point) float64 { return Point.X } 上述代码可以成功编译，说明Point.X()函数可以被赋值给func(Point)float64类型的Function Value。接下来反编译GetX()函数\n第4行代码用IP作为基址加上一个偏移0来得到一个地址，这个0只作为预留的一个32位整数，等到链接阶段，链接器会填写上实际的偏移值。第4行代码得到的 地址被用作返回值，也就是最终的Function Value，而该地址处就是第二级指针\n4.2.2 基于对象 可以把一个对象的某个方法赋值给一个变量，这样就会得到一个基于对象的Method Value\n1 2 p := Point{x: 10} x := p.X 从语义角度来看，与基于类型的Method Value不同，基于对象的Method Value隐式地包含了对象的数据，所以在上述代码中调用x时不需要再显式地传递接 收者参数。第3章中已经了解了闭包的实现原理，所以这里推断x是个指向闭包对象的指针，通过闭包的捕获列表捕获了对象p。\n示例函数\n1 2 3 func X(p Point) func() float64 { return p.X } 反编译\n伪代码\n编译器为返回值自动定义了一个struct，第1个成员是一个函数指针，第2个成员是一个Point对象。对应到闭包对象的结构，捕获列表中是Point类型的对象， 闭包函数是gom.Point.X-fm()函数，也是由编译器自动生成的。反编译这个闭包函数\n伪代码\n主要逻辑就是通过DX寄存器得到闭包对象的地址，再以捕获列表里的Point对象的值作为参数调用Point.X()方法，并把Point.X()方法的返回值作为自己的 返回值。\n进一步探索会发现，闭包是捕获对象的值还是捕获地址，跟Method Value对应的方法接收者类型一致。上述示例中Point.X()方法的接收者为值类型，所以闭 包捕获的也是值类型，如果换成接收者为指针类型的∗Point.SetX()方法，闭包捕获列表中就会相应地变成指针类型。\n至此可以进行一下总结，基于类型的Method Value和基于对象的Method Value本质上都是Function Value，只不过前者是简单的两级指针，而后者通常是 个闭包（考虑编译器优化）。\n4.3 组合式继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 第4章 code_4_2.go package gom type Point2dV struct { Point y float64 } func (p Point2d) Y() float64 { return p.y } func (p *Point2d) SetY(y float64) { p.y = y } 4.3.1 嵌入值 图4-3 Point2d内存布局示意图\n再次用nm命令查看一下OBJ文件中为Point2d类型实现了哪些函数和方法\n最后一个函数是由编译器自动生成的，用于判断两个Point2d对象是否相等\n反编译Point2d.X()后的伪代码\n以p.Point为参数来调用Point.X()方法的代码，也就说明这是个包装方法，因此可以推测，编译器对于继承来的方法都是通过生成相应的包装方法来调用原始 方法的方式实现的。\n反编译(∗Point2d).SetX()\n第1条指令把接收者的值复制到AX寄存器中。 第2条指令尝试访问AX存储的地址处的数据，如果接收者为空指针就会触发空指针异常。 第3条指令把AX的值复制到栈上接收者参数的位置，这一行其实可以优化掉。 第4条指令用于跳转到(∗Point).SetX()方法的起始地址。 反编译一下(∗Point2d).X()方法，对照汇编整理出的伪代码如下：\n可以看到除了接收者为指针类型外，代码逻辑与Point2d.X()方法基本一致\n4.3.2 嵌入指针 1 2 3 4 5 6 7 // 第4章 code_4_3.go package gom type Point2dP struct { *Point y float64 } 图4-4 Point2d与Point的内存布局关系\n再用nm命令查看一下OBJ文件中为Point2d类型实现了哪些函数和方法\n这里值得注意的是Point2d.SetX()方法，它的存在意味着虽然接收者Point2d是通过值的形式传递的，但是通过Point2d的值可以得到原始Point对象的地址， 所以依然可以对原始Point对象进行修改。\n看一下在嵌入指针的情况下(∗Point2d).SetX()方法还会不会被优化处理\n编译器还进行了优化处理，第1行指令把栈上的接收者参数复制到AX寄存器中，其实也就是Point2d对象的地址。 第2行指令把Point2d的第1个字段的值复制到AX寄存器中，也就是Point对象的地址。 第3行指令把AX的值复制回栈上的接收者参数处。 第4行指令用于跳转到(∗Point).SetX()方法的起始地址。 至于其他3种方法，编译器都会生成相应的包装方法, 伪代码\n因为在嵌入指针的情况下总是能够得到基类对象的地址，所以子类中的值接收者方法可以调用基类中的指针接收者方法，编译器会尽可能把符合逻辑的包装方法 都生成出来。\n4.3.3 多重继承 首先定义两种类型A和B\n定义一种类型C，将A和B以值的形式嵌入\n通过nm命令查看编译生成的OBJ文件中都实现了哪些方法\n发现只有A和B的方法，编译器没有为C生成任何方法。结合Go语言官方文档的说明，因为同时嵌入A和B而且嵌套的层次相同，所以编译器不知道应该让包装方法 继承自谁，这种情况只能由程序员手工实现。\n定义一种类型D，把A以嵌入值的形式嵌入D中，然后把C中的A改成D\n再次通过nm命令查看\n这次类型C成功地继承了这一组方法，对这些方法进行反编译就能确定是继承自类型B，因为B的嵌套层次比A要浅，编译器优先选择短路径。\n4.4 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC4%E7%AB%A0-%E6%96%B9%E6%B3%95/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 第4章 code_4_1.go package gom type Point struct { x float64 } func (p Point) X() float64 { return p.x } func (p *Point) SetX(x float64) { p.x = x } 4.1 接收者类型 为了排除编译器内联优化造成的干扰，","title":"第4章 方法"},{"content":"2.1 车身规格 Body Specification 车宽尺寸包括后视镜吗？\n现在，全世界各汽车厂商在汽车车身规格的标注方面基本上都统一了，尤其是车身总长、轴距、轮距、前悬和后悬等规格上都完全一样。但是，在车身总宽和总 高上稍有区别\n车身尺寸标注示意图\n什么是汽车的通过性？\n指汽车通过各种坏路和无路地带以及克服各种障碍的能力。汽车的外形尺寸甚至直接决定了汽车的通过性能，如最小离地间隙、接近角和离去角、纵向通过角等。\n最大爬坡度\n一种是百分比坡度，它是指坡道的垂直高度与坡道的水平距离之比值，如30%，即表示此坡度为每前进100米，坡度便升高30米； 另一种表述方法是坡道的倾角度。 2.2 车身构造 Body Structure 为什么车身要由面板和骨架组成？\n车身面板只是汽车的“皮肤”，其实它的厚薄甚至强度如何，对汽车的安全性没有太大影响。 骨架的形状，基本决定了车身的造型。为了使车身更加安全，分散来自各方向的撞击力，现在的汽车厂商在设计汽车时往往都要把车身做成像一个鸟笼子那样， 也称为“网状交叉式设计”。 奥迪R8车身构造\n大众高尔夫汽车鸟笼车身骨架图\n什么是承载式车身和非承载式车身？\n承载式车身的汽车没有刚性车架，发动机、前后悬架、传动系统的一部分总成部件都装配在车身上，车身负载通过悬架装置传给车轮。\n承载式车身的优点是：公路行驶非常平稳，整个车身为一体，固有频率振动低，噪声小，重量轻，比较省油。 缺点：底盘强度远不如有大梁结构的非承载式车身；当四个车轮受力不均匀时，车身易发生变形。 承载式车身示意图\n非承载式车身的汽车有一刚性车架，又称底盘大梁，发动机、传动系统、车身等总成部件都固定在车架上，车架通过前后悬架与车轮连接。\n非承载式车身的优点是：底盘强度较高，抗颠簸性能好；四个车轮受力即使再不均匀，也是由车架承担，而不会传递到车身上去，因此车身不易扭曲变形。 缺点是：车身比较笨重。非承载式车身多用在货车、客车和越野车上，但也有部分高级轿车使用，这是因为非承载式车身具有较好的平稳性和安全性。 非承载式车身示意图\n为什么说车门防撞杠非常重要？\n当汽车受到侧面撞击时，可减轻车门的变形程度，从而起到对驾乘人员的保护作用。\n车门防撞杠示意图\n车身安全设计\n车身结构示意图\n奥迪TT车身结构\n什么是NVH特性？\nNVH是Noise（噪声）、Vibration（振动）和Harshness（声振粗糙度，通俗地称为不舒适性或不平顺性）的缩写。噪声是由振动引起的，通过振动波来传递， 因此噪声、振动和声振粗糙度三者在汽车等机械振动中是同时出现且密不可分的\n车辆在行驶时的振动源主要有三个：发动机、传动系统和不平的路面。 车辆在行驶时的噪声主要有四个：发动机产生的噪声、空气流过车身时的噪声、轮胎滚动和振动时的噪声，以及车身和底盘结构振动时产生的噪声。 汽车NVH设计示意图\n发动机噪声主要包括燃烧噪声、机械噪声和排气噪声。\n燃烧噪声是指气缸燃烧压力通过活塞、连杆、曲轴、缸体等途径向外辐射产生的噪声； 机械噪声是指活塞、齿轮、配气机构等运动件之间机械撞击产生的振动噪声； 排气噪声是指发动机排气产生的声音。一般情况下，低转速时燃烧噪声占主要地位，高转速时机械噪声占主要地位。 轮胎噪声主要来自泵气效应和轮胎振动。\n泵气效应是指轮胎高速滚动时引起轮胎变形，使得轮胎花纹与路面之间的空气受压挤，随着轮胎滚动，空气又在轮胎离开接触面时被释放，这样连续的“压挤 释放”，空气就迸发出噪声。 轮胎运行时的振动也会产生噪声，而且刚性越大或阻尼越小的轮胎，其振动噪声越大。 汽车上的空气噪声主要包括风阻噪声和风笛噪声。\n风阻噪声是指空气流过车身时与车身之间的摩擦声，而且风阻越大的汽车，其风阻噪声越大，因此现在轿车都要设计成流线形，以减少空气噪声； 风笛噪声是指空气进入或流出车身钣金缝隙时产生的噪声。车门、车窗等密封性越好的汽车，其风笛噪声越小。 车身和底盘结构噪声\n汽车在运动时，尤其是行驶在不平路面时，车身会产生一定的扭曲，此时车身钣金件在各种力的作用下就会产生一定的扭曲和振动，从而产生一定的噪声。 底盘中的部件，尤其是传动和悬架结构等运动部件，在运行时也会因转动、扭动或振动而产生一定的噪声，尤其是汽车行驶在不平路面或高速行驶时，底盘噪 声可能更大。这些噪声可能会通过底盘而传入车内。 2.3 车身材料 Body Material 什么是车身刚性？\n刚性是指物体受力后抗变形的能力。车身刚性则是指在施加不至毁坏车身的普通外力时车身不容易变形的能力。高刚性车身具有极高的抗扭曲和抗弯曲的能力， 反之亦然。当汽车行驶在凹凸不平的地面时，刚性差的汽车车身会发出“嘎吱嘎吱”的响声，因为这样的车身此时扭曲较严重，从而使一些装配部位产生摩擦。\n2018款奥迪A8车身结构\n在汽车高速转弯时，车身的刚性优劣也会暴露无遗。车身刚性好的车辆在过弯时，其行驶稳定性会比较好，反之亦然。\n为了保证车身具有较高的刚性，最可靠的手段就是采用高强度钢材来打造车身的关键部位，而在对刚性没有影响或影响较小的部位，则采用普通钢材或材质来制 作。\n奔驰CL双门轿车轻量化车身设计构造图\n怎样减轻车身重量？\n车身越重，其制动能力和操控能力可能受到的影响越大。 对车身轻量化起作用最大的还是广泛采用铝质材料。 保时捷车身用材料强度示意图\n奥迪TT铝质车身构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC2%E7%AB%A0-%E8%BD%A6%E8%BA%AB/","summary":"2.1 车身规格 Body Specification 车宽尺寸包括后视镜吗？ 现在，全世界各汽车厂商在汽车车身规格的标注方面基本上都统一了，尤其是车身总长、轴距、轮距、前悬和后悬等规","title":"第2章 车身 Body"},{"content":"4.1 品牌是一种什么样的资产 图4-1 时代集团控股的手袋及小皮具平均出厂价\n总之，奢侈品包的制造成本，与其定价相去甚远。\n奢侈品皮具代工行业相对分散，中国是全球最大的供应地\n图4-2 全球奢侈品皮具代工市场份额（以销售额计）\n奢侈品溢价的来源是设计吗，设计的重要性有多高？\n奢侈品包的高价并非来自物料成本：售价上万元的奢侈品包，平均出厂价仅约200元。 奢侈品包的高价并非来自特殊制造工艺：皮具的生产以代工为主，代工费用已计入出厂价；中国是全球的奢侈品皮具主要代工地。 奢侈品的高价并非来自设计：有一部分奢侈品包是由代工厂设计、品牌“贴牌”生产的，主流消费者显然无法轻易分辨奢侈品包的设计方（否则“贴牌”奢侈品的 相关信息早就传遍网络，而不会被深埋在招股说明书中）。 品牌溢价来自品牌认知，即品牌过去的所有动作给消费者留下的整体印象\n品牌本质上还是认知。认知一方面是动态反馈形成的，另一方面是要靠时间积淀的。 品牌认知的形成，是品牌的各种动作在不同环境下，不断和周围环境相互反馈，并形成动态认知的过程。 譬如，品牌标识、品牌设计特色、品牌销售渠道、品牌营销广告、品牌粉丝互动等，都属于品牌动作，并不断产生动态变化。而在这个动态变化的过程中，消 费者对品牌产生各种各样的印象，长时间积累下来形成的动态认知的集合，就是品牌认知，也是品牌溢价的来源。 品牌溢价=品牌认知=品牌所有的动作反馈在时间上的积分\n图4-3 “品牌计分板”理论下的品牌溢价公式\n“品牌计分板”具备三重含义：\n品牌认知并非由单一因素形成，而由各种因素综合构成。 品牌认知是有时间维度的，需要经过时间积淀。 在对的时候做对的事情，方能得分，切忌刻舟求剑。 4.2 我们为何会为品牌溢价买单 消费者为品牌商品额外支付的溢价，就是在购买品牌背后的信用契约。\n信用契约的作用可以从两个方面理解：降低搜索成本、赋予文化认同\n图4-4 品牌（信用契约）的作用\n文化认同常见于奢侈品，也是奢侈品溢价的主要来源。\n赋予文化价值和降低搜索成本这两种作用，大致对应了两种行为模式的消费者。前者我们称之为悦己型消费者，后者为省心型消费者\n图4-5 悦己型消费者和省心型消费者\n悦己型消费者和省心型消费者并不是完全割裂的，二者之间没有严格界限。\n所以消费升级并不意味着省心型品牌会被淘汰；同样，消费降级也不意味着悦己型品牌的消亡。消费升级的大趋势并不会使得高端品牌取代大众品牌，因为格调 需要通过对比来体现，所以只属于少部分人；反之，若经济持续低迷，高端品牌也不见得会全部消失，因为对于炫耀、身份展示和自我满足的追求，不见得会随 着经济低迷而退散。\n对于悦己型公司，我们更应关注其品牌形象的维持，以及定价能力的不断提升；对于省心型公司，我们更应关注其经营规模的增长，以及渠道覆盖范围的演进。\n4.3 品牌化或是未来中国消费品投资最重要的机会之一 品牌是消费品产业链中利润空间最大的一环\n图4-6 品牌、供应链、渠道的毛利率（2019年）\n图4-7 品牌、供应链、渠道的净利率（2019年）\n国牌崛起的必要条件：发达的消费品供应链，特殊的渠道环境\n我国拥有强大的供应链，能够产出物美价廉高质量的产品。国产品牌使用本土供应链，就能生产出品质不亚于（甚至超过）海外大牌的产品。 2010年全世界有42%的奢侈品手袋产自中国（以代工市场份额计） 大多数苹果数码产品也是由位于中国本土的代工厂组装生产的。 我国已经形成多个优质的产业链集群。 广东有服装、化妆品、3C电子的产业链集群； 浙江有箱包、小商品的产业链集群； 江苏有家纺等商品的产业链集群； 福建有服装、鞋的产业链集群。 在渠道方面，独特的电商和互联网文化造就了国产品牌成长的沃土。 中国整体社零电商渗透率已达20%以上，且仍在高速增长（而美国只有大约10%的电商渗透率）。 国牌崛起的核心逻辑首先是“国崛起”，其次才是“货崛起”\n表4-1 “70后”“80后”与“Z世代”的生长环境对比\n国产品牌崛起是我们研究消费行业时必须重点关注的一个行业趋势性投资机会。\n从何处找到这类正在崛起的国产品牌标的呢？\n第一，它们的产品在国内有成体系的供应链，大多数消费品都在此范围之内； 第二，这些品牌经营的品类适合线上渠道销售，或能够通过互联网营销实现快速传播，因为对线上渠道和互联网文化的理解，是国产品牌的核心领先之处。 4.4 结语 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC4%E7%AB%A0-%E5%93%81%E7%89%8C-%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A%E7%9A%84%E7%9A%87%E5%86%A0%E6%98%8E%E7%8F%A0/","summary":"4.1 品牌是一种什么样的资产 图4-1 时代集团控股的手袋及小皮具平均出厂价 总之，奢侈品包的制造成本，与其定价相去甚远。 奢侈品皮具代工行业相对分散，","title":"第4章 品牌 消费行业的皇冠明珠"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/cninfo/","summary":"主页","title":"巨潮资讯"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/wind/","summary":"主页","title":"Win.d"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/insiderintelligence/","summary":"主页","title":"eMarketer"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/stats/","summary":"主页","title":"国家统计局"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/zhangdetalk/%E8%B6%85%E5%85%A8%E9%9D%A2-mysql%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/","summary":"原文","title":"超全面 MySQL语句加锁分析"},{"content":"图3-1 函数调用发生前\nCALL指令会先把下一条指令的地址(返回地址)压入栈中, IP寄存器存储f1的地址 图3-2 CALL指令执行后\n执行f1() f1()最后有条RET指令, 弹出栈顶的返回地址(应该弹到IP中), 跳到返回地址处继续执行 图3-3 RET指令执行后\n3.1 栈帧 3.1.1 栈帧布局 函数栈帧是由编译器管理的。\n图3-4 Go语言函数栈帧布局示意图\n猜测代码逻辑在其他地方, 这里只保存函数状态.\nreturn address：函数返回地址，占用一个指针大小的空间。实际上是在函数被调用时由CALL指令自动压栈的，并非由被调用函数分配。 caller’s BP：调用者的栈帧基址，占用一个指针大小的空间。用来将调用路径上所有的栈帧连成一个链表，方便栈回溯之类的操作， 只在部分平台架构上存在。函数通过将栈指针SP直接向下移动指定大小，一次性分配caller’s BP、locals和args to callee所占用的空间， 在x86架构上就是使用SUB指令将SP减去指定大小的。 locals：局部变量区间，占用若干机器字。用来存放函数的局部变量，根据函数的局部变量占用空间大小来分配，没有局部变量的函数不分配。 args to callee：调用传参区域，占用若干机器字。这一区域所占空间大小，会按照当前函数调用的所有函数中返回值加上参数所占用的最大空 间来分配。当没有调用任何函数时，不需要分配该区间。callee视角的args from caller区间包含在caller视角的args to callee区间内，占用空间 大小是小于或等于的关系。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 第3章 code_3_1.go package main func main() { var v1, v2 int v3, v4 := f1(v1, v2) println(\u0026amp;v1, \u0026amp;v2, \u0026amp;v3, \u0026amp;v4) f2(v3) } //go:noinline func f1(a1, a2 int) (r1, r2 int) { var l1, l2 int println(\u0026amp;r2, \u0026amp;r1, \u0026amp;a2, \u0026amp;a1, \u0026amp;l1, \u0026amp;l2) return } //go:noinline func f2(a1 int) { println(\u0026amp;a1) } 实际上，代码中的println()函数会被编译器转换为多次调用runtime包中的printlock()、printunlock()、printpointer()、printsp()、 printnl()等函数。前两个函数用来进行并发同步，后3个函数用来打印指针、空格和换行。这5个函数均无返回值， 只有printpointer()函数有一个参数，会在调用者的args to callee区间占用一个机器字。\n输出结果\n表3-1 3个函数栈帧上各区间的大小\n(1+4+4)*8 = 72B = 0x48B 依次类推 图3-5 main调用f1()函数和f2()函数的栈帧布局图\n调用f2()函数时的栈，在a1和v4之间空了3个机器字。这是因为Go语言的函数是固定栈帧大小的，args to callee是按照所需的最大空间来分配的。\n3.1.2 寻址方式 图3-6 SUB指令分配整个栈帧\n如果把图3-6中整个函数栈帧视为一个struct，SP存储着这个struct的起始地址，然后就可以通过基址＋位移的方式来寻址struct的各个字段，也就是栈帧上 的局部变量、参数和返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 第3章 code_3_3.go package main func main() { fa(0) } //go:noinline func fa(n int) (r int) { r = fb(n) return } //go:noinline func fb(n int) int { return n } 图3-7 函数fa的栈帧布局\n4～7行和最后两行汇编代码主要用来检测和执行动态栈增长 倒数第4行的RET指令用于在函数执行完成后跳转回返回地址。 第8行的SUBQ指令向下移动栈指针SP，完成当前函数栈帧的分配。倒数第5行的ADDQ指令在函数返回前向上移动栈指针SP，释放当前函数的栈帧。释放与分 配时的大小一致，均为0x18，即24字节，其中BP of main占用了8字节，args to fb占用了16字节。 第9行代码把BP寄存器的值存到栈帧上的BP of main中，第10行把当前栈帧上BP of main的地址存入BP寄存器中。倒数第6行指令在当前栈帧释放前用 BP of main的值还原BP寄存器。 第12行和第13行代码，通过AX寄存器中转，把参数n的值从args to fa区间复制到args to fb区间，也就是在fa中把main()函数传递过来的参数n，复 制到调用fb()函数的参数区间。 第14行代码通过CALL指令调用fb()函数。 Go语言中函数的返回值可以是匿名的，也可以是命名的。对于匿名返回值而言，只能通过return语句为返回值赋值。对于命名返回值，可以在代码中通过其名称 直接操作，与参数和局部变量类似。无论返回值命名与否，都不会影响函数的栈帧布局。\n3.1.3 又见内存对齐 Go语言函数栈帧中返回值和参数的对齐方式与struct类似，对于有返回值和参数的函数，可以把所有返回值和所有参数等价成两个struct，一个返回值 struct和一个参数struct。因为内存对齐方式更加紧凑，所以在支持大量参数和返回值时能够做到较高的栈空间利用率。\n验证函数参数和返回值的对齐方式与struct成员的对齐方式是一致的\n栈帧上的参数和返回值到底是分开后作为两个struct，还是按照一个struct来对齐的？\n1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_5.go package main //go:noinline func f1(a int8) (b int8) { println(\u0026amp;b, \u0026amp;a) return } func main() { f1(0) } f1()函数有一个返回值和一个参数，而且都是int8类型，如果返回值和参数作为同一个struct进行内存对齐，则a和b应该是紧邻的，中间不会插入padding。 可以看到参数a和返回值b并没有紧邻，而是分别按照8字节的边界进行对齐的，也就说明返回值和参数是分别对齐的，不是合并在一起作为单个struct。 局部变量的对齐\n1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_6.go package main //go:inline func fn() { var a int8 var b int64 var c int32 var d int16 var e int8 println(\u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d, \u0026amp;e) } 1 2 3 4 5 6 7 struct { e int8 a int8 d int16 c int32 b int64 } 局部变量的顺序被重排的, 布局更紧凑\n为什么编译器会对栈帧上局部变量的顺序进行调整以优化内存利用率，但是并不会调整参数和返回值呢？\n因为函数本身就是对代码单元的封装，参数和返回值属于对外暴露的接口，编译器必须按照函数原型来呈现 局部变量属于封装在内部的数据，不会对外暴露，所以编译器按需调整局部变量布局不会对函数以外造成影响。 3.1.4 调用约定 对Go语言普通函数的调用约定进行如下总结：\n返回值和参数都通过栈传递，对应的栈空间由调用者负责分配和释放。 返回值和参数在栈上的布局等价于两个struct，struct的起始地址按照平台机器字长对齐。 验证编译器能够参照函数声明来生成传参相关指令\n1 2 3 4 5 6 7 8 9 10 11 // 第3章 code_3_7.go package main import _ \u0026#34;unsafe\u0026#34; func main() { Add(1, 2) } // 只有声明 func Add(a, b int) 编译\n反编译\n与Add()函数调用相关的几行汇编代码\n可以看到两条MOVQ指令分别复制了参数1和2，证明编译阶段参照函数声明生成了正确的传参指令，也就是调用约定在发挥作用。 CALL指令处，十六进制编码e800000000预留了32位的偏移量空间，在链接阶段会被链接器填写为实际的偏移值。 3.1.5 Go 1.17的变化 1.16版及以前的版本中都是通过栈来传递参数的，这样实现简单且能支持海量的参数传递，缺点就是与寄存器传参相比性能方面会差一些。 在1.17版本中就实现了基于寄存器的参数传递，当然只是在部分硬件架构上实现了。 结合Go自带的反编译工具，在汇编代码层面看一下1.17版本的函数调用是如何通过寄存器传递参数的。\n1. 函数入参的传递方式\n第1～9个参数是依次用AX、BX、CX、DI、SI、R8、R9、R10和R11这9个通用寄存器来传递的 从第10个参数开始使用栈来传递 (注意MOVW $0xb0a, 0(SP)直接复制了两个数字10, 11) 图3-8 Go 1.17中in12()函数入参的传递方式\n2. 函数返回值的传递方式\n反编译out12()函数\n3.2 逃逸分析 3.2.1 什么是逃逸分析 1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_10.go package main func main() { println(*newInt()) } //go:noinline func newInt() *int { var a int return \u0026amp;a } 如果局部变量a仍分配在栈中, 那么返回的地址会变成一个悬挂指针\n反编译newInt()函数\n重点关注上述汇编代码中runtime.newobject()函数调用，该函数是Go语言内置函数new()的具体实现，用来在运行阶段分配单个对象。 CALL指令之后的两条MOVQ指令通过AX寄存器中转，把runtime.newobject()函数的返回值复制给了newInt()函数的返回值，这个返回值就是动态分配的 int型变量的地址。 3.2.2 不逃逸分析 验证new()函数与堆分配是否有必然关系\n1 2 3 4 5 6 // 第3章 code_3_11.go //go:noinline func New() int { p := new(int) return *p } 反编译New()函数\nMOVQ指令直接把返回值赋值为0，其他的逻辑全都被优化掉了，所以即便是代码中使用了new()函数，只要变量的生命周期没有超过当前函数栈帧的生命周期， 编译器就不会进行堆分配。\n3.2.3 不逃逸判断 如果把局部变量的地址赋值给包级别的指针变量，应该也会造成变量逃逸\n1 2 3 4 5 6 7 8 // 第3章 code_3_12.go var pt *int //go:noinline func setNew() { var a int pt = \u0026amp;a } 反编译setNew()函数\n验证逃逸分析的依赖传递性\n1 2 3 4 5 6 7 8 9 var pp **int //go:noinline func dep() { var a int var p *int p = \u0026amp;a pp = \u0026amp;p } 反编译dep()函数\n跨包测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 第3章 code_3_14.go package inner //go:noinline func RetAry(p *int) *int { return p } // 第3章 code_3_15.go package main //go:noinline func arg() int { var a int return *inner.RetAry(\u0026amp;a) } 反编译\n阻止编译器参考函数实现的测试\n反编译arg()函数\n变量a依旧是栈分配，变量b已经逃逸了。 在上述代码中的retArg()函数只是个函数声明，没有给出具体实现，通过linkname机制让链接器在链接阶段链接到inner.RetArg()函数。 retArg()函数只有声明没有实现，而且编译器不会跟踪linkname，所以无法根据代码逻辑判定变量b到底有没有逃逸。 3.3 Function Value 3.3.1 函数指针 函数指针存储的也是地址, 该地址指向代码段中某个函数的第一条指令\n3.3.2 Function Value分析 1 2 3 4 5 6 7 8 9 10 11 // 第3章 code_3_18.go package main func main() { println(helper(nil, 0, 0)) } //go:noinline func helper(fn func(int, int) int, a, b int) int { return fn(a, b) } 反编译\n4～7行和最后两行用于栈增长，暂不需要关心。 第8～10行分配栈帧并赋值caller’s BP，RET之前的两行还原BP寄存器并释放栈帧。 CALL后面的两行用来复制返回值。 CALL连同之前的6条MOVQ指令，实现了Function Value的传参和过程调用。 MOVQ 0x30(SP)，AX和MOVQ AX，0(SP)用于把helper()函数的第2个参数a的值复制给fn()函数的第1个参数。 MOVQ 0x38(SP)，AX和MOVQ AX，0x8(SP)同理，把helper()函数第3个参数b的值复制给fn()函数的第2个参数。 MOVQ 0x28(SP)，DX把helper()函数第1个参数fn的值复制到DX寄存器，MOVQ 0(DX)，AX把DX用作基址，加上位移0，也就是从DX存储的地址处读 取出一个64位的值，存入了AX寄存器中。 CALL AX说明，上一步中AX寄存器最终存储的是实际函数的地址。 栈分析\n40(SP) return value -| 38(SP) b | stack of main 30(SP) a | 28(SP) fn -| 20(SP) return addr 18(SP) bp -| 10(SP) return value | stack of helper 8(SP) b | 0(SP) a -| 3.3.3 闭包 1 2 3 4 5 6 // 第3章 code_3_19.go func mc(n int) func() int { return func() int { return n } } 闭包的状态保存在哪里呢？\n闭包对象 反编译\n栈分析\n... | 28(SP) main arg (mc-func()int) | stack of main 20(SP) main arg (mc-n) -| 18(SP) return address of mc 10(SP) bp -| 8(SP) newobject ret | stack of mc 0(SP) newobject arg -| 推测newobject所创建的对象的结构\n1 2 3 4 5 6 7 // 闭包对象 struct { // 闭包函数 F uintptr // 捕获列表 n int } 看到闭包 newobject的原型\n1 func newobject(typ *_type) unsafe.Pointer 使用自定义的newobject实现来查看_type的布局\n运行结果\n因为start++导致start变量逃逸, 所以调用了两次newobject\nint struct { F uintptr; start *int } 图3-12 Function Value和闭包对象\n调用闭包 闭包函数在被调用的时候，必须得到当前闭包对象的地址才能访问其中的捕获列表，这个地址是如何传递的呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 第3章 code_3_22.go package main func main() { a := mc(2) a() } func mc(n int) func() int { return func() int { return n } } 反编译\n将DX寄存器用作基址，再加上位移8，把该地址处的值复制到AX寄存器中。 把AX寄存器的值复制给闭包函数的返回值。 闭包函数返回。 书中说把AX的值给闭包函数的返回值, 不太理解为啥0x8(SP)是返回值地址.\n闭包与变量逃逸 1 2 3 4 5 6 7 // 第3章 code_3_23.go func sc(n int) int { f := func() int { return n } return f() } 禁用内联优化\n1 $ go build -gcflags=\u0026#39;-l\u0026#39; 反编译\nreturn f()之前的6行汇编代码\nXORPS和MOVUPS这两行利用128位的寄存器X0，把栈帧上从位移8字节开始的16字节清零，这段区间就是sc()函数的局部变量区，正好符合捕获了一个int变 量的闭包对象大小。 LEAQ和MOVQ把闭包函数的地址复制到栈帧上位移8字节处，正是闭包对象中的函数指针。 接下来的两个MOVQ把sc()函数的参数n的值复制到栈帧上位移16字节处，也就是闭包捕获列表中的int变量。 图3-13 sc()函数中构造的闭包对象f\nreturn之后的5行汇编代码\nMOVQ把闭包函数的地址复制到AX寄存器中，LEAQ把闭包对象的地址存储到DX寄存器中。 CALL指令调用闭包函数，接下来的两条MOVQ把闭包函数的返回值复制到sc()函数的返回值。 图3-14 调用闭包函数f()\n闭包对象的捕获列表，捕获的是变量的值还是地址？\n只有在变量的值不会再改变的前提下，才可以复制变量的值，否则就会出现不一致错误。 示例, 需要禁用内联优化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 第3章 code_3_24.go // 捕获地址 func sc(n int) int { f := func() int { n++ return n } return f() } // 第3章 code_3_25.go // 捕获值 func sc(n int) int { n++ f := func() int { return n } return f() } // 第3章 code_3_26.go // 捕获地址 func sc(n int) int { f := func() int { return n } n++ return f() } 3.4 defer 3.4.1 最初的链表 使用go1.12\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 第3章 code_3_28.go package main func main() { println(df(10)) } func df(n int) int { defer func(i *int) { *i *= 2 }(\u0026amp;n) return n } 反编译df()\ndeferproc Go语言中，每个goroutine都有自己的一个defer链表，而runtime.deferproc()函数做的事情就是把defer函数及其参数添加到链表中。 编译器还会在当前函数结尾处插入调用runtime.deferreturn()函数的代码，该函数会按照FILO的顺序调用当前函数注册的所有defer函数。 如果当前goroutine发生了panic（宕机），或者调用了runtime.Goexit()函数，runtime的panic处理逻辑会按照FILO的顺序遍历当前goroutine的整 个defer链表，并逐一调用defer函数，直到某个defer函数执行了recover，或者所有defer函数执行完毕后程序结束运行。 runtime.deferproc()函数原型\n1 func deferproc(size int32, fun *funcval) Go语言用两级指针结构统一了函数指针和闭包，这个funcval结构就是用来支持两级指针的。 funcval结构中只定义了uintptr 图3-15 funcval对Function Value两级指针的支持\n参数siz表示defer函数的参数占用空间的大小，这部分参数也是通过栈传递的，虽然没有出现在deferproc()函数的参数列表里，但实际上会被编译器追加 到fn的后面 注意defer函数的参数在栈上的fn后面，而不是在funcval结构的后面。这点不符合正常的Go语言函数调用约定，属于编译器的特殊处理。 图3-16 df()函数调用deferproc时的栈帧\n基于第3章/code_3_28.go反编译得到的汇编代码，整理出等价的伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func df(n int) (v int) { r := runtime.deferproc(8, df.func1, \u0026amp;n) if r \u0026gt; 0 { goto ret } v = n runtime.deferreturn() return ret: runtime.deferreturn() return } func df.func1(i *int) { *i *= 2 } deferproc()函数的返回值为0或非0时代表不同的含义\n0代表正常流程，也就是已经把需要延迟执行的函数注册到了链表中，这种情况下程序可正常执行后续逻辑。 返回值为1则表示发生了panic，并且当前defer函数执行了recover，这种情况会跳过当前函数后续的代码，直接执行返回逻辑。 deferproc()函数的具体实现, 摘抄自runtime包的panic.go\n通过getcallersp()函数获取调用者的SP，也就是调用deferproc()函数之前SP寄存器的值。这个值有两个用途\n一是在deferreturn()函数执行defer函数时用来判断该defer是不是被当前函数注册的 二是在执行recover的时候用来还原栈指针。 基于unsafe指针运算得到编译器追加在fn之后的参数列表的起始地址，存储在argp中。\n通过getcallerpc()函数获取调用者指令指针的位置，在amd64上实际就是deferproc()函数的返回地址，从调用者df()函数的视角来看就是CALL runtime.deferproc后面的那条指令的地址。这个地址主要用来在执行recover的时候还原指令指针。\n调用newdefer()函数分配一个runtime._defer结构，newdefer()函数内部使用了两级缓冲池来避免频繁的堆分配，并且会自动把新分配的_defer结构添加 到链表的头部。\nruntime._defer的定义\nsiz表示defer参数占用的空间大小，与deferproc()函数的第1个参数一样。 started表示有个panic或者runtime.Goexit()函数已经开始执行该defer函数。 _panic的值是在当前goroutine发生panic后，runtime在执行defer函数时，将该指针指向当前的_panic结构。 link指针用来指向下一个_defer结构，从而形成链表。 _defer中没有发现用来存储defer函数参数的空间，参数应该被存储到哪里？\n实际上runtime.newdefer()函数用了和编译器一样的手段，在分配_defer结构的时候，后面额外追加了siz大小的空间，如图3-17所示，所以deferproc() 函数接下来会将fn、callerpc、sp都复制到_defer结构中相应的字段，然后根据siz大小来复制参数，最后通过return0()函数来把返回值0写入AX寄存器中。\n图3-17 deferproc执行中为_defer赋值\n通过deferproc()函数注册完一个defer函数后，deferproc()函数的返回值是0。后面如果发生了panic，又通过该defer函数成功recover，那么指令指针 和栈指针就会恢复到这里设置的pc、sp处，看起来就像刚从runtime.deferproc()函数返回，只不过返回值为1，编译器插入的if语句继而会跳过函数体，仅 执行末尾的deferreturn()函数。\ndeferreturn 在正常情况下，注册过的defer函数是由runtime.deferreturn()函数负责执行的，正常情况指的就是没有panic或runtime.Goexit()函数，即当前函数完 成执行并正常返回时。\ndeferreturn()函数的代码如下：\n值得注意的是参数arg0的值没有任何含义，实际上编译器并不会传递这个参数，deferreturn()函数内部通过它获取调用者栈帧上args to callee区间的起 始地址，从而可以将defer函数所需参数复制到该区间。defer函数的参数个数要比编译器传给deferproc()函数的参数还少两个，所以调用者的 args to callee区间大小肯定足够，不必担心复制参数会覆盖掉栈帧上的其他数据。\ndeferreturn()函数的主要逻辑如下：\n若defer链表为空，则直接返回，否则获得第1个_defer的指针d，但并不从链表中移除。 判断d.sp是否等于调用者的SP，即判断d是否由当前函数注册，如果不是，则直接返回。 如果defer函数有参数，d.siz会大于0，就将参数复制到栈上\u0026amp;arg0处。 将d从defer链表移除，链表头指向d.link，通过runtime.freedefer()函数释放d。和runtime.newdefer()函数对应，runtime.freedefer()函数 会把d放回缓冲池中，缓冲池内部按照defer函数参数占用空间的多少分成了5个列表，对于参数太多且占用空间太大的d，超出了缓冲池的处理范围则不会被 缓存，后续会被GC回收。 通过runtime.jmpdefer()函数跳转到defer函数去执行。 runtime.jmpdefer()函数是用汇编语言实现的，amd64平台下的实现代码如下：\n第2行把fn赋值给DX寄存器，3.3节中已经讲过Function Value调用时用DX寄存器传递闭包对象地址。接下来的3行代码通过设置SP和BP来还原 deferreturn()函数的栈帧，结合最后一条指令是跳转到defer函数而不是通过CALL指令来调用，这样从调用栈来看就像是deferreturn()函数的调用者直接 调用了defer函数。\njmpdefer()函数会调整返回地址，在amd64平台下会将返回地址减5，即一条CALL指令的大小，然后才会跳转到defer函数去执行。这样一来，等到defer函数 执行完毕返回的时候，刚好会返回编译器插入的runtime.deferreturn()函数调用之前，从而实现无循环、无递归地重复调用deferreturn()函数。直到当 前函数的所有defer都执行完毕，deferreturn()函数会在第1、第2步判断时返回，不经过jmpdefer()函数调整栈帧和返回地址，从而结束重复调用。\n使用deferproc()函数实现defer的好处是通用性比较强，能够适应各种不同的代码逻辑。\n因为defer函数的注册是运行阶段才进行的，可以跟代码逻辑很好地整合在一起，所以像if这种条件分支不用完成额外工作就能支持。由于每个 runtime._defer结构都是基于缓冲池和堆动态分配的，所以即使不定次数的循环也不用额外处理，多次注册互不干扰。\n但是链表与堆分配组合的最大缺点就是慢，即使用了两级缓冲池来优化runtime._defer结构的分配，性能方面依然不太乐观，所以在后续的版本中就开始了对 defer的优化之旅。\n3.4.2 栈上分配 在1.13版本中对defer做了一点小的优化，即把runtime._defer结构分配到当前函数的栈帧上。很明显这不适用于循环中的defer，循环中的defer仍然需要 通过deferproc()函数实现，这种优化只适用于只会执行一次的defer。\n编译器通过runtime.deferprocStack()函数来执行这类defer的注册，相比于runtime.deferproc()函数，少了通过缓冲池或堆分配_defer结构的步骤， 性能方面还是稍有提升的。\nruntime._defer结构中新增了一个bool型的字段heap来表示是否为堆上分配，对于这种栈上分配的_defer结构，deferreturn()函数就不会用 freedefer()函数进行释放了。因为编译器在栈帧上已经把_defer结构的某些字段包括后面追加的fn的参数都准备好了，所以deferprocStack()函数这里只 需为剩余的几个字段赋值，与deferproc()函数的逻辑基本一致。最后几行中通过unsafe.Pointer做类型转换再赋值，源码注释中解释为避免写屏障，暂时理 解成为提升性能就行了\n同样使用第3章/code_3_28.go，经过Go 1.13编译器转换后的伪代码如下：\n图3-18 df()函数调用deferprocStack()时的栈帧\n栈上分配_defer这种优化只是节省了_defer结构的分配、释放时间，仍然需要将defer函数添加到链表中，在调用的时候也还要复制栈上的参数，整体提升比 较有限。\n3.4.3 高效的open coded defer 在Go 1.14版本中又进行了一次优化，这次优化也是针对那些只会执行一次的defer。编译器不再基于链表实现这类defer，而是将这类defer直接展开为代码中 的函数调用，按照倒序放在函数返回前去执行，这就是所谓的open coded defer。\n使用第3章/code_3_28.go，在1.14版本中经编译器转换后的伪代码如下：\n1 2 3 4 5 6 7 func df(n int) (v int) { v = n func(i *int) { *i *= 2 }(\u0026amp;n) return } 两个问题：\n如何支持嵌套在if语句块中的defer？ 当发生panic时，如何保证这些defer得以执行呢？ 第1个问题其实并不难解决，可以在栈帧上分配一个变量，用每个二进制位来记录一个对应的defer函数是否需要被调用。Go语言实际上用了一字节作为标 志，可以最多支持8个defer，为什么不支持更多呢？笔者是这样理解的，open coded defer本来就是为了提高性能而设计的，一个函数中写太多defer，应该 是不太在意这种层面上的性能了。\n还需要考虑的一个问题是，deferproc()函数在注册的时候会存储defer函数的参数副本，defer函数的参数经常是当前函数的局部变量，即使它们后来被修改 了，deferproc()函数存储的副本也是不会变的，副本是注册那一时刻的状态，所以在open coded defer中编译器需要在当前函数栈帧上分配额外的空间来存 储defer函数的参数。\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_30.go package main func fn(n int) (r int) { if n \u0026gt; 0 { defer func(i int) { r \u0026lt;\u0026lt;= i }(n) } n++ return n } 经编译器转换后的等价代码如下：\n其中局部变量f就是专门用来支持if这类条件逻辑的标志位，局部变量i用作n在defer注册那一刻的副本，函数返回前根据标志位判断是否调用defer函数。\n图3-19 fn()函数通过open coded defer的方式调用defer函数\n3.5 panic 3.5.1 gopanic()函数 1.12版本的gopanic()函数的源码\n从函数原型来看，与内置函数panic()完全一致，有一个interface{}类型的参数，这使gopanic()函数可以接受任意类型的参数。函数首先通过getg()函数 得到当前goroutine的g对象指针gp，然后会进行一些校验工作，主要目的是确保处在系统栈、内存分配过程中、禁止抢占或持有锁的情况下不允许发生panic。 接下来gopanic()函数在栈上分配了一个_panic类型的对象p，把参数e赋值给p的arg字段，并把p安放到当前goroutine的_panic链表的头部，特意使用 noescape()函数来避免p逃逸，因为panic本身就是与栈的状态强相关的。\nruntime._panic结构的定义代码如下：\nargp字段用来在defer函数执行阶段指向其args from caller区间的起始地址。 arg字段保存的就是传递给gopanic()函数的参数。 link字段用来指向链表中的下一个_panic结构。 recovered字段表示当前panic已经被某个defer函数通过recover恢复。 aborted字段表示发生了嵌套的panic，旧的panic被新的panic流程标记为aborted。 gopanic()中的for循环\n每次循环开始都会从gp的_defer链表头部取一项赋值给d，直到链表为空时结束循环。 接下来判断若d.started为真则表明当前是一个嵌套的panic，也就是在原有panic或Goexit()函数执行defer函数的时候又触发了panic，因为触发 panic的defer函数还没有执行完，所以还没有从链表中移除。这里会把d关联的旧的_panic设置为aborted，然后把d从链表中移除，并通过freedefer() 函数释放。 后续的3大块逻辑就是：调用defer函数、释放_defer结构和检测recover。 调用defer函数 调用defer函数的代码如下：\n首先将d.started设置为true，这样如果defer函数又触发了panic，新的panic遍历defer链表时，就能通过started的值确定该defer函数已经被调用 过了，避免重复调用。 然后为d._panic赋值，将d关联到当前panic对象p，并使用noescape()函数避免p逃逸，这一步是为了后续嵌套的panic能够通过d._panic找到上一个 panic。 接下来，p.argp被设置为当前gopanic()函数栈帧上args to callee区间的起始地址，recover()函数通过这个值来判断自身是否直接被defer函数调用 reflectcall()函数\n1 func reflectcall(argtype *_type, fn, arg unsafe.Pointer, argsize uint32, retoffset uint32) reflectcall()函数的主要逻辑是根据argsize的大小在栈上分配足够的空间，然后把arg处的参数复制到栈上，复制的大小为argsize字节，然后调用fn() 函数，再把返回值复制回arg＋retoffset处，复制的大小为argsize-retoffset字节，如果argtype不为nil，则根据argtype来应用写屏障。\n在编译阶段，编译器无法知道gopanic()函数在运行阶段会调用哪些defer函数，所以也无法预分配足够大的args to callee区间，只能通过 reflectcall()函数在运行阶段进行栈增长。defer函数的返回值虽然也会被复制回调用者的栈帧上，但是Go语言会将其忽略，所以这里不必应用写屏障。\n释放_defer结构 调用完d.fn()函数后，不应该出现gp._defer不等于d这种情况。假如在d.fn()函数执行的过程中没有造成新的panic，那么所有新注册的defer都应该在 d.fn()函数返回的时候被deferreturn()函数移出链表。假如d.fn()函数执行过程中造成了新的panic，若没有recover，则不会再回到这里，若经 recover之后再回到这里，则所有在d.fn()函数执行过程中注册的defer也都应该在d.fn()函数返回之前被移出链表。\n检测recover 检测recover的代码如下：\n如果d.fn()函数成功地执行了recover，则当前_panic对象p的recovered字段就会被设置为true，此处通过检测后就会执行recover逻辑。\n首先把p从gp的_panic链表中移除，然后循环移除链表头部所有已经标为aborted的_panic对象。如果没有发生嵌套的panic，则此时gp._panic应该是nil， 不为nil就表明发生了嵌套的panic，而且只是内层的panic被recover。代码的最后把局部变量sp和pc赋值给gp的sigcode0和sigcode1字段，然后通过 mcall()函数执行recovery()函数。mcall()函数会切换到系统栈，然后把gp作为参数来调用recovery()函数。\nrecovery()函数负责用存储在sigcode0和sigcode1中的sp和pc恢复gp的执行状态。recovery()函数的主要逻辑代码如下：\n首先确保栈指针sp的值不能为0，并且还要在gp栈空间的上界与下界之间，然后把sp和pc赋值给gp.sched中对应的字段，并且把返回值设置为1。\n调用gogo()函数之后，gp的栈指针和指令指针就会被恢复到sp和pc的位置，而这个位置是deferproc()函数通过getcallersp()函数和getcallerpc()函 数获得的，即deferproc()函数正常返回后的位置，所以经过某个defer函数执行recover()函数后，当前goroutine的栈指针和指令指针会被恢复到deferproc()函数刚刚注册完该defer函数后返回的位置，只不过返回值是1而不是0。\n3.5.2 gorecover()函数 defer函数中调用了内置函数recover()，实际上只会设置_panic的一种状态。内置函数recover()对应runtime中的gorecover()函数，代码如下：\n编译器会把调用者的args from caller区间的起始地址作为参数传递给gorecover()函数。\n1 2 3 4 5 6 7 // 第3章 code_3_31.go func fn() { defer func(a int) { recover() println }(0) } 经编译器转换后的等价代码如下：\n1 2 3 4 5 func fn() { defer func(a int) { gorecover(uintptr(unsafe.Pointer(\u0026amp;a))) }(0) } 图3-20 p.argp和gorecover()函数参数argp的关系\n3.5.3 嵌套的panic Go语言的panic是支持嵌套的，第1个panic在执行defer函数的时候可能会注册新的defer函数，也可能会触发新的panic。如果新的panic被新注册的defer 函数中的recover恢复，则旧的panic就会继续执行，否则新的panic就会把旧的panic置为aborted。\n1 2 3 4 5 6 7 // 第3章 code_3_32.go func fn() { defer func() { panic(\u0026#34;2\u0026#34;) }() panic(\u0026#34;1\u0026#34;) } fn()函数首先将一个defer函数注册到当前goroutine的defer链表头部，记为defer1，然后当panic(＂1＂)执行时，会在当前goroutine的_panic链表中 新增一个_panic结构，记为panic1，panic1触发defer执行，defer1中started字段会被标记为true，_panic字段会指向panic1\n图3-21 panic2执行前的_defer链表和_panic链表\n然后执行到panic(＂2＂)这里，也会在当前goroutine的_panic链表中新增一项，记为panic2。panic2同样会去执行defer链表，通过defer1记录的 _panic字段找到panic1，并将其标记为aborted，然后移除defer1，处理defer链表中的后续节点。\n图3-22 panic2执行后的_defer链表和_panic链表\n在defer函数中嵌套一个带有recover的defer函数\n1 2 3 4 5 6 7 8 9 10 // 第3章 code_3_35.go func fu() { defer func() { defer func() { recover() }() panic(\u0026#34;2\u0026#34;) }() panic(\u0026#34;1\u0026#34;) } 依然把fn()函数首先注册的defer函数记为defer1，把接下来执行的panic记为panic1，此时goroutine的_defer链表和_panic链表与图3-21中的链表并 无不同。只不过当panic1触发defer1执行时，会再次注册一个defer函数，记为defer2，然后才会执行到panic(＂2＂)，这里触发第二次panic，在_panic 链表中新增一项，记为panic2。\n图3-23 defer2执行前的_defer链表和_panic链表\n然后panic2去执行_defer链表，首先执行defer2，将其started字段置为true，_panic字段指向panic2。待到defer2执行recover()函数时，只会把 panic2的recovered字段置为true，defer2结束后，从_defer链表中移除\n图3-24 defer2结束后的_defer链表和_panic链表\n接下来，panic处理逻辑检测到panic2已经被刚刚执行的defer2恢复了，所以会把panic2从_panic链表中移除，如图3-25所示，然后进入recovery()函数 的逻辑中。\n图3-25 panic2恢复后的_defer链表和_panic链表\n结合3.5.1节中的recovery()函数的介绍，panic2被recover后，当前协程会恢复到defer1中注册完defer2刚刚返回时的状态，只不过返回值被置为1，直 接跳转到最后的deferreturn()函数处，而此时defer链表中已经没有defer1注册的defer函数了，所以defer1结束返回，返回panic1执行defer链表的逻 辑中继续执行。\n3.5.4 支持open coded defer 1.14版本中runtime._defer结构的定义\n3.6 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC3%E7%AB%A0-%E5%87%BD%E6%95%B0/","summary":"本章建议最多读到3.4, 到这里已经看不太懂了","title":"第3章 函数"},{"content":"原文\n锁的种类 Record Locks Gap Locks, RR及以上级别才会加上 Next-Key Locks 在RR, Serializable级别时, 在索引上的查询将锁表, 实现方式是Record+Gap Locks(Next-Key Locks)\n加锁分析 RC/RU+条件列非索引 RC/RU+条件列是聚簇索引 RC/RU+条件列是非聚簇索引 RR/Serializable+条件列非索引 RR/Serializable+条件列是聚簇索引 RR/Serializable+条件列是非聚簇索引 总结 影响锁住的记录的范围因素\n查询条件下的记录范围(等值, 范围) 索引类型(非索引, 聚簇索引, 非唯一索引) 隔离级别(Gap) 读/写锁(s, x) ","permalink":"https://jdxj.github.io/posts/articles/cnblogs/rjzheng/%E6%83%8A-%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E7%9A%84select%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90-mysql/","summary":"该文章展示了事务隔离级别与锁的关系, 推荐阅读","title":"惊! 史上最全的select加锁分析(Mysql)"},{"content":"1.1 整车构造组成 Vehicle Structure 四大组成\n车身部分包括车身骨架、车身钣金件以及座椅、仪表、天窗、车外后视镜等车身附件。 动力系统由发动机和变速器组成。 底盘由传动系统、悬架系统、转向系统、制动系统和车轮轮胎组成。 电气电子系统包括蓄电池、发电机、空调、照明系统、行车电脑、音响以及电子控制单元、驾驶辅助系统、电信号传输系统等。 轿车车身骨架和钣金件构造示意图\n宾利汽车整车构造\n汽车主要部件构造图\n双门轿车构造示意图\n动力系统和传动系统构造示意图\n底盘组成\n传动系统包括离合器、传动轴、半轴和差速器等； 行驶系统由悬架系统、转向系统、制动系统、车轮和轮胎等组成。 轿车底盘构造示意图\n1.2 整车布局形式 Vehicle Layout 什么是前置发动机、前轮驱动车型？\n将发动机放置在前部，而且一般都是横置，并采用前轮驱动，就是前置前驱车型（简称F F）。这种传动方式简单，紧凑，传动效率高，制造和维修成本低。\n前横置发动机前轮驱动车型构造图\n前横置发动机前轮驱动\n什么是前置发动机、四轮驱动车型？\n在原来前驱车的基础上再塞进四轮驱动系统, 这样要将发动机输出的动力方向转90°才能向后传递\n前横置发动机四轮驱动车型构造图\n前横置发动机四轮驱动\n什么是前置发动机、后轮驱动车型？\n发动机放置在前部，两个后轮为驱动轮，这种布局方式称为前置后驱车型（简称FR）。豪华汽车一般采用这种前置后驱方式，因为它们通常采用大排量发动机， 发动机体积较大。如果把发动机和传动系统都放置在汽车前部，不仅布置困难，而且还会造成“一头沉”，影响汽车的操控性和安全性。\n前置后驱车型构造图\n前纵置发动机\n什么是后置发动机、后轮驱动车型？\n将发动机放置在后轴后方并采用后轮驱动，称为后置后驱车型（简称RR）。现在，这种布局方式只有保时捷汽车采用。\n后置后驱车型构造图\n保时捷GT3\n什么是前纵置发动机、四轮驱动车型？\n大排量发动机的四驱车型，一般都是从前纵置发动机、后驱车型改造来的。它的发动机采用前纵置方式，动力经变速器后由分动器一分为二，分别传递给后轴和 前轴。\n前纵置发动机、四轮驱动车型（奔驰GL）构造图\n怎样判断发动机是横置还是纵置？\n站在车头前，面向发动机，打开发动机舱盖，如果看到发动机的气缸排列方向是左右方向，则此车发动机为“横置”；如果看到发动机的气缸排列方向为前后方向， 则此车发动机为“纵置”。\n什么是后中置发动机、四轮驱动车型？\n将发动机放置在后轴前端并采用四轮驱动，称为后中置发动机、四轮驱动方式。现在，大多数超级跑车都采用这种驱动方式。\n后中置发动机、四轮驱动车型（奥迪R8）构造图\n奥迪R8超级跑车\n什么是前中置发动机、后轮驱动车型？\n将发动机放置在前轴后方、采用后轮驱动，称为前中置发动机后轮驱动布局方式（简称M R）。跑车喜欢采用这种驱动方式，因为这样可以将整车重心尽量靠近车 身中间，使车辆拥有较高的操控性能。\n奔驰SLR McLaren Roadster构造图\n出气孔\n汽车制动时，前制动盘要比后制动盘承受更大的制动力，它需要更快速地散热，尤其对于车速较快的超级跑车而言，前制动盘的散热效果更为重要。因此，多数 超级跑车上都设计有专为前制动盘散热的出气孔，以利于提高制动性能。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC1%E7%AB%A0-%E6%95%B4%E8%BD%A6/","summary":"1.1 整车构造组成 Vehicle Structure 四大组成 车身部分包括车身骨架、车身钣金件以及座椅、仪表、天窗、车外后视镜等车身附件。 动力系统由发动机和变速器组成。 底盘由传","title":"第1章 整车 Automobile"},{"content":"3.1 如何发现好赛道 必选消费中有食品饮料、日用品、卫生用品、烟酒等，可选消费有珠宝首饰、房地产、汽车\n如何从种类繁多的领域中找到成长性强、模式优秀、值得投资的赛道？\n明白行业处于其生命周期中的哪一个环节 图3-1 行业生命周期理论\n表3-1 四个阶段的行业在股票市场中的体现\n某个消费品可能会衰退，但消费行业本身不会衰退。\n表3-2 消费品三条成长逻辑与行业生命周期的关系\n我们可以参考海外成熟市场的发展历程，来寻找消费行业的投资机会 站在2022年，我们是否还能通过对标海外的方式，来提前发现消费行业的发展方向呢？答案是肯定的。比较显而易见的方向是医美和餐饮 我们可以借助统计局的统计数字，来判断各个行业的景气程度 国家统计局披露的宏观消费数据主要有三个：\n社会消费品零售（简称社零）总额 “住户调查”下的人均居民消费支出 GDP支出法口径下的最终消费支出。 一般来说，我们主要关注社零总额，这个数据反映社会企业销售非生产、非经营的实物商品以及提供餐饮服务所获得的收入。关注社零数据的原因在于：\n第一，社零数据的更新频率较快，每个月更新一次（除1～2月春节期间只更新一次以外），能够迅速地反映消费趋势的变化； 第二，它的口径更为详细，每个月都会披露不同类目下限额以上企业的零售总额及同比增速，可以帮助我们具体判断消费行业每个细分赛道的景气程度； 第三，它的统计结果准确程度相对较高，因为限额以上口径的数字是由各地的大型企业填表报送而来的，是相对直接的一手统计数据。 “限额以上企业”是指主营业务收入超过一定数额的企业，这类企业的零售额由填表报送而来，而非推算得来，具有较高的准确度。\n表3-3 各品类限额以上企业零售额增速\n在消费领域中，什么样的行业值得我们投资？\n其实这取决于我们想找什么样的投资品。\n喜欢进攻、风格犀利的投资者可以关注医美、新能源汽车等处于渗透率提升阶段的消费品； 风格稳妥的投资者可以选择成熟期的价值股（如大家电）进行投资； 均衡的消费者可以选择功能性服饰、功能性护肤品品牌这类处于市占率提升阶段的标的来投资，其具备优异的持续成长能力，也正在不断地创造利润； 而行业格局稳定、拥有持续提价能力的白酒等品类，能够跑赢通胀，也具备明显的壁垒和稀缺性，几乎适合绝大多数的投资者。 3.2 消费品公司分类体系：品牌、渠道、供应链 我们的消费研究框架：供应商-品牌商-渠道商\n按照在消费产业链上所处的环节，企业由上到下可分为供应商、品牌商、渠道商。三者分别对应产品、品牌、渠道三要素。其中， 品牌是消费者和商家间的信用契约，渠道是消费者和商家间的反馈机制，产品是商家对于消费者需求的解读。\n国内知名的渠道商包括京东集团、永辉超市等。 品牌商通常扮演着渠道和供应链的组织者，一方面要设计产品，寻找代工厂，另一方面也要管理其库存与销售渠道，此外还要负责品牌营销等，并给消费者提 供质量背书。国内知名品牌包括服装品牌李宁和安踏、白酒品牌茅台等。 对于长期投资而言，重点是看清投资标的的壁垒和护城河。 壁垒通常是企业具备的难以被复制，并能够持续创造超额利润的资产。\n供应商的壁垒包括规模化生产能力、管理与成本控制能力、研发能力、工艺改善能力等。 渠道商的壁垒包括网络效应、渠道效率、覆盖面、组织管理能力等。 品牌商的壁垒主要在于品牌认知，它的形成需要时间积淀，不可复制，是品牌溢价的基础，能够持续为企业带来利润和成长；此外也在于销售渠道的建设和管 理，这对于即时性消费品类（比如瓶装饮料）而言非常重要。 供应链：中国拥有世界上首屈一指的消费品制造业 供应链主要包括各种原材料供应商和代工厂，它们负责产品的生产环节。比如服装供应链主要包括桐昆股份、百宏实业等原料供应商，以及申洲国际、晶苑国际 等成衣制造商。消费品供应链涉及的范围很广，很多科技企业本质上都属于消费品供应链环节。\n消费行业的定价权通常由品牌和渠道环节掌控，供应链环节的议价能力比较一般，产品出厂价主要依据成本而定。因此，供应链企业的毛利率通常较低，盈利能 力短期受到上游价格波动的影响，长期受制于人工成本提升的挤压。想要持续实现盈利，需持续优化生产过程中的每个细节，并保证充足的产能利用率。\n供应链企业的核心壁垒包括规模化生产能力、管理能力、成本控制能力、研发能力和工艺改善能力等。 研发能力、工艺改善能力近年来变得越来越重要，品牌方会把一部分设计工作（如打样等）交给供应链企业负责，有时也会购买代工厂的方案，未来研发能力 或将成为供应链企业之间决出胜负的关键要素。 我国本土的消费行业在品牌环节整体较为薄弱，其一大原因是形成品牌需要时间积淀。没有品牌、没有销路是国内优质制造商遇到的最大的问题，大量工厂只能 帮海外品牌干苦力活，而拿不到品牌订单的工厂只能艰难度日，这甚至一度催生了“山寨”这种畸形业态。\n渠道：电商是中国消费行业中的核心变量 渠道包括商超、百货、经销商、电商平台等。渠道的核心作用是将终端消费者与品牌和厂家对接起来，将批量生产的商品零售给消费者。\n商超（如永辉超市等）、百货（如百联股份等）、经销商（如滔博体育等）、电商平台（如天猫、京东等）、在电商平台上开店的店家和服务商（如壹网壹创等），都属于渠道商的范畴。 渠道可分为线上渠道和线下渠道，按照经营模式又可分为自营（经销）模式和平台（租赁）模式。对于不同类型的渠道，我们的关注重点有所不同。\n对于线上渠道，我们关注规模、流量和变现能力。线上渠道的壁垒在于网络效应、变现能力、反馈效率、用户习惯等。 网络效应非常关键，用户越多，商家越多；商家越多，用户越多。在线上渠道中，消费者获得的效用与使用该平台的其他用户人数具备相关性，因此线上渠 道的规模（主要用GMV衡量）和流量（主要用活跃用户数衡量）是核心指标。 变现能力反映渠道的利润率和货币化率，直接决定了企业的盈利能力。 反馈效率指渠道把信息传递给商家、供应商的速度，这将影响渠道的整体经营效率。 用户习惯反映了消费者对渠道的倾向性，这将显著影响渠道的流量。 线下渠道的壁垒在于经营模式、规模、渠道覆盖面、经营效率、组织管理能力、用户习惯等。 我们首先要弄清楚渠道是自营的还是加盟的：自营投入高、经营杠杆大，但企业对门店的把控可以做得更到位；加盟相当于自带财务杠杆，扩店所需投入小， 但需要关注加盟协议的细节，以及企业对加盟商的管理能力。 关注门店数量的多寡以及分布情况，门店的扩张需要时间，覆盖面大是线下消费业态的重要壁垒，此外扩店是线下消费最直接的增长方式。 我们要关注门店的经营效率，核心指标包括坪效、店效等，以此考量门店经营的健康程度。 组织管理能力可通过横向对比相似企业的费用率来衡量； 用户习惯主要基于大家在日常生活中对各个渠道的理解，比如“超市的菜没有菜市场的新鲜，所以尽量去菜市场”就是一个用户习惯。 自营渠道的壁垒在于经营效率、规模、渠道覆盖面、用户体验等。所谓自营，就是企业通过低买高卖的形式获利，同时承担存货风险。 通常这个买卖价差并不会很大，因此经营效率上的微小差异，最终可能给利润带来大变化。经营效率是企业长年累月抠细节抠出来的，难以复制。 规模与渠道覆盖面之间存在联系，通常渠道覆盖面大了，规模才能上来。渠道覆盖面决定有多少消费者能前来购物；规模一方面决定了渠道议价能力，影响 进货价，另一方面对于摊薄固定成本意义重大（自营渠道的经营杠杆通常比较高）。 用户体验的好坏、用户习惯的形成与改变，是决定渠道长期存亡的重要变量。 平台模式的壁垒主要在于流量及规模（网络效应）、变现能力。 线上平台和线下商铺租赁是同一种商业模式，都在为经营者提供流量，并向其收取流量费用。收费的多少很大程度上取决于平台提供流量的价值，而平台所 具备的流量在一定程度上取决于网络效应。 线下商铺也类似，租金多少由商铺人流量而定，而人流量通常取决于聚集效应。 对于平台模式的渠道而言，运营组织能力也很重要，它将在更长的周期里决定渠道的人气，并关系到渠道的价值。 总的来说，我们要关注的指标是GMV（反映规模）、活跃用户数（反映流量）、货币化率（反映变现能力）。 表3-4 消费渠道分类\n我国的零售渠道最为特殊之处在于电商。\n图3-4 2019年各国零售电商销售额\n渠道变革永不停歇，每次渠道变革都蕴藏着巨大的机会。\n图3-5 拼多多与开市客涨幅\n品牌：品牌认知带来溢价 消费者根据品牌来评价和挑选商品，制造商在品牌的组织下完成生产，经销商在品牌的管理下销售商品，可以说品牌是消费产业链的枢纽。\n品牌的壁垒，很多时候就是品牌本身。\n图3-6 “品牌计分板”理论\n“品牌计分板”理论告诉我们：\n品牌溢价的形成并非单纯由用料成本、设计、营销中的某个单一因素造成，而是通过所有品牌动作（包括设计、制造、宣传、销售等所有环节）不断和市场交 互反馈，长年累月积淀而成的。 品牌认知具备时间维度。可以把品牌认知想象成一个计分板，有的动作得分，有的动作减分。品牌认知是品牌动作反馈的最终得分，包含动作和时间两个维度。 只有在对的时候做对的事才能得分，品牌资产难以复制。比如，商家在2000年前投放央视广告，在2010年前投放淘宝直通车（买搜索排名），大概率是高分 动作，但放在此时此刻就未必了。 品牌资产的核心在于品牌认知，主要体现在品牌的规模和溢价能力上。一个优秀的品牌不但要具备足够的规模及相应的规模增速，也要有领先的定价能力、溢价 能力、涨价能力。\n具备一定的规模是一个品牌存在的必要条件，不成规模，难言品牌。品牌的销售规模是消费者用真金白银买出来的，是品牌认可度的一个直接体现。 定价能力即“说一不二”的能力，只要定了10元的建议零售价，就不会以9元卖出去，体现为打折少、力度小。 溢价能力强是指毛利率高，比如出厂价为5元的东西，可以凭借品牌力以10元甚至20元的高价卖出。 涨价能力是指能让消费者接受持续涨价，这是最为稀缺的能力，只有部分高端白酒和传统奢侈品等极少数品牌具备这样的能力。 品牌作为一个能够持续创造利润的资产，却不被计入报表之中。ROE=净利润÷净资产，由品牌资产带来的那部分利润会抬高ROE。优秀的品牌企业通常具备较高的 ROE。品牌企业中浮现了大量的“现金牛”，因为品牌的持续经营通常并不需要持续的资本性投入，经营产生的利润基本上都是自由现金流。\n表3-5 部分品牌、渠道、供应链公司的核心优势\n3.3 读懂数字，看清公司 上市公司的数据主要包括财务数据和经营数据。\n财务数据指三张合并报表（利润表、资产负债表、现金流量表）披露的数据，比如收入、利润、存货、现金流等，以及根据报表上的数据算出来的比率，比如 毛利率、净利率、营运周期、ROE等。 经营数据指三张表之外的重要数据，如门店数量、员工数量、坪效、店效等，主要来自上市公司财报的业务概要或经营情况分析等章节，也可来自上市公司官 网、官方微信公众号等渠道。 一份财报通常包括重要提示、释义、公司简介和主要财务指标、公司业务概要、经营情况讨论与分析、重要事项、股份变动及股东情况、优先股情况、 员工情况、公司治理、债券相关情况、财务报告、备查文件目录等。\n以贵州茅台2020年年度报告为例\n标准无保留意见代表对报表的质量满意，如果未获得标准无保留意见，则说明财报中的某些地方是有问题的。 重要提示之后是目录 图3-7 贵州茅台2020年年度报告目录\n公司简介和主要财务指标关注主要会计数据，可清楚看到营业收入、归属于上市公司股东的净利润、经营活动产生的现金流量净额、总资产及它们的同比变动 情况. 我们还可以在公司简介中找到公司的联系方式，若对公司的经营情况有疑问，投资者可拨打相应的电话，或在投资者交流平台上与公司互动。 图3-8 贵州茅台2020年主要会计数据\n公司业务概要主要包含公司对其主要业务的介绍。如果公司业务没有发生重大变化，那么这一段的内容可能会连续很多年没有大变化。当然，在初次分析一家 公司的时候，可以从此处入手来了解公司的主要业务。 经营情况讨论与分析是非常重要的一节，其中最重要的当数管理层对经营情况的文字分析。本节亦会披露大量的经营数据，包括重要的收入和成本的构成， 这有助于我们厘清公司的业务条线，以及各个条线的经营情况和增长情况 主要客户、主要供应商情况也很关键，一方面看采购和销售的集中程度，另一方面也可以通过前五大供应商的构成情况来辅助判断公司主要业务的经营实质 （当然大多数时候企业只会在招股书中披露前五大客户具体是谁）。 前五大供应商、客户的成交额数据有时也可以用来做交叉验证，比如若上游企业前五大客户和下游企业前五大供应商有重合，可以对比双方报表中的数据， 这可以用来大致判断双方报表的数据质量。 图3-9 贵州茅台2020年主营业务分行业、分产品情况\n重要事项统计了公司的历史股利分配方案、承诺履行、会计师事务所聘任情况、关联交易、收并购事项等内容，这部分的很多内容在此前的公告中披露过了， 投资者可利用本节查漏补缺，同时也需关注在本节中是否有可能给经营、股价带来风险的事件。 普通股股份变动及股东情况展示了公司前十大股东、前十大流通股东的变动情况，我们一般关注实控人背景、新增大股东情况、原有大股东股份变动或质押等 信息。 董事、监事、高级管理人员和员工情况是相对比较重要但分析起来有难度的一节。所谓“事在人为”，公司经营情况的好坏很大程度上取决于员工的能力及动力。 在这部分中我们可以看到公司高管的简介、变动情况，以及员工人数及构成。人数和构成都是重点，通常一家业务不断扩张的公司，员工数量会不断增多，尤 其是业务部门的员工。 关注财报中的文字信息 财报中的文字包含了大量的经营信息，有时候能领先于统计数据，折射出企业经营环境的变化。我们在阅读各类财务经营数据之前，可以先看公司管理层对公司 自身经营的分析。这部分内容一般在第四节“经营情况讨论与分析”，当然也在各种“致股东的信”中。\n阅读经营情况讨论与分析的方法：竖着读、横着读。\n竖着读指依次阅读公司历史上各个年度的经营情况讨论与分析，弄清楚公司经营和业务发生变化的脉络，并尽量和各个时期的经济大环境对应起来，找到决定 行业、公司经营的关键变量。 横着读指阅读同一个时期行业同业企业的经营情况讨论与分析，了解彼此之间的竞争情况，并对每个时期的行业景气度进行全景扫描。 利润表：主要关注收入规模及增速、利润规模及增速、毛利率、净利率和费用率等 在利润表中，最重要的两个原始数字是营业收入和归属于母公司股东的净利润（简称归母净利润）的数字。除了关注这两个数字本身，更要关注它们的同比增速。\n利润表中其余的项目，我们主要关注其占营业收入的比率，以及比率的变动趋势。\n图3-10所示为一个基本的消费品利润表分析框架。\n收入反映企业的整体经营规模，企业的成长首先要体现在收入规模的增长上。\n对于消费品企业而言，收入上升通常意味着卖出了更多的产品，有时收入规模就是企业的壁垒所在。 于品牌企业，收入规模增长通常意味着消费者对其总体认可程度提升； 于线上渠道，收入规模增长意味着流量的增长和网络效应的扩大； 于线下渠道，收入规模增长通常来自门店数量增长、覆盖面提升，或坪效、店效的增长； 于供应链企业，收入规模增长则意味着得到更多的下游订单，并有望带来规模效应。 毛利率是非常重要的指标，具备一定的前瞻性。\n一般来说，渠道和品牌企业的利润率是比较稳定的，收入增速会与利润增速相匹配。当两个增速不匹配时，除了非经常性费用、财务费用发生改变的少数情况 外，利润率会发生变化。此时我们要去溯源，看是哪一个环节的成本、费用率发生了变化。 在行业转好时，需求会率先增长起来，但企业的产能扩充难以快速跟上，此时产品价格上涨，毛利率率先提高，此后企业扩产，兑现利润；反之，毛利率将率 先下降。 对于供应链企业而言，通常影响毛利率的因素从大到小分别是：①销售情况，当行业需求变好的时候，价格提升，体现为毛利率增长；②原材料价格，当原材 料降价幅度大于产品降价幅度时，毛利率将会增长；③规模效应降低生产成本。 对于渠道企业而言，平台模式、租赁模式、联营模式的毛利率高于自营，而自建门店的毛利率大于加盟门店。很多公司同时采用多种模式经营，且不同的品类 毛利率通常不一样。当毛利率发生变化时，要先弄清楚这是由结构变化导致的，还是因为经营基本面重大变化而产生的。 费用率反映企业综合管理水平，同类企业中管理水平高的企业，费用率通常更低。这些企业通过费用率的优势，获取了高于行业的利润率。\n费用会包含一部分固定成本，因此规模效应的提升通常将在一定程度上摊薄费用率。 品牌和渠道类消费品公司的销售费用率比较高，品牌公司的销售费用主要来自营销投放等，线下渠道公司的销售费用来自门店租金和折旧、店内员工的工资等。 在分析销售费用的时候，我们要特别注意物流费用的处理方法，在2020年1月1日开始执行的新准则中，物流相关费用从销售费用转移到了营业成本，而一部分 海外公司仍然记在销售费用中，这一点我们在做横向、纵向对比的时候要特别注意。 销售费用率有时候有前瞻指导意义 我们还要将收入和成本拆分到每个业务或每个渠道，并对其逐一分析。\n首先，按业务（产品）拆分。在这一步我们要弄清楚：① 公司的主要收入来源，每个业务的收入及收入占比；② 主要的增长点，即每个业务的增速；③ 哪个业 务利润率高，即每个业务的毛利率；④ 公司的主要利润来源，一般通过毛利构成来判断。\n表3-6 申洲国际各业务收入拆分\n其次，按渠道拆分，即按照不同的渠道进行逐一拆分，弄清楚每个渠道的收入、增速、毛利率，以及相应的收入占比和毛利占比。不同的渠道会有不同的成本和 费用结构，如果不拆清楚，分析就没有意义。\n表3-7 周大生各渠道收入拆分\n以上两个拆分步骤进行完毕之后，我们可以进一步按照“量×价”对收入进行拆分，即拆出销量和单价。有时候财报只披露了销量，这时候我们可以用销售额除以 销量来估算单价。我们可以纵向观察每个产品的销量、单价、毛利率在历史上的变动关系，以及相互之间的关联性。“量×价”也可以按其他方式来进行展开，比如 “店铺数量×单店收入”，或者“经营面积×坪效”等。这里的关键在于找出公司的增长驱动力，发掘不同经营指标之间的关系，并找出决定公司业绩的核心变量。\n资产负债表：关注营运能力指标 观察资产负债表，第一个项目是现金及现金等价物。这是一个相对重要的指标，是否有足够的现金关系到企业能否持续正常运转。\n资产负债表中的营运能力指标会耗费我们大量的分析时间，这些指标主要包括：存货、应收账款、应收票据、应付账款、应付票据、预收款项、预付款项等。对 于这些指标，除了关注其绝对值之外，更重要的是关注其周转速度指标（如周转率、周转天数，二者的区别仅为展现方式不同，乘积为365）。\n存货是一个需要特别小心的科目，其金额和周转天数都要关注。\n第一，一部分消费品存在保质期或时间价值，老库存过多将有可能导致存货减值损失，而如果清仓甩卖，则有可能带来直接亏损，并影响品牌价格带。 第二，存货过高会占用企业的运营资金，影响运营效率。 存货一般可以分为三类：原材料、在产品或半成品、产成品（包括库存商品和发出商品）。\n应收应付款项、预收预付款项代表着企业的行业地位。在产业链中地位越高，就越能够占用上下游资金，体现为预收款项和应付款项高，而预付款项和应收款项 少。\n现金流量表：消费赛道频出“现金牛” 在国内现行管理下，我们更多地关注现金流量表中的经营活动净现金流量。经营活动净现金流量的数值通常会高于净利润，因为净利润不会包括企业的折旧摊销 费用。\n如何看待消费行业的ROE ROE是一个非常重要的财务指标，由净利润除以账面净资产得来，其含义是“股东每投入1元钱，每年能够产生多少净利润”。ROE还表征企业自然增速的天花板： 假设企业新业务的ROE等于原有业务，那么如果企业将每年的利润都投入到再生产中，所能带来的业绩增速就等于该ROE，而我们知道新业务的ROE通常不会高于 原有业务，因此ROE通常被认为是企业自然增速的天花板。\n我们一般会比较看重供应链企业的ROE，而不会太关注消费品牌和加盟类、平台类渠道的ROE。\n对于供应链企业，ROE能很好地反映“每投1元钱能赚多少”，但对于品牌和渠道则不行。 品牌是在企业与消费者长年累月的不断交互中产生的，花钱并不一定能买来品牌认知； 而不同渠道企业如果采取不同的经营模式，会直接对ROE造成较大的扰动； 此外，像阿里巴巴这类电商平台的核心资产其实是平台上的用户和供应商，这些资产不会被计价放入报表中，因此也会使ROE失去意义。 数据的作用仅仅是帮助我们理解行业的景气度和企业的经营情况。在实践中，我们应当站在企业家的角度，思考整个生意的运转，这样才能够得到真实的、对投 资有意义的结论。\n3.4 探寻消费牛股的上涨驱动力 股价=P/E×EPS，股价的上涨可以由利润驱动（EPS驱动），也可以由估值驱动（P/E驱动）。从历史上看，大多数消费牛股都是由利润驱动的。\n表3-8 A股消费行业牛股股价增长拆解（2011-12-31～2021-12-31）\n论消费品估值：为何消费品企业的PEG常大于1\n消费品企业的增长持续性、确定性强。品牌力的形成、产品不断提价、用户消费习惯的转变、新消费渗透率的提升、渠道网络效应的形成，都是消费品企业增长 的根本来源。历史多次证明这些转变是缓慢但具备趋势性的，很多时候企业增速虽然不太高，但能够持续很多年，且增长具有惯性，确定性较强，因此市场乐于 给予使PEG\u0026gt;1的估值。\n再论消费品估值：什么样的企业能够实现长期估值增长\n为什么这些白酒、调味品标的能够在长周期内实现估值的增长？\n答案是：涨价逻辑。头部白酒品牌的涨价逻辑类似于奢侈品。\n首先，白酒是有社交和分享属性的商品，饮酒的场合通常是各种聚会，在这类场合下人们有溢价购买品牌商品的动力，对价格相对不敏感。 其次，在白酒品牌中，口碑最佳、最具品牌力的就是这些A股龙头白酒上市公司，市面上能够买到的最好的白酒，就出自这些品牌。 最后，白酒保质期长，越放越醇，越值钱。 图3-13 飞天茅台（53度）的经销商调货均价持续上升\n调味品在一盘菜中所占的成本比重极低，几乎可以忽略不计，但存在感高，在相当大的程度上决定了一盘菜的风味。仅几滴酱油，就能决定菜品的色香味，而如 果换了一个品牌，可能就完全不一样了。这使得用户对酱油的品种存在较强的黏性，同时对涨价相对不敏感。因此，酱油这类调味品拥有很高的涨价能力。\n为什么涨价能力如此重要？因为其代表永续增长和跑赢通胀的能力。有涨价能力意味着企业可以以超过通胀的速度逐渐提升其产品的售价，以实现实际意义上的 永续增长当然，这个永续增长的速度并不会很快。这类资产在经济增速放缓、无风险利率下降的经济环境下，将迎来估值提升。提升的本质逻辑可以用戈登模型 解释，戈登模型告诉我们，股票的P/E=1/（r-g）。如表3-9所示，永续增长率g更高的资产，在贴现率r下降时，估值的增长幅度更大。\n表3-9 在不同贴现率、永续增长率下，戈登模型预示的P/E\n3.5 结语 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC3%E7%AB%A0-%E6%B6%88%E8%B4%B9%E5%93%81%E6%8A%95%E8%B5%84%E5%89%91%E6%8B%9B/","summary":"3.1 如何发现好赛道 必选消费中有食品饮料、日用品、卫生用品、烟酒等，可选消费有珠宝首饰、房地产、汽车 如何从种类繁多的领域中找到成长性强、模式优秀","title":"第3章 消费品投资剑招"},{"content":"品牌投资的三条主要逻辑 行业规模、渗透率提升：行业增长可由消费人群的增长或人均消费的增长驱动，渗透率指的是现有消费群体在潜在消费群体中的占比，渗透率提升是品类市场 规模增长的重要驱动力。 市占率提升：如果行业原本较为分散，没有成规模、成体系的供应，这时出现了品牌公司整合资源实现规模化，就有品牌化程度提升；如果行业的龙头公司不 断扩大市场份额，品牌增速大于行业增速，就有品牌集中度提升。 价格带提升：一部分消费品具备持续提升价格带的能力，比如茅台、爱马仕等；另一些消费品公司则通过不断提升产品定位，做高端迭代来提升产品价格带， 如华为等。 2.1 消费品品牌增长逻辑之一：行业规模、渗透率提升 行业规模增长可以拆分成用户基数增长和人均消费增长\n图2-1 行业规模增长可拆分成用户基数（渗透率）增长和人均消费增长\n现阶段大多数的消费品品类已经进入了成熟期，拥有渗透率提升逻辑的并不多。这类行业通常代表新兴需求，如2021年的新能源汽车、医美、扫地机器人等行业， 都拥有渗透率提升的增长逻辑。\n医美就是一个典型的渗透率增长的行业。\n图2-2 每千人医美诊疗次数（2019年）\n图2-3 中国大众对医美的接受度调查（2018年）\n图2-4 我国不同城市层级的医美渗透率（2020年）\n图2-5 我国医美消费者年龄分布（2020年）\n2.2 消费品品牌增长逻辑之二：市占率提升 市占率提升包括品牌化程度提升和品牌集中度提升。\n品牌化程度提升指的是，把原本并不集中的行业通过品牌整合起来，如连锁餐饮行业； 品牌市占率提升指的是，行业内具备优势的品牌蚕食对手份额，提升市占率的过程 图2-6 中日美餐饮连锁化率\n海底捞崛起的逻辑是品牌化程度提升\n图2-7 2020年中国连锁餐饮市占率\n龙头企业市占率提升背后的原因包括：\n规模生产降低成本，从而提供了质量更好、更具性价比的产品； 知名度高，具备更强的消费者认知； 拥有分布更广的销售和售后服务渠道等。 通常而言，具备功能性的消费品细分赛道更容易出现市占率较高的大品牌，因为细分赛道中的龙头品牌更加容易被贴上标签，与某些特殊功能、功效形成强绑定。\n图2-8 皮肤学级护肤品行业龙头品牌市占率高于整个化妆品行业\n2.3 消费品品牌增长逻辑之三：价格带提升 在具备彰显个性和社交属性特征的消费品赛道，通常更容易出现具备持续提价能力的品牌。\n茅台 爱马仕 图2-9 飞天茅台（53度）的经销商调货价格持续上升\n根据戈登模型P/E=1/（r-g），在投资者要求的回报率r（即贴现率）保持不变的情况下，永续增长率g越高的标的，其合理P/E越高。\n表2-1 在不同贴现率、永续增长率下，戈登模型预示的P/E\n类似茅台、爱马仕这样具备直接提价能力的品牌毕竟是极少数。对于大部分消费品品牌而言，提价主要通过产品迭代完成。\n图2-10 波司登2017～2018年各价格带产品销售量分布\n图2-11 我国高端美妆个护品的市占率逐年提升\n总的来说，渗透率提升阶段的资产进攻性最强、涨得最快、风险最大，投资时要充分小心，要充分摸清公司质地，并保持对公司基本面的紧密跟踪，当增速不及 预期时要及时防范回撤风险。投资于市占率不断提升的龙头公司是一种平衡了风险和收益的好做法，关键在于对行业的景气度以及公司的成长速度保持跟踪。而 投资于具备持续涨价能力的品牌企业是一种相对稳妥的做法，理论上这类资产在当前经济增长放缓、无风险利率下行的经济环境之下，会有让人眼前一亮的表现。\n2.4 结语 行业规模与渗透率提升是稀缺逻辑。大多数消费品品类已经进入成熟期，行业规模与渗透率提升逻辑主要出现在新兴需求领域。拥有这类逻辑的消费品容易实现 持续高增长。\n市占率提升即品牌化程度提升、品牌集中度提升。品牌化程度提升指品牌把分散的行业整合起来，品牌集中度提升指龙头企业市占率提升。\n拥有持续提价能力的品牌容易成为核心资产。大多数品牌通过产品高端化迭代来提升价格带，只有极少数品牌拥有让产品直接涨价的能力。\n","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC2%E7%AB%A0-%E6%B6%88%E8%B4%B9%E5%93%81%E6%8A%95%E8%B5%84%E5%BF%83%E6%B3%95/","summary":"品牌投资的三条主要逻辑 行业规模、渗透率提升：行业增长可由消费人群的增长或人均消费的增长驱动，渗透率指的是现有消费群体在潜在消费群体中的占比，","title":"第2章 消费品投资心法"},{"content":"2.1 指针构成 1 var p *int 无论指针的元素类型是什么，指针变量本身的格式都是一致的，即一个无符号整型，变量大小能够容纳当前平台的地址。例如在386架构上是一个32位无符号整 型，在amd64架构上是一个64位无符号整型。\n有着不同元素类型的指针被视为不同类型，这是语言设计层面强加的一层安全限制，因为不同的元素类型会使编译器对同一个内存地址进行不同的解释。\n2.1.1 地址 2.1.2 元素类型 后两条指令由MOVQ变为MOVL\n2.2 相关操作 2.2.1 取地址 LEAQ指令的作用就是取得main.n的地址并装入AX寄存器中。后面的MOVQ指令则把AX的值复制到返回值p。\n这里获取的是一个包级别变量n的地址，等价于C语言的全局变量，变量n的地址是在编译阶段静态分配的，所以LEAQ指令通过位移寻址的方式得到了main.n 的地址。 LEAQ同样也支持基于基址和索引获取地址 Go语言通过逃逸分析机制避免返回局部变量地址所引发的问题, 实际上在堆上分配\n2.2.2 解引用 空指针异常 所谓空指针，就是地址值为0的指针。按照操作系统的内存管理设计，进程地址空间中地址为0的内存页面不会被分配和映射，保留地址0在程序代码中用作无效 指针判断，所以对空指针进行解引用操作就会造成程序异常崩溃 遭遇空指针异常并非语言设计方面的缺陷，而是程序逻辑上的Bug。 野指针问题 在C语言中, 未初始化的指针变量是随机值, 会绕过代码中的空指针判断逻辑，从而造成内存访问错误。 Go语言中声明的变量默认都会初始化为对应类型的零值，指针类型变量都会初始化为nil 悬挂指针问题 指程序过早地释放了内存，而后续代码又对已经释放的内存进行访问，从而造成程序出现错误或异常。 Go语言实现了自动内存管理，由GC负责释放堆内存对象。GC基于标记清除算法进行对象的存活分析，只有明确不可达的对象才会被释放 2.2.3 强制类型转换 2.2.4 指针运算 假如有一个元素类型为int的指针p，要把p移动到下一个int的位置，在C语言中可以通过指针的自增运算实现，代码如下：\n1 ++p; 在Go语言中等价的代码如下：\n1 p = (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(p))+unsafe.Sizeof(*p))) 2.3 unsafe包 经典的类型转换\n图2-1 String Header和Slice Header的结构\n如果不经意修改了slice就可能会造成程序逻辑错误。\n2.3.1 标准库与keyword ArbitraryType在这里只是用于文档目的，实际上并不属于unsafe包，它可以表示任意的Go表达式类型。 Sizeof()函数用来返回任意类型的大小 Offsetof()函数用来返回任意结构体类型的某个字段在结构体内的偏移 Alignof()函数用来返回任意类型的对齐边界 最重要的是这3个函数的返回值都是常量。 这条MOVQ指令直接向返回值o中写入了立即数8，也就说明Sizeof()函数在编译阶段就被转换成了立即数。 上述测试方法同样适用于Offsetof()函数和Alignof()函数。 2.3.2 关于uintptr 很多人都认为uintptr是个指针，其实不然。不要对这个名字感到疑惑，它只不过是个uint，大小与当前平台的指针宽度一致。因为unsafe.Pointer可 以跟uintptr互相转换，所以Go语言中可以把指针转换为uintptr进行数值运算，然后转换回原类型，以此来模拟C语言中的指针运算。\n需要注意的是，不要用uintptr来存储堆上对象的地址。具体原因和GC有关，GC在标记对象的时候会跟踪指针类型，而 uintptr不属于指针，所以会被GC忽略, 造成堆上的对象被认为不可达，进而被释放。用unsafe.Pointer就不会存在这个问题了，unsafe.Pointer类 似于C语言中的void∗，虽然未指定元素类型，但是本身类型就是个指针。\n参考聊一个string和[]byte转换问题\n2.3.3 内存对齐 硬件的实现一般会将内存的读写对齐到数据总线的宽度，这样既可以降低硬件实现的复杂度，又可以提升传输的效率。 Go语言的内存对齐规则参考了两方面因素：一是数据类型自身的大小，复合类型会参考最大成员大小；二是硬件平台机器字长。 机器字长是指计算机进行一次整数运算所能处理的二进制数据的位数，在x86平台可以理解成数据总线的宽度。当数据类型自身大小小于机器字长时，会被对齐 到自身大小的整数倍；当自身大小大于机器字长时，会被对齐到机器字长的整数倍。\n通过unsafe.Sizeof()函数和unsafe.Alignof()函数可以得到目标数据类型的大小和对齐边界\n地址应该是Alignof的倍数.\n表2-1 常见内置类型的大小和对齐边界\n通过调整结构体成员的位置，尽量避免编译器添加padding\n2.4 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC2%E7%AB%A0-%E6%8C%87%E9%92%88/","summary":"2.1 指针构成 1 var p *int 无论指针的元素类型是什么，指针变量本身的格式都是一致的，即一个无符号整型，变量大小能够容纳当前平台的地址。例如在386架构","title":"第2章 指针"},{"content":"1.1 消费行业的特点 消费涵盖了人们生活的方方面面，范围广、韧性强\n消费对应了大多数行业的终端需求\n不论是上游周期行业，还是中游科技制造行业，最终都将会以某种形式对应到终端的消费上 消费行业牛股辈出，基业长青\n具备明显的经营壁垒，能占据人们的认知和心智，通过品牌认知、网络效应不断为投资者带来超额收益\n1.2 消费研究，始于日常 在众多的行业中，消费行业可谓是最容易理解的赛道之一。理解消费行业，不需要太多的数理化专业知识，不需要相关的从业经验，甚至不一定需要第一手的行 业数据。只要能够做到对周围生活敏锐洞察和深刻理解，每个人都能够从自身周围感受、感知到投资的机会。\n1.3 中美消费行业复盘对比 总的来说，中美两国的消费品发展，都出现过三个典型的阶段。\n第一个阶段是生活必需品普及阶段，主要是食品和生活用品的普及； 第二个阶段是家庭消费阶段，体现为大家电、汽车渗透率的提升； 第三个阶段是个人消费阶段，体现为品牌商品的增长，在这个阶段，人们消费更加注重个性化的需求和消费主张的宣扬。 美国消费行业发展复盘\n第一个阶段是1900～1930年的生活必需品普及阶段 第二个阶段是1930～1960年的家庭消费阶段 第三个阶段是1960～1990年的个人消费阶段 第四个阶段是1990年至今的新消费阶段。 图1-6 美国各类主要消费品的历史渗透率 回顾改革开放以来的中国消费发展历史\n至2021年，我国的消费发展历史大致可以分为生活必需品、家庭消费、个性化消费三个阶段。 中国消费的下一个阶段\n美国的主题是新消费习惯、新消费主张的兴起，这带来了大量的新需求与新品牌崛起的机会； 日本的主题是低欲望，是对于朴素、精巧、实用、去品牌化的追求。 笔者认为，中国消费行业未来的发展会更像美国，而不像日本 1.4 欧美消费股群雄志 总的来说，欧美股市投资回报率比较高的标的主要是奢侈品、有一定溢价能力的品牌、餐饮等服务公司、持续扩张的渠道商，而投资回报率比较一般的标的主要 是市场空间趋于饱和的大众消费品、成熟渠道。在回报率较高的标的中有大量的“十倍股”，而投资回报率一般的标的也能给投资者带来两三倍的稳定回报。从风 险回报比上看，消费品投资是一个值得下注的赛道。\n消费品企业的估值存在共性：如图1-19所示，企业P/E中枢大体上稳定在15～35倍，其中奢侈品的估值较高，而大众消费品的估值较低。\n1.5 结语 第一，奢侈品具备长期的价值。 茅台 第二，有功能性、品牌力强的消费品。 李宁 安踏 珀莱雅 贝泰妮 第三，在服务消费中，能够实现连锁化、标准化的行业是好的投资方向。 第四，渠道和大众消费品的投资机会主要来源于业务的扩张。 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC1%E7%AB%A0-%E4%B8%BA%E4%BD%95%E9%80%89%E6%8B%A9%E6%B6%88%E8%B4%B9%E5%93%81%E6%8A%95%E8%B5%84/","summary":"1.1 消费行业的特点 消费涵盖了人们生活的方方面面，范围广、韧性强 消费对应了大多数行业的终端需求 不论是上游周期行业，还是中游科技制造行业，最终都将","title":"第1章 为何选择消费品投资"},{"content":"1.1 x86通用寄存器 32位x86是intel推出的,64位x86_64是amd推出的(amd64)\n1.1.1 32位架构 在汇编中使用名称来引用寄存器.\n表1-1 Intel指令编码中8个通用寄存器的编号和名称\n编号 名称 编号 名称 0 EAX 4 ESP 1 ECX 5 EBP 2 EDX 6 ESI 3 EBX 7 EDI 0~3号寄存器可以拆分\n图1-1 EAX寄存器的结构 表1-2 编号为0～3的寄存器的结构设计\n32位 16位 高8位 低8位 EAX AX AH AL ECX CX CH CL EDX DX DH DL EBX BX BH BL 4~7号寄存器没有8位独立名称\n表1-3 编号为4～7的寄存器的结构设计\n32位 16位 32位 16位 ESP SP ESI SI EBP BP EDI DI 通用寄存器的特殊用途\nEAX寄存器会被乘法和除法指令自动使用，通常称为扩展累加寄存器。 ECX被LOOP系列指令用作循环计数器，但是多数上层语言不会使用LOOP指令，一般通过条件跳转系列指令实现。 ESP用来寻址栈上的数据，很少用于普通算数或数据传输，通常称为扩展栈指针寄存器。 ESI和EDI被高速内存传输指令分别用来指向源地址和目的地址，被称为扩展源索引寄存器和扩展目标索引寄存器。 EBP在高级语言中被用来引用栈上的函数参数和局部变量，一般不用于普通算数或数据传输，称为扩展帧指针寄存器。 EFLAGS标志寄存器\n汇编语言中用于比较的CMP和TEST会修改标志寄存器里的相关标志，再结合条件跳转系列指令，就能实现上层语言中的大部分流程控制语句 EIP指令指针寄存器\n存储的是下一条将要被执行的指令的地址，而且汇编语言中不能通过名称直接引用EIP，只能通过跳转、CALL和RET等指令间接地修改EIP的值。 1.1.2 64位架构 64位架构把通用寄存器的个数扩展到16个，之前的8个通用寄存器也被扩展成了64位，每个寄存器的低8位、16位、32位都可以单独使用。\n表1-4 64位架构下16个通用寄存器的结构设计\n64位 32位 16位 8位 RAX EAX AX AL RCX ECX CX CL RDX EDX DX DL RBX EBX BX BL RSP ESP SP SPL RBP EBP BP BPL RSI ESI SI SIL RDI EDI DI DIL R8~R15 R8D~R15D R8W~R15W R8B~R15B 指令指针EIP被扩展为64位的RIP，但依然不能在代码中直接引用。标志寄存器EFLAGS被扩展为64位的RFLAGS，里面的标志位保持向前兼容。\n1.2 常用汇编指令 x86的汇编指令一般由一个opcode（操作码）和0到多个operand（操作数）组成，大多数指令包含两个操作数，一个目的操作数和一个源操作数。\n1.2.1 整数加减指令 源操作数可以是寄存器, 内存, 立即数, 目的操作数可以是寄存器, 内存. 两个操作数不能同时为内存\nADD EAX, 16 ; EAX = EAX + 16 SUB ESP, 32 ; ESP = ESP - 32 ADD AL, CL ADD AX, CX 1.2.2 数据传输指令 MOV指令主要用来在寄存器之间及寄存器和内存之间传输数据，也可以用来把一个立即数写到寄存器或内存中。\nMOV EAX, ECX ; EAX = ECX MOV EDX, 1234 ; EDX = 1234 内存寻址方式\nDisplacement：位移，是一个8位、16位或32位的值。 Base：基址，存放在某个通用寄存器中。 Index：索引，存放在某个通用寄存器中，ESP不可用作索引。 Scale：比例因子，用来与索引相乘，可以取值1、2、4、8。经过计算得到的地址称为有效地址。 Effective Address = Base + (Index x Scale) + Displacement (1-1) 基于Base和Displacement的寻址\n位移(Displacement)：一个单独的位移表示距离操作数的直接偏移量。因为位移被编码在指令中，所以一般用于编译阶段静态分配的全局变量之类。 基址(Base)：将内存地址存储在某个通用寄存器中，寄存器的值可以变化，所以一般用于运行时动态分配的变量、数据结构等。 基址＋位移(Base＋Displacement)：基址加位移，尤其适合寻址运行时动态分配的数据结构的字段，以及函数栈帧上的变量。 MOV EAX, [16] ; 位移 MOV EAX, [ESP] ; 基址 MOV EAX, [ESP + 16] ; 基址 + 位移 1.2.3 入栈和出栈指令 PUSH EAX ; 等价于 SUB ESP, 4 MOV [ESP], EAX POP EAX ; 等价于 MOV EAX, [ESP] ADD ESP, 4 1.2.4 分支跳转指令 JMP指令会修改EIP的值\n只有一个操作数, 可以是立即数, 通用寄存器, 内存位置 JMP 32 JMP EAX JMP [EAX+32] 1.2.5 过程调用指令 可以认为CALL在JMP的基础上多了一步记录返回地址的操作\nCALL指令先把返回地址入栈，然后跳转到目的地址执行 目的地址也可以经由一个立即数、通用寄存器或内存位置来给出。\nCALL EAX ; 等价于 PUSH 32 JMP EAX 子过程执行完成后通过RET指令返回，RET指令会从栈上弹出返回地址，并跳转到该地址处继续执行。\nRET 可以不带参数 RET 8 ; 等价于 RET ADD ESP, 8 1.3 内存分页机制 在分页模式下，应用程序中使用的地址被称为线性地址，需要由MMU(Memory Management Unit)基于页表映射转换为物理地址，整个转换过程对于应用程序 是完全透明的。\n1.3.2 80386两级页表 每个页面4KB, 地址总线32bit, 物理地址32bit 每个页面存1024个地址 = 4KB/32bit(4B) = 1K 图1-2 80386线性地址到物理地址的转换 1.3.3 PAE三级页表 Physical Address Extension，PAE 物理地址扩展\nPAE地址总线36bit, 使硬件能够寻址64GB 仍使用32bit线性地址宽度(进程地址空间大小不变) 每个页面4KB, PAE地址总线36bit, 物理地址64bit 每个页面存储512个地址 = 4KB/64bit(8B) = 0.5K 图1-3 PAE线性地址到物理地址的转换 1.3.4 x64四级页表 Intel推出的IA64架构因为与原来的x86架构不兼容，所以没能普及，而AMD公司通过扩展x86推出的x64架构，因为良好的向下兼容性而被广泛采用。常见的 x64、x86_64都是指amd64架构，如今的个人计算机基本是基于amd64架构的。\n在amd64上，寄存器的宽度变成了64位，而线性地址实际只用到48位，也就是最大可寻址256TB的内存。很少有单台计算机会安装如此大量的内存，所以没有必 要实现48位的地址总线，常见的个人计算机的CPU的地址总线实际还不到40位，例如笔者的计算机的Core i7实际只有36位。服务器的CPU的地址总线的宽度会 更大，例如Xeon E5系列能达到46位。\n每个页面4KB, 地址总线48bit, 物理地址64bit 每个页面存储512个地址 = 4KB/64bit(8B) = 0.5K 1.3.5 虚拟内存 猜测前面的地址转换图中的CR3是每个进程页表的起始物理地址\n进程是以页面为单位向操作系统申请内存的，操作系统一般只是对进程已申请的区间进行记账，并不会立刻映射所有页面。等到进程真正去访问某个未映射的页 面时，才会触发Page Fault异常，操作系统注册的Page Fault Handler会检查内存记账：如果目标地址已申请，就是合法访问，系统会分配一个物理页面并 完成映射，然后恢复被中断的程序，程序对这一切都是无感的；如果目标地址未申请，就是非法访问，系统一般会通过信号、异常等机制结束目标进程。\n当物理内存不够用的时候，操作系统可以把一些不常使用的物理页面写到磁盘交换分区或交换文件，从而能够将空出的页面给有需要的进程使用。当被交换到磁 盘的页面再次被访问时，也会触发Page Fault，由Page Fault Handler负责从交换分区把数据加载回内存。程序对这一切都是无感的，并不知道某个内存页 面到底是在磁盘上，还是在物理内存中，所以称为进程的虚拟内存。\n1.4 汇编代码风格 1.操作数的宽度\n在Go汇编中通过指令的后缀来判断操作数的宽度，后缀W代表16位，后缀L代表32位，后缀Q代表64位，不像Intel汇编中有AX、EAX、RAX不同的寄存器名称。 例如对于整数自增指令，Intel汇编风格的代码如下：\nINC EAX INC RCX 对应的Go汇编风格的代码如下：\nINCL AX INCQ CX 2.操作数的顺序\n对于常见的有两个操作数的指令，Go汇编中操作数的顺序与Intel汇编中操作数的顺序是相反的，源操作数在前而目的操作数在后。\n例如Intel汇编的代码如下：\nMOV EAX, ECX 转换成Go汇编的代码如下：\nMOVL CX, AX 3.地址的表示\n有效地址的计算公式如式(1-1)所示，如果要用ESP作为基址寄存器，EBX作为索引寄存器，比例系数取2，位移为16，则可以分别给出两种风格的代码。\nIntel汇编的代码如下：\n[ESP + EBX*2 + 16] Go汇编的代码如下：\n16(SP)(BX*2) 4.立即数格式\nGo汇编中的立即数类似于AT\u0026amp;T风格的立即数，需要加上$前缀。\nIntel汇编的代码如下：\nMOV EAX, 1234 Go汇编的代码如下：\nMOVL $1234, AX 1.5 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC1%E7%AB%A0-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/","summary":"1.1 x86通用寄存器 32位x86是intel推出的,64位x86_64是amd推出的(amd64) 1.1.1 32位架构 在汇编中使用名称来引用寄存器. 表","title":"第1章 汇编基础"},{"content":"构建适合自己的盈利体系 对普通投资者来说，要构建什么样的盈利体系呢？\n首先，它要适合自己的能力圈。对普通投资者来说，学习基本面投资的方法，在自己熟悉的行业或领域内坚持价值投资，是很好的盈利方法。 其次，它要逻辑自洽。 再次，它要符合市场规律和趋势。 最后，它要可持续、可复制。 投资的2.5分原则——接受不完美的股票 满足 \u0026ldquo;好赛道+好公司+好估值\u0026rdquo; 的股票几乎不存在.\n不一定非要找到得3分的股票才投资，得2.5分的股票也可以考虑。得2.5分的股票，是满足3个条件中的两个，其中一个条件不太差、不得零分的股票。 让我想起了 CAP定理\n具备常识和逻辑能力 常识例子\n在基本面不变的情况下，买入的价格越低，风险就越低，未来的投资回报就越高 “十送十”、“十送二十”这样的“高送转”，只是数字游戏，对股票的投资价值没有任何影响 投资者的持仓成本不影响股价未来的涨跌 感悟\n投资无法偷懒，想做好投资必须勤奋 做投资一定要避免管中窥豹，避免利用局部的信息直接做出投资决策，完整、详尽的研究非常有必要 要做可预测性强的决策 预测链条越长，可预测性就越差. 预测宏观经济 -\u0026gt; 预测行业周期 -\u0026gt; 预测公司基本面 影响因素越多，预测越难. 股票指数, 宏观经济、货币政策（流动性）、大国关系、海外市场、大宗商品价格、市场情绪、监管政策等 影响因素的可变性越强，预测越难. 国际关系 价值投资是预测链条短, 影响因素少且相对稳定的投资方法. 把预测变量范围缩小至单个公司，而且只选择有护城河的龙头公司进行跟踪和预测，大 大降低了预测的难度 模糊正确和精确错误. 很多时候大家会陷入过于在意细节的旋涡, 而忽视更高维度的信息 资金性质决定投资策略 如果资金期限足够长，投资策略就可以关注行业的长期趋势、企业的长期竞争力和发展空间，忽略短期的股价波动。 如果资金规模大，投资策略就要求所投资的领域有较大的市场容量，构建资产配置方案并多元化投资。 如果资金期限短、规模小，投资策略应偏向于趋势投资、短期博弈，更关注短期的机会。 投资中安全边际极度重要 股票内在价值与市场价格之间的差距，就是安全边际。 价值投资者是利用市场的非理性和错误定价，在资产价格低于其潜在价值时买入该资产，这样就获得了安全边际。 择时不靠谱 杠杆是价值投资的大敌. 如果你加了杠杆，就有期限限制，就有止损机制，这时候时间不再是你的朋友，而是你的敌人。 区分能力和运气. 当你没有至少5年的业绩来证明的时候，你就不能认为自己能力有多强。 投资中“昂贵”的一句话: 这次情况有所不同！ 不看后视镜开车，拥挤的地方不去，不懂的股票不碰 善于第二层次思维 例子 第一层次思维这样想：这是一家好公司，所以我们可以买这家公司的股票。第二层次思维这么认为：这是一家好公司，市场上很多人也认为它是好公司，所以它 的股价已经很高，它的股票不一定值得买。\n第一层次思维认为：现在经济不好，通货膨胀率很高，股市行情不好，我们要卖股票。第二层次思维认为：现在经济不好，很多人恐慌，都在卖股票，说不定有 买入的机会。\n第一层次思维认为：公司利润下跌，所以我们要卖出股票。第二层次思维认为：这家公司利润确实下跌了，但是它的下跌幅度比大家预期的小，说不定是一个投 资机会。\n第一层思维认为：A股市场是一个投机市，所以基本面研究是没有用的。第二层次思维认为：A股市场确实有很多投机者，也有定价错误，所以我们能用基本面研 究的方法找到定价错误，获得超额收益。\n第二层次思维是帮助大家发现定价错误，而不能代替系统研究和严密决策。\n《投资最重要的事》的核心观点, 霍华德从自己40多年的投资经验中，提炼总结出投资最重要的18件事。\n最重要的不是盲目相信股市总是有效或者总是无效，而是清醒认识到股市相当高效而且相当难以击败，只有真正的高手才能长期战胜市场。 最重要的投资决策不是以价格为本而是以价值为本。 最重要的不是买好的而是买得好。 最重要的不是波动性风险而是永久损失的可能性风险。 最重要的巨大风险不是人人恐惧而是人人都觉得风险很小。 最重要的不是追求高风险高收益而是追求低风险高收益。 最重要的不是趋势而是周期。 最重要的不是市场心理钟摆的中点而是终点的反转。 最重要的不是顺势而为而是逆势而为。 最重要的不是想到而是做到逆向投资。 最重要的不是价格、价值而是相对的性价比，即安全边际。 最重要的不是主动寻找机会而是耐心等待机会上门。 最重要的不是预测未来而是认识到未来无法预测但可以准备。 最重要的不是关注未来而是关注现在。 最重要的是认识短期业绩靠运气、长期业绩靠技术。 最重要的不是进攻而是防守。 最重要的不是追求伟大成功而是避免重大错误。 最重要的不是牛市跑赢市场而是熊市跑赢市场。 坚持简单实用的价值投资 第一，选择简单行业里的好公司。 消费品、公用事业等行业 第二，在股市低迷甚至恐慌时买入。这样大概率就能买到价格比较低、估值比较合理的股票。 第三，组合投资，不集中持股。 第四，耐心持有，做好公司的朋友，等待时间帮助公司实现价值。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%81%9A%E4%B8%AA%E8%81%AA%E6%98%8E%E7%9A%84%E6%8A%95%E8%B5%84%E8%80%85/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%81%AA%E6%98%8E%E6%8A%95%E8%B5%84%E8%80%85%E7%9A%84%E6%8A%95%E8%B5%84%E5%87%86%E5%88%99/","summary":"全书总结","title":"第十章 聪明投资者的投资准则"},{"content":"把股市当作赌场 资本市场的三类钱 聪明钱是那些有深刻洞察力、前瞻判断力的资金。一般来说，聪明钱赚的是上市公司成长的钱。中国A股市场有很多公司给投资者创造了丰厚回报。当然，聪明钱 有时候也会利用人的恐惧和贪婪，在市场低迷时买入，在市场疯狂时卖出，赚一部分其他投资者亏的钱。\n邪恶钱是各类游资，它们不太看公司基本面，善于制造题材和热点，吸引个人投资者跟风，并趁机获利。它们赚的不是上市公司成长的钱，赚的是博弈的钱。它 们赚的钱，基本上是个人投资者亏的钱。\n傻钱，是不懂基本面，不懂估值，无知无畏的钱。A股市场这样的资金很多，而且源源不断。\n图9-1 A股市场生态图 基于错误的原因买入股票 轻信所谓“内部消息”买入股票 因为“题材”买入股票 因为“高送转”买入股票 “高送转”只是一个数字游戏，相当于把一张20元纸币分成两张10元纸币，对投资者没有任何意义 因为股价放量突破买入股票 因为股票连续下跌买入股票 因为喜欢某公司的产品买入其股票 持仓成本影响决策 你应该继续持有还是卖出某只股票，和你的持仓成本、盈亏没有任何关系，只和这只股票未来的涨跌预期有关。\n股票的价格未来会涨还是会跌，取决于基本面和估值 对股价止损，而不是对基本面止损 投资要对基本面止损，而不是对股价止损。\n如果发现自己对一家公司的基本面判断错误，或者一家公司的基本面发生了逆转，这时候你要坚决止损，哪怕自己已经亏了很多钱。 顽固坚持已经失效的策略 表9-1 2016年年底市盈率分布情况（剔除亏损股） 小盘股是否真的意味着高成长? 不管从国内经验看，还是从国际经验看，产业在不断走向集中。而行业龙头，依靠着它的品牌、渠道、规模效应，会获得比小市值公司更高、更确定的业绩增长。\n这两年小盘股溢价正在快速消失。 表9-2 2018年年底市盈率分布情况（剔除亏损股） 随着小盘股溢价消失，小市值的公司越来越多。 表9-3 2016年年底和2018年年底市盈率对比（没有剔除亏损股） 并购或者重组策略，还是好的投资策略吗? 第一，IPO新政实施后，监管部门对并购加强了监管，不再允许随意的并购。 第二，IPO速度加快后，原来因为IPO时间久而被迫选择和上市公司并购的优秀资产，现在自己排队进行IPO。相比并购，IPO对优质资产的股东来说，收益更 大。 我们如何得知公司的并购是否合理呢？\n第一，并入资产是否具有可持续增长能力。 第二，并入资产是否具有协同效应。 第三，估值是否合理。并入资产的估值如果太高，也会损害上市公司股东的利益。 既要绝对收益，又要相对收益 很多投资者在牛市里要相对收益，希望业绩跑赢指数，在熊市里要绝对收益，自己不能亏损，这就既要相对收益，又要绝对收益。\n好公司的股价低，差公司的股价反而高，这种现象叫定价错误。\n盲目相信神秘“主力”和政策 中国股市大部分时间是“疯牛 + 股灾 + 慢熊”的组合。可见，我们不能简单地认为，中国的股市是政策市。 我国政府特别重视关键会议、关键时间点的维稳工作，在维稳工作中，股市维稳是重头戏。重要事件期间，A股却是跌多涨少。 2007年的时候，政府在上半年就开始警惕泡沫过大，2007年5月30日凌晨，财政部突然将证券交易印花税税率由1‰上调至3‰，股市暴跌。但股市短暂调整之 后，一口气从4 000点涨到6 000多点。 我们到底怎么正确看待政府在股市中的作用？\n第一，我们现在股市的盘子越来越大，总市值已经接近60万亿元，这么大的市场，政府调控起来也有难度。 第二，这些年，政府在积累经验，不断进步，大部分时间是不干预指数的，当然，也不可能控制指数的涨跌。 第三，政府要回归本源，要回到强化监管、保护投资者利益上。保护投资者利益，不是操纵股市涨跌，而是加强监管，让信息披露更加透明，让造假公司无处 遁形。当然，市场如果出现极端情况，如出现特别大的股灾，可能影响整个金融体系的稳定，政府也应该果断进行干预。 对于我们做基本面投资的人，除了政策，我们更要关心行业趋势、公司竞争力、财务健康度、估值等基本面因素，这些才是影响公司发展、影响公司长期股价的 根本性因素。\n大部分股票根本就不存在“主力”，在绝大部分情况下，“主力”是大家臆想出来的。\n市场上没有人坐庄，那还有没有所谓的“主力”？股价又是由谁决定的呢？\n股市中有一些持仓量比较大的机构投资者，它们和个人投资者臆想的“主力”是完全不一样的。因为这些机构投资者基本上用的是买入持有策略，很少会走以前 庄家吸筹、打压、拉升、出货的方法。 股价其实是千千万万投资者，即机构投资者和个人投资者共同影响、共同交易出来的。 股价的短期波动有很大的偶然性。 基本面选股，技术面择时 在现实投资中，“基本面”和“技术面”经常水火不相容，根本原因在于基本面和技术指标结论一致的时候，投资者做决策是很容易的，但大部分时候，技术指标发 出的买入或卖出信号，和投资者依据基本面做出的判断，是不一致的。\n图9-4 短线交易中基本面分析的辅助作用 图9-5 基本面投资中技术指标提示预期差 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%81%9A%E4%B8%AA%E8%81%AA%E6%98%8E%E7%9A%84%E6%8A%95%E8%B5%84%E8%80%85/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%8A%95%E8%B5%84%E8%80%85%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/","summary":"把股市当作赌场 资本市场的三类钱 聪明钱是那些有深刻洞察力、前瞻判断力的资金。一般来说，聪明钱赚的是上市公司成长的钱。中国A股市场有很多公司给投","title":"第九章 投资者常犯的错误"},{"content":" 1 $ git merge --squash \u0026lt;branch\u0026gt; ","permalink":"https://jdxj.github.io/posts/cmd/git/%E5%8E%8B%E7%BC%A9%E5%85%B6%E4%BB%96%E5%88%86%E6%94%AF%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9C%AC%E5%88%86%E6%94%AF/","summary":"1 $ git merge --squash \u0026lt;branch\u0026gt;","title":"压缩其他分支提交到本分支"},{"content":"解决could not read Username for \u0026lsquo;https://github.com\u0026rsquo;: terminal prompts disabled\n1 $ git config --global --add url.\u0026#34;git@github.com:\u0026#34;.insteadOf \u0026#34;https://github.com/\u0026#34; ","permalink":"https://jdxj.github.io/posts/cmd/git/terminal-prompts-disabled/","summary":"解决could not read Username for \u0026lsquo;https://github.com\u0026rsquo;: terminal prompts disabled 1 $ git config --global --add url.\u0026#34;git@github.com:\u0026#34;.insteadOf \u0026#34;https://github.com/\u0026#34;","title":"terminal prompts disabled"},{"content":"识别关键驱动因素 对股价有持续、重要影响的因素\n鉴别信号和噪声，就是要判断某个信息会不会对公司的收入、成本、业绩等产生比较大的持续影响。 不同的行业、不同发展阶段的公司，有不同的关键驱动因素。 驱动因素举例\n互联网初创公司，我们要关注它的App下载量、日活跃周活跃月活跃数据等 对于一些发展初期的电商公司，成交总额很重要 对于连锁行业，我们要看开店数量和坪效 对于服装行业，我们看库存 对于白酒行业，我们看预收账款 除了关心公司本身的经营情况，还要关注重要客户和重要供应商的动态。\n一般来说，上市公司的客户集中度越高，风险越大。 除了跟踪重要客户，投资者还要关心竞争对手的动态。\n对有些公司来说，政策有举足轻重的影响\nPPP公司的商业本质是“类金融公司”，一边大规模负债融资，一边投向能产生稳定回报的资产，通过加杠杆实现高净资产收益率。 PPP公司的关键驱动因素\n（1）企业的融资成本。企业的融资成本越低，PPP公司越赚钱。 （2）所投资产的回报率。企业所投资产的回报率越高，PPP公司越赚钱。 （3）坏账率。坏账率越低越好。 总之，我们寻找关键驱动因素，就要抓大放小，关注主要产品的销量和价格、主要成本的边际变化、主要客户和主要竞争对手的动态和政策的变化。\n跟踪关键驱动因素 我们跟踪关键驱动因素的变化，能帮助我们提前判断公司的业绩变动趋势。\n跟踪关键驱动因素的方法很多，可是普通投资者没有那么多资源和时间，该怎么办？\n一是尽量选择自己能力圈内的公司投资 二是尽量用好那些能得到的资源, 比如上市公司公告、券商分析师的分析报告 三是多做基本调研。跟踪贵州茅台的投资者，可以找经销商交流，这是最直接的信息渠道。 识别和利用预期差 “预期差”是市场还没有充分预期到，股价还没有充分反应。\n表8-1 信号和噪声 正确应对“黑天鹅” “黑天鹅”是负的预期差。\n图8-1 正确应对“黑天鹅”的方法 股票买卖之后，我们要做的事情是：一不“死捂”股票，二不天天盯着K线，而要跟踪关键驱动因素的变化，并结合股价变化，理性做出决策。\n","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9F%BA%E6%9C%AC%E9%9D%A2%E6%8A%95%E8%B5%84%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%B7%9F%E8%B8%AA%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E9%9D%A2%E7%9A%84%E5%8F%98%E5%8C%96/","summary":"识别关键驱动因素 对股价有持续、重要影响的因素 鉴别信号和噪声，就是要判断某个信息会不会对公司的收入、成本、业绩等产生比较大的持续影响。 不同的行","title":"第八章 跟踪股票基本面的变化"},{"content":"设定买入股票的条件 一般来说，买入股票的条件包括股价进入合理区间，一些重要的基本面因素发生积极变化（“催化剂”事件发生）。\n等股价下跌到预期价格时不能马上买入, 要分析下跌原因. 股价下跌的原因有多种，大致有以下几类：\n一是公司基本面没有任何变化，因为大盘下跌，股价跟着大盘跌下来； 二是公司发生了一些事情，这些事情对公司基本面只有很小的影响，但市场放大了悲观情绪，导致股价下跌； 三是公司基本面发生恶化，股价下跌。 经过验证之后，你发现了一家好公司，但你不太确定，需要等待一些因素（如基本面“催化剂”）更加明朗才能判断其是否有投资价值，这时候你也需要等待。\n图7-1 确定和跟踪“催化剂”的流程 只有当“催化剂”事件发生，而且还没有被市场充分消化、还没有充分反映在股价中时，才是买入的机会。\n确定合理的买入金额或者仓位 你要确定合理的买入金额或仓位，确定整体仓位和个股仓位，并事先确定动态调整仓位的方法。\n对绝大多数投资者来说，甚至对绝大多数机构投资者来说，宏观经济就是“重要但是能力圈外”的事情。\n所谓能力圈内的事情，是你能研究清楚、你能跟踪的东西，也就是股票的基本面。\n哪些是重要但不是能力圈内的东西呢？那就是宏观经济、指数、汇率、利率等，投资者花时间研究和预测这些东西，只会事倍功半。\n哪些是能力圈内但不重要的东西呢？比如投资者手中股票的盈亏状况，研究这个很容易，但它与股价未来走势没有相关性，所以我们不必过于关注。但很多投资 者会根据自己手中股票的盈亏状况来决定买卖。\n哪些是能力圈外不重要的东西呢？我认为股票市场的短期波动既不重要，也很难预测，但个人投资者偏偏喜欢预测短期涨跌，天天盯着K线做交易。把时间花在这 些既不重要又是能力圈外事情上的人，很难做好投资。\n股票市场的相对吸引力，我们可以用“全市场市盈率的倒数−5年期国债收益率”来衡量，一般来说这个值在4%以上，股票市场就有吸引力。\n表7-1 一个简明的仓位策略 两种经常被使用的仓位策略\n固定股票比例策略 背后的逻辑是“高抛低吸” 适合比较平稳的市场, 如果遇到大牛市，随着市场不断上涨，你会不断卖出股票，可能会“错失”好时机；如果遇到大熊市，随着市场不断下跌，你会不断补 仓买入股票，你可能要忍受较大幅度的套牢或亏损。 安全垫策略 背后的逻辑是本金不能发生亏损, 等组合有了盈利，再加大风险暴露程度 本质是“追涨杀跌”，适合大波动、大震荡的市场 表7-2 固定股票比例策略和安全垫策略对比 现代组合理论告诉我们，要分散风险，过度集中持股（比如只持有2～3只股票），风险太高。那么，分散到什么程度是合适的呢？有人通过实证分析得出， 20～30只股票就基本能分散非系统性风险。但对于个人投资者来说，资金、时间有限，分散到8～10只股票可能就够了。\n具体到某只股票，确定性越大，空间越大，仓位可以更高。当然，任何一只股票的仓位不要超过总仓位的15%～20%，超过这个比例，风险就有点儿高。 “3—6—9”的个股仓位配置方法\n第一步，当他觉得某公司很不错，但还不是特别确定，就先买入3%的仓位。有了3%的仓位，他就会紧密跟踪这家公司的基本面变化，增加对它的了解。 第二步，当他对这家公司理解加深、更加有信心之后，会把仓位加到6%，这是单只股票的中性仓位。 第三步，当这家公司的基本面有超预期发展，或者估值更有吸引力的时候，他会把仓位加到9%，这是他重仓个股的仓位。 然后使用固定股票比例策略, 控制比例.\n预先设定股票的卖出条件 一般来说，卖出股票的条件包括估值不再有吸引力、基本面恶化，或者你找到了更好的股票。\n道理说起来容易，但实际操作起来并不容易，为什么？\n一是公司基本面发生明显恶化的时候，你会发现股价往往已经跌了不少，因为市场上总有一些投资者比你先知先觉。这时候，你要判断坏消息是否已经充分反 映在股价中，而这很难。 二是公司股价上涨超出你预先评判的合理估值区间，有可能是公司基本面发生了超预期的变化，但你不知道。这时候如果你卖出股票，可能错失了一只大牛股。 不论止盈还是止损，核心是两点，第一要看基本面有没有变化，第二要看估值是不是已经到位了，而不是简单地在涨了多少时止盈，在跌了多少时止损\n三个卖出股票的原因，那就是你发现了一只空间更大、确定性更高的股票，投资者的资金有限，这时候选择换股也是明智之举。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9F%BA%E6%9C%AC%E9%9D%A2%E6%8A%95%E8%B5%84%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%B9%B0%E5%85%A5%E4%B9%8B%E5%89%8D%E5%81%9A%E5%A5%BD%E5%85%85%E5%88%86%E5%86%B3%E7%AD%96/","summary":"设定买入股票的条件 一般来说，买入股票的条件包括股价进入合理区间，一些重要的基本面因素发生积极变化（“催化剂”事件发生）。 等股价下跌到预期价格","title":"第七章 买入之前做好充分决策"},{"content":"Redis setup tips Linux 设置内核参数 vm.overcommit_memory = 1\n表示 Always overcommit 写到 /etc/sysctl.conf 配置中后重启 或者直接激活 sysctl vm.overcommit_memory=1 linux的vm.overcommit_memory的内存分配参数详解 理解LINUX的MEMORY OVERCOMMIT 关闭 Transparent Huge Pages\necho never \u0026gt; /sys/kernel/mm/transparent_hugepage/enabled 避免碎片化访问 page Memory 启用交换区, 大小等于物理内存 配置 maxmemory 选项, 要到达内存限制时报错而不是失败 ","permalink":"https://jdxj.github.io/posts/docs/redis/managing-redis/administration/","summary":"Redis setup tips Linux 设置内核参数 vm.overcommit_memory = 1 表示 Always overcommit 写到 /etc/sysctl.conf 配置中后重启 或者直接激活 sysctl vm.overcommit_memory=1 linux的vm.overcommit_memory的内存分配参数详解 理","title":"Redis administration"},{"content":"How is Redis different from other key-value stores? 拥有复杂的数据类型, 及其上的原子操作 是可持久化的内存型数据库, 在数据集比内存大的限制下可以权衡读写速度 What\u0026rsquo;s the Redis memory footprint? 空实例~3MB 1百万小 key 的 string 类型~85MB 1百万个有5个字段的 hash ~160MB What happens if Redis runs out of memory? 不接受写, 但是可以读 可以配置 key 淘汰策略 How can Redis use multiple CPUs or cores? Redis 通常受内存和网络的限制 如果想使用多个 CPU, 那么应该今早使用 Redis Cluster Redis 未来会越来越线程化 What is the maximum number of keys a single Redis instance can hold? What is the maximum number of elements in a Hash, List, Set, and Sorted Set? 理论上2^32个 key, 经过测试可以保存2.5亿个 key hash, list, set, sorted set 每种类型可以保存2^32个 key Where does the name \u0026ldquo;Redis\u0026rdquo; come from? REmote DIctionary Server.\nHow is Redis pronounced? /ˈrɛd-ɪs/\n","permalink":"https://jdxj.github.io/posts/docs/redis/getting-started/faq/","summary":"How is Redis different from other key-value stores? 拥有复杂的数据类型, 及其上的原子操作 是可持久化的内存型数据库, 在数据集比内存大的限制下可以权衡读写速度 What\u0026rsquo;s the Redis memory footprint? 空实例~3M","title":"Redis FAQ"},{"content":" 1 2 $ uptime 08:38:29 up 37 min, 1 user, load average: 1.20, 1.25, 1.18 ","permalink":"https://jdxj.github.io/posts/cmd/uptime/","summary":" 1 2 $ uptime 08:38:29 up 37 min, 1 user, load average: 1.20, 1.25, 1.18 ","title":"uptime"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/cheney/","summary":"主页","title":"Dave Cheney"},{"content":"原文\n在提问之前 尝试在你准备提问的论坛的旧文章中搜索答案。 尝试上网搜索以找到答案。 尝试阅读手册以找到答案。 尝试阅读常见问题文件（FAQ）以找到答案。 尝试自己检查或试验以找到答案。 向你身边的强者朋友打听以找到答案。 如果你是程序开发者，请尝试阅读源代码以找到答案。 在邮件列表或新闻组寻求帮助时加上一句 我在 Google 中搜过下列句子但没有找到什么有用的东西 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮 助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。\n好问题是答者的回报\n当你提问时 慎选提问的论坛 如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：\n在与主题不合的论坛上贴出你的问题。 在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。 在太多的不同新闻群组上重复转贴同样的问题（cross-post）。 向既非熟人也没有义务解决你问题的人发送私人电邮。 网站和 IRC 论坛 第二步，使用项目邮件列表 当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。\n使用有意义且描述明确的标题 一个好标题范例是目标 —— 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望 的行为不一致的地方。\n如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题\n使问题容易回复 在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你 只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如追踪此讨论串、有回复时发送邮件提醒等功能。\n使用清晰、正确、精准且合乎语法的语句 使用易于读取且标准的文件格式发送问题 别动辄声称找到 Bug 低声下气不能代替你的功课 描述问题症状而非你的猜测 按发生时间先后列出问题症状 描述目标而不是过程 问题解决后，加个简短的补充说明 如果还是搞不懂 如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需 要对方解释，记得表现出你已经从中学到了点什么。\n处理无礼的回应 很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直截了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。\n如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这没有发生而你却发火了，那么 你发火对象的言语可能在黑客社区中看起来是正常的，而你将被视为有错的一方，这将伤害到你获取信息或帮助的机会。\n另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之 前一定要非常非常的有根据。\n不该问的问题 我能在哪找到 X 程序或 X 资源？ 我怎样用 X 做 Y？ 如何设定我的 shell 提示？ 我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？ 我的程序/设定/SQL 语句没有用 我的 Windows 电脑有问题，你能帮我吗？ 我的程序不会动了，我认为系统工具 X 有问题 我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？ 如果得不到回答 如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。\n","permalink":"https://jdxj.github.io/posts/articles/ryanhanwu/how-to-ask-questions/","summary":"原文 在提问之前 尝试在你准备提问的论坛的旧文章中搜索答案。 尝试上网搜索以找到答案。 尝试阅读手册以找到答案。 尝试阅读常见问题文件（FAQ）以找到","title":"How to Ask Questions The Smart Way"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/polarisxu/go1.18%E5%BF%AB%E8%AE%AF-%E6%96%B0%E7%9A%84ip%E5%8C%85/","summary":"原文","title":"Go1.18快讯 新的IP包"},{"content":"用“望远镜”验证公司的赛道 好股票的标准可以用“好赛道+好公司+好价格（估值）”来概括\n什么是赛道？赛道是公司所处的行业或者业务领域。\n赛道吸引力是最重要的基本面之一 图6-1 2001—2017年贵州茅台和张裕的业绩和股价 白酒赛道为什么要比其他酒的赛道好？\n首先，白酒是受我国文化影响很大的行业，没有外国产品的竞争。白酒相对于其他酒有不同的地位，它具有悠久的历史和独特的民族文化内涵，这也是白酒 行业的壁垒和护城河。 其次，白酒是一种情感消费，消费者除了考虑口感等因素，更多考虑的是社交需求、面子需要。中国是一个强社交的社会，使得白酒消费呈现不完全追求 “性价比”的特点。 最后，白酒没有库存问题。白酒行业有一个与其他行业不一样的特点，消费者认为白酒储藏的时间越久，会越香醇、越值钱。所以白酒企业不用担心库存管理。 验证公司所处的“赛道”好不好，我们需要看得远一些，不能只看公司目前的收入和盈利状况。\n戴维斯双击、戴维斯双杀与赛道紧密相关。\n市盈率=股价/利润，那么股价=利润×市盈率，行业和公司的发展前景对盈利和市盈率都有影响。 判断清楚公司所处赛道的吸引力如何。我认为可以从两个维度去判断：第一个维度看它所在的赛道的空间有多大，第二个维度要看赛道中的竞争状况如何。\n评判赛道的空间 我们在评判赛道好不好的时候，先要分析赛道的发展空间。而我们评判赛道空间，则可以从目前市场容量和未来增长趋势两个维度来考虑：首先看这个行业目前 的容量，是100亿元、500亿元，还是1 000亿元。其次看未来增长的趋势，是向上、稳定，还是向下。\n我们应该怎么去判断赛道空间有多大呢？很简单，我们先上网搜索信息，对行业进行基本了解。搜索之后，我们还有4个方法：一是看招股说明书，二是看券商的 分析报告，三是看一些专业网站，四是和行业内的人谈一谈，获得更多的信息。\n招股说明书是最好的了解行业空间的帮手。招股说明书的特点是，券商和中介机构要对其严格审核，一般很难造假，所以里面的数据都是有来源和依据的，相 对来说可信度是比较高的。缺点是比较陈旧. 但是，越是新股，上市时间离现在越近，我们越要看招股说明书。 看业务和技术部分. 这个部分是讲这家公司所在行业的前景如何、行业规模有多大等。 图6-3 景旺电子所属行业状况 券商报告、专业网站及行业专家是不错的辅助工具。除了招股说明书，我们还要看券商报告，看券商研究报告的窍门是什么呢？我们看券商研究报告，基本原 则是不看它的目标价，不看它的评级，而要看它对行业和公司的分析。 关于专业的资讯网站，我推荐知乎和雪球。 最后的途径是找行业专家了解行业的情况，这个难度最大、成本最高，但效果最好。一般券商组织的策略会会邀请细分行业的专家来演讲，这是最好的积累行 业知识的机会，只是参与难度比较高。 对不同赛道的不同关注点 分析赛道的三个维度: 消费, 周期, 成长\n消费 消费品的需求是最稳定的。\n消费行业为什么容易出现长期牛股呢？\n第一，消费行业的周期属性相对较弱，经营业绩不太受宏观经济周期的影响。 第二，消费品公司经过长期经营和资金投入形成较强的品牌壁垒和规模优势，获得了行业垄断地位，且这种垄断地位相对稳定。 消费品公司一旦形成品牌护城河和规模护城河，不太需要进行持续的大规模资本支出，也不太容易被新技术、新模式颠覆 图6-4 菲利普-莫里斯国际股价走势图 在投资消费品公司的时候，要注意它们的品牌护城河是否被侵蚀（品牌老化），这是消费品公司的大敌。\n成长 在研究科技股的时候，我们要着重关注需求和技术：只有下游的应用空间足够大，公司所处的赛道才会足够宽敞；只有公司持续进行研发投入，公司才能在未来 新技术上占得先机。\n周期 周期股受宏观经济影响大，即受需求波动影响大，而产品价格和产能利用率的波动会严重影响公司业绩。\n周期性行业的强周期来自哪里？\n一是需求本身就有周期。周期性行业的需求，受宏观经济影响很大，宏观经济本身有周期，即需求本身就有周期。 二是周期性行业往往是重资本行业，沉没成本很高，虽然竞争激烈的产品已经不盈利，但只要产品价格大于变动成本，企业就有继续生产的动力。这导致周期 性行业产能退出很难。 三是周期性行业产品往往无差异化，企业属于同质化竞争，一旦供过于求，价格战是唯一手段。 四是周期性行业都是顺周期扩张产能，当宏观经济繁荣度下滑时，市场对产品需求降低，但之前的新增产能却陆续完成，供给过剩的问题越发严重，全行业陷 入恶性竞争。 评判赛道的竞争格局 关注市场集中度 市场份额是我们所说的市占率，它表示公司收入占行业收入的比重，比重越高，说明公司在行业中地位越高。 而集中度是指该行业内前几家大公司所占市场份额的总和，一般我们认为CR4（行业排名前4的公司的累计市场占有率）小于30%～40%，则该行业为竞争型； 而如果CR4大于等于30%～40%，则该行业为寡头垄断型。 图6-5 乳制品行业竞争格局 关注新进入者的挑战 即使在一个已实现寡头垄断的行业，面对全新商业逻辑的新进入者，我们同样要注意相关的竞争状况。\n图6-6 中国咖啡市场份额分布情况 图6-7 中国咖啡市场规模和平均年复合增长率 关注价格战的激烈程度 “价格战”是企业之间通过竞相降低商品的市场价格展开的一种商业竞争行为，其主要内部动力有市场拉动、成本推动和技术推动，目的是打压竞争对手、占领更 多市场份额、消化库存等。\n容易打价格战的行业\n航空 味精 黑电行业 关注上下游是否强势 强大的上下游是企业的噩梦。一家公司的上下游越集中、越强大（强大的上游客户可以随时涨价甚至断货，强大的下游客户可以随时找到竞争对手来替代），这 家公司定价权就越弱，盈利能力和盈利前景就越差。\n手机零部件 -\u0026gt; 苹果 沥青行业 -\u0026gt; 防水涂料 -\u0026gt; 房地产行业 英特尔 -\u0026gt; 浪潮信息(一个公司) -\u0026gt; 阿里云 因为议价能力都很强的上下游可能会压制赛道，所以我们在评估赛道时，一定要考虑到这一点。当你所研究的公司有强大的上下游时，你一定要想一想，这家公 司有没有反制上下游的核心能力。\n大行业小龙头和小行业大龙头 表6-2 大行业小龙头和小行业大龙头的区别 不同的股票由于它的行业空间不一样，适合的投资者也是不一样的。成长型投资者，更喜欢大行业小龙头。价值型投资者，更喜欢小行业大龙头。对于大行业小 龙头，市场往往会给更高的估值。\n用“透视镜”寻找公司的护城河 表6-3 五粮液和贵州茅台的财务数据对比 护城河指的是企业在相当长的一段时间内无法被模仿被替代的竞争优势。护城河是把竞争对手挡在外面的东西。\n当你看到一家公司盈利能力很强的时候，一定要问两个问题：“它凭什么能做得这么好？未来它是否能持续做好？”这两个问题都是关于公司护城河的。 我们判断公司有没有护城河、有什么样的护城河，一定要透过收入、利润、增长率等表象，找到真正让这家公司持续保持高盈利能力的东西。 哪些是公司的护城河呢？品牌、网络效应、成本优势、高客户转换成本以及渠道优势，是常见的护城河，一家优秀的公司至少要具备其中一项。\n品牌 品牌作为无形资产，能给企业带来宽广的护城河。有品牌影响力的企业，产品畅销，拥有强大的定价权，能让消费者为品牌支付更高的价格，利润率更高。\n贵州茅台无疑是品牌护城河最深的公司之一\n图6-8 2008—2019年贵州茅台的股价走势 图6-9 2008—2017年贵州茅台的毛利率 贵州茅台如此高的毛利率，如此强劲的利润增长，为什么没有竞争对手模仿它，和它竞争？茅台酒成本这么低，为什么有那么多消费者愿意花高价购买？核心在 于品牌影响力。贵州茅台由于悠久的历史、独特的酿造工艺，在消费者心中成为高端白酒的代名词。\n即使公司有品牌，我们还要跟踪和判断：品牌会不会老化？会不会被消费者抛弃？\n百雀羚 雅戈尔 杉杉 网络效应 网络效应，或者说“双边效应”，一旦形成，是最深的护城河。什么是网络效应？如果一家平台公司，随着用户人数的增加，用户之间发生交易的可能性和频率是 以几何级数增加的，这就是网络效应。而网络效应一旦形成，无论是供给端，还是需求端，都会被牢牢吸附在这张网络中，很难脱离，在这种黏性下，供需两端 的迁移成本都是巨大的。而这家平台公司，也构成了非常深的网络效应护城河。\n微信 滴滴 Airbnb 具有网络效应的公司面临的最大挑战，一是来自颠覆性的技术或者商业模式；二是来自监管\n“互联网思维”是近几年最热的词语之一，大致意思是“通过免费策略或者用户补贴，获得海量用户，养成用户习惯，之后基于海量用户慢慢变现”。淘宝、滴滴、 美团等互联网巨头，都是“互联网思维”的产物。\n“互联网思维”是有前提的，那就是靠补贴吸引用户，并形成强大的“网络效应”或者“双边平台效应”，才能在没有补贴的时候保持用户黏性，让用户离不开。淘宝 、支付宝、微信、滴滴、美团等，都符合这个特征。\n各种互联网金融平台因为不符合这个特征，所以没有通过“烧钱”的方式形成超级公司。 房地产中介这个行业并不适合互联网思维 第一，房地产交易金额大，又涉及很多环节，线上不能完全替代线下的信任和服务； 第二，房地产交易是较“低频”的业务，靠补贴获得的客户，很长时间才会第二次交易（大部分人一生只进行一次房地产交易）。 成本优势 成本优势, 就是一家公司的产品的成本比另一家的低。如果成本低，公司的产品就可以比竞争对手的卖得便宜，那消费者就会来买这家公司的产品。如果竞争对 手的产品价格和这家公司的一样，那该公司因为成本低能赚到更多利润，更有发展后劲。\n图6-10 格力电器的股价走势 格力电器的毛利率是30%，而行业的平均值是20%；格力电器的净利率是15%，而行业的平均值不到10%。\n格力电器为什么成本低？\n它经营的钱都是借来的，而且借来的钱都不用付利息，什么意思？格力电器的运营资本，要么是原材料供应商的垫资，因为它可以先用几个月的原材料，不付 钱；要么是下面渠道商的钱，格力电器可以先收钱再给渠道商发货。格力电器能无偿占用上下游资金，这是它低成本的秘密之一。 规模效应带来议价权，议价权带来低成本，从而形成格力电器强有力的护城河。 图6-11 海螺水泥的股价走势 海螺水泥的核心竞争力也来自成本端的绝对优势。\n2017年海螺水泥的毛利率是35%，而行业的平均值是30%；海螺水泥的净利率是22%，而行业的平均值是11%。\n海螺水泥的成本为什么这么低？\n因为低廉的矿山成本和公司的规模优势。另外，不得不提的是，海螺水泥独创的T型战略布局。 高客户转换成本 什么是客户转换成本？客户转换成本，既包括金钱，也包括学习成本等隐性成本。如果消费者学习使用新产品和新服务需要大量的时间投入，那么就会降低消费 者转用竞争对手的产品和服务的概率。\n图6-12 广联达股价走势 什么样的产品、公司和行业具有很高的客户转换成本呢？\n第一，制造业里需要经过严格品质认证的产品。比如汽车产业供应链中的公司。汽车行业对安全性要求很高，所以涉及安全的产品，都有严格的进入壁垒。但 产品一旦进入，客户就不会轻易更换供应商，供应商就能获得持续的订单和利润。 第二，消费品领域的公司通过增值服务来留住客户。比如现在的智能手机公司，它们都提供云服务，让用户把照片、通讯录、记事本等免费同步到云上，很大 一个原因是增强用户黏性。用户如果不用它的产品，要处理这些东西很麻烦。 第三，金融服务业. 银行, 因为客户重新开户要填写一大堆表格，而银行卡可能还关联了支付宝、微信、水电费账户、工资账户、房贷账户等，所以很多客户 并不愿意改变。 第四，学习成本特别高的产品，如Office软件等。 渠道优势 拥有更多的渠道，意味着企业能抢占更多与消费者接触的机会，就有可能占有更多的市场份额。所以，对消费品企业来说，渠道优势是非常深的护城河。\n图6-13 苏宁电器（苏宁易购）股价走势（后复权） 在A股市场，拥有渠道优势的公司主要有以下几种类型。\n一是占据流量入口的互联网公司，如阿里巴巴、京东。 二是占据线下流量入口的连锁超市、连锁卖场等，如高鑫零售、永辉超市。三是产品有规模效应，并且和前两者形成战略合作，抢占它们入口的产品方，如海 天味业。 技术领先是不是护城河 乐视之后，谁将可能是下一个破灭的大泡泡？！\n科大讯飞的技术领先能否持续？它的领先技术能不能转化为吸引用户的产品？能不能转化为持续赚钱的商业模式？最后的结论是，单纯的领先技术并不能保证科 大讯飞获得护城河。\n科大讯飞的股价从2017年最高点的近50元，一路下跌到2018年年底的23元 图6-15 科大讯飞股价走势 科大讯飞的领先技术为什么没有形成护城河呢？\n首先，我们来看科大讯飞引以为傲的语音识别技术。它的语音识别技术在多项比赛中蝉联第一，目前在国际领先，但是各大公司的识别率差距并不大，许多公 司的语音识别率都已经达到95%以上，这样微弱的领先优势不足以使科大讯飞形成强大的护城河。 其次，BAT等巨头开始在人工智能领域发力，快速追赶技术甚至赶超，科大讯飞的技术领先优势迅速缩小甚至消失，但BAT的流量、应用场景、资金实力等优 势，是科大讯飞远远不能比的。 最后，科大讯飞的财务报表没有体现高科技公司应有的特点。 曾有财务专家说道：“从财务报表来看，科大讯飞在经营层面是一家快速增长但含金量不高的公司； 在管理层面，是一家扩张很快但效率低下的公司；在财务层面，是一家擅长募资但却不擅长赚钱的公司； 在业绩层面，是一家大手笔花钱但股东回报率低的公司。其光鲜增长的背后，其实隐藏了巨大的风险。” 科技股为什么看上去值得持有，却不是好的长期投资标的呢？原因有以下几点。\n第一，单纯的技术公司的护城河不深。“一招鲜”的领先技术，容易被模仿甚至被超越，一般来说，两三年的技术，基本上已经没有优势。技术只有能落地为产 品能力、营销能力和品牌力，才能给公司创造可观的利润，公司再利用自己的盈利能力，建立起强大的、持续的技术研发能力，才是护城河。海康威视就 是典型的案例。在A股市场，有些公司头顶高科技的光环，如人工智能、生物技术等，但销量和利润却很少。 第二，不少科技公司，在商业模式上称雄，但在核心技术上却受制于人。某基因测序公司 第三，科技股的估值往往偏高。估值高，未来的投资回报率自然就低。 能干的管理团队非常重要 在研究一家公司的时候，我们要注重激励的有效性、长期性，激励不够和过度的短期激励都是公司治理的大敌。\n当心被侵蚀的护城河 护城河消失的原因\n第一个是技术变革。 第二个是行业变迁，即很多的商业模式发生了变化。最典型的是苏宁，原来它是一家非常有实力的公司，在电商的冲击下开始亏损。 第三个是公司的自杀性增长。这是指公司盲目扩张，之前格力电器要做半导体，这让很多投资者不明白，因为半导体需要很大的开支，同时会影响格力电器未 来的分红计划，短期的股价已经证明市场对这一想法不买单。 如何识别公司有无护城河 如何了解公司的核心竞争力呢？\n我们可以看招股说明书、券商报告、专业网站，还可以找行业专家、下游用户等谈一谈， 分析公司核心竞争力可以用指标分析\n市场占有率、主营业务收入增长率、毛利率、净利率、净资产收益率等 还要找几家对标公司进行比较分析 表6-4 不同行业和不同竞争力公司的估值情况 但是A股市场经常是反过来的情况，很多公司，所属行业很差，自身也没有竞争力，但是市盈率很高，有80倍，甚至100倍，所以从基本面投资的角度，我们就不 要购买这种股票。反过来，有些不错行业的龙头公司，有很强的核心竞争力，估值却很低，这说明市场定价是错的。 市场出错时，就是我们投资机会出现的时候。\n用“显微镜”检验公司财务状况 所有的定性研究和定性逻辑都要落实到公司的财务数据上，我们要学会用财务指标来验证公司到底经营得怎么样。\n简单了解3张报表 （1）资产负债表: 反映的是某个特定时点公司的状态。 （2）利润表: 反映了公司在这个时间段里，收入怎么样，支出怎么样，利润怎么样 （3）现金流量表: 反映了公司在这个时间段里, 现金流入和流出情况 表6-5 2017年小王的家庭资产负债表\n总资产: 541万元 净资产(股东权益): 326万元 表6-6 2018年小王的家庭资产负债表\n总资产: 525万元 净资产(股东权益): 325万元, 净资产减少1万元 表6-7 2018年小王的家庭收入支出表\n全年收入: 35万元 全年支出: 36万元 多支出1万元对应净资产减少1万元 现金流量是一个公式: 年末的现金余额=年初的现金余额 + 当年的现金流入 - 当年的现金流出\n不太明白为啥要用公式算, 年末时应该也能查到账户上有多少现金吧.\n表6-8 2018年小王的家庭现金流量表 注意\n15万元本金是要还银行的钱, 所以不在利润表 利息是成本, 要进利润表 8万元亏损要进利润表, 但没有现金流出, 所以不在现金流量表 四大维度验证公司质地 成长能力、盈利能力、经营效率和经营风险。\n判断成长能力的指标有哪些？\n比如主营业务收入增长率、营业利润增长率和净利润增长率。 反映公司盈利能力的指标有哪些？ 毛利率、净利率和净资产收益率等。 反映公司经营效率的指标有 周转率、存货周转率、应收账款周转率、固定资产周转率等。 反映公司经营风险的指标 主要是负债率等。 如何评估公司的成长能力 评估公司的成长能力的指标，主要有主营业务收入增长率、营业利润增长率和净利润增长率。\n当年的增长率和过去3～5年的平均或复合增长率的计算公式为： A股市场上市公司的平均增长率水平, 大部分年份的增长率在5%至10%这个区间。\n图6-16 A股市场上市公司增长率情况 投资者不仅要看整个A股市场，还要和同行业公司做具体比较。如果同行业公司的增长率都在30%以上，那即便是20%的增长率，也是低速增长。\n我们还要分析一些异常因素，这些异常因素会导致增长率的失真。\n借壳. 分众传媒, 2013~1014借壳七喜控股 图6-17 分众传媒归母公司净利润 重大资产重组. 天润数娱，原名是天润控股, 2016年第二季度实现并表 图6-18 天润数娱归母公司净利润 非经常性损益, 是指和企业的主营业务没有直接关系的各项收支。 广东甘化, 表6-9 广东甘化净利润 从财务角度来看，公司创造价值的最佳衡量指标是投入资本回报率，它直接反映了公司投入和产出的效果。一家公司的投入资本回报率只有大于投入资本的资金 成本时，它才真正创造价值。只有在这样的前提下，成长才是有质量的。\n如何评估公司的盈利能力 毛利率、营业利润率以及净资产收益率\n1 毛利率 =（主营业务收入 - 主营业务成本）/主营业务收入×100% 表6-10 云南白药营业收入 表6-11 云南白药营业成本 图6-19 A股市场上市公司毛利率情况 表6-12 两面针主营业务分产品情况 1 2 营业利润率=营业利润 / 营业收入 × 100% 营业利润=营业收入 - 营业成本 - 营业税金及附加 - 管理费用 - 财务费用 - 资产减值损失 + /- 公允价值变动收益/损失 + 投资收益 营业利润可以在公司的利润表里直接找到这一项\n表6-13 云南白药和两面针的营业利润率对比 图6-20 A股市场上市公司利润率情况 1 净资产收益率=净利润 / 股东权益(净资产) 这个指标反映的是股东投入资金的回报率\n表6-14 云南白药和两面针净资产收益率对比 云南白药的盈利优势\n一方面是云南白药的秘方以及它的商标权，这使得它的品牌优势比较明显，定价可以比竞品高很多； 另一方面是云南白药“轻资产 + 快速周转”的类消费公司的经营模式。 1 市净率 =股价 / 净资产 中国A股市场有很多高净资产收益率公司，它们的市净率反而低；很多低净资产收益率公司，包括很多垃圾股，它们的市净率反而高. 我们投资一定要远离那些净资产收益率很低，但市净率很高的公司。\n图6-21 A股上市公司净资产收益率情况 我们在计算净资产收益率的时候，要把非经常性损益扣除掉。\n如何评估一家公司的经营效率 用周转率衡量公司的经营效率。\n存货周转率、应收账款周转率、固定资产周转率 一般来说，存货周转率越高越好。\n1 存货周转率=销货成本 / 平均存货余额 × 100% 这个比率也是越高越好，应收账款周转率越高，表明产品销售情况越好，公司就不需要通过赊销这样的方法提高销量。\n1 应收账款周转率=赊销净收入 / 平均应收账款余额×100% 固定资产周转率反映公司固定资产的使用效率。固定资产周转率越高，表明公司对厂房和设备等固定资产的利用效率越高。\n1 固定资产周转率=营业收入 / 固定资产净值×100% 表6-15 6家调味品公司的经营指标对比 如何评估一家公司的经营风险 建议大家看两个指标，一个是资产负债率，另一个是有息负债率。\n图6-22 负债是一把双刃剑 图6-23 公司资产负债表 1 公司的资产负债率 =（无息负债 + 有息负债）/总资产×100% 一般来说，这个比例在60%以内算是合理的。如果这个比例超过80%，也就是负债金额是所有者权益的4倍以上，那么公司的经营风险就偏高了。\n无息负债在整体负债中的占比越高，说明公司对供应商和经销商的谈判地位越高、控制能力越强。\n表6-16 贵州茅台和五粮液预收账款占比 识别财务欺诈 两个概念\n盈余管理，是公司合理合法地利用制度和规则，对财务数据进行适当“美容”，这是在制度和规则允许的范围之内做的。 财务造假包括报表粉饰、管理舞弊、会计欺诈，是超出制度和规则范围的。 做高收入和做低成本是主要的造假方式 图6-24 常见的财务造假动机 提高收入的手段比较多，比如通过关联交易增加营业收入，提前确认营业收入等。 降低成本的手段也很多，比如通过管理方支付本应由公司支付的成本，延后确认成本等。 我们建议多看几年的财务报表，因为持续造假超过5年是不容易的。我们只有分析了某公司连续5年以上的财务报表，才能看清楚它的真正经营情况。\n表6-17 2013—2015年乐视研发费用资本化情况 乐视对影视剧版权采购费采取直线摊销法\n如果按照收入和成本匹配原则，它就应该使用加速法来进行摊销，也就是第一年多计算成本，以后年份少计算成本，而不是每年平均计算成本。 表6-18 2013—2015年乐视版权费用摊销情况 财务“洗澡” 公司本年度大幅计提固定资产损失，未来几年就无须再计提固定资产损失。商誉、应收账款、存货、权益投资等都可以成为业绩“大洗澡”的计提项目。\n图6-25 业绩粉饰常见方法 财务“洗澡”什么时候发生？\n一种情况，公司当年的亏损已经不可避免，反正是亏，公司就进行一次性亏损。我们的监管制度规定，上市公司不能连续亏损，连续亏损要被ST、要退市，但 监管制度未规定一次能亏多少钱。 另一种情况，公司管理层换人，首席执行官上任后，发现公司有很多问题账，就让公司在当年一次性亏损，因为责任全在前 任首席执行官身上，这种现象是 较普遍的。 表6-19 2013—2015年4家ST公司的财务数据 表6-20 2018年预告大幅商誉减值的公司 如何发现财务造假 首先，我们可以对同行业的公司进行对比分析，识别潜在的造假。 其次，我们不要只盯着利润表，也要留意资产负债表。财务造假的目标是提高收入和利润，但改变了利润表的项目，一定会对资产负债表产生影响。这是因为， 通过造假使得利润虚增，资产负债表中的所有者权益也应该增加。所有者权益增加后，相应的资产就要增加，否则资产负债表就无法配平。 最后，还有一些信号，大家一定要重视。 第一个信号是财务总监辞职，这可能说明财务总监对造假感到害怕。 第二个信号是公司更换会计师事务所，这往往意味着会计师事务所可能不愿意配合上市公司做账，或者公司另外找到一家愿意配合的会计师事务所。 第三个信号是会计师事务所发表了保留意见或者拒绝发表意见，这表明这家公司基本上是造假了。因为一般来说，会计师事务所都会出无保留意见，也就是 说报表是真实的，没有问题。会计师事务所如果发表了保留意见或拒绝发表意见，表明这家公司的财务报表应该有大问题。 用“公平秤”评估股票性价比 常见的估值方法 推荐大家看达莫达兰（Damodaran）的《估值》（The Dark Side of Valuation）这本书\n原始成本估值法\n原始成本是资产被取得时所支付的对价。 原始成本估值法是不合理的，在现实的估值中几乎用不到。 上市公司报表里的很多资产，如房地产、土地使用权等，是按照原始成本入账的，有时候这些资产是被严重低估的。 重置成本估值法\n重置成本是重新取得相同或类似资产所需要支付的对价。 房地产公司经常用重置成本估值法 也很少用 绝对估值法\n绝对估值法，也叫“地老天荒”的现金流贴现法，是把未来某只股票能产生并分配给投资者的现金流贴现到今天的价值。 做估值的时候，会假设这家公司会永续经营下去 表6-21 不同贴现率下的房子估值 绝对估值法的挑战有两个：\n一是对股票的未来现金流预测很难； 二是贴现率差一点儿，结果就会差很多。 合理的贴现率到底应该是多少呢？\n经验数据是：5年期的国债收益率 +（3%～5%）。这里的3%～5%是“风险溢价”。 绝对估值法有缺点。\n其中的假设和预测，投资者很难学习。 当你用绝对估值法去衡量股票的时候，你会发现绝大部分股票的价格，都比它算出来的绝对估值要高，这时候你找不到可买的股票。 相对估值法\n是以类似资产在市场上的定价为基础，进行比较估值。 表6-22 绝对估值和相对估值的区别 具体到股票投资，相对估值法可以分为3个步骤：\n第一，选取可比公司 选取的可比公司有两个标准：第一，要有可比性；第二，要有足够的代表性。 第二，选取并计算比较指标 市盈率（市值/净利润） 市销率（市值/营业收入） 市净率（市值/净资产） 第三，根据公司质地调整估值。 行业内公司的竞争力、发展前景、盈利稳定性的差异还是很大的，这时候你要根据公司的竞争力、发展前景、盈利稳定性等情况，对估值进行适当调整。 表6-23 白酒行业各公司的估值情况 相对估值的问题\n一旦市场整体被严重高估或者被严重低估，某家公司的估值也就会跟着被高估或者被低估 无法对公司成长能力等进行准确估值 综合应用绝对估值法和相对估值法 绝对估值法，用来确定“安全边际”，也就是确定绝对估值有吸引力的公司，长期“估值有吸引力”，才有安全边际。相对估值法用来进行“个股选择”，确定相对估 值低的公司，即在可比公司中性价比较高的公司。\n表6-25 相对估值和绝对估值的应用 影响股票估值的因素 绝对估值: 贴现率(利率水平) 公司成长能力 市盈增长比率，是市盈率除以未来的复合增长率。在计算的时候，增长率不能是1年的数据，至少是3年的复合增长率才有意义。 市盈增长比率的缺点是预测未来的复合增长率很难。 估值和盈利稳定性的关系是，一家公司的盈利越稳定，意味着投资这家公司的风险越小；投资风险越小，贴现率就可以低一点儿，估值就可以高一点儿。\n一个简单易行的“绝对估值法” 公司合理股价=3年后的预测每股利润 × 公司未来合理市盈率3年后的预测每股利润\n表6-27 合理估值区间（单位：倍） 行业成长空间\n如果行业未来8～10年能保持15%左右的增长率，那就属于超高增长行业； 如果未来8～10年能保持10%左右的增长率，那就属于高增长行业； 如果能保持5%左右的增长率，那就属于低增长行业。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9F%BA%E6%9C%AC%E9%9D%A2%E6%8A%95%E8%B5%84%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%9B%E5%A4%A7%E5%B7%A5%E5%85%B7%E9%AA%8C%E8%AF%81%E5%A5%BD%E8%82%A1%E7%A5%A8/","summary":"用“望远镜”验证公司的赛道 好股票的标准可以用“好赛道+好公司+好价格（估值）”来概括 什么是赛道？赛道是公司所处的行业或者业务领域。 赛道吸引力","title":"第六章 四大工具验证好股票"},{"content":"错误的使用uintptr转换结果可能被 GC.\n原文\n","permalink":"https://jdxj.github.io/posts/articles/huoding/%E8%81%8A%E4%B8%80%E4%B8%AAstring%E5%92%8Cbyte%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/","summary":"错误的使用uintptr转换结果可能被 GC. 原文","title":"聊一个 string 和 []byte 转换问题"},{"content":"原文 1. Primary Concerns 1.1. Usability 建立惯例使库的特性可发现 潜在的错误使用 易于完成常见任务 Case Study: net/http 看起来有些繁琐\n1 2 3 4 5 6 7 8 9 10 // import \u0026#34;net/http\u0026#34; req, err := http.NewRequest(http.MethodGet, \u0026#34;http://example.com\u0026#34;, nil /* body */) if err != nil { return err } var client http.Client res, err := client.Do(req) // ... 更简单的方法\n1 2 3 // import \u0026#34;net/http\u0026#34; res, err := http.Get(\u0026#34;http://example.com\u0026#34;) 但是不应该使用全局 HTTP Client.\n1.2. Readability 在实现之前写伪代码和文档有助于设计出可读性好的 API. 随着经验的增加可能会减少这个习惯.\n1.3. Flexibility 灵活性决定能否加入新功能来满足新用例, 允许用户自定义和扩展来适应他们的需要.\n生态系统 第三方扩展 Case Study: net/http 1 2 var client http.Client res, err := client.Get(\u0026#34;http://example.com\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 package http type Client struct { // Transport specifies the mechanism by which individual // HTTP requests are made. // If nil, DefaultTransport is used. Transport RoundTripper // ... } type RoundTripper interface { RoundTrip(*Request) (*Response, error) } 封装一层, 添加日志功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type loggingRT struct { http.RoundTripper } func (rt *loggingRT) RoundTrip(req *http.Request) (*http.Response, error) { log.Printf(\u0026#34;%v %v\u0026#34;, req.Method, req.URL) return rt.RoundTripper.RoundTrip(req) } roundTripper := \u0026amp;loggingRT{ RoundTripper: http.DefaultTransport, } client := http.Client{ Transport: roundTripper, } res, err := client.Get(\u0026#34;http://example.com\u0026#34;) 1.4. Testability 不要事后想到可测试性, 而是在设计时.\n2. Backwards compatibility 新版本软件可以使用旧版本软件的数据.\n使用某个库的重要因素是该库承诺后向兼容 绝对的后向兼容有缺点 不能使用语言特性 不能使用标准库的新 API 偿还技术债务 设置向后兼容的范围, 例子\n维护当前和前一版本的 releases 遵循 Semantic versioning 2.1. Breaking changes Go 1 and the Future of Go Programs 给出了一些 breaking changes 定义\n向公开的 interface 添加方法是 breaking change\n2.2. Semantic versioning 1.0之前被视为不稳定版本\n3. Recommendations 3.1. Work backwards 在实现之前要考虑\nAPI 可能的使用方法 能否被误用 如何测试功能符合预期 考虑灵活性以适应未来可能的新需求 API 对输入的要求是什么, 对输出的保证是什么 3.2. Minimize surface area 公开的\u0026quot;表面积\u0026quot;越小, 你的库在实现上会获得很大灵活性 公开的\u0026quot;表面积\u0026quot;越大, 需要保证稳定的东西越多 3.2.1 Internal packages 使用 internal 包减少表面积\n不要在公开的 API 中包含 internal 中的实体 3.3. Avoid unknown outputs 对输入进行严格检查 必要情况下 copy 传入的 slice/map, 以免受元素内部状态变更所导致的问题 函数出错时返回类型的零值\u0026amp;err 考虑返回的 slice 的元素顺序 3.4. No global state 全局状态的缺点\n不易测试 高耦合 减少灵活性 Bad\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var cache map[string]*Value func init() { cache = make(map[string]*Value) } func Lookup(name string) (*Value, error) { if v, ok := cache[name]; ok { return v, nil } // ... v := /* ... */ cache[name] = v return v, nil } Good\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Handle struct { cache map[string]*Value } func NewHandle() *Handle { return \u0026amp;Handle{ cache: make(map[string]*Value), } } func (h *Handle) Lookup(name string) (*Value, error) { if v, ok := h.cache[name]; ok { return v, nil } // ... v := /* ... */ h.cache[name] = v return v, nil } 3.5. Accept, don’t instantiate Bad\n1 2 3 4 func New(fname string) (*Parser, error) { f, err := os.Open(fname) // ... } Good\n1 2 3 func New(f *os.File) (*Parser, error) { // ... } 3.6. Accept interfaces Bad\n1 2 3 func New(f *os.File) (*Parser, error) { // ... } Good\n1 2 3 func New(r io.Reader) (*Parser, error) { // ... } 组合接口\n1 2 3 4 5 6 7 8 9 10 11 type Source interface { io.Reader Name() string } var _ Source = (*os.File)(nil) func New(src Source) (*Parser, error) { // ... } 3.7. Interfaces are forever 对接口的增删改都是 break change.\n3.8. Return structs 返回 struct 而不是 interface 可以获得灵活性和向后兼容能力\nBad\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Client interface { Set(k string, v []byte) error Get(k string) ([]byte, error) } type clientImpl struct { // ... } func (c *clientImpl) Set(...) error func (c *clientImpl) Get(...) ([]byte, error) func New(/* ... */) Client { return \u0026amp;clientImpl{ // ... } } Good\n1 2 3 4 5 6 7 8 9 10 11 type Client struct { // ... } func (c *Client) Set(...) error func (c *Client) Get(...) ([]byte, error) func New(/* ... */) *Client { return \u0026amp;Client{ // ... } } 3.9. Upgrade with upcasting 不能给公开的 interface 添加方法\n1 2 3 4 5 6 type Source interface { io.Reader Name() string + Offset() int64 // bad: breaking change } 要创建新的 interface\n1 2 3 4 5 type OffsetSource interface { Source Offset() int64 } 向后兼容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func New(src Source) *Parser { osrc, ok := src.(OffsetSource) if !ok { osrc = \u0026amp;nopOffsetSource{src} } return \u0026amp;Parser{ osrc: osrc, // ... } } type nopOffsetSource struct{ Source } func (*nopOffsetSource) Offset() int64 { return 0 } 3.10. Parameter objects Bad\n1 2 3 func New(url string) *Client { // ... } Good\n1 2 3 4 5 6 7 type Config struct { URL string } func New(c *Config) *Client { // ... } 3.11. Functional options 1 2 3 4 5 6 7 8 9 package db type Option /* ... */ func Connect(addr string, opts ...Option) (*Connection, error) func WithTimeout(time.Duration) Option { /* ... */ } func WithCache() Option { /* ... */ } 1 2 3 4 5 6 7 db.Connect(addr) db.Connect(addr, db.WithTimeout(time.Second)) db.Connect(addr, db.WithCache()) db.Connect(addr, db.WithTimeout(time.Second), db.WithCache(), ) 3.11.1. How to implement functional options 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 定义 option type connectOptions struct { timeout time.Duration cache bool } // 定义操作 option 的接口 type Option interface { apply(*connectOptions) } // 实现 option 接口 type timeoutOption struct{ d time.Duration } func (t timeoutOption) apply(o *connectOptions) { o.timeout = t.d } func WithTimeout(d time.Duration) Option { return timeoutOption{d: d} } // 默认值 func Connect(addr string, os ...Option) (*Connection, error) { opts := connectOptions{ timeout: time.Second, } for _, o := range os { o.apply(\u0026amp;opts) } // ... } 3.11.2. Planning for functional options 预留\n1 2 3 4 5 6 7 8 // Option configures the behavior of Connect. // // There are no options at this time. type Option interface { unimplemented() } func Connect(addr string, opts ..Option) *Connection 3.12. Result objects 向后兼容的\n1 2 3 4 5 6 7 8 9 10 type UpsertResponse struct { Entries []*Entry } func (c *Client) Upsert(ctx context.Context, req *UpsertRequest) (*UpsertResponse, error) { // ... return \u0026amp;UpsertResponse{ Entries: entries, }, nil } 3.13. Errors 要么返回 err, 要么打印 log, 不要都有 不要使用 pkg/errors, 有性能问题 3.14. Goroutines 不要无限启 goroutine\n处理一个请求所启动的 goroutine 数量应该与请求的内容无关 使用 goroutine 池 注意 goroutine 泄露 应该能够 graceful stop goroutine goleak 3.15. Reflection 谨慎地使用反射.\n3.16. Naming Effective Go \u0026gt; Names What’s in a name? 不要使用 common, util.\n3.17. Documentation 有文档也是采用某个库的重要原因.\n使用文档而不是开发文档 使用段落和列表突出信息 提供例子 不要写没用的注释 3.18. Keep a changelog 面向用户的 changelog changelog 格式 ","permalink":"https://jdxj.github.io/posts/articles/abhinavg/designing-go-libraries/","summary":"原文 1. Primary Concerns 1.1. Usability 建立惯例使库的特性可发现 潜在的错误使用 易于完成常见任务 Case Study: net/http 看起来有些繁琐 1 2 3 4 5 6 7 8 9 10 // import \u0026#34;net/http\u0026#34; req, err := http.NewRequest(http.MethodGet, \u0026#34;http://example.com\u0026#34;, nil /* body */) if err != nil","title":"Designing Go Libraries"},{"content":"各列详解 Extra 展示额外信息\nNo tables used 没有 from 子句\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT 1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | No tables used | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ 1 row in set, 1 warning (0.00 sec) Impossible WHERE where 子句永远为 false\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE 1 != 1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+ | 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | Impossible WHERE | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+ 1 row in set, 1 warning (0.01 sec) No matching min/max row 当查询列表处有 min 或者 max 聚集函数，但是并没有符合 where 子句中的搜索条件的记录\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = \u0026#39;abcdefg\u0026#39;; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+ | 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | No matching min/max row | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+ 1 row in set, 1 warning (0.00 sec) Using index 使用索引覆盖\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT key1 FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | Using index | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) Using index condition 使用了索引条件下推 (Index Condition Pushdown)\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39; AND key1 LIKE \u0026#39;%b\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 266 | 100.00 | Using index condition | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.01 sec) 范围区间做下推\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 266 | 100.00 | Using index condition | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.02 sec) 等值不做下推\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.03 sec) Using where where 中的条件包含非索引列, 需要 server 层判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE common_field = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 10.00 | Using where | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1 row in set, 1 warning (0.01 sec) mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39; AND common_field = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 10.00 | Using where | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) Using join buffer (Block Nested Loop) 在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL 一般会为其分配一块名叫 join buffer 的内存块来加快查询速度，也就是我们所讲的 基于块的嵌套循环算法\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 10.00 | Using where; Using join buffer (Block Nested Loop) | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+ 2 rows in set, 1 warning (0.03 sec) Not exists 使用左（外）连接时，如果 WHERE 子句中包含要求被驱动表的某个列等于 NULL 值的搜索条件，而且那个列又是不允许存储 NULL 值的，那么在该表的执行计划的 Extra 列就会提示 Not exists 额外信息\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL; +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | ref | idx_key1 | idx_key1 | 303 | xiaohaizi.s1.key1 | 1 | 10.00 | Using where; Not exists | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+ 2 rows in set, 1 warning (0.00 sec) Using filesort 很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | Using filesort | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ 1 row in set, 1 warning (0.00 sec) Using temporary 在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含 DISTINCT、GROUP BY、UNION 等子句的查 询过程中\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT DISTINCT common_field FROM s1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | Using temporary | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+ 1 row in set, 1 warning (0.00 sec) ","permalink":"https://jdxj.github.io/posts/books/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84-%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3mysql/17-explain%E8%AF%A6%E8%A7%A3%E4%B8%8B/","summary":"各列详解 Extra 展示额外信息 No tables used 没有 from 子句 1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT 1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | 1 | SIMPLE | NULL | NULL | NULL | NULL |","title":"17 Explain详解(下)"},{"content":" A股上市公司数量接近4000只 有研究报告覆盖的公司数量也不超过2000家 第一种武器：跟着券商研报选股 基本方法: 三看两不看\n三看: 一看基本情况分析，二看推荐逻辑，三看财务预测。 两不看: 不看券商研究报告的目标价和评级。 选择研报的窍门\n选择深度报告. 页数多, 或者包含\u0026quot;深度报告\u0026quot;, \u0026ldquo;首次报告\u0026quot;字样 研究员对盈利预测或投资评级进行调整的报告, 往往意味着研究员观点的变化，可能存在“预期差”，也就是存在市场没有意识到的机会 如果有关某公司的报告很久都没有，突然有一篇报告发布，而且是深度报告，这样的报告我们要特别关注。 第二种武器：跟着财报选股 利用财务指标的组合选出潜力好公司\n净资产收益率，企业的赚钱能力 A股的净资产收益率均值现在在7%至8%之间，所以一家公司的净资产收益率能达到15%就不错了。\n表5-1 2009—2018年股价涨幅靠前公司的平均净资产收益率 经营性现金流，企业的盈利质量 一般来说，公司的经营性现金流净额和净利润的比大于1，表示盈利质量高，反之，则表示盈利质量较差。 也可以用经营性现金流入额和公司的销售收入的比值，来考察公司的盈利质量。在实际交易中，由于赊账情况的产生，实际产生的经营性现金流入额要小于销 售收入。两者的比值越接近1，就说明公司资金回笼的速度越快，反之则会造成大量资金的挤压。 表5-3 乐视2015—2017年部分财务数据 市盈率，估值的合理性 用“净资产收益率—经营性现金流—市盈率”3个指标筛选股票的例子\n过去3年净资产收益率连续高于20%，过去3年经营性现金流/净利润大于1，最新市盈率不超过25倍。 预收账款，这个指标是评估公司竞争力和行业最重要的动态指标。\n表5-4 贵州茅台预收账款 如何利用财报中的“管理层讨论”选出潜力好公司。\n财报中的“管理层讨论”主要包含公司管理层对公司过去一年经营情况的概述，以及管理层对未来的行业分析和战略规划。 图5-1 圣农发展2017年年报管理层讨论的部分内容 第三种武器：跟着聪明钱选股 股票市场上总有这样一些资金，它们能在资本市场上先知先觉，赚取很好的投资回报。这类资金被我们称为“聪明钱”。聪明钱一般来自专业机构，包括社保基金、 保险资金、外资，以及知名的公募基金、私募基金的资产等。\n聪明钱的特点\n（1）政策洞察力强。聪明钱团队往往和决策层保持紧密沟通，并对国家各种政策进行持续跟踪。简单来说，大机构对宏观政策面的把握比普通投资者更为深刻。 （2）团队实力强。聪明钱团队的研究、风险控制、投资等流程的分工有序，团队的专业知识和实践经验也是个人投资者所不能比的。所谓“好汉难敌四手”， 就是这个道理。 （3）偏好行业龙头，偏好大而美公司。由于资金庞大，聪明钱偏向选择规模大、流动性强、盈利能力强的大而美公司。如果市值很小，难以容纳大资金，这 样的股票就很难进入机构的核心股票池。 （4）长线投资。聪明钱的资金规模、资金性质决定了团队要做长线投资，大机构的持股周期一般都在2～3年以上，而我们个人投资者往往是追涨杀跌，能持 股几个月就不错了。 （5）逆向投资。聪明钱团队利用人性的贪婪、恐惧和欲望，往往会做出“在市场萧条时进场，在市场繁荣时出场”这种逆向操作的决定。而普通投资者往往会 因为贪婪或恐惧，采取追涨杀跌的方式，让操作处于被动局面。 哪些机构才是聪明钱呢？\n看机构的长期业绩 第四种武器：跟着“内部人”选股 公司内部人士最清楚公司的经营情况，所以内部人，特别是大股东、高管等的大规模增持、回购行为，通常会透露重要信息。\n投资者可以格外关注以下几点，仔细甄别增持、回购是信号还是噪声。\n第一，我们要分析增持的动机。 第二，我们需要关注增持、回购的金额或比例。 第三，我们要结合基本面进行分析。 在跟着“内部人”选股的过程中，我们要注意以下风险。\n第一，我们要注意雷声大、雨点小的增持、回购。A股市场中那些只有上限没有下限的增持回购计划，我们要警惕，因为这些计划基本都不靠谱。 第二，我们要注意假增持、假回购。 第三，我们要格外注意公司的基本面，如果公司的基本面已经恶化，不管内部人是何种意图去增持、回购公司股票，我们都应该绕道，避开风险个股。 第五种武器：跟着生活经验选股 留意日常 坚持能力圈原则 要学会区别信号和噪声 第六种武器：跟着新闻选股 看新闻，是每个投资者必备的一项技能。\n以下几类新闻值得投资者格外关注。\n第一，国家政策类新闻需要格外关注，因为政策对行业、市场可能有非常重要的影响。例: 供给侧改革 第二，国家领导人调研考察类新闻需要格外关注，因为这表明国家对某公司、行业的重视。例: 国家领导人首次调研考察徐工机械 第三，行业性新闻需要格外关注，因为行业格局的变化也会带动一大拨机会。例: 以药养医 每个人接收的投资信息却差异巨大，区别在哪里？\n一是区别信号和噪声的能力。 二是判断股价是否已经提前反应的能力。 三是从 A 推导出 B 的逻辑推理能力。 根据新闻选股，投资者需要长期的知识积累和高度的敏感性，这样才能洞察其中的机会。\n第七种武器：跟着专业投顾团队选股 股票投顾市场通常有两大派：一派是传统的投顾服务，另一派是机构研究服务。投顾和研究员之间的差别，就像全科医生和专科医生的差别。\n服务团队所在公司持有证监会颁发的证券投资咨询执照，服务人员拥有投顾职业编号，这是投顾提供服务的基本要求，投资者也可以据此排除一大批冒牌投顾。\n好的投顾\n专业的投顾服务是帮助客户做好资产配置并构建股票组合，而不是单纯推荐某只股票。 在构建股票组合的过程中，投顾要充分了解客户的风险承受能力，帮助客户构建适合自己、匹配自己的股票组合。 在资产配置和构建组合的过程中，投顾一定要坚持“长期投资”原则，而不是短线博弈。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9F%BA%E6%9C%AC%E9%9D%A2%E6%8A%95%E8%B5%84%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%80%89%E5%87%BA%E6%BD%9C%E5%8A%9B%E5%A5%BD%E8%82%A1%E7%A5%A8%E7%9A%847%E7%A7%8D%E6%AD%A6%E5%99%A8/","summary":"A股上市公司数量接近4000只 有研究报告覆盖的公司数量也不超过2000家 第一种武器：跟着券商研报选股 基本方法: 三看两不看 三看: 一看基本情况分","title":"第五章 选出潜力好股票的\"7种武器\""},{"content":"“知—择—行”，构建自己的投资体系 知\n清楚自己的能力圈, 包括专业背景, 知识结构 清楚自己的风险承受能力, 年龄, 收入, 投资占收入和其他资产的比重 形成对股票市场的正确认知, 2016年开始, 基本面的作用越来越大 择\n了解各种盈利体系的适用性 没有大涨大跌的平衡市 大幅震荡的波动行情 价值风格盛行的行情 了解各种盈利体系的风险度 评判所建立的盈利体系和你的能力圈及风险承受能力是否匹配 行\n知行合一. 在实际投资中，你遇到的最大挑战是，当你的投资方法论遭遇困难，特别是投资非常不顺的时候，你开始对自己的盈利体系产生怀疑和动摇。这时 候你该怎么办？这时我们要有良好的心态，并坚持自己的体系。 “与时俱进”要求我们经常回顾和评估自己的方法论是否满足市场的发展趋势，以及自己是否真正执行了既定策略。 股市新常态下，基本面投资体系的重要性 A股市场进入新常态的原因\n第一，中国经济进入新常态。首先，中国经济从高速增长阶段进入中速增长阶段，以前动辄8%甚至10%以上的高增长率一去不复返，取而代之的是6%甚至更低 的增长率。其次，结构优化、结构升级取代速度增长，成为中国经济的主旋律。 第二，上市公司发展进入新常态。随着中国经济进入中速增长，很多产业的增长空间变得有限，产业的竞争格局变得相对固化，行业内更多是“存量竞争”的状 态。与此同时，中国股市开始进入“良币驱逐劣币”的阶段。 第三，股市环境进入新常态。市场化、国际化、法制化正在深刻影响着中国股市的生态，推动中国股市越来越健康地发展。在这样的背景下，A股市场的投资 理念、投资风格一定会越来越向成熟市场靠拢。 投资的目的是盈利，追求长久、可持续的盈利。所以我们选择价值投资，用价值投资的可复制性来维持盈利的可持续性。而价值投资可复制的根本原因，是价 值投资逻辑简单，交易不拥挤。\n价值投资的核心逻辑是寻找“好赛道+好公司+好价格”的股票, 其需要考虑的变量相对较少，而且变量相对稳定、相对容易把控。 而其他很多投资方法论，影响决策的变量特别多，比如宏观经济、大宗商品价格、汇率和美国经济等多种“重要但难以预测”的因素。投资者考虑这些因素的难 度更大，成功更多靠运气，而不是靠体系和能力。 价值投资看上去很简单，但为什么追随巴菲特的投资者如此之多，做到的却寥寥无几呢？\n因为价值投资需要极强的忍耐力：对股价回撤的忍耐力，对股价长期不涨的忍耐力。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%8E%E6%97%B6%E4%BF%B1%E8%BF%9B%E5%8F%91%E5%B1%95%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/","summary":"“知—择—行”，构建自己的投资体系 知 清楚自己的能力圈, 包括专业背景, 知识结构 清楚自己的风险承受能力, 年龄, 收入, 投资占收入和其他资产的比重 形","title":"第四章 与时俱进发展自己的盈利体系"},{"content":"示例表 使用例子\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT 1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | No tables used | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ 1 row in set, 1 warning (0.01 sec) 各列作用\n列名 描述 id 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id select_type SELECT关键字对应的那个查询的类型 table 表名 partitions 匹配的分区信息 type 针对单表的访问方法 possible_keys 可能用到的索引 key 实际上使用的索引 key_len 实际使用到的索引长度 ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 rows 预估的需要读取的记录条数 filtered 某个表经过搜索条件过滤后剩余记录条数的百分比 Extra 一些额外的信息 例表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CREATE TABLE single_table ( id INT NOT NULL AUTO_INCREMENT, key1 VARCHAR(100), key2 INT, key3 VARCHAR(100), key_part1 VARCHAR(100), key_part2 VARCHAR(100), key_part3 VARCHAR(100), common_field VARCHAR(100), PRIMARY KEY (id), KEY idx_key1 (key1), UNIQUE KEY idx_key2 (key2), KEY idx_key3 (key3), KEY idx_key_part(key_part1, key_part2, key_part3) ) Engine=InnoDB CHARSET=utf8; 假设有两个和 single_table 表构造一模一样的 s1、s2 表，而且这两个表里边儿有10000条记录，除 id 列外其余的列都插入随机值。\n各列详解 table explain 中的每条记录对应某个单表访问方法, table 就表示所访问的表\n一条查询语句 1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) join 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | Using join buffer (Block Nested Loop) | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ 2 rows in set, 1 warning (0.01 sec) id sql 语句中每出现一个 select, 就会分配一个 id\n只有一个 select 语句 1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.03 sec) 对于连接查询来说, 一个 select 中有多个 table, 所以 explain 有多条记录, 但 id 相同 出现在前面的表是驱动表(s1) 出现在后面的表是被驱动表(s2) 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | Using join buffer (Block Nested Loop) | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ 2 rows in set, 1 warning (0.01 sec) 包含子查询的语句涉及多个 select, 所以每个 id 是不同的 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | SUBQUERY | s2 | NULL | index | idx_key1 | idx_key1 | 303 | NULL | 9954 | 100.00 | Using index | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ 2 rows in set, 1 warning (0.02 sec) 子查询可能会被 mysql 转换为连接查询, 导致 id 相同 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = \u0026#39;a\u0026#39;); +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+ | 1 | SIMPLE | s2 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9954 | 10.00 | Using where; Start temporary | | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | xiaohaizi.s2.key3 | 1 | 100.00 | End temporary | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+ 2 rows in set, 1 warning (0.00 sec) union 查询合并两个表的结果并去重 id 为 null 表示创建了用于合并的临时表 table 为 \u0026lt;union1,2\u0026gt; 表示临时表的名称 1 2 3 4 5 6 7 8 9 mysql\u0026gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2; +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 2 | UNION | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | NULL | | NULL | UNION RESULT | \u0026lt;union1,2\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ 3 rows in set, 1 warning (0.00 sec) union all 查询合并两个表, 但不去重 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 2 | UNION | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ 2 rows in set, 1 warning (0.01 sec) select_type 有多种值\n名称 描述 SIMPLE Simple SELECT (not using UNION or subqueries) PRIMARY Outermost SELECT UNION Second or later SELECT statement in a UNION UNION RESULT Result of a UNION SUBQUERY First SELECT in subquery DEPENDENT SUBQUERY First SELECT in subquery, dependent on outer query DEPENDENT UNION Second or later SELECT statement in a UNION, dependent on outer query DERIVED Derived table MATERIALIZED Materialized subquery UNCACHEABLE SUBQUERY A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query UNCACHEABLE UNION The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY) SIMPLE 查询语句中不包含 union 或子查询\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) PRIMARY 包含 union, union all, 子查询的语句, 最左边的小查询的 select_type 是 primary\n1 2 3 4 5 6 7 8 9 mysql\u0026gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2; +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 2 | UNION | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | NULL | | NULL | UNION RESULT | \u0026lt;union1,2\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ 3 rows in set, 1 warning (0.00 sec) UNION 包含 union 或 union all 的查询语句, 除了最左边的是 primary, 其余是 union\n1 2 3 4 5 6 7 8 9 mysql\u0026gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2; +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 2 | UNION | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | NULL | | NULL | UNION RESULT | \u0026lt;union1,2\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ 3 rows in set, 1 warning (0.00 sec) SUBQUERY 如果包含子查询的查询语句不能够转为对应的 semi-join 的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案 来执行该子查询时，该子查询的第一个 select 关键字代表的那个查询的 select_type 就是 subquery\n由于 select_type 为 subquery 的子查询会被物化，所以只需要执行一遍 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | SUBQUERY | s2 | NULL | index | idx_key1 | idx_key1 | 303 | NULL | 9954 | 100.00 | Using index | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ 2 rows in set, 1 warning (0.00 sec) DEPENDENT SUBQUERY 如果包含子查询的查询语句不能够转为对应的 semi-join 的形式，并且该子查询是相关子查询，则该子查询的第一个 select 关键字代表的那个 查询的 select_type 就是 dependent subquery\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = \u0026#39;a\u0026#39;; +----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | DEPENDENT SUBQUERY | s2 | NULL | ref | idx_key2,idx_key1 | idx_key2 | 5 | xiaohaizi.s1.key2 | 1 | 10.00 | Using where | +----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+ 2 rows in set, 2 warnings (0.00 sec) DEPENDENT UNION 在包含 union 或者 union all 的大查询中，如果各个小查询都依赖于外层查询的话，除了最左边的那个小查询之外，其余的小查询的 select_type 的值 就是 dependent union\n1 2 3 4 5 6 7 8 9 10 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = \u0026#39;a\u0026#39; UNION SELECT key1 FROM s1 WHERE key1 = \u0026#39;b\u0026#39;); +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | DEPENDENT SUBQUERY | s2 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 12 | 100.00 | Using where; Using index | | 3 | DEPENDENT UNION | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | Using where; Using index | | NULL | UNION RESULT | \u0026lt;union2,3\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+ 4 rows in set, 1 warning (0.03 sec) 这个例子给的不太清晰\nDERIVED 对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的 select_type 就是 derived\n派生表 物化 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c \u0026gt; 1; +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | 1 | PRIMARY | \u0026lt;derived2\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 33.33 | Using where | | 2 | DERIVED | s1 | NULL | index | idx_key1 | idx_key1 | 303 | NULL | 9688 | 100.00 | Using index | +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ 2 rows in set, 1 warning (0.00 sec) MATERIALIZED 当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 select_type 属性就是 materialized\nid 为2的记录是单表查询, 并被物化 id 为1的两条记录是连接查询 table 为 的记录表示其是 id 为2的记录对应的查询结果 1 2 3 4 5 6 7 8 9 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2); +----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ALL | idx_key1 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 1 | SIMPLE | \u0026lt;subquery2\u0026gt; | NULL | eq_ref | \u0026lt;auto_key\u0026gt; | \u0026lt;auto_key\u0026gt; | 303 | xiaohaizi.s1.key1 | 1 | 100.00 | NULL | | 2 | MATERIALIZED | s2 | NULL | index | idx_key1 | idx_key1 | 303 | NULL | 9954 | 100.00 | Using index | +----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+ 3 rows in set, 1 warning (0.01 sec) UNCACHEABLE SUBQUERY 不常用\nUNCACHEABLE UNION 不常用\npartitions 没讲\ntype 单表访问方法\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.04 sec) system 表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如 MyISAM、Memory，那么对该表的访问方法就是 system\n1 2 3 4 5 6 7 8 9 10 11 12 13 mysql\u0026gt; CREATE TABLE t(i int) Engine=MyISAM; Query OK, 0 rows affected (0.05 sec) mysql\u0026gt; INSERT INTO t VALUES(1); Query OK, 1 row affected (0.01 sec) mysql\u0026gt; EXPLAIN SELECT * FROM t; +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+ | 1 | SIMPLE | t | NULL | system | NULL | NULL | NULL | NULL | 1 | 100.00 | NULL | +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) const 根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是 const\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE id = 5; +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | NULL | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.01 sec) eq_ref 在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须 进行等值比较），则对该被驱动表的访问方法就是 eq_ref\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id; +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | PRIMARY | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | eq_ref | PRIMARY | PRIMARY | 4 | xiaohaizi.s1.id | 1 | 100.00 | NULL | +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ 2 rows in set, 1 warning (0.01 sec) ref 当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是 ref\nfulltext 没讲\nref_or_null 对普通二级索引进行等值匹配查询，该索引列的值也可以是 NULL 值时，那么对该表的访问方法就可能是 ref_or_null\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39; OR key1 IS NULL; +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | ref_or_null | idx_key1 | idx_key1 | 303 | const | 9 | 100.00 | Using index condition | +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+ 1 row in set, 1 warning (0.01 sec) index_merge 1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39; OR key3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+ | 1 | SIMPLE | s1 | NULL | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL | 14 | 100.00 | Using union(idx_key1,idx_key3); Using where | +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+ 1 row in set, 1 warning (0.01 sec) unique_subquery 针对在一些包含 IN 子查询的查询语句中，如果查询优化器决定将 IN 子查询转换为 EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该 子查询执行计划的 type 列的值就是 unique_subquery\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = \u0026#39;a\u0026#39;; +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | DEPENDENT SUBQUERY | s2 | NULL | unique_subquery | PRIMARY,idx_key1 | PRIMARY | 4 | func | 1 | 10.00 | Using where | +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+ 2 rows in set, 2 warnings (0.00 sec) index_subquery index_subquery 与unique_subquery 类似，只不过访问子查询中的表时使用的是普通的索引\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 = s2.key1) OR key3 = \u0026#39;a\u0026#39;; +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | DEPENDENT SUBQUERY | s2 | NULL | index_subquery | idx_key1,idx_key3 | idx_key3 | 303 | func | 1 | 10.00 | Using where | +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+ 2 rows in set, 2 warnings (0.01 sec) 例子不清楚\nrange 使用索引获取某些范围区间的记录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;); +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 27 | 100.00 | Using index condition | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.01 sec) mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;a\u0026#39; AND key1 \u0026lt; \u0026#39;b\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 294 | 100.00 | Using index condition | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.00 sec) index 当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ | 1 | SIMPLE | s1 | NULL | index | NULL | idx_key_part | 909 | NULL | 9688 | 10.00 | Using where; Using index | +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ 1 row in set, 1 warning (0.00 sec) ALL 全表扫描\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) possible_keys 和 key possible_keys 列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，key 列表示实际用到的索引有哪些\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39; AND key3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1,idx_key3 | idx_key3 | 303 | const | 6 | 2.75 | Using where | +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+ 1 row in set, 1 warning (0.01 sec) 使用 index 访问方法来查询某个表时，possible_keys 列是空的，而 key 列展示的是实际使用到的索引\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ | 1 | SIMPLE | s1 | NULL | index | NULL | idx_key_part | 909 | NULL | 9688 | 10.00 | Using where; Using index | +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ 1 row in set, 1 warning (0.00 sec) possible_keys 列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的 索引。\nkey_len 索引记录的长度, 由三部分组成\n对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是 VARCHAR(100)，使用的字符集是utf8，那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。 如果该索引列可以存储 NULL 值，则 key_len 比不可以存储 NULL 值时多1个字节。 对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。 由于 id 列的类型是 INT，并且不可以存储 NULL 值，所以在使用该列的索引时 key_len 大小就是4。\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE id = 5; +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | NULL | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.01 sec) 当索引列可以存储 NULL 值时\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key2 = 5; +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | const | idx_key2 | idx_key2 | 5 | const | 1 | 100.00 | NULL | +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) 对于可变长度的索引列来说\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) 在执行计划中输出 key_len 列主要是为了让我们区分某个使用联合索引的查询具体用了几个索引列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key_part | idx_key_part | 303 | const | 12 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = \u0026#39;a\u0026#39; AND key_part2 = \u0026#39;b\u0026#39;; +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key_part | idx_key_part | 606 | const,const | 1 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+ 1 row in set, 1 warning (0.01 sec) ref 当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是 const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery 其中之 一时，ref 列展示的就是与索引列作等值匹配的数据是什么, 常见的有常数或者某个列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.01 sec) mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id; +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | PRIMARY | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | eq_ref | PRIMARY | PRIMARY | 4 | xiaohaizi.s1.id | 1 | 100.00 | NULL | +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ 2 rows in set, 1 warning (0.00 sec) 与索引列进行等值匹配的值是个函数\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1); +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | ref | idx_key1 | idx_key1 | 303 | func | 1 | 100.00 | Using index condition | +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+ 2 rows in set, 1 warning (0.00 sec) rows 如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的 rows 列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的 rows 列就代表预计扫描的索引记录行数。\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 266 | 100.00 | Using index condition | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.00 sec) filtered MySQL 在计算驱动表扇出时采用的一个策略：\n如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。 该查询使用 idx_key1 索引来执行查询，从 rows 列可以看出满足 key1 \u0026gt; \u0026lsquo;z\u0026rsquo; 的记录有266条。执行计划的 filtered 列就代表查询优化器预测在这 266条记录中，有多少条记录满足其余的搜索条件，也就是 common_field = \u0026lsquo;a\u0026rsquo; 这个条件的百分比。此处 filtered 列的值是10.00，说明查询优 化器预测在266条记录中有10.00%的记录满足 common_field = \u0026lsquo;a\u0026rsquo; 这个条件。\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39; AND common_field = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 266 | 10.00 | Using index condition; Using where | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+ 1 row in set, 1 warning (0.00 sec) 对于单表查询来说，这个 filtered 列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的 filtered 值\n从执行计划中可以看出来，查询优化器打算把 s1 当作驱动表，s2 当作被驱动表。 我们可以看到驱动表 s1 表的执行计划的 rows 列为9688，filtered 列为10.00，这意味着驱动表 s1 的扇出值就是9688 × 10.00% = 968.8，这说 明还要对被驱动表执行大约968次查询。 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ALL | idx_key1 | NULL | NULL | NULL | 9688 | 10.00 | Using where | | 1 | SIMPLE | s2 | NULL | ref | idx_key1 | idx_key1 | 303 | xiaohaizi.s1.key1 | 1 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+ 2 rows in set, 1 warning (0.00 sec) ","permalink":"https://jdxj.github.io/posts/books/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84-%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3mysql/16-explain%E8%AF%A6%E8%A7%A3%E4%B8%8A/","summary":"示例表 使用例子 1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT 1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | No tables","title":"16 Explain详解(上)"},{"content":"技术分析 所有的技术分析都是建立在三大假设之上的。\n第一，市场行为包含一切。这句话的含义是所有的基础事件——经济事件、社会事件、战争、自然灾害等作用于市场都会反映到价格和交易量的变化中，特别是 与一家公司收入、利润和未来业绩有关的所有信息都已自动反映在公司股票的价格和交易量上。 第二，价格以趋势方式演变：价格会沿着原有的趋势继续运行，也就是说，价格正在上涨的股票会继续上涨，价格正在下跌的股票会继续下跌，而横盘整理的 股票会继续盘整，直到趋势改变。 第三，历史会重演：人们可以借助市场的历史信息和历史规律，对今后市场的变化进行推断预测。 技术分析的三大假设并没有被主流学术界所接受 在实践当中，单纯的技术分析在预测股价的实用性方面是存疑的 量化投资在中国兴起的时候，一群从海外回来的基金经理，用电脑技术打败国内投资者，赚钱很轻松。但随着越来越多的高智商、精通电脑技术的人加入量化投 资的行列，这几年量化投资赚钱也越来越难。\n未来技术分析的发展方向，可能向“行为金融学”寻求理论支持，并和基本面分析做结合 股票该持有还是该卖出，只和股价的未来走势有关，而股价的未来走势和投资者成本没有任何关系，所以理性的投资者不应该根据自己的持仓成本和盈亏来做买 卖决策。但行为金融学告诉我们，人是不理性的，人一定会根据自己的持仓成本和盈亏来做买卖决策。这时候，密集成交区的股价就构成了技术分析中的压力线 和支撑线。\n技术分析发现交易信号，基本面分析剔除高危垃圾股\n基本面投资 基本面投资的流派\n价值投资 成长股投资 价值投资就是买入被低估的股票，等待价值回归 买入价格低于价值的股票，等待价值回归\n核心问题\n什么是低估 被低估的股票会不会回归价值 低估的多种含义\n相对低估是它的估值相对同类公司便宜 绝对低估又可以分为两种情形 一种是低于净资产或者重置成本 另一种是低于内在价值 推荐大家读一读《投资最重要的事》\n成长股投资就是寻找能持续高成长的公司，享受业绩和估值双重提升带来的获利机会 市盈率=股价 / 每股盈利 股价=每股盈利×市盈率 成长股投资的核心理念是，从静态估值看，股价已经不便宜，但如果其业绩有持续高增长的潜力，静态估值贵一点儿，也值得投资。\n成长股投资最大的风险是，当高成长性逆转后，股价可能会跌得非常厉害。\n股价=每股盈利×市盈率，每股盈利和市盈率都上涨，股价自然会快速上涨。但是，成长股的成长性一旦逆转，就会遭遇“戴维斯双杀”。每股盈利下跌，估值也下 跌，这时候股价就会跌得很厉害。\n价值投资和成长股投资进行比较得知，价值投资更看重现在，成长股投资更看重未来。所\n“买卖逻辑自洽”，就是你买和卖的理由要逻辑一致。\n那么对价值投资来说，买入的理由是什么？低估。对成长股投资来说，买入的理由是什么？高成长。 那什么时候卖出股票呢？对价值投资来说，是不再低估。对成长股投资来说是不再高成长。 价值投资最大的问题是，很多股票被低估是有合理原因的。\n行业可能在下坡路了 投资者只有将公司的成长性、竞争力和公司的合理估值相结合，才是价值投资。\n在用估值指标的时候，投资者需要注意3点。\n第一，估值必须和未来可持续的复合增长率匹配，也就是说，投资者要找到估值和成长性合理匹配的公司。 第二，投资者计算估值时要剔除非经常性损益的影响。很多公司的盈利里有一些非经常性损益，比如一次性出售房地产的收益，这类收益要剔除掉，特别是在 用市盈率估值的时候。 第三，投资者要注意财务造假的可能性。如果盈利都是假的，那估值就完全没有意义了。 表3-1 价值投资和成长股投资的区别 基本面投资为什么能够战胜市场，为什么能够取得超额收益。\n第一，基本面投资讲究安全边际。什么叫安全边际？通俗一点儿说，你买的股票的价格便宜、合理，就有安全边际。 第二，基本面投资讲究投资逻辑，买卖逻辑要自洽。逻辑自洽是买一只股票和卖这只股票的逻辑要一致。 第三，基本面投资能够让投资者避免追涨杀跌，避免过度交易。 第四，在中国做基本面投资的人不多，所以更有机会成功。 基本面博弈 为什么叫“基本面博弈”？因为如果将它归类于技术分析，它关注的东西、用的语言都和基本面相关，比如它会关心经济形势、政府政策、公司盈利等基本面因素； 如果将它归类于基本面投资，它的持股周期并不长，往往只有几个月，很少超过1年，和基本面投资的“买入持有”策略有很大差异。“基本面博弈”这一称呼，表 明它用的是基本面的语言，但本质上是一种博弈。\n在基本面博弈中，最常见的是主题投资策略和轮动策略。\n主题投资策略 主题有点儿类似大家常说的“题材”，主题投资是通过挖掘对股票市场有较大影响的因素，对潜在受益的行业和公司进行投资的一种策略。但和纯粹的题材炒作或 者概念炒作不一样，主题投资依赖于对基本面的判断，寻找有较大概率能兑现业绩高增长的投资机会，延续的时间周期可能较长，而题材炒作或者概念炒作则完 全是资金推动的短期炒作，基本上是“昙花一现”。\n主题投资的特点在于它并不按照一般的行业划分来区分股票，而是将驱动经济发展的某个因素作为“主题”，以此来选择地域、行业、板块或个股。\n表3-2 2011-2016年主题投资类型 一般来说，主题投资更适合早期的产业。正因为早期，所以想象空间大、无法在短时间内证伪，投资者对收入和利润的要求相对没那么高，或者产业内竞争不那 么激烈，率先进入这个产业的公司能取得不错的利润。随着产业演进，产业内公司充分竞争，公司盈利能力经常会出现一个阶段性低点，兼并重组开始出现，部 分经营不善的公司甚至退出产业，集中度开始提升，龙头公司盈利能力也逐步回升，出现所谓的成长股投资阶段。\n图3-1 产业演进曲线 表3-3 主题投资和成长股投资的区别 在A股市场投资，主流机构一般会选择哪些主题进行重点投资？什么样的主题是优质的主题？\n第一，主题选择要高大上，具备想象空间。选择的主题想象空间越大，越能引起市场的参与热情。比如2015年的互联网+主题，想象空间就足够大。反过来共 享单车这样的主题，想象空间就小很多。 第二，主题容量要足够大。主题相关的标的股票要能容纳足够多的资金，如果太小，就不能吸引主流机构资金大规模参与。 第三，主题要能被普通投资者理解并关注和传播。一个能被普通投资者理解和传播的主题，较容易形成市场热点并扩散，太专业的主题只能由少数专业机构参 与，很难形成大行情。 第四，主题持续的时间要足够长，特别是较长时间内难以被证伪。 轮动策略 根据宏观经济景气周期、行业盈利周期、股票市场变动趋势等因素，轮流选择不同板块、不同行业、不同风格股票进行投资的策略。\n“美林时钟”理论按照经济增长与通胀的不同搭配，将经济周期划分为4个阶段。\n（1）“经济上行，通胀下行”构成复苏阶段，此阶段由于股票对经济的弹性更大，其相对债券和现金具备明显的超额收益。 （2）“经济上行，通胀上行”构成过热阶段，此阶段由于通胀上升，增加了持有现金的机会成本，可能出台的加息政策降低了债券的吸引力，股票的配置价值 相对较强。 （3）“经济下行，通胀上行”构成滞胀阶段，此阶段现金收益率提高，持有现金最明智，经济下行对企业盈利的冲击将对股票构成负面影响，债券相对股票的 收益率提高。 （4）“经济下行，通胀下行”构成衰退阶段，此阶段通胀压力下降，货币政策趋松，债券表现最突出，随着经济即将见底的预期逐步形成，股票的吸引力逐步 增强。 图3-2 “美林时钟”的经济周期和投资策略 在股票市场中，轮动策略可以进一步分为以下方法。\n板块轮动：根据大的经济周期，在成长、消费、周期、金融地产等大板块之间进行择时投资。 行业轮动：根据不同行业的不同景气周期，在行业之间进行择时投资。 风格轮动：根据股票市场的变化趋势，在不同风格之间进行择时投资，比如大小盘风格轮动、成长价值风格轮动等。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/","summary":"技术分析 所有的技术分析都是建立在三大假设之上的。 第一，市场行为包含一切。这句话的含义是所有的基础事件——经济事件、社会事件、战争、自然灾害等","title":"第三章 股票投资常见的盈利体系"},{"content":"盈利体系的基石：正确认知 对股票的认知: 投资股票靠什么赚钱 对风险的认知: 如何应对投资亏损 对股票的认知 一种认知是：股票就是博弈的筹码。 零和游戏 另一种认知是：股票是投资上市公司的载体。 你赚的钱是上市公司的成长带给你的利润增长 股票是一个财富转移的工具。 对风险的认知 现代金融学理论用股价的波动率来衡量风险，股价的波动程度代表着风险的高低。股价波动性越大，意味着股票的风险越大。 巴菲特认为投资的风险并不来源于波动，波动反而是机会，因为股价波动的幅度越大，好公司越会出现被低估的机会。 巴菲特认为本金的永久性损失才是真正的风险。什么是本金的永久性损失？是你所买入股票的公司基本面恶化，股价永远回不到你买入的价格，这才是真正的风 险。所以，真正的风险并非股价的波动，而是来自公司的“内在价值风险”。所以，选择安全边际高的股票，才是避免风险的最好投资方法。\n盈利体系的基本内容：“选股—验证—决策—跟踪”四大环节 第一步：选股，就是发现潜在的好股票 最常见的就是从财务指标中进行初选。\n净资产收益率 (ROE) A股市场3000多家上市公司，平均净资产收益率在7%至8%之间。 我们设定一个简单指标，选出净资产收益率连续3年大于20%的股票，就能剔除掉90%的股票，只剩下大约300只，这就能大大降低我们选择的难度。 从新闻中发现好股票的线索，从生活中发现好股票的线索，从券商研报中发现好股票的线索。 第二步：验证，当你初选出好股票之后，需要验证它是不是真的好股票 首先，我们要看这个行业的空间大不大，行业空间决定公司的发展空间。\n技术发展趋势 智能手机 -\u0026gt; 改变手机产业 -\u0026gt; 移动社交/支付/手机游戏 人工智能, 大数据, 物联网 供求关系. 是变化的, 需要不断跟踪 政策扶持 其次，我们要验证公司的核心竞争力。\n足够深的护城河. 企业相当长一段时间内无法被模仿和替代的竞争优势，如品牌、专利、垄断性牌照、规模优势等 优秀的管理团队. 需要考察管理层的眼光、能力和管理思路，还要考察管理层是否有把企业做大做强的决心 再次，我们要重视财务分析，因为财务分析是验证公司是否有竞争力的重要手段。\n最后，我们还要看估值。\n投资者做基本面投资就必须要研究估值，不管是价值股投资还是成长股投资，都必须研究估值，因为好股票=好公司+合理估值。 我们只有了解了公司的合理估值，才能通过与现有股价进行对比，判断目前股价是被高估、合理还是被低估。 如果股价被高估，即使基本面再好，也不是买入的机会。 第三步：决策，就是做出是否买、如何买的判断 在买入之前，你要想清楚以下问题。\n第一，我准备在什么价格区间买入？或者我在哪些条件具备的情况下买入这只股票？ 第二，我准备用多少资金买入这只股票？这只股票占我整个组合的比例是多少？ 第三，我准备持有这只股票多长时间？到什么价格或发生什么情况，我会准备卖出这只股票？ 第四，买入之后可能会出现什么样的意外？如果出现了意外，我应该怎样应对？ 第四步：跟踪，持续关注和研究公司的基本面变化 如何止盈和止损\n重点\n股票的价格与其曾经的价格无关, 只和估值有关 忘掉成本, 唯一决定这只股票涨跌的是它的基本面未来会怎么样，跟你被套牢还是盈利没有任何关系 要学会利用各种资源，尤其是券商分析师的报告 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%9E%84%E5%BB%BA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/","summary":"盈利体系的基石：正确认知 对股票的认知: 投资股票靠什么赚钱 对风险的认知: 如何应对投资亏损 对股票的认知 一种认知是：股票就是博弈的筹码。 零和游戏 另","title":"第二章 我们需要构建什么样的盈利体系"},{"content":"股票投资看似简单却很复杂 股票投资难，在于股票投资是一个概率游戏，正确决策（过程）未必带来好的结果，错误决策（过程）有时候会让你赚钱。也就是说，决策（过程）正误和投资 结果好坏没有必然联系，这就会导致以下3种情况。\n一是赚了钱，却很难归因或者错误归因 比如“十送十”买入股票，股价上涨后投资者很开心，觉得自己决策正确。但股价真正上涨的原因可能是业绩超预期，或者政策变化，但投资者却把上涨原因归结 为“十送十”。下次投资，投资者就会去找“十送十”的股票，而不是业绩超预期的股票。\n二是赚了钱，却不可重复，运气成分大于能力成分 投资是一个概率游戏\n三是因为运气，错误决策（过程）产生了好结果，强化了错误决策 长期按照这个思路操作下去，投资者一定会亏损累累，因为很可能有这样的结果：多次“成功操作”赚来的钱被一次连本带利地亏完。\n投资最重要的事：建立可重复、大概率能赚钱的盈利体系 大数定律\n表1-1 单次博弈和重复博弈 DFH盈利体系的内容，概括起来有以下几点。\n选股：幸运的行业+能干的公司 投资者要看公司所处的行业特征如何，是否有较大的发展空间； 公司的商业模式如何，是否具有可持续的发展能力，是否经得起未来的考验； 管理层是否足够优秀，是否拥有与自己行业特征相匹配的能力。 投资者要尽量不买上市不到两年的新股，不追逐主题、热点，不买市盈率特别高的股票。 策略：长期投资，陪伴好公司成长 投资者坚持“自下而上”地选择优秀公司，深入研究公司的基本面，关注公司的本身，关注公司的核心竞争力的提升和行业地位的稳固； 坚信有核心竞争力的优质上市公司的回报率会远高于社会平均回报率； 避免高换手率，不频繁交易，坚持长期投资，陪伴好公司成长，赚取上市公司长期盈利增长的钱，赚取上市公司分红的钱。 风控：专注于择股，大部分时间不择时 时间是优质公司的朋友 眼于长期的投资机会而不过多考虑股价的短期波动 敢于逆向思维、逆向投资 时间是好体系的朋友，是差体系的敌人 任何投资，脱离时间维度，都是没有意义的:\n对于价值投资来说，至少要有2～3年的持股周期。 对于技术分析来说，时间长则要数月，短则要数天。 而对于量化高频交易来说，考虑的时间可能是几秒，甚至是零点几秒。 从长期来看，股价是由价值决定的，股价永远围绕着公司价值波动。什么是公司价值？它是公司基本面决定的合理估值。但在短期内，股价往往会和公司价值发 生偏离，甚至是很大的偏离。对优秀公司来说，随着时间的推移，它的盈利会不断增长，价值会不断提升。\n投资者亏钱的最大问题：没有盈利体系或者拥有错误的盈利体系 正确的盈利体系应该符合3个标准\n适合自己的能力圈. 个人投资者在构建自己的盈利体系的过程中，要综合考虑自己的职业、财务状况、风险承受能力，以及自己的性格特点。 逻辑自洽 买股票的逻辑和卖股票的逻辑要一致。 我经常会碰到一些个人投资者跟我说他买了哪只股票，我问他为什么买这只股票，他说看好这个行业，公司业绩也很好，讲了一堆理由，都是基本面的逻辑。 过了3天，他又跟我说他把那只股票卖了，因为股价跌穿5日线、“死叉”出来了，这又是技术分析的逻辑。这样的买卖逻辑自洽吗？买卖逻辑不自洽的人， 99%的概率是做不好投资的，能做好投资的一定是买卖逻辑自洽的人。 符合市场规律和趋势 可持续、可复制. 一个正确的盈利体系，一定是在相当长一段时间内可持续、可复制的。有些策略或者方法，虽然也能赚钱，但不能持续。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E8%A6%81/","summary":"股票投资看似简单却很复杂 股票投资难，在于股票投资是一个概率游戏，正确决策（过程）未必带来好的结果，错误决策（过程）有时候会让你赚钱。也就是说","title":"第一章 盈利体系为什么重要"},{"content":"15.1 Introduction to InnoDB 15.1.2 Best Practices for InnoDB Tables 使用索引 关闭自动提交 (写速度限制) 15.1.3 Verifying that InnoDB is the Default Storage Engine DEFAULT 字样\n1 2 SHOW ENGINES; SELECT * FROM INFORMATION_SCHEMA.ENGINES; 15.2 InnoDB and the ACID Model A: atomicity. C: consistency. I: isolation. D: durability. 15.3 InnoDB Multi-Versioning InnoDB 在每行记录上添加三个字段\nDB_TRX_ID: 最新进行操作(insert, update, delete)的事务 id DB_ROLL_PTR: 指向 undo log 的指针 DB_ROW_ID: row id, InnoDB 自动生成的聚集索引才有 insert undo log 在事务提交后删除, update undo log 在没有依赖后删除.\n15.7 InnoDB Locking and Transaction Model 15.7.1 InnoDB Locking Shared and Exclusive Locks 就是读写锁\nIntention Locks 表级锁, 表明一个事务稍后要对该表某行请求的锁\nintention shared lock (IS) intention exclusive lock (IX) SELECT ... FOR SHARE sets an IS lock, and SELECT ... FOR UPDATE sets an IX lock.\nRecord Locks SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE, 阻止其他事务 insert, update, delete t.c1 = 10 的行\nGap Locks 锁定索引记录间的间隙, 或者第一条记录之前的间隙, 或者最后一条记录后的间隙\nSELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE, t.c1 = 15 不能被插入\nNext-Key Locks record lock 和索引记录之前的 gap lock 组合\nInsert Intention Locks AUTO-INC Locks AUTO_INCREMENT 列\nPredicate Locks for Spatial Indexes 15.7.5 Deadlocks in InnoDB 隔离级别不影响死锁的可能性, 因为隔离级别负责读操作, 然而死锁发生在写操作\n","permalink":"https://jdxj.github.io/posts/docs/mysql/chapter15-the-innodb-storage-engine/","summary":"15.1 Introduction to InnoDB 15.1.2 Best Practices for InnoDB Tables 使用索引 关闭自动提交 (写速度限制) 15.1.3 Verifying that InnoDB is the Default Storage Engine DEFAULT 字样 1 2 SHOW ENGINES; SELECT * FROM INFORMATION_SCHEMA.ENGINES; 15.2 InnoDB and the ACID Model A: atomicity. C: consistency. I: isolation. D: durability. 15.3 InnoDB Multi-Versioning InnoDB 在每行记录","title":"Chapter15 The InnoDB Storage Engine"},{"content":" 官方文档 curl获取请求时间统计 ","permalink":"https://jdxj.github.io/posts/cmd/curl/","summary":"官方文档 curl获取请求时间统计","title":"curl"}]
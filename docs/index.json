[{"content":"变速器档位数的多少对汽车性能有什么影响？ 对于汽车来说，变速器的档位数较多，那么汽车加速时更顺畅、省力，加速时的顿挫感也较小，舒适性会更好，同时也更省油。如果有级变速器相当于上楼梯台阶，那 么无级变速器就相当于乘坐滚梯了，可以没有台阶地一路斜上，没有顿挫感，非常顺畅，而且更省劲，也更省油了。\n福特双离合变速器\n手动变速器构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.11/","summary":"变速器档位数的多少对汽车性能有什么影响？ 对于汽车来说，变速器的档位数较多，那么汽车加速时更顺畅、省力，加速时的顿挫感也较小，舒适性会更好，同","title":"4.11 变速器档位数"},{"content":"自动离合变速器是怎样变速的？ 自动离合变速器是在手动变速器的基础上加装一套自动换档装置，它可以替代驾驶人进行离合器分离及更换档位的动作。它的基本变速结构和手动变速器是一样的，但 它可以利用电子控制单元收集驾驶人的操作信息和车辆运行信息，指挥电子液压机构来操纵离合器和换档拨叉，从而实现自动换档。\n这类在手动变速器的基础上改进而来的变速器简称为AMT（Automated Manual Transmission），也称半自动变速器等。\n雪铁龙电控自动离合变速器构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.10/","summary":"自动离合变速器是怎样变速的？ 自动离合变速器是在手动变速器的基础上加装一套自动换档装置，它可以替代驾驶人进行离合器分离及更换档位的动作。它的基","title":"4.10 自动离合变速器（AMT）"},{"content":"序列式变速器是怎样变速的？ 序列式变速器简称为SMG（Sequential Manual Gearbox），全称为序列式手动变速器。\n序列式变速器（SMG）构造图\n序列式变速器（SMG）构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.09/","summary":"序列式变速器是怎样变速的？ 序列式变速器简称为SMG（Sequential Manual Gearbox），全称为序列式手动变速器。 序列式变速器（SMG）构","title":"4.9 序列式变速器（SMG）"},{"content":"双离合变速器是怎样变速的？ 双离合变速器（Double Clutch Transmission，简称DCT）是从手动变速器进化而来的，它的变速结构和原理与手动变速器一样，只不过比手动变速器多了一个 离合器，因此称为双离合变速器。或者说，双离合变速器相当于把两个手动变速器整合在一起，交替传递动力。\n雷诺汽车双离合变速器原理示意图\n大众汽车6速双离合变速器\n双离合变速器\n奥迪汽车7速双离合变速器原理示意图\n大众汽车6速双离合变速器原理示意图\n双离合变速器\n奥迪汽车7速双离合变速器构造图（正在3档工作状态）\n奥迪7速双离合变速器\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.08/","summary":"双离合变速器是怎样变速的？ 双离合变速器（Double Clutch Transmission，简称DCT）是从手动变速器进化而来的，它的变速结构和原理与手","title":"4.8 双离合变速器（DCT）"},{"content":"HTTP/2服务端推送（以下称为HTTP/2推送）允许服务器发回客户端未请求的额外资源。\nHTTP/2多路复用技术允许在同一连接上并行请求所有资源，因为这样排队会减少，所以它优于HTTP/1。 如果没有HTTP/2推送，浏览器必须在下载初始页面之后才能请求这些关键的资源。 图5.1　关键资源需要一个额外的请求往返(http/1)\n图5.2　关键资源的往返延迟瀑布图(http/1)\n这个往返延迟催生了一些性能优化手段，如将样式通过\u0026lt;style\u0026gt;标签内联到HTML页面中，或类似的，通过\u0026lt;script\u0026gt;标签将JavasScript内联到HTML中。通过 内联这些关键资源，浏览器可以在原始页面下载解析之后马上开始渲染，而不需要等待附加的关键资源。\n内联资源有几个缺点\n需要将关键CSS提取出来防止页面过大, 但是该操作比较复杂, 也有可能造成重复代码 要求使用JavaScript来加载非关键CSS文件 变更困难(重复的地方都要改) 图5.3　使用HTTP/2推送可以避免关键资源的往返延迟\n服务器岂不是解析html才能发送被关联资源?\n图5.4　使用HTTP/2推送在一个往返中接收所有请求的瀑布图\n图5.5　一个基本的网页请求流，不使用HTTP/2推送（左边）和使用HTTP/2推送（右边）的情况\n如果使用方法正确，HTTP/2推送可以减少加载时间。但如果你多推送了资源（客户端不需要，或者已经在缓存里），则将会延长加载时间。所以，在使用HTTP/2推送 时应该小心，经过考虑后再使用。\nHTTP/2推送是否能替代WebSockets或者SSE\n诸如WebSockets和服务器发送事件（SSE）之类的技术真正允许双向流，HTTP/2中不是真正的双向流，一切都仍然是从客户端请求发起的。按照HTTP/2推送现在的 规范，它不是WebSockets或SSE的替代品，但如果以后它进一步扩展的话，也许有替代它们的机会\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.1/","summary":"HTTP/2服务端推送（以下称为HTTP/2推送）允许服务器发回客户端未请求的额外资源。 HTTP/2多路复用技术允许在同一连接上并行请求所有","title":"5.1 什么是HTTP/2服务端推送"},{"content":"4.3.1 查看HTTP/2帧 使用Chrome net-export\n抓包chrome://net-export 查看日志 https://netlog-viewer.appspot.com/#import 图4.7　在Chrome中查看HTTP/2帧\n以下输出来自一个SETTINGS帧：\n使用nghttp\n使用Wireshark\n需要告诉Wireshark HTTPS密钥 对于macOS，设置SSLKEYLOGFILE环境变量 或者直接作为命令行参数提供 在Wireshark中加载密钥 图4.8　设置Wireshark HTTPS密钥文件\n图4.9　Wireshark中显示的HTTP/2魔法字符串\n图4.10　Wireshark中的ClientHello消息中的ALPN扩展\n4.3.2 HTTP/2帧数据格式 每个HTTP/2帧由一个固定长度的头部和不定长度的负载组成。\n表4.1　HTTP/2帧头部格式\nStream Identifier, 将此字段限制为31位的其中一个原因是考虑到Java的兼容性，因为它没有32位无符号整数 4.3.3 HTTP/2消息流示例 可以使用-n参数来隐藏数据，仅显示帧头部：\n首先，通过HTTPS（h2）协商建立HTTP/2连接。nghttp不输出HTTPS建立过程和HTTP/2前奏/“魔术”消息，因此我们首先看到SETTINGS帧： SETTINGS帧 SETTINGS帧（0x4）是服务器和客户端必须发送的第一个帧（在HTTP/2前奏/“魔术”消息之后）。该帧不包含数据，或只包含若干键/值对\n表4.2　SETTINGS帧格式\n规范中的Value是默认值, 顺序与Identifier对应, e.g. 0x1-\u0026gt;4096.\n再回头看第一个消息\n收到的SETTINGS帧有30个8位字节数据，没有设置标志位（因此不是确认帧），使用的流ID为0。流ID 0是保留数字，用于控制消息（SETTINGS和 WINDOW_UPDATE帧），所以服务器使用流ID 0发送此SETTINGS帧是合理的。\n在此示例中有5个设置项（niv=5），每个设置项长度为16位（标识符）+32位（值）。也就是说，每项设置有48位即6字节\n查看接下来的3个SETTINGS帧 nghttp接收初始服务器SETTINGS帧（刚讨论过），然后，客户端发送带有几个设置项的SETTINGS帧。接下来，客户端确认服务器的SETTINGS帧。确认SETTINGS 帧非常简单，只有一个ACK（0x01）标志，长度为0，因此只有0设置（niv=0）。再接下来是服务器确认客户端的SETTINGS帧，格式同样简单。\nWINDOW_UPDATE帧 WINDOW_UPDATE帧（0x8）用于流量控制，比如限制发送数据的数量，防止接收端处理不完。在HTTP/1下，同时只能有一个请求。如果客户端无法及时处理数据，它 会停止处理TCP数据包，然后TCP流量控制（类似HTTP/2流量控制）开始工作，降低发送数据的流量，直到接收方可以正常处理为止。在HTTP/2下，在同一个连接上 有多个流，所以不能依赖TCP流量控制，必须自己实现针对每个流的减速方法。\n表4.3　WINDOW_UPDATE帧格式\nWINDOW_UPDATE帧未定义标志位，该设置用于给定的流，如果流ID指定为0，则应用于整个HTTP/2连接。发送方必须跟踪每个流和整个连接。\n如果流ID指定为0中的流ID应该是帧首部中的Stream Identifier.\nHTTP/2流量控制设置仅应用于DATA帧，所有其他类型的帧（至少目前定义的），就算超出了窗口大小的限制也可以继续发送。这个特性可以防止重要的控制消息（比 如WINDOW_UPDATE帧自己）被较大的DATA帧阻塞。同时DATA帧也是唯一可以为任意大小的帧。\nPRIORITY帧 通过dep_stream_id，它将其他流悬挂在开始时创建的流之下(该流依赖dep_stream_id所指定的流)。使用之前创建的流的优先级，可以方便地对请求进行优先级 排序，无须为每个后续新创建的流明确指定优先级。并非所有HTTP/2客户端都给流预定义优先级\n表4.4　PRIORITY帧格式\nPRIORITY帧（0x2）长度固定，没有定义标志位。\nHEADERS帧 一个HTTP/2请求以HEADERS帧开始发送（0x1）\nHTTP/2定义了新的伪首部（以冒号开始），以定义HTTP请求中的不同部分：\n:authority伪首部代替了原来HTTP/1.1的Host首部 HTTP/2伪首部定义严格，不像标准的HTTP首部那样可以在其中添加新的自定义首部 不能这样创建新的伪首部\n:barry: value 如果应用需要，还得用普通的HTTP首部，没有开头的冒号\nbarry: value 可以依照新的规范来创建新的伪首部\n在Bootstrapping WebSockets with HTTP/2 RFC中添加:protocol伪首部。应用新的伪首部需要使用新的SETTINGS参数，也需要客户端和服务端的支持。 可以在客户端工具中查看这些伪首部，它们表明正在使用HTTP/2请求 图4.11　Chrome开发者工具中的伪首部\nHTTP/2强制将HTTP首部名称小写, HTTP首部的值可以包含不同的大小写字母\nHTTP/2对HTTP首部的格式要求也更严格。开头的空格、双冒号或者换行，在HTTP/2中都会带来问题 当客户端发现首部格式不正确时，报错信息通常含义不明（比如Chrome中的ERR_SPDY_PROTOCOL_ERROR） 表4.5　HEADERS帧格式\n添加Pad Length和Padding字段是出于安全原因，用以隐藏真实的消息长度。 Header Block Fragment（首部块片段）字段包含所有的首部（和伪首部）。这个字段不是纯文本的，不像nghttp里所显示的那样。(首部压缩了) HEADERS首部定义了4个标志位\nEND_STREAM(0x1)，如果当前HEADERS帧后面没有其他帧（比如POST请求，后面会跟DATA帧），设置此标志。有点违反直觉的是，CONTINUATION帧不受此限 制，它们由END_HEADERS标志控制，被当作HEADERS帧的延续，而不是额外的帧。 END_HEADERS（0x4），它表明所有的HTTP首部都已经包含在此帧中，后面没有CONTINUATION帧了。 PADDED(0x8)，当使用数据填充时设置此标志位。这个标志表明，DATA帧的前8位代表HEADERS帧中填充的内容长度。 PRIORITY(0x20)，表明在帧中设置了E、Stream Dependency和Weight字段。 如果HTTP首部尺寸超出一个帧的容量，则需要使用一个CONTINUATION帧（紧接着是一个HEADERS帧），而不是使用另外一个HEADERS帧。\n这个过程相较于HTTP正文来说好像过于复杂，HTTP正文会使用多个DATA帧。因为表4.5中的其他字段只能使用一次，所以如果同一个请求有多个HEADERS帧，并 且它们的其他字段值不同，就会带来一些问题。 要求CONTINUATION帧紧跟在HEADERS帧后面，其中不能插入其他帧，这影响了HTTP/2的多路复用，人们正考虑其他替代方案。 实际上CONTINUATION帧很少使用，大多数请求都不会超出一个HEADERS帧的容量。 再回头看这些日志输出\n每个新的请求都会被分配一个独立的流ID，其值在上一个流ID的基础上自增（在这个示例中上一个流ID是11，它是nghttp创建的PRIORITY帧，所以这个帧使用 流ID13创建，偶数12是服务端使用的）。 同时设置了多个标志位，组合起来的十六进制数为0x25 其中的END_STREAM（0x1）和END_HEADERS（0x4）标志位说明，当前帧包含完整的请求，没有DATA帧（可能用于POST请求）。 PRIORITY标志位（0x20）表明，此帧使用了优先级策略。 将这些十六进制数加起来（0x1 + 0x4 + 0x20），结果是0x25，在帧首部中显示。 这个流依赖流11，所以被分配了对应的优先级，权重为16。 nghttp的注释说，这个流是新建的（Open new stream）， 然后列出了多个HTTP伪首部和HTTP请求首部 HTTP响应在同一个流上也使用HEADERS帧发送\n作者也提到了nghttp将HEADERS帧首部放到帧详情之后是一个疑惑点.\n尾随首部 HTTP/1.1引入了尾随首部的概念，可以在正文之后发送它。这些首部可以支持不能提前计算的信息。例如，在以流的形式传输数据时，内容的校验和或者数字签名可 以包含在尾随首部中。\n实际上，尾随首部的支持很差，很少应用。但是HTTP/2决定继续支持它，所以一个HEADERS帧（或者一个后跟CONTINUATION帧的HEADERS帧）可能出现在流 的DATA帧之前或者之后。\nDATA帧 表4.6　DATA帧格式\nDATA帧定义了两个标志位\nEND_STREAM(0x1)，当前帧是流中的最后一个。 PADDED(0x8)，当使用数据填充时设置此标志位。这个标志表明，DATA帧的前8位代表HEADERS帧中填充的内容长度。 GOAWAY帧 用于关闭连接，当连接上没有更多的消息，或发生了严重错误时使用该帧。\n表4.7　GOAWAY帧格式\n查看之前nghttp输出日志中最后的消息，会看到一个GOAWAY帧的示例\n当响应被处理，并且客户端不再等待更多的数据时，它会发送这个帧来关闭HTTP/2连接。Web浏览器可能会保持连接打开，以供后续的请求使用。\n4.3.4 其他帧 CONTINUATION帧 太大的首部需要使用CONTINUATION帧（0x9），它紧跟在HEADERS帧或者PUSH_PROMISE帧后面。因为在请求可以被处理之前，需要完整的HTTP首部，并且为了应 用HPACK的字典，所以CONTINUATION帧必须紧跟在HEADERS帧后面。\n这种要求降低了HTTP/2的多路复用性 很少被用到 表4.8　CONTINUATION帧格式\nCONTINUATION帧只定义了一个标志位\nEND_HEADERS（0x4），当设置这个标志的时候，表明HTTP首部内容到此帧结束，后续没有别的CONTINUATION帧了。 PING帧 PING帧（0x6）用以计算发送方的消息往返时间，也可以用来保持一个不使用的连接。当收到这类帧的时候，接收方应当马上回复一个类似的PING帧。两个PING帧都 应当在控制流（流ID为0）上发送。\n表4.9　PING帧格式\nPING帧定义了一个可以在通用帧首部中使用的标志位\nACK（0x1）标志位，在发起方的PING帧中不设置，在返回方中需要设置。 PUSH_PROMISE帧 服务器使用PUSH_PROMISE帧（0x5）通知客户端它将推送一个客户端没有明确请求的资源。PUSH_PROMISE帧需要提供将要向其推送资源的客户端信息，所以它包含 通常在HEADERS帧中包含的那些首部信息（同样，如果要推送的资源首部比较大，则它后面也可能会跟一个CONTINUATION帧）。\n表4.10　PUSH_PROMISE帧格式\nPUSH_PROMISE帧定义了两个标志位\nEND_HEADERS（0x4），它表明所有的HTTP首部都已经包含在此帧中，后面没有CONTINUATION帧了。 PADDED(0x8)，当使用数据填充时设置此标志位。这个标志表明，DATA帧的前8位代表PUSH_PROMISE帧中填充的内容长度。 RST_STREAM帧 用于直接取消（重置）一个流。该取消可能是由于一个错误，或者是因为请求已经不需要进行了。可能是客户端已经跳转到其他页面、取消了加载，或者不再需要服务 器推送的资源了。\nHTTP/1.1不提供这种功能。如果你正在下载页面上一个较大的资源，除非中断连接，否则就算跳转到其他页面，这个资源的下载也不会停止。 表4.11　RST_STREAM帧格式\nALTSVC帧 其允许服务端宣告获取资源时可用的其他服务。这个帧可以用来进行升级（比如从h2升级到h2c）或者重定义流量到另外一个版本。\n表4.12　ALTSVC帧格式\nORIGIN帧 服务器使用它来宣告自己可以处理哪些源（比如域名）的请求。当客户端决定是否合并HTTP/2连接的时候，该帧非常有用。\n该帧可以包含多组Origin-Len/Origin。 CACHE_DIGEST帧 客户端可以使用这个帧来表明自己缓存了哪些资源。例如，它指示服务器不必再推送这些资源，因为客户端已经有了。\n表4.14　CACHE_DIGEST帧格式\nCACHE_DIGEST帧定义了如下标志位\nRESET(0x1)，客户端用来告诉服务器重置当前保存的CACHE_DIGEST信息。 COMPLETE(0x2)，表明当前包含的缓存摘要代表所有的缓存，而不是缓存的一部分。 总结 HTTP/2是一个二进制协议，其消息有明确的、精细的格式和结构。 由于这个原因，客户端和服务端在发送HTTP消息之前必须协商都使用HTTP/2。 对于Web浏览器，这个协商的过程主要在HTTPS连接协商中完成，使用一个新的叫ALPN的扩展。 在HTTP/2中，请求和响应通过HTTP/2帧的形式传输。 一个HTTP/2 GET请求，通常以HEADERS帧的形式发送，接收的响应通常是一个HEADERS帧，跟着一个DATA帧。 大多数Web开发者和Web服务器管理员，不需要关心HTTP/2帧的细节，尽管可以使用工具查看这些帧。 当前有几种HTTP/2帧，以后还会添加新的帧。 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC4%E7%AB%A0-http2%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/4.3/","summary":"4.3.1 查看HTTP/2帧 使用Chrome net-export 抓包chrome://net-export 查看日志 https://netlog-viewer.appspot.com/#import 图4.7 在Chrome中查看HTTP/2帧 以下输出","title":"4.3 HTTP/2帧"},{"content":" 使用HTTPS协商。 使用HTTP Upgrade首部。 和之前的连接保持一致。 理论上，HTTP/2支持基于未加密的HTTP（也就是h2c）创建连接，也支持基于加密的HTTPS（即h2）创建连接。实际上，所有的Web浏览器仅支持基于HTTPS（h2） 建立HTTP/2连接，所以浏览器使用第一个方法来协商HTTP/2。服务器之间的HTTP/2连接可以基于未加密的HTTP（h2c）或者HTTPS（h2）。\n4.2.1 使用HTTPS协商 HTTPS需要经过一个协议协商阶段来建立连接，在建立连接并交换HTTP消息之前，它们需要协商SSL/TLS协议、加密的密码，以及其他的设置。这个过程比较灵活， 可以引入新的HTTPS协议和密码，只要客户端和服务端都支持就行。在HTTPS握手的过程中，可以同时完成HTTP/2协商，这就不需要在建立连接时增加一次跳转。\nHTTPS握手\n公钥私钥加密被称为非对称加密, 但它比较慢，所以这种加密方式用于协商一个对称加密的密钥，以便在创建连接之后使用对称密钥加密消息。\n图4.4　HTTPS握手 (TLSv1.2, 与TLSv1.3略微不同)\n握手过程涉及4类消息：\n客户端发送一个ClientHello消息，用于详细说明自己的加密能力。不加密此消息，因为加密方法还没有达成一致。 服务器返回一个SeverHello消息，用于选择客户端所支持的HTTPS协议（如TLSv1.2）。基于客户端在ClientHello中声明的密码，和服务器本身支持的密码， 服务器返回此连接的加密密码（如ECDHE-RSA-AES128-GCM-SHA256）。 之后提供服务端HTTPS证书（ServerCertificate）。 然后是基于所选密码加密的密钥信息（ServerKeyExchange） 以及是否需要客户端发送客户端证书（CertificateRequest，大多数网站不需要）的说明。 最后，服务端宣告本步骤结束（ServerHelloDone）。 客户端校验服务端证书，如果需要发送客户端证书（ClientCertificate，大多数网站不需要）。 然后发送密钥信息（ClientKeyExchange）。这些信息通过服务端证书中的公钥加密，所以只有服务端可以通过密钥解密消息。 如果使用客户端证书，则会发送一个CertificateVerify消息，此消息使用私钥签名，以证明客户端对证书的拥有权。 客户端使用ServerKeyExchange和ClientKeyExchange信息来定义一个加密过的对称加密密钥，然后发送一个ChangeCipherSpec消息通知服务端加密开 始 最后发送一个Finished消息。 配置客户端证书需要私钥吗?\n服务端也切换到加密连接上（ChangeCipherSpec），然后发送一个加密过的Finished消息。 当HTTPS会话建立完成后，在同一个连接上的HTTP消息就不再需要这个协商过程了。类似地，后续的连接（不管是并发的额外连接，还是后来重新打开的连接）可以 跳过其中的某些步骤 —— 如果它复用上次的加密密钥，这个过程就叫作TLS会话恢复。\nTLSv1.3可以将协商过程中的消息往返减少到1个（如果复用之前的协商结果，则可以降到0个）\nALPN\nALPN给ClientHello和ServerHello消息添加了功能扩展，客户端可以用它来声明应用层协议支持（“嗨，我支持h2和http/1，你用哪个都行。”），服务端 可以用它来确认在HTTPS协商之后所使用的应用层协议（“好的，我们用h2吧”）。\n图4.5　使用ALPN的HTTPS握手\nNPN\n在使用NPN时，客户端决定最终使用的协议，而在使用ALPN时，服务端决定最终使用的协议。\n图4.6　使用NPN的HTTPS握手\n现在不再推荐使用NPN，应该使用ALPN。\n使用ALPN进行HTTPS握手的示例(curl)\n4.2.2 使用HTTP Upgrade首部 通过发送Upgrade首部，客户端可以请求将现有的HTTP/1.1连接升级为HTTP/2。这个首部应该只用于未加密的HTTP连接（h2c）。基于加密的HTTPS连接的 HTTP/2（h2）不得使用此方法进行HTTP/2协商，它必须使用ALPN。我们已经说过多次，Web浏览器只支持基于加密连接的HTTP/2，所以它们不会使用这个方法。\n示例1：一个不成功的Upgrade请求\n客户端支持并想要使用HTTP/2，发送一个带Upgrade首部的请求：\n这样的请求必须包含一个HTTP2-Settings首部，它是一个Base-64编码的HTTP/2 SETTINGS帧\n不支持HTTP/2的服务器可以像之前一样返回一个HTTP/1.1消息，就像Upgrade首部没有发送一样：\n示例2：一个成功的Upgrade请求\n支持HTTP/2的服务器可以返回一个HTTP/1.1 101响应以表明它将切换协议，而不是忽略升级请求，并返回HTTP/1.1 200响应：\n然后服务器直接切换到HTTP/2，发送SETTINGS帧（见4.3.3节），之后以HTTP/2格式发送响应。\n示例3：服务端请求的升级\n当客户端认为服务器不支持HTTP/2时，它会发送不带Upgrade的请求：\n一个支持HTTP/2的服务端可以返回一个200响应，但是在响应首部中添加Upgrade来说明自己支持HTTP/2。这个时候，它是一个升级建议，而不是升级请求，因为只 有客户端才发起升级请求。\n如下是一个服务端宣告支持h2（基于HTTPS的HTTP/2）和h2c（基于纯文本的HTTP/2）的示例：\n客户端可以利用这个信息来完成协议升级，并在下一个请求中发送一个Upgrade首部\n发送Upgrade首部的问题\n由于所有的浏览器都只支持基于HTTPS的HTTP/2，因此这个Upgrade方法可能永远不会被浏览器使用，这会带来问题。\n应用服务器可能会发送一个Upgrade首部，帮助升级到HTTP/2以提升性能。反向代理Web服务器可能会透传这个首部。浏览器会收到升级建议，并决定升级。但是 与客户端直接连接的这个反向代理Web服务器并不支持HTTP/2。 在类似的场景中，可能反向代理已经和Web浏览器使用HTTP/2交互，但使用HTTP/1.1将请求代理到后端应用服务器。应用服务器可能会发出升级建议，如果其被反 向代理透传，浏览器就会困惑，因为当前已经使用HTTP/2通信了，服务端还在建议升级到HTTP/2。 4.2.3 使用先验知识 有不同的方法可以让客户端事先知道服务器是否支持HTTP/2。如果你使用反向代理来卸载HTTPS，则可能会通过基于纯文本的HTTP/2（h2c）与后端服务器通信，因 为你知道它们支持HTTP/2。或者，可以根据Alt-Svc首部（HTTP/1.1）或ALTSVC帧（参见4.3.4节）推断先前的连接信息。\n4.2.4 HTTP Alternative Services 第4种方法是使用HTTP Alternative Services（替代服务），它没有被包含在原来的标准中，在HTTP/2发布之后，将其列为单独的标准。此标准允许服务器使用 HTTP/1.1协议（通过Alt-Svc HTTP首部）通知客户端，它所请求的资源在另一个位置（例如，另一个IP或端口），可以使用不同的协议访问它们。该协议可以使用 先验知识启用HTTP/2。\n4.2.5 HTTP/2前奏消息 不管使用哪种方法启用HTTP/2连接，在HTTP/2连接上发送的第一个消息必须是HTTP/2连接前奏，或者说是“魔法”字符串。此消息是客户端在HTTP/2连接上发送的 第一个消息。它是一个24个八位字节的序列，以十六进制表示法显示如下：\n这个序列被转换为ASCII字符串后如下所示：\n这个无意义的看起来像HTTP/1样式的消息，目的是兼容，客户端向不支持HTTP/2的服务端发送HTTP/2消息的情况。然后服务器会尝试解析此消息，就像收到其他 HTTP消息时一样。因为它无法识别这个无意义的方法（PRI）和HTTP版本（HTTP/2.0），所以解析会失败，从而拒绝此消息。注意，此消息前奏是官方规范中唯一一 处使用HTTP/2.0的地方，在其他地方都是HTTP/2，正如4.1节中所讨论的。而对于支持HTTP/2的服务器，可以根据这个收到的前奏消息推断出客户端支持HTTP/2， 它不会拒绝这个神奇的消息，它必须发送SETTINGS帧作为其第一条消息（可以为空）。\n为什么是PRI和SM\n在早期的草稿中，HTTP/2规范中的消息前奏使用FOO和BAR或者BA表示，它们是编程中常见的占位符。但是在规范草稿的第4个版本中，这个占位符变成了PRI SM， 但是没有说为什么。\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC4%E7%AB%A0-http2%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/4.2/","summary":"使用HTTPS协商。 使用HTTP Upgrade首部。 和之前的连接保持一致。 理论上，HTTP/2支持基于未加密的HTTP（也就是h2c）创建连","title":"4.2 如何创建一个HTTP/2连接"},{"content":"新版本的协议与原来的协议有很大的不同，新增了如下概念：\n二进制协议 多路复用 流量控制功能 数据流优先级 首部压缩 服务端推送 HTTP/1.0的Web服务器可以支持HTTP/1.1的消息，并可以忽略后来的版本中新增的功能，但在HTTP/2中，就不能兼容了，HTTP/2使用了不同的数据结构和格式。 出于这个原因，HTTP/2被视为主版本更新。\nHTTP/2.0还是HTTP/2\nHTTP/2定义了新版本HTTP的主要部分（二进制、多路复用等），并且未来的任何实现或变更（如果有HTTP/2.1的话），此规范都兼容。 所以小版本号不太重要.\n此外，与HTTP/1消息不同，在HTTP/2请求中未明确声明版本号。 例如，HTTP/2中没有GET /index.html HTTP/1.1形式的请求。 但是，许多实现会在日志文件中使用次要版本号（.0）。例如，在Apache日志文件中，版本号显示为HTTP/2.0，其甚至会伪造HTTP/1形式的请求 4.1.1 使用二进制格式替换文本格式 使用基于文本的协议，要先发完请求，并接收完响应之后，才能开始下一个请求。\nHTTP的小改进\nHTTP/1.0引入了二进制的HTTP消息体，支持在响应中发送图片或其他媒体文件。 HTTP/1.1引入了管道化和分块编码。 都有队头阻塞（HOL）的问题——在队列首部的消息会阻塞后面消息的发送，更不用说，管道化在实际应用中并没有得到很好的支持。 4.1.2 多路复用代替同步请求 HTTP/1是一种同步的、独占的请求-响应协议。HTTP/1的主要解决方法是打开多个连接，并且使用资源合并以减少请求数，但这两种解决方法都会引入其他的问题和 带来性能开销。\n图4.1　并发多个HTTP/1请求，需要多个TCP连接\nHTTP/2允许在单个连接上同时执行多个请求，每个HTTP请求或响应使用不同的流。通过使用二进制分帧层，给每个帧分配一个流标识符，以支持同时发出多个独立请 求。当接收到该流的所有帧时，接收方可以将帧组合成完整消息。\n图4.2　使用多路复用技术的HTTP/2连接请求三个资源\nHTTP/2连接在请求发出后不需要阻塞到响应返回 服务器发送响应的顺序完全取决于服务器，但客户端可以指定优先级。 每个请求都有一个新的、自增的流ID（如图4.2中所示的流5、7和9）。返回响应时使用相同的流ID 响应完成后，流会被丢弃而且不能重用 为了防止流ID冲突，客户端发起的请求使用奇数流ID, 服务器发起的请求使用偶数流ID。 请注意，在写作本书时，从技术上讲服务器不能新建一个流，除非是特殊情况（服务端推送，但也要客户端先发起请求） ID为0的流（图中未显示出）是客户端和服务器用于管理连接的控制流。 小结\nHTTP/2使用多个二进制帧发送HTTP请求和响应，使用单个TCP连接，以流的方式多路复用。 HTTP/2与HTTP/1的不同主要在消息发送的层面上，在更上层，HTTP的核心概念不变。例如，请求包含一个方法（例如GET）、想要获取的资源 （例如/styles.css）、首部、正文、状态码（例如200、404）、缓存、Cookie等，这些都与HTTP/1保持一致。 图4.3　HTTP/2中的流和HTTP/1中的连接相似\n4.1.3 流的优先级和流量控制 现在HTTP/2对并发的请求数量的限制放宽了很多（在许多实现中，默认情况下允许同时存在100个活跃的流），因此许多请求不再需要浏览器来排队，可以立即发送它 们。这可能导致带宽浪费在较低优先级的资源（例如图像）上，从而导致在HTTP/2下页面的加载速度变慢。所以需要控制流的优先级，使用更高的优先级发送最关键 的资源。\n流的优先级控制是通过这种方式实现的：当数据帧在排队时，服务器会给高优先级的请求发送更多的帧。\n流量控制是在同一个连接上使用多个流的另一种方式。如果接收方处理消息的速度慢于发送方，就会存在积压，需要将数据放入缓冲区。而当缓冲区满时会导致丢包， 需要重新发送。在连接层，TCP支持限流，但HTTP/2要在流的层面实现流量控制。\n4.1.4 首部压缩 HTTP首部（包括请求首部和响应首部）用于发送与请求和响应相关的额外信息。在这些首部中，有很多信息是重复的，多个资源使用的首部经常相同。\nCookie User-Agent Host Accept Accept-Encoding 4.1.5 服务端推送 HTTP/2添加了服务端推送的概念，它允许服务端给一个请求返回多个响应。\nHTTP/2服务端推送是HTTP协议中的新概念，如果使用不当，它很容易浪费带宽。浏览器并不需要推送的资源，特别是，在之前已经请求过的服务器推送的资源，放在 浏览器缓存中。决定什么时候推送、如何推送，是充分利用服务端推送的关键。\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC4%E7%AB%A0-http2%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/4.1/","summary":"新版本的协议与原来的协议有很大的不同，新增了如下概念： 二进制协议 多路复用 流量控制功能 数据流优先级 首部压缩 服务端推送 HTTP/1.0的Web服","title":"4.1 为什么是HTTP/2而不是HTTP/1.2"},{"content":"3.1 HTTP/2的支持 你能否在网站上使用新的网络技术，主要取决于三点：\n浏览器是否支持这项技术？ 你的基础设施是否支持？ 如果这项技术未获得支持，是否有健壮的回退机制？ 3.1.1 浏览器对HTTP/2的支持 图3.1　caniuse.com中的HTTP/2数据\n图3.2　caniuse.com中的HTTP/2数据，Usage Relative视图\n浏览器对HTTP/2和HTTPS的支持\n在前面的图中，每个支持HTTP/2的浏览器都有一个小2作为备注，底部有“仅支持基于TLS的HTTP2（https）”的说明，因此不使用HTTPS的网站无法从HTTP/2中受 益。SPDY也有类似的限制，当HTTP/2被标准化时，人们也对此限制进行了大篇幅的讨论，许多参与方都要求强制将HTTPS作为规范的一部分。后来，这个要求被排除 在HTTP/2的正式规范之外，但是所有浏览器厂商都表示，他们将仅支持基于HTTPS的HTTP/2，这使其成为事实上的标准。要求支持HTTPS无疑会使仅支持HTTP 网站的站长不开心，但这种要求有两个很好的理由。\n第一个理由纯粹从实用方面考虑。仅通过HTTPS使用HTTP/2意味着不太可能出现兼容性问题。网上许多基于HTTP的基础设施，在升级之前不知道如何处理HTTP/2 消息。在HTTPS中包装消息，可以隐藏HTTP消息本身，从而避免兼容性问题。 第二个理由比较主观。许多浏览器厂商（和其他人，包括我）坚信，要远离未加密的HTTP，所有网站都应该转向HTTPS。因此，较新的功能通常仅支持HTTPS，以 鼓励人们切换为HTTPS。 即使你的网站支持了HTTPS，仍可能遇到问题。\n一些浏览器（如Chrome、Firefox和Opera）上的备注4意味着“只有服务器支持ALPN，其才支持HTTP2。 许多浏览器在使用HTTP/2之前需要更新为更安全的密码套件。 中间代理\n为了能够使用HTTP/2，浏览器和服务器都必须支持HTTP/2。但是，如果用户使用代理，把一个HTTP连接变成两个，且这个代理不支持HTTP/2，那HTTP/2还是不能 启用。\n查看计算机是否使用代理的最简单方法，是查看HTTPS证书，看看它是由谁颁发的，由真正的证书颁发机构颁发（有很多证书颁发机构，所以可能弄不清楚）还是由本 地软件颁发。\n图3.3　查看直接连接Google和通过反病毒产品连接Google时的HTTPS证书\n浏览器对HTTP/2支持情况的总结\n有几个情况可能导致无法使用HTTP/2，如服务端HTTPS设置不匹配，在使用拦截代理等。 对HTTPS的要求，尤其对ALPN的要求，使得启用HTTP/2变得更复杂了，会引起疑惑。这里的复杂性主要体现在，要求服务器正确设置 论。网络正朝着HTTPS大步迈进，未加密的HTTP网站受到的惩罚将继续增加，会有更明显的警告，新功能更少。 evergreen浏览器\n一些浏览器（如Chrome和Firefox）会在后台静默更新，不提示用户，我们称之为evergreen浏览器。这些浏览器的用户可能运行的是最新版本的浏览器，它们支持 HTTP/2。\n3.1.2 服务器对HTTP/2的支持 HTTPS库及其对HTTP/2的支持\nChrome和Opera仅支持基于ALPN的HTTP/2，而不支持NPN（Next Protocol Negotiation，下一代协议协商）。与之前的NPN一样，ALPN允许Web服务器在 HTTPS协商的过程中，声明服务器支持哪些应用程序协议；\n问题是ALPN仅包含在最新版本的OpenSSL（1.0.2及更高版本）中，在很多标准版本中并没有包含。 表3.1　不同的Linux系统对ALPN的支持\n服务端支持总结\n3.1.3 兼容不支持HTTP/2的情况 当客户端不支持HTTP/2时，网站仍然能正常工作，因为它们可以降级到HTTP/1.1。HTTP/1.1距离被废弃（如果会的话）还很遥远。从理论上讲，如果可能，应该启 用HTTP/2，因为并没有客户端不支持的问题。\n3.2 网站开启HTTP/2的方法 3.2.1 在Web服务器上开启HTTP/2 图3.4　Web服务器上的HTTP/2\n表3.2　流行的Web服务器开始支持HTTP/2的版本\n3.2.2 反向代理实现HTTP/2 图3.5　通过反向代理实现HTTP/2\n反向代理很常见，主要用于以下两种场景：\n作为负载均衡器 用以卸载一些功能，如HTTPS或者HTTP/2 图3.6　反向代理负载均衡\n是否需要在整个链路中支持HTTP/2\nHTTP/2的主要优点是可以提升高延迟、低带宽连接的速度，连接到边缘服务器（在这种情况下为反向代理）的用户通常处在这样的网络环境下。从反向代理到其他Web 基础架构的流量一般处于低延迟、高带宽、短距离的网络环境中（即使不是同一台机器，也通常是相同的数据中心），因此此场景下通常不需要考虑HTTP/1.1的性能 问题。\n如果反向代理到实际服务器的连接使用HTTP/2，则采用HTTP/2单个连接的方式收益也不高。因为反向代理到服务器的连接数不受限于浏览器设置的6个连接。甚至有 些人担心使用单个连接可能会导致性能问题，具体取决于在反向代理和目标服务器上的实现方式。Nginx已经声明，它不会为代理连接实现HTTP/2，所以也有这 方面原因。\n图3.7　在应用服务器/数据库服务器之前使用Web服务器\n图3.8　添加临时的反向代理，来测试HTTP/2\n3.2.3 通过CDN实现HTTP/2 大多数CDN已经支持HTTP/2了，所以你可以通过使用CDN的方式来启用HTTP/2，而源站只需要支持HTTP/1.1就行了。这个方法和使用反向代理类似，但是CDN有很 多反向代理服务器，它们可以帮你管理这个基础架构。\n图3.9　通过CDN启用HTTP/2\n3.2.4 小结 3.3 常见问题 表3.3　常见TLS库对ALPN的支持\n总结 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC1%E9%83%A8%E5%88%86-%E5%90%91http2%E9%9D%A0%E6%8B%A2/%E7%AC%AC3%E7%AB%A0-%E5%8D%87%E7%BA%A7%E5%88%B0http2/","summary":"3.1 HTTP/2的支持 你能否在网站上使用新的网络技术，主要取决于三点： 浏览器是否支持这项技术？ 你的基础设施是否支持？ 如果这项技术未获得支持，是","title":"第3章 升级到HTTP/2"},{"content":" 1 $ git config --global pager.branch false 执行git branch的结果将直接输出, 而不是输出到类似 more 命令的界面.\n可以利用自动补全查看pager.*下其他可配置东西.\n","permalink":"https://jdxj.github.io/posts/cmd/git/%E7%9B%B4%E6%8E%A5%E5%B1%95%E7%A4%BA%E7%BB%93%E6%9E%9C%E5%88%B0%E7%BB%88%E7%AB%AF%E8%80%8C%E4%B8%8D%E6%98%AFpager/","summary":"要不还得按\u003ccode\u003eq\u003c/code\u003e退出","title":"直接展示结果到终端而不是pager"},{"content":"无级变速器如何实现无级变速的？ 无级变速器的主要部件是两个滑轮和一条金属带，金属带套在两个滑轮上。\n无级变速器\n奥迪无级变速器工作原理示意图\n无级变速器视频\n无级变速器变速原理示意图\n奥迪无级变速器构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.07/","summary":"无级变速器如何实现无级变速的？ 无级变速器的主要部件是两个滑轮和一条金属带，金属带套在两个滑轮上。 无级变速器 奥迪无级变速器工作原理示意图 无级变","title":"4.7 无级变速器（CVT）"},{"content":"自动变速器是怎样利用行星齿轮变速的？ 自动变速器由两大部分组成：一是前面介绍的液力变矩器；二是下面要介绍的行星齿轮变速系统。\n从发动机输出的动力，经液力变矩器后，就会传递到变速结构。这个变速结构虽然也是利用齿轮组合来调节传动比，但它和手动变速器采用普通齿轮的方式截然不同， 而是采用行星齿轮机构，利用行星齿轮机构的特点调节出不同的传动比。\n所谓行星齿轮，是指有自转和公转的齿轮结构。中间的齿轮就像是太阳，只能自转；其周围的小齿轮则像是行星，可以围绕中间的太阳轮进行公转。当将太阳轮或行星 齿轮中的某一种齿轮固定不动时，就会变化出不同的传动比来，包括反转，从而可以输出不同的转速和转矩。\n行星齿轮是怎样实现变速的？ 自动变速器中的行星齿轮机构共有三种齿轮：中间的大齿轮称为太阳轮，黄色的小齿轮称为行星齿轮，最外面的齿圈称为环齿轮。这三种齿轮在进行变速时，分别作为 固定齿轮、主动齿轮和从动齿轮，根据不同的任务分配，就可变换出不同的传动比。\n环齿轮固定：太阳齿轮为主动齿轮，行星轮为从动齿轮，或相反。 行星齿轮固定：太阳齿轮为主动齿轮，环齿轮为从动齿轮，或相反。 太阳齿轮固定：环齿轮为主动齿轮，行星齿轮为从动齿轮，或相反。 自动变速器构造图\n自动变速器\n锁止离合器起什么作用？ 当液力变矩器传递动力时，由于它采用液压油作为传递介质，不是刚性传递，其间大约有10%的能量损失，这对节能降耗很不利，也会影响操控性。为了解决这个问题， 在液力变矩器和飞轮之间设置了一个单向锁止离合器，当车速较高时，用电控的方式起动此离合器，将液力变矩器的输入轴和输出轴锁止在一起，实现刚性直接传递动 力。也就是从发动机曲轴输出的动力，不需经过液力变矩器而直接传递到变速机构，从而提高传动效率。\n采埃孚9速自动变速器\n自动变速器最多档位数是多少？ 自从自动变速器被发明以来，它的前进档位数一直在增长，从最初发明时的3速，已增加到现在最多9速自动变速器，如奔驰、路虎和吉普等就有采用9速自动变速器的 车型。现在，8速自动变速器主要配备在宝马和奥迪等车型上，而7速自动变速器仅在奔驰老款车型上还有使用。现在，市场上主流的还是6速自动变速器，使用5速自动 变速器的越来越少，而使用4速自动变速器就非常落后了。\n奔驰9G-TRONIC PLUS 9速自动变速器 Continuous Variable Transmission\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.06/","summary":"自动变速器是怎样利用行星齿轮变速的？ 自动变速器由两大部分组成：一是前面介绍的液力变矩器；二是下面要介绍的行星齿轮变速系统。 从发动机输出的动力","title":"4.6 行星齿轮变速系统"},{"content":"液力变矩器是怎样工作的？ 液力变矩器主要由三个“轮”组成：泵轮、导轮和涡轮。在三个轮之间充满了液压油。泵轮与发动机曲轴相连，当发动机旋转时，泵轮便会随之旋转，并搅动液压油，将 其“甩向”与后面变速机构相连的涡轮，使涡轮旋转，从而将动力传向后面的变速机构，最终传递到车轮。固定不动的导轮的作用是增大传递转矩。\n液力变矩器\n奥迪A8轿车8速自动变速器\n液力变矩器构造示意图 Planetary Gear Transmission System\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.05/","summary":"液力变矩器是怎样工作的？ 液力变矩器主要由三个“轮”组成：泵轮、导轮和涡轮。在三个轮之间充满了液压油。泵轮与发动机曲轴相连，当发动机旋转时，泵","title":"4.5 液力变矩器 Hydraulic Torque Converter"},{"content":"奥迪汽车6速自动变速器构造示意图\n为什么自动变速器没有离合器？ 自动变速器组成: 液力变矩器、控制器、电磁控制机构、多片离合器和行星齿轮等\n液力变矩器的作用相当于手动档汽车上的离合器。其原理类似两个对吹的电风扇，当一个电扇通电旋转后，另一个电扇也会被吹得随之旋转。对吹电扇传递动力的介质 是空气，而液力变矩器传递动力的介质是油液。通过控制油液的流动状态，就可以控制动力和转速输出的大小。\n液力变矩器的原理类似两个对吹的电风扇，它们通过介质可以传递动力，起到离合器传递动力的作用\n液力变矩器\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.04/","summary":"奥迪汽车6速自动变速器构造示意图 为什么自动变速器没有离合器？ 自动变速器组成: 液力变矩器、控制器、电磁控制机构、多片离合器和行星齿轮等 液力变矩","title":"4.4 自动变速器（AT）Automatic Transmission"},{"content":"为什么手动变速器需要同步器？ 在手动变速器上，所有档位的主动齿轮和从动齿轮副都一直处于啮合状态并持续旋转，但只有一个档位的齿轮副与动力输出轴相接合。当我们操纵变速杆换档时，其实 是更换与动力输出轴接合的齿轮副。\n在与新的齿轮副接合时，由于动力输出轴基本保持原来上个档位的旋转速度，它与新的齿轮副之间的转速有差别，这样在与新齿轮副接合时就会产生一定的速度差，而 不同转速的部件硬性接合时就会产生冲击，损坏齿轮。\n为了避免换档时的冲击，使换档更加顺畅，手动变速器中都设有几个同步器。利用同步器的特殊性能，可以减少换档冲击。\n老式的汽车变速器上没有同步器，为了减少换档冲击，换档时必须采取“两脚离合”的方法：升档时在空档位置稍停顿一下，降档时在空档位置稍踩下加速踏板，以减少 齿轮之间的转速差。\n手动变速器原理示意图\n手动变速器构造图\n同步器是怎样工作的？ 同步器也称为犬牙啮合套，因为它在与档位齿轮接合时如同犬牙一样相互交错在一起。如图所示，当向左推动同步器时，同步器上的同步环就与档位齿轮上的接合齿圈 犬牙交错在一起。同步器毂与动力输出轴是接合在一起的，这样就可以使档位齿轮与动力输出轴接合在一起，从而达到变速的目的。\n同步器与档位齿轮接合示意图\n单件式同步器构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.03/","summary":"为什么手动变速器需要同步器？ 在手动变速器上，所有档位的主动齿轮和从动齿轮副都一直处于啮合状态并持续旋转，但只有一个档位的齿轮副与动力输出轴相","title":"4.3 同步器 Synchronizer"},{"content":"手动变速器\n手动变速器是怎样变速的？ 当离合器接合时，不管是在空档还是在任何档位，变速器中每个档位的主动齿轮（红色齿轮）以及每个档位的从动齿轮（蓝色部分）始终啮合在一起，并按照各自的转 速不停地旋转。但是，在空档时，各个档位的所有从动齿轮并没有和输出轴连接，此时输出轴是静止不转的。\n当挂上1档或其他前进档位时，实际上是将1档或其他档位的从动齿轮通过同步器（或称犬牙啮合套）和输出轴接合起来共同旋转。当变换档位时，则是换成新档位的从 动齿轮来与输出轴接合并共同旋转。\n5速手动变速器原理示意图\n倒档的主动齿轮和从动齿轮之间“夹”了一个中间轮，这样就可使输出轴的旋转方向与其他档位相反。\n4速手动变速器构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.02/","summary":"手动变速器 手动变速器是怎样变速的？ 当离合器接合时，不管是在空档还是在任何档位，变速器中每个档位的主动齿轮（红色齿轮）以及每个档位的从动齿轮（","title":"4.2 手动变速器 (MT) Manual Transmission"},{"content":"为什么汽车需要变速器？ 自行车变速原理示意图\n当主动链轮的直径和转速固定不变时，从动链轮越小，从动链轮的转速也会越高，输出的转矩也会越小；反之亦然\n汽车也是一样，发动机的转速非常高，但输出的转矩非常有限。起步时，不需要较大的车速，但需要较大的转矩，因此在起步阶段最好是让汽车低速、大转矩平稳运行； 在车速提高后，就不需要太大的转矩，而需要较高的车速。变速器的作用就如同自行车的变速齿轮，可以由驾驶人根据行驶情况来调节发动机输出的转速和转矩，从而 使汽车顺利地起步、爬坡和快速行驶等。\n什么是齿轮传动比？ 齿轮传动比简称齿比，是指主动齿轮与被动齿轮的角转速之比，也等于被动齿轮与主动齿轮的齿数之比。变速器的每个档位齿轮组合，都有一个与其他档位不同的传动 比。档位越低，其传动比越大；档位越高，其传动比越小。\n变速器各档位传动比值示例\n为什么变速器中要使用很多齿轮？ 一对相互啮合的齿轮，直径较小的齿轮以较小的力旋转，那么在较大齿轮上就会获得更大的力，但作为获得较大力的代价，大齿轮的转速则会相应降低。或者说，相互 啮合的一对齿轮，直径越大或齿数越多的齿轮，它的转速越低，转矩越大；转速越高，则转矩越小。\n齿轮变速原理示意图\n利用齿轮原理，可以将较大的转速转变为较小的转速，也可以将较小的转速转变为较大的转速\n齿轮放大转矩原理示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.01/","summary":"为什么汽车需要变速器？ 自行车变速原理示意图 当主动链轮的直径和转速固定不变时，从动链轮越小，从动链轮的转速也会越高，输出的转矩也会越小；反之亦","title":"4.1 变速原理 Transmission Principle"},{"content":"跳过\n","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC10%E7%AB%A0-%E5%85%B8%E5%9E%8B%E6%B6%88%E8%B4%B9%E5%93%81%E4%BC%81%E4%B8%9A%E8%B4%A2%E6%8A%A5%E5%88%86%E6%9E%90/","summary":"跳过","title":"第10章 典型消费品企业财报分析"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/httparchive/","summary":"主页","title":"http archive"},{"content":"转子发动机是怎样产生动力的？ 现在所说的转子发动机，是指德国工程师菲利克斯·汪克尔在20世纪50年代设计的三角形活塞式转子发动机。因此，转子发动机也被称为汪克尔发动机。\n转子发动机的主要部件结构简单，体积小，功率大，高速时运转平稳，性能较好，曾引起汽车行业的关注，纷纷进行研制试验。但是，经过几十年的试验证明， 这种机型尚无法与传统往复活塞式发动机相媲美，其边缘磨损严重，油耗较高。\n马自达RX-8跑车转子发动机\n转子发动机工作行程示意图\n转子发动机 转子发动机\n往复式四行程发动机工作原理示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.19/","summary":"转子发动机是怎样产生动力的？ 现在所说的转子发动机，是指德国工程师菲利克斯·汪克尔在20世纪50年代设计的三角形活塞式转子发动机。因此，转子发","title":"3.19 转子发动机 Rotary Engine"},{"content":"奔驰V6柴油发动机构造图\n柴油发动机\n为什么柴油发动机没有点火系统？ 柴油发动机是一种压燃式内燃机，是以柴油为燃料的内燃机。柴油发动机利用气体被压缩后温度会上升的原理，用活塞压缩进入气缸的空气；当空气温度上升到 柴油燃点温度时，用喷油器将柴油喷成雾状射入气缸；柴油一旦与灼热的空气相遇，即发生燃烧；燃烧所产生的高温高压燃气在气缸内膨胀，从而推动活塞做功。 柴油是在高温高压之下“自燃”的，不是被点燃的，所以柴油发动机不需要点火系统。\n随着技术的发展，现在一些柴油发动机也被应用在轿车上，甚至作为跑车的动力系统。尤其在欧洲，柴油发动机在轿车上的应用非常普遍。\n柴油发动机是怎样工作的？ 进气行程. 进气门打开，排气门关闭，空气从进气门被吸入气缸，然后进气门关闭。 压缩行程. 活塞上升并压缩吸入的空气，使空气温度升高。喷油器将燃油喷入气缸，并混入热空气中 做功行程. 柴油与空气的混合气越来越热，以至于温度升高到可以自燃。混合气燃烧爆炸的力量将活塞向下推动，并通过连杆推动曲轴旋转。 排气行程. 排气门打开。旋转的曲轴推动活塞向上运动，活塞将燃烧后的废气从排气门推出气缸。 柴油发动机\n柴油发动机工作行程示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.18/","summary":"奔驰V6柴油发动机构造图 柴油发动机 为什么柴油发动机没有点火系统？ 柴油发动机是一种压燃式内燃机，是以柴油为燃料的内燃机。柴油发动机利用气体被压","title":"3.18 柴油发动机 Diesel Engine"},{"content":"发动机润滑系统示意图\n发动机润滑过程\n机油在发动机内是怎样流动的？ 当发动机不工作时，机油主要储存在油底壳。当发动机运转时，机油从油底壳经机油集滤器被机油泵抽送到机油滤清器中，经机油滤清器过滤后再进入主油道， 然后再通过各分油道进入润滑部位进行润滑。润滑后的机油，在重力作用下再流回到油底壳，参与再循环。\n为什么机油能起润滑作用？ 机油分散在摩擦面上，在摩擦面之间形成隔离层，并可以四处自由流动，这样就可以避免接触面上微小凹凸颗粒之间的摩擦，从而使部件之间的相对运动更加顺 畅。\n通用汽车V8发动机润滑系统示意图\n发动机润滑过程\n为什么要使用机油滤清器？ 为了不断清除润滑系统中的杂质，如金属屑、机油中的胶质等，在机油循环系统中必须装备机油滤清器，并且要定期更换，以保证它拥有较佳的过滤性能。\n下图中，黄色表示还没有过滤的机油，绿色表示已经过滤的机油。\n机油滤清器构造图\n奥迪3.0升V6 TFSI发动机润滑循环系统\n湿式油底壳和干式油底壳有什么不同？ 湿式油底壳，发动机的曲轴曲拐和连杆大头在曲轴每旋转一周时都会浸入油底壳的机油内一次，从而起到润滑作用，同时曲拐每次高速浸入油液内都会激起一定 的油花和油雾，还可以对曲轴和轴瓦进行润滑。\n这种润滑方式对于追求运动性能和越野性能的车型来讲就存在一个比较大的问题，当汽车高速过弯或者在极限越野中车身倾斜很大时，离心力或者重力会造成机 油聚集于油底壳的一个局部，导致部分曲拐不能浸入油液，从而影响润滑。\n为了解决这个问题，把发动机底部的油底壳，改成一个独立安装的机油箱，利用机油泵的压力强制将机油送到各个润滑点，并将润滑后的机油回送到机油箱。这 样的润滑方式，可以不受重力和离心力的影响，这就是干式油底壳。\n奔驰SLS发动机干式油底壳构造图\n保时捷水平对置6缸发动机润滑系统示意图\n为什么水平对置发动机的润滑系统更复杂？ 水平对置发动机的气缸都呈横卧形状，而且是对向排列，因此，要将机油抽送到气缸各处参与润滑，其难度比直列或V形发动机要大得多。更难的是，参与润滑后 的机油无法在重力作用下流回油底壳，必须通过机油泵才能回送到机油箱。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.17/","summary":"发动机润滑系统示意图 发动机润滑过程 机油在发动机内是怎样流动的？ 当发动机不工作时，机油主要储存在油底壳。当发动机运转时，机油从油底壳经机油集滤","title":"3.17 润滑系统 Lubrication System"},{"content":"发动机都有哪些冷却方式？ 风冷是在气缸体周围设计散热片，利用自然风或风扇来吹散发动机的热气，达到降低发动机温度的目的。 水冷是指利用冷却液来降低发动机的温度。 发动机冷却系统\n散热器和风扇构造图\n散热器是怎样散热的？ 汽车发动机冷却系统示意图\n为什么发动机不能过热或过冷？ 如果发动机温度过高，活塞和气门在高温下就可能发生膨胀变形，导致发动机损坏；如果冷却不良，发动机动力输出会下降，甚至引起爆燃等不正常的燃烧现象。 如果发动机过冷，会使汽油雾化效果变差，燃烧效率降低，燃烧不完全，进而降低动力输出，增加油耗。\n发动机内部温度有多高？ 在发动机内部，当发动机以极高速度运转时，它的最高燃烧温度可以高达2500℃，最低也要超过1000℃。可惜的是，这些热量很难被有效利用。不仅如此，它还 会使与其接触的机械部件受热膨胀，因此还必须消耗机械能量使其降温。据测试，燃油燃烧产生的总热量有1/3被吹散到大气中，被白白浪费掉。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.16/","summary":"发动机都有哪些冷却方式？ 风冷是在气缸体周围设计散热片，利用自然风或风扇来吹散发动机的热气，达到降低发动机温度的目的。 水冷是指利用冷却液来降低","title":"3.16 冷却系统 Coolant System"},{"content":"活塞的直线运动怎样转变成曲轴的旋转运动？ 与我们骑自行车的情况类似。\n活塞相当于人的膝盖，连杆相当于人的小腿，曲轴相当于脚蹬子，当活塞上下运动时，便会带动曲轴做旋转运动。 由直线运动转变为旋转运动示意图\n发动机直线运动转为旋转运动构造图\n发动机内部运动\n汽油发动机内部构造 为什么说活塞是心脏中的心脏？ 在发动机中，活塞的工作条件最严酷，不仅要承受巨大的压力，而且要承受非常高的温度。在高速运转中，活塞的行进速度有时可达到20米/秒。因此，活塞对 材质和制作精度等要求都非常高。\n活塞的顶部一般都不是平的，而是凹进去一点，这主要是为燃烧室留出空间。另外，为了减轻活塞的重量，一般都将它设计成空心的。\n被拆解的活塞连杆组件\n发动机活塞\n活塞和连杆构造和分解图\n活塞连杆构造图\n1马力代表1匹马的力量吗？ 马力最早是指一匹货运马在一定时间内所做的功，而不是指一匹马的力量或它的“劲儿”有多大。\n1英制马力（hp）=76千克力·米/秒\n“马力”概念示意图\n后来马力又被定义为：1公制马力（ps）=75千克力·米/秒\n在正规场合或专业术语中，人们基本不再使用马力作为功率的单位，而是使用瓦特（W）或千瓦（k W）作为功率的标准单位，或同时用马力和千瓦来表示。\n1英制马力（hp）=0.746千瓦（kW） 1公制马力（ps）=0.735千瓦（kW） 美国SAE标准常用英制马力（hp），而德国DIN、欧共体EEC和日本JIS标准常用公制马力（ps）。\n怎样理解转矩的概念？ 用一根1米长的扳手去扭动一个螺母，如果你用1牛顿或1千克力的手力量去扭动，那么施加在螺母上的转矩就是“1牛·米”或“1千克力·米”。\n所谓发动机的动力, 其大小是转矩与转速的乘积。\n应该功率.\n什么是曲轴、曲拐、曲柄？ 发动机主要构造分解图\n曲轴上的曲柄长度对发动机性能有直接影响。曲柄长度越大，它的最大转矩输出相对也越大，但最大转速相对较低；反之，如果曲柄越短，则它的发动机最大转 矩相对较小，但最高转速相对较高。另外，气缸的行程等于曲柄长度的2倍。\n曲轴在发动机中的位置示意\n为什么说曲轴是中心轴？ 发动机产生的动力经由活塞、连杆再传到曲轴，使曲轴每分钟旋转数千次，将动力传递到传动系统，使车轮转动。曲轴的旋转也会带动水泵、机油泵、发电机和 凸轮轴带轮等。可以说，曲轴是发动机动力的中转轴，是中心轴。由于它是弯弯曲曲的轴，故称为曲轴。\n为什么需要平衡重和平衡轴？ 平衡重的作用\n曲轴通过连杆将活塞的往复运动转变成圆周运动，既要承受很大的力，又要高速旋转，它的强度必须非常高，刚性也要好，因此一般都比较粗壮，运动起来振动 也较大。为了减小曲轴运转中的振动，一般都会在它上面装有平衡重块，以保证发动机运转平稳。\n平衡轴的作用\n当活塞运行到上止点和下止点时，连杆是倾斜的，会产生一个横向力，从而使曲轴在运转时产生振动。由于活塞完成一次往复运动要产生两次振动，因此又把这 种振动称为二次振动。在曲轴两侧设置两根平衡轴，并且使平衡轴的转速是曲轴的2倍，以平衡二次振动。\n平衡轴有链传动和齿轮传动形式，它们的转速都是曲轴的2倍。\n发动机平衡轴\n发动机曲轴构造图\n链传动的双平衡轴曲轴构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.15/","summary":"活塞的直线运动怎样转变成曲轴的旋转运动？ 与我们骑自行车的情况类似。 活塞相当于人的膝盖，连杆相当于人的小腿，曲轴相当于脚蹬子，当活塞上下运动时","title":"3.15 发动机主运动部件 Engine Major Moving Parts"},{"content":"发动机共有多少个部件？ 根据构造复杂程度的不同，一台发动机不可拆解的零部件总数，大概为300～600个。据称，一辆法拉利跑车的发动机约有800个独立的零部件，而布加迪威航的 W16发动机约有3500个零件。\n雪佛兰克尔维特V8发动机部件分解图\n克尔维特V8发动机\n克尔维特ZR1跑车6.2升V8机械增压汽油发动机分解图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.14/","summary":"发动机共有多少个部件？ 根据构造复杂程度的不同，一台发动机不可拆解的零部件总数，大概为300～600个。据称，一辆法拉利跑车的发动机约有800","title":"3.14 发动机整体构造 Engine Structure"},{"content":"为什么说火花塞像闪电？ 火花塞构造图\n要想产生燃烧，必须满足三个条件：燃料、氧气和温度。\n柴油发动机上没有火花塞，它是先将气缸内的空气强力压缩，直到空气温度升高到柴油的燃点，然后向气缸内喷射柴油，便可瞬间点燃柴油。\n火花塞产生高压放电的原理和雷电产生的原理是一样的。分别带正电和负电的两个电极离得非常近，一般不到1毫米。当它们分别带正电和负电时，一旦接近就会 产生电火花，电压甚至高达1万伏。它可以在瞬间点燃气缸中已被压缩升温的混合气。\n发动机是怎样起动的？ 发动机起动\n汽油发动机起动系统示意图\n汽车起动和点火流程示意图\n发动机起动和充电系统\n起动机是怎样工作的？ 汽车起动机构造示意图\n起动机工作原理\n为什么不能再用“接线法”起动汽车了？ 在传统汽车的点火起动系统中，只要将起动机与蓄电池之间的电路接通，就能利用起动机带动发动机的活塞运转，同时带动分电器工作，控制每个气缸的点火和 喷油，使发动机正常起动。因此，即使不用车钥匙，也能用“接线法”将汽车起动。\n现在的发动机已没有了分电器，不再用机械方式控制每个气缸的点火和喷油，而是由发动机电脑（ECU）控制。因此，即使将起动机的电源线接通，也只能使起 动机转动，并不能使点火和喷油系统正常工作。当车钥匙插入并扭转时，汽车上的防盗系统会识别车钥匙内密码芯片的信息，当确认合法后，才会起动燃油喷射 和点火系统。否则，将拒绝喷油和点火，使车辆无法起动。\n车辆起动防盗系统\n蓄电池的作用是什么？ 蓄电池只是储存电能的设备，而产生电能的部件还是由发动机驱动的发电机。发电机与蓄电池并联使用。\n蓄电池构造图\n汽车发电机构造图\n为什么发动机起动需要飞轮？ 飞轮的作用是储存发动机的运动能量，因为无论旋转速度多高，活塞在完成的四个行程中只有一次是做功的，而进气、压缩、排气三个行程中活塞都会遇到较大 的阻力，需要一定的力量才能完成任务。因此，利用重量和直径都较大的飞轮先把动能储存起来，便可带动曲轴平稳运转。\n飞轮还有另外两个作用：\n一是它的外周镶有齿环，它与起动机直接相连，通过起动机带动飞轮旋转从而起动发动机； 二是利用飞轮圆盘的大面积，可以让它与离合器相连，从而向传动系统传递动力。 发动机的气缸数越多，动力重叠便越多，因此不必储存太多动能，飞轮就可以小一点。虽然飞轮越重，发动机越平稳，但是因为惯性，太重的飞轮也会使发动机 加速或减速都慢。因此，载货车发动机的飞轮大而重，跑车发动机的飞轮则小而轻。\n发动机飞轮构造图\n飞轮作用一：储存能量，带动曲轴平稳旋转。\n飞轮作用二：起动机通过带动飞轮旋转来起动发动机。\n飞轮作用三：与离合器相连，向传动系统传递动力。\n发动机制动是怎么回事？ 当驾驶人完全抬起加速踏板，但不踏下离合器踏板，车辆的惯性力就会带动车轮继续旋转，进而由驱动轮通过半轴、差速器齿轮、变速器齿轮、发动机飞轮等传 动机构，带动发动机曲轴旋转。而此时发动机的压缩行程会产生压缩阻力，加上发动机内摩擦力和进排气阻力等，就会对驱动轮形成制动作用。这种现象就称为 发动机制动。\n发动机制动时，档位越低，发动机制动力就越大；反之，则越小。在下长坡道路行驶时，挂入低速档，利用发动机制动，可以减少制动次数，防止制动器过热引 起制动力热衰减；在冰雪、湿滑路面上行驶，应用发动机制动，可以防止侧滑。\n发动机制动原理示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.13/","summary":"为什么说火花塞像闪电？ 火花塞构造图 要想产生燃烧，必须满足三个条件：燃料、氧气和温度。 柴油发动机上没有火花塞，它是先将气缸内的空气强力压缩，直","title":"3.13 点火起动系统 Ignition Starting System"},{"content":"多点喷射和单点喷射有什么不同？ 如果每个气缸的进气歧管上都单独装配一个喷油器，每个喷油器只向一个气缸喷射燃油，那么就称之为多点喷射（M P I）。反之，只在进气管入口处装配一个 喷油器，由这一个喷油器向进气管处喷射燃油，然后再由进气歧管把混合气分散到各个气缸中，那么就称其为单点喷射。其实，随着多点喷射系统制造成本的下 降，现在轿车上已很少采用单点喷射了。\n单点燃油喷射系统示意图\n多点燃油喷射系统示意图\n发动机燃油喷射\n什么是“双喷”发动机？ “双喷”发动机配有两套燃油喷射装置，除了缸内燃油直喷系统外，还在进气道内设计了一个喷油器。根据行驶状况，缸内喷射与缸外喷射之间可以进行切换或共 同混合喷射，确保高效的动力输出和最佳的燃油经济性。\n丰田“双喷”发动机\n缸内直喷和缸外喷射有什么不同？ 缸外喷射是将燃油喷射到进气道中，与进气混合后再进入气缸内。缸内直喷是直接将燃油喷射入气缸中，如所有的柴油发动机和部分缸内直喷汽油机。由于燃油 缸内直喷对提高燃油经济性、提高动力输出都很有帮助，因此现在采用缸内直喷发动机的车辆越来越多。燃油缸内直喷已成为发动机先进技术的代表之一。\n缸外燃油喷射系统示意图\n缸内燃油喷射系统示意图\n“双喷”发动机喷射系统示意图\n怎样控制喷油时刻和喷油量？ 缸内直喷发动机上最先进的喷油器采用压电式喷嘴，它由无数个相互叠置的微型陶瓷碟片组成。如果给电磁线圈施予电压，陶瓷碟片的晶体结构就会发生改变（ 也就是所谓的压电效应），碟片随后以最低限度强力扩张，快速而精确地作用于控制阀，控制阀则会触发喷射针，从而喷射燃油；当电磁线圈断电后，磁力消失， 在压力弹簧的作用下，喷油针阀回复原位，喷油结束。这样，通过控制电磁线圈的电压，就可以实现喷油时刻和喷油量的精确控制。\n什么是高压油轨？ 缸内直喷发动机的高压油轨系统中的“轨”其实是一个储压器，其中燃油由油泵供给，可在最高200兆帕的压强下存储燃油，这相当于将一辆高档豪华轿车的重量 集中在1平方厘米的面积上。正是由于高压作用以及喷嘴上一个直径只有0.1毫米的精细小孔设计，共轨系统的喷射器能够将燃油雾化为极为精细的微粒，从而确 保出色、均匀的油气混合及高效的燃烧。\n奥迪缸内燃油直喷发动机喷油器\n高压共轨\n奥迪直列4缸汽油发动机燃油喷射系统\n燃油是怎样供给到发动机的？\n燃油被燃油泵从燃油箱中抽出，在进入发动机之前，还要经过燃油滤清器，才能进入燃油轨道，并在发动机电脑（ECU）的控制下喷射到进气道（缸外喷射） 或气缸内（缸内直喷），最终参与燃烧。\n由于燃油喷射的压力较大，在喷入进气歧管时可能造成进气歧管内压力不平衡，从而影响燃烧效率。为此，专门设置了一个压力调节器，当进气歧管内压力差较 大时，压力调节器打开阀门，允许一部分燃油流回燃油箱中。\n燃油供给\n燃油供给路线示意图\n燃油箱和炭罐\n炭罐起什么作用？ 汽油是易挥发的燃料，油箱内的燃油很容易挥发并增加油箱内部的压力，当压力到达一定值时就会产生危险。为了避免危险，在燃油箱和发动机之间设置了一个 充满活性炭的炭罐，让油箱中多余的燃油蒸气不再排到大气中，而是通过蒸气导管引入炭罐中，由活性炭来吸附燃油蒸气。当汽车开动时，炭罐电磁阀适时打开， 新鲜空气进入炭罐中，将炭罐中吸附的燃油“吹”向进气歧管，加入发动机燃烧中，以达到节约燃油和环保的目的。\n燃油箱是怎样布置的？ 现在，轿车用的燃油箱大多采用高分子高密度聚乙烯塑料制成。这种塑料燃油箱的优点是强度高，密封性好，容易制成符合布置空间的异形，从而可充分利用空 间，而且重量轻，耐腐蚀，抗冲击性好，在燃烧时也不易爆炸等。\n奥迪A8轿车燃油箱构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.12/","summary":"多点喷射和单点喷射有什么不同？ 如果每个气缸的进气歧管上都单独装配一个喷油器，每个喷油器只向一个气缸喷射燃油，那么就称之为多点喷射（M P I）。","title":"3.12 燃油供给系统 Fuel Supply System"},{"content":"机械增压器\n机械增压器是怎样工作的？ 机械增压（Supercharger）与涡轮增压的原理完全不同，它并不是依靠排出的废气来压缩进气，而是通过一个机械式的空气压缩机与曲轴相连，通过发动机曲 轴的动力带动空气压缩机旋转来压缩进气。压缩机是通过两个转子的相对旋转来压缩进气的。正因为需要通过曲轴转动的能量来压缩进气，机械增压会对发动机 输出的动力造成一定程度的损耗。\n机械增压器的特性也与涡轮增压器的特性刚好相反，由于机械增压器始终在“增压”，因此在发动机低转速时，其转矩输出就十分出色。另外，由于进气压缩量完 全是按照发动机转速线性上升的，整个发动机运转过程与自然吸气发动机极为相似，加速过程呈线性，没有涡轮增压发动机在涡轮介入那一刻的唐突，也没有涡 轮增压发动机的低速迟滞。但由于高转速时机械增压器对发动机动力的损耗巨大，因此在高转速时，其作用就不太明显了。\n机械增压器构造图\n带中冷器的机械增压发动机进气示意图\n机械增压器\n机械增压发动机工作原理示意图\n梅赛德斯-奔驰机械增压发动机构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.11/","summary":"机械增压器 机械增压器是怎样工作的？ 机械增压（Supercharger）与涡轮增压的原理完全不同，它并不是依靠排出的废气来压缩进气，而是通过一","title":"3.11 机械增压器 Supercharger"},{"content":"涡轮增压器\n涡轮增压器如何增压？ 涡轮增压（Turbocharger）发动机，是指利用排气冲击涡轮来压缩进气的增压发动机，简称Turbo或T。如果在一些轿车尾部看到字母Turbo或T，就表明该车 采用涡轮增压发动机。\n涡轮增压拥有良好的加速持续性，用通俗的话说就是后劲十足，而且最大转矩输出的转速范围宽广，转矩曲线平直。但是，低速时由于涡轮不能及时介入，导致 动力性稍差。\n大众汽车涡轮增压发动机构造图\n为什么要配备增压器？ 涡轮增压发动机原理示意图\n为什么涡轮增压器还要使用中冷器？ 气体有这样一个特性：当它受到压缩时，随着它的密度增加，它的温度也会上升，从而影响发动机的充气效率。如果想要进一步提高增压发动机的充气效率，就 要降低进气温度。\n热胀冷缩\n如果未经冷却的增压空气进入燃烧室，除了会影响发动机的充气效率外，还很容易导致发动机燃烧温度过高，造成爆燃等非正常燃烧，而且会增加废气中氮氧化 物的含量，加重排放污染。\n中冷器实际上就是个散热器，它被放置在通风良好的位置，吸收进气被压缩时产生的热量，从而降低进气温度。\n涡轮增压器\n奥迪2.5升直列5缸涡轮增压发动机\n涡轮增压器工作原理示意图\n为什么排气会有动力？ 排气的冲击力来自活塞上升时挤压燃烧废气的力量，当燃烧废气被“挤出”气缸时，废气就会带有一定的冲击力。\n双涡管单涡轮增压器是怎么回事？ 宝马直列6缸双涡管单涡轮增压发动机原理示意图\n宝马双涡管涡轮增压器\n4缸双涡管单涡轮增压器怎样工作？ 在宝马直列4缸双涡管单涡轮发动机排气系统中，将点火时间相邻的两个气缸的排气歧管两两分开（1和4一组，2和3一组），这样当3缸完成做功进行排气时， 1缸进入进气行程。由于1缸和3缸的排气歧管不相连，3缸的排气不会影响1缸的进气效果。其他缸工作时原理相同。这样点火相邻的两个缸的进排气不受干涉影 响，可以提高各个气缸的进排气量，从而有效提高发动机的效率。\n直列4缸双涡管单涡轮增压器构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.10/","summary":"涡轮增压器 涡轮增压器如何增压？ 涡轮增压（Turbocharger）发动机，是指利用排气冲击涡轮来压缩进气的增压发动机，简称Turbo或T。如","title":"3.10 涡轮增压器 Turbocharger"},{"content":"可变气缸和可变排量是怎么回事？ 每个厂商的可变气缸技术并不完全相同，但基本都是采用关闭气门和停止喷油的方式来关闭气缸的。\nDid You Know?\n在进排气凸轮轴上安装一套零行程的凸轮，当需要关闭部分气缸的工作时，只要指挥步进电动机使凸轮轴左右移动，就可以使部分气门处于零行程的工作状态， 也就是停止工作，使对应的气缸也停止工作\n奥迪可变气缸技术\n奥迪可变气缸发动机构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.09/","summary":"可变气缸和可变排量是怎么回事？ 每个厂商的可变气缸技术并不完全相同，但基本都是采用关闭气门和停止喷油的方式来关闭气缸的。 Did You Know? 在进排气凸轮轴上","title":"3.9 可变气缸 Variable Cylinder"},{"content":"可变气门有什么优点？ 当高转速时，需要吸入更多的空气（混合气），因此如果能把气门提得更高些（改变升程）或延长气门的打开时间（改变正时），便能满足需求，从而提高动 力； 反之低速时，则可以降低气门的升程或缩短打开时间，少吸入混合气，从而节省燃料。 奔驰可变气门\n宝马V12发动机可变气门发动机\n宝马Valvetronic电子气门是怎样工作的？ 宝马Valvetronic电子气门示意图\n宝马Valvetronic电子气门构造图\n宝马电子气门\n奥迪AVS可变气门是怎么回事？ 奥迪可变气门\n奥迪发动机可变气门构造图\n奥迪发动机可变气门AVS工作原理示意图\n本田VTEC可变气门是怎么回事？ 本田可变气门\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.08/","summary":"可变气门有什么优点？ 当高转速时，需要吸入更多的空气（混合气），因此如果能把气门提得更高些（改变升程）或延长气门的打开时间（改变正时），便能满","title":"3.8 可变气门技术 Variable Valve Technology"},{"content":"气缸内部构造图\n进气门和排气门\n进气门为什么比排气门大？ 因为进气是被“吸”进去的，而排气是被“推”出去的，所以进气比排气更困难，而且进气越多，燃烧得越好，发动机的性能也越好。因此，一般都将进气门设计得 比排气门大，以降低进气难度，提高进气量。有的干脆多设计一个进气门，这才有了3气门（2进1排）和5气门（3进2排）设计。\n气门构造及其辅助零件\n气门数为什么不能太多？ 多气门发动机具有高转速、高效率的优点。由于气门较多，高转速时进排气效果较好，且火花塞放在中央可提高压缩比，因此发动机性能也较好。但是，多气门 设计较复杂，气门驱动方式、燃烧室构造和火花塞位置都要精密安排，而且制造成本高，工艺要求先进，维修也较困难，其带来的效果并不是特别明显，或者说 有点不太划算。因此，现在基本放弃每缸5气门设计，而采用更为流行的每缸4气门设计。\n汽油发动机构造图\n为什么说凸轮轴像是指挥棒？ 在凸轮轴上，有数个圆盘形的凸轮。当凸轮轴旋转时，凸轮便会依序下压而使气门运动，使发动机产生四行程循环运动。同时，通过灵活控制凸轮轴的运行，还 可调节气门的升程和正时，从而提高发动机的性能。\n双顶置凸轮轴（DOHC）构造图\nV12发动机双顶置凸轮轴（DOHC）构造图\n配气正时机构示意图\n什么是顶置凸轮轴和双顶置凸轮轴？ 如果凸轮轴位于气缸的顶部，就称为顶置凸轮轴（Over Head Camshaft，简称OHC）。 如果在顶部只有一根凸轮轴同时负责进气门和排气门的开关，则称为单顶置凸轮轴（Single Over Head Camshaft，简称SOHC）。 如果在顶部有两根凸轮轴分别负责进气门和排气门的开关，则称为双顶置凸轮轴（Double Over Head Camshaft，简称DOHC） 奥迪V6发动机正时机构示意图\n为什么发动机需要正时？ 在进气、压缩、做功和排气四个行程中，曲轴要转两周，而进气门或排气门只动作一次。由此可知，凸轮轴的转速必须是曲轴转速的一半，才能上下合拍，也就 是达到正时。因此，凸轮轴齿（带）轮齿数是曲轴齿（带）轮齿数的两倍，以使它的转速慢下一半来。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.07/","summary":"气缸内部构造图 进气门和排气门 进气门为什么比排气门大？ 因为进气是被“吸”进去的，而排气是被“推”出去的，所以进气比排气更困难，而且进气越多，燃","title":"3.7 气门和气门正时 Valve and Valve Timing"},{"content":"为什么发动机要进气和排气？ 空气由进气口进入，通过空气滤清器过滤后，经进气歧管进入气缸，并在进气歧管内布置有节气门和空气流量计来控制和调节进气量。\n发动机排气系统的作用，是将已燃烧的废气排入大气。它主要由排气歧管、排气管和排气消声器组成，并在排气管段布置有三元催化转化器，以净化排气。\n汽油发动机进气和排气系统构造图\n节气门起什么作用？ 进气系统主要包括两大部件：\n一是空气滤清器，它主要滤清空气，去除空气中的杂质； 二是进气道，它将空气与燃油的混合气引入气缸。 在进气道中有节气门，它可控制进入气缸的混合气的多少。\n此节气门与驾驶人脚下的加速踏板（俗称“油门踏板”）直接相连，加速踏板踏下越深，节气门开度越大，混合气进入就越多，发动机的转速就越高。 如果加速踏板和节气门是通过电信号控制的，而不是拉索硬性连接，那么就称其为电子节气门（俗称“电子油门”）。 节气门体和进气歧管\n节气门在发动机上的位置图\nhttps://res.weread.qq.com/wrepub/epub_26688761_73\n进气歧管系统\n节气门体\n什么是理想空燃比？ 空气与汽油的混合比也称空燃比。根据计算，它的理想值大概在14.7∶1左右，也就是燃烧1千克的汽油需要吸入14.7千克的空气。如果按体积之比，则大概为 9000∶1，就是说要燃烧1升的汽油，必须吸入9000升的空气。这样算来，汽车每分钟要吸入3000～5000升的空气，而我们人体每分钟只需吸入6升空气就够用 了。\n为了提高进气量，人们想出了各种方法，比如增大发动机的排气量、采用进气歧管可变技术、采用气门可变技术、配备增压器等。可以说，现在的发动机技术， 基本就是指怎样精确调节进气的技术，使发动机顺畅呼吸，让燃油得到充分燃烧，从而提高动力，节省燃油，降低排放。\n每分钟吸入空气量比较\n为什么进气歧管长度可以变化？ 原理是根据需要打开或关闭进气歧管中的一些阀门，使进气“走捷径”或“绕道”来改变进气行程，从而调节进气量和进气速率。\n可变进气歧管长度示意图\n可变进气歧管发动机\n为什么排气歧管奇形怪状？ 排气歧管是指从排气门出来的七扭八歪的那部分金属管。由于每个气缸的排气时刻都不一样，为了保证每个气缸的排气顺畅，必须防止不同气缸之间的排气有干 扰。因此，在设计排气歧管时要遵循四项基本原则：\n排气歧管要尽可能长。 各缸排气歧管要尽可能等长。 各缸排气歧管要尽可能独立，互不干涉。 排气歧管内表面要尽可能光滑。 排气管上的部件相对要多一些，如氧传感器（2个）、三元催化转化器（1～2个）、消声器（1～2个），都要安装在排气管上。\n发动机排气歧管造型\n氧传感器起什么作用？ 氧传感器位置示意图\n发动机排气系统\n现在，汽车的发动机都采用电脑（ECU）控制燃油的喷射，必须精确地控制混合气的空燃比（空气和燃油比例的理想值为14.7∶1），才能使燃油的燃烧效率尽可 能高。氧传感器实际上就是测量排气中氧气含量的部件，当排气中氧气含量高于或低于规定时（也就是空燃比偏离理想值时），氧传感器就会向发动机ECU报告， ECU就会根据情况自动调节喷油量。\n目前，车辆大多安装有两个氧传感器，在三元催化转化器前后方各有一个。\n前方氧传感器的作用是检测发动机不同工况的空燃比，同时ECU根据该信号调整喷油量和计算点火时间。 后方氧传感器的作用主要是检测三元催化转化器的工作好坏，即催化器的转化率。通过与前氧传感器数据的比较，来检测三元催化转化器是否工作正常。 ","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.06/","summary":"为什么发动机要进气和排气？ 空气由进气口进入，通过空气滤清器过滤后，经进气歧管进入气缸，并在进气歧管内布置有节气门和空气流量计来控制和调节进气","title":"3.6 进气和排气系统 Intake and Exhaust System"},{"content":"为什么发动机会发出有节奏的声音？ 活塞在气缸中要完成吸气、压缩、燃烧和排气四个行程，才算是完成一个工作循环。在此期间，活塞要在气缸内上下各两次，曲轴则同时要旋转两周。\n为什么发动机的动力能够源源不断？ 活塞在气缸中上下移动，活塞下行到的最低点叫下止点，上行到顶点的位置称为上止点。上止点与下止点之间的距离称为行程。当活塞在上止点时，活塞顶端的 空间称为燃烧室。\n发动机工作原理\n发动机工作原理示意图\n气缸结构示意图\n前面所述的发动机，活塞在气缸中移动四个行程，也就是曲轴转720°（2周）才完成一次动力输出，因此称为四冲程发动机。\n如果活塞在气缸中移动两个行程，也就是曲轴转360°（1周）就可完成一次动力输出，则称为二冲程发动机。以前，在汽车上曾使用过二冲程发动机，但现在只 在摩托车上使用。二冲程发动机的进气和压缩动作可以在一个行程中完成，而燃烧做功和排气动作则在另一个行程完成。\n发动机内部构造图(四冲程)\n发动机工作原理\n二冲程\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.05/","summary":"为什么发动机会发出有节奏的声音？ 活塞在气缸中要完成吸气、压缩、燃烧和排气四个行程，才算是完成一个工作循环。在此期间，活塞要在气缸内上下各两次","title":"3.5 发动机工作循环 Engine Working Cycle"},{"content":"为什么发动机需要吸入大量的空气？ 书中没直接描述原因, 猜测是氧气不足时会导致能量转换效率不高.\n汽油蕴含巨大能量\n同等重量情况下，汽油所含能量大约是糖的3倍，木头的5倍，电池的200倍。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.04/","summary":"为什么发动机需要吸入大量的空气？ 书中没直接描述原因, 猜测是氧气不足时会导致能量转换效率不高. 汽油蕴含巨大能量 同等重量情况下，汽油所含能量大约","title":"3.4 发动机燃烧原理 Engine Combustion Principle"},{"content":"汽油在气缸内燃烧爆炸示意图\n为什么说发动机动力来自于爆炸？ 如果将汽油和空气按照最适合的燃烧比例（1∶14.7）混合，并对它们进行大力压缩使之温度上升，此时点燃它们就会产生更大的爆炸力。 将这种力量通过一系列的机构“引导”到车轮上，便会推动汽车前进。 发动机排气量和压缩比计算方式示意图\n为什么动力与排量大小有关？ 气缸排气量是指活塞从下止点到上止点所扫过的气体容积，它取决于缸径和活塞行程。 发动机排量是各气缸排量的总和，一般用c c（立方厘米）、m L （毫升）或L（升）来表示。 发动机的排量越大，每次吸入的可燃混合气就越多，燃烧时产生的动力就越强。 ","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.03/","summary":"汽油在气缸内燃烧爆炸示意图 为什么说发动机动力来自于爆炸？ 如果将汽油和空气按照最适合的燃烧比例（1∶14.7）混合，并对它们进行大力压缩使之温","title":"3.3 发动机工作过程 Engine Working Process"},{"content":"发动机的气缸有哪几种排列形式？ 最常见的有3种气缸排列形式：直列、V形和水平对置。 还有一种W形气缸排列形式，但这种形式较为少见，而且与V形发动机较为相似。 发动机气缸形式\n直列发动机气缸排列示意图\n水平对置发动机 宝马V8发动机构造示意图\nV8发动机\nV形发动机更先进吗？ V形发动机的气缸成一角度对向布置，还可以抵消一部分振动。V形发动机的缺点，就是必须使用两个气缸盖，结构较为复杂。 W形发动机为什么应用少？ 与V形发动机相比，W形发动机最大的问题，就是发动机由一个整体被分割为两个部分，在运作时必然会引起很大的振动，因此现在应用极少。 针对这一问题，大众汽车在W形发动机上设计了两个反向转动的平衡轴，让两个部分的振动在内部相互抵消。现在，只有大众汽车集团某些品牌车型采用W形发 动机，如W8、W12和W16等发动机。 奥迪W12发动机构造图\nW16气缸形式\nW形发动机气缸夹角示意图\nW12发动机气缸排列示意图\nW12发动机气缸体\n什么是内燃机和外燃机？ 我们经常把汽车发动机称为内燃机，难道还有外燃机？是的，外燃机是存在的，比如原来火车上用的蒸汽机，发电厂和轮船上使用的汽轮机等，都是外燃机。它 们都是利用燃料在发动机气缸的外部燃烧来产生动力的。如早期的蒸汽机，它利用燃料（木材、煤、煤气、柴油等）烧开锅炉中的水，使之产生高压蒸汽并进入 气缸内，利用蒸汽压力推动活塞做功，从而产生动力。\n内燃机则是相对外燃机而言的，它的燃料在气缸内燃烧。现在，汽车上用的汽油发动机和柴油发动机，都是内燃机。\n外燃机工作原理示意图\n内燃机工作原理示意图\n为什么说水平对置发动机更有个性？ 水平对置发动机的英文为Boxer Engine，含义就是“拳击手发动机”，简称为B型发动机。比如B6、B4发动机，分别代表水平对置6缸和4缸发动机。 由于相邻两个气缸水平对置，这种发动机可以很简单地相互抵消振动，使发动机运转更平稳。水平对置发动机的重心低，能让车头设计得又扁又低。这两点都 增强了汽车的行驶稳定性。 水平对置发动机本身就左右对称，因此它可使变速器等放置在车身正中，让汽车左右重量对称，而不会像大多数汽车那样重心偏向一侧。 水平对置发动机的动力输出轴方向与传动轴方向一致，因此不需要改变动力传递方向，而是可以直接与离合器、变速器对接，大大提高了动力传递效率，使汽 车的起动和加速更迅猛。 水平对置发动机的缺点是维修不方便，而且各缸点火间隔不一致，使其排气声音比较怪异。普通汽车极少装配水平对置发动机，现在只有保时捷、斯巴鲁和丰 田等仍在生产和使用这种发动机。 水平对置6缸发动机构造图\n水平对置发动机\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.02/","summary":"发动机的气缸有哪几种排列形式？ 最常见的有3种气缸排列形式：直列、V形和水平对置。 还有一种W形气缸排列形式，但这种形式较为少见，而且与V形发动","title":"3.2 气缸排列形式 Cylinder Arrangement"},{"content":"汽车动力从哪里来？ 汽车动力来源于它的“心脏”，也就是发动机。那么发动机的“心脏”是什么？气缸！\n汽油发动机构造剖视图\n直列4缸汽油发动机构造图\n发动机原理\n气缸数为什么不能太多？ 在同样功率的要求下，缸数越多，缸径就可越小，转速就可提高，发动机的运转平衡性也更好。但是，随着气缸数的增加，发动机的零部件数也成比例增加，从 而使发动机结构更复杂、可靠性降低、重量增加、制造成本和使用费用增加、油耗增加等。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.01/","summary":"汽车动力从哪里来？ 汽车动力来源于它的“心脏”，也就是发动机。那么发动机的“心脏”是什么？气缸！ 汽油发动机构造剖视图 直列4缸汽油发动机构造图 发","title":"3.1 发动机基本原理 Engine Principle"},{"content":"9.1 新消费主张带来新品牌崛起 我们通常把1995～2010年出生的一代人称为“Z世代”。\n“Z世代”是注重个体、追求悦己的一代。追求品质, 强调个性 “Z世代”是在互联网环境下成长起来的一代，被称为“互联网原住民”，更加习惯于在互联网上获取信息，并通过互联网进行社交活动。 社交平台的风向可以对“Z世代”的消费决策产生较大影响 各种各样的圈层文化，包括“饭圈文化”“二次元文化”等，这些圈层文化会影响人们的消费决策。 “Z世代”是在文化自信下成长起来的一代。喜欢传统文化、国潮元素、红色经典 “Z世代”消费者对国潮的喜爱，对于国产品牌来说是千载难逢的机会。\n表9-1 运动服饰品牌在天猫上的销售额排行(2021)\n“Z世代”消费者对于生活方式的新主张也将带来新的品牌成长机会。\n比如健康食品、无糖饮料赛道， 互联网已经成为“Z世代”相互交流的主要场所。\n“买网友们真实体验后相互种草推荐的商品”是一个新的消费决策方式，我们将其称为“互联网主张” 互联网运营能力将成为决定未来品牌分化趋势的关键变量 总之，未来消费品投资的第一个大方向就是顺着“Z世代”消费者的消费主张，寻找对应品牌标的的成长机会。关键在于对消费群体的了解，对品牌定位的把握，对网络 风向和热点的洞察。比如国潮崛起对应着国产品牌的崛起；健康的生活方式带来了无糖饮料、健康食品等领域的投资机会；互联网传播对应互联网运营能力强的消费品 品牌和新锐品牌的投资机会。\n9.2 关注新消费习惯带来的需求增长 从长远来看，当人们的收入增长之后，消费结构将会发生改变。其中，食品等必需品的支出占比将会下降，而服务类消费的占比将会提升。\n从什么地方能够找到新消费习惯形成的机会？\n人们的根本诉求是一个很好的出发点。比如对美的追求、对娱乐和刺激的需求、对陪伴和认同的渴望、对方便的需求、对新奇事物的好奇等。 图9-1 中国医美市场规模(2021)\n图9-2 2020年部分国家每千人医美诊疗次数\n健康、多元的生活方式也是一个新消费习惯带来的潜在投资机会。健身消费 文娱需求也是一个重要的发展方向。 电影、电视剧、文艺创作、游戏等 旅游 图9-3 全国旅游收入和增速\n懒人经济将是未来的重点方向。 器具，即帮我们省事的商品, 洗碗机, 洗菜机, 烘干机, 扫地机器人 让人们“懒”的服务. 餐饮业, 外卖, 跑腿 新消费需求往往在大家的生活中潜移默化地生成，其发展很多时候具备长期的趋势性，而不会像技术突破那样猛烈。这样的匀速持续增长，恰恰是最适合价值投资者长 期发挥的领域——不但要发现这些投资机会，也要拿得住持续上涨的股票。\n9.3 新技术的突破 增长最迅猛的一类消费品投资机会基于技术突破，更好地满足了人们的一些固有需求。这类技术突破直接体现为消费品渗透率的直接提升\n比如电池技术的量变引发质变带来了电动车的普及 移动互联网带宽的提升带来了短视频和直播电商等。 技术突破带来的投资机会往往来势迅猛，投资者往往会因为错过了新科技龙头企业的成长机会而捶胸顿足。但从另一个角度看，追逐新技术的投资往往也伴随着高风险。 大多数自身无明显信息优势、技术背景不深的投资者，在参与这类机会时，应该三思而后行。\n","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC9%E7%AB%A0-%E6%9C%AA%E6%9D%A5%E6%B6%88%E8%B4%B9%E5%93%81%E6%96%B0%E6%9C%BA%E4%BC%9A/","summary":"9.1 新消费主张带来新品牌崛起 我们通常把1995～2010年出生的一代人称为“Z世代”。 “Z世代”是注重个体、追求悦己的一代。追求品质, 强调个性","title":"第9章 未来消费品新机会"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/hh1024/","summary":"主页","title":"红人点集"},{"content":"2.1 HTTP/1.1和当前的万维网 图2.1　网站加载内容平均大小（2014年—2018年）\n表2.1　美国访问量排名前10网站\n2.1.1 HTTP/1.1根本的性能问题 图2.2　在一个简单的网站示例中，HTTP请求及响应的流程\n处理时间在整个请求流程中占比很小, 大部分时间都在等待, 效率低 现代互联网最大的问题之一是延迟而不是带宽。 2.1.2 HTTP/1.1管道化 图2.3　简单示例网站的HTTP管道化\n管道化技术应该会对HTTP带来巨大的性能改善，但由于多种原因，它很难实现，易于出错，并且没有获得Web浏览器和Web服务器的良好支持。因此，它很少被 使用。没有一个主流的Web浏览器支持管道化技术。\n即使管道化技术得到了更好的支持，它仍然需要按照请求的顺序返回响应。如果图像2可用，但必须从另一台服务器获取图像1，则图像2的响应会等待，即 使应该可以立即发送图像2。此问题被称为队头（HOL）阻塞问题，在其他网络协议及HTTP中很常见。\n2.1.3 网络性能瀑布流图 图2.4　示例网站的请求瀑布图\n图2.5　示例网站使用管道化技术的瀑布图\n在这两个示例中，第一条垂直线表示可以渲染初始页面的时间（称为开始绘制时间或开始渲染时间），第二条垂直线表示页面何时加载完成。浏览器通常会在下 载图像之前尝试绘制页面，并在稍后填充图像，因此图像下载通常在这两个时间之间。\n图2.6　webpagetest.org上的瀑布图\n它将每个请求分成几个部分\nDNS查询 网络连接时间 HTTPS（或SSL）协商时间 请求的资源分类（并且还将资源负载分成两部分，用于请求的颜色较浅，用于响应的颜色较深） 加载页面各个阶段的各种垂直线 其他图表，显示CPU使用率、网络带宽，以及浏览器工作在哪个主线程中 2.2 解决HTTP/1.1性能问题的方案 随着时间的推移，已经有各种突破HTTP/1.1的性能限制的技术，这些技术分为以下两类：\n使用多个HTTP连接。 合并HTTP请求。 其他的和HTTP关联不大的性能优化技术，包括优化用户请求资源的方式（比如先请求关键CSS），减小下载资源的大小（压缩和使用响应式图片），减少浏览器 的渲染任务（更高效的CSS和JavaScript）。这些技术的细节超出了本书的讨论范围，但我们会在第6章涉及一些。Manning出版社所出版的 Web Performance in Action（Jeremy Wagner著）一书，是学习这些技术 的绝佳资料。\n\u0026laquo;Web性能实战\u0026raquo; 内容可能有点旧.\n2.2.1 使用多个HTTP连接 与管道化技术不同，该技术不会导致HOL阻塞，因为每个HTTP连接都独立于其他HTTP连接。因此，大多数浏览器可以为每个域名打开6个连接。\n为了进一步突破6个连接的限制，许多网站从子域提供静态资源, 如图像、CSS和JavaScript，Web浏览器从而可以为每个新域名打开另外6个连接。这种技术称 为域名分片\n除了提高并发数，域名发散还有其他优势，比如减小HTTP请求首部（如cookies） 图2.7　stackoverflow.com使用多个域名加载资源\n使用多个http连接的缺点\n打开TCP连接需要时间 维护连接需要更多的内存和CPU资源。 图2.8　TCP三次握手\nTCP在开启连接时比较小心，在确认网络不拥堵之前只会发送比较少的数据包。CWND（Congestion Window，拥塞窗口）随着时间的推移逐渐增加，只要连接 没发现丢包，就可以处理更大的流量。\nTCP拥塞窗口的大小受TCP慢启动算法控制。 在拥塞窗口中的TCP数据包需要在收到ACK消息之后发送。 在CWND比较小时，可能需要多个TCP ACK消息才能发出一个完整的HTTP请求。 HTTP响应常常比请求大很多，所以它同样也会受到拥塞窗口的影响。 最后，就算没有TCP建立连接的开销和慢启动的问题，使用多个独立的连接也可能导致带宽问题。例如，如果所有带宽都用掉了，就会导致TCP超时，和其他的 连接上的重传。在这些独立的连接之间，没有优先级的概念，这就无法更高效地利用带宽。\n优先级如何使带宽高效利用?\n创建TCP连接之后，安全的网站要求建立HTTPS连接。这个过程可以节约开销，比如，重用TCP连接的参数，不从零开始。但这个过程依然需要更多的网络往返，这意 味着更多的时间。\n使用多个连接会导致额外的tcp/https握手过程, 反而导致延迟问题. 过多的连接数, 收益会比较低 2.2.2 发送更少的请求 减少不必要的请求, 比如在浏览器中缓存静态资源(相当于不发请求) 以更少的HTTP请求获取同样的资源(打包合并静态资源) 对于图片来说，这种打包技术叫作精灵图。\n图2.9　TinyPNG的精灵图\n如果是CSS和JavaScript文件，很多网站就将多个文件合并为一个文件，这样需要的请求数就少了，但是总的代码量并不少。在合并文件的时候，通常还会去掉代码 中不必要的空格、注释和其他不必要的元素，以减小CSS和JavaScript的文件尺寸。这些方法都会提升效率，但是会增加配置的难度。\n其他的技术还包括内联资源到其他文件。比如，Critical CSS经常直接被内联在HTML的\u0026lt;style\u0026gt;标签中。图片可以包含在CSS中，通过行内SVG，或者转换为 Base64编码，也能减少HTTP请求数。\n另外一个问题是，合并会导致文件的浪费。\n一些网页可能只用到一张精灵图中的一两个图标，但却要下载整张精灵图。 当有新的精灵图时，还要重写CSS文件，以防止新的精灵图中图标的位置发生变化。 同样，如果合并了太多文件，JavaScript也可能会变得臃肿。有时候我们只需要其中的很少一部分，却要下载一个大得多的文件。 无论是从网络的方面（特别在开始的时候，TCP启动慢）还是从浏览器执行的方面（浏览器需要处理它不需要的代码）来说，这种技术都不够高效。 最后一个问题是缓存。\n如果把精灵图缓存了很长一段时间（这样用户就不需要频繁下载它），当需要添加一个图标的时候，必须让浏览器再次下载整个精灵图，但访客并不需要。 可以使用很多技术来解决这个问题，比如添加版本号或者使用查询参数，但是这些技术也会浪费资源。使用CSS和JavaScript也一样，改变一行代码就需要重新下 载整个合并文件。 2.2.3 HTTP/1性能优化总结 归根到底，优化HTTP/1性能的方法是一些解决HTTP/1基础缺陷的小技巧。应该有更好的办法在协议层面解决这个问题，从而节省时间，这正是HTTP/2要做的。\n2.3 HTTP/1.1的其他问题 基于文本的协议处理起来复杂易出错, 还会导致安全问题. 文本协议编码效率不高, 体积大 首部内容有重复 就算只有主页需要cookie，每个发向服务器的HTTP请求中都会包含cookie。 纯文本协议的安全和隐私问题（HTTPS加密很好地解决了这个问题） 缺少状态的问题（cookie在一定程度上解决了这个问题）。 2.4 实际案例 用于测试web性能的WebPageTest\n2.4.1 示例网站1: amazon.com 图2.10　www.amazon.com的部分运行结果\n首个请求是主页的请求\n图2.11　首页的第一个请求\nHTML引用了几个CSS文件\n图2.13　图片下载\n图2.14　加载amazon.com的连接视图\n2.4.2 示例网站2：imgur.com 图2.15　imgur.com的瀑布图\n图2.16　Chrome开发者工具中imgur.com的瀑布图\n2.4.3 这个问题究竟有多严重 你必须认识到，和其他性能问题想比，HTTP协议的问题有多严重。导致网站缓慢的原因很多，从网络连接的质量到网站的大小，再到某些网站可能使用荒唐的 JavaScript文件数，再到越来越多的性能低下的广告、数据追踪服务，等等。尽管更高效和更快地下载资源可以解决一部分问题，但是很多网站还是会慢。很多网站 清楚地知道HTTP协议对网站性能的影响，所以他们实现了一些优化HTTP/1.1性能的方法。但是因为这些方法复杂且难以理解，所以很多其他的网站没有实现。\n另外一个问题是，这些解决方案也有一些限制。这些方案本身也会引入低效率的因素，随着网站内容和复杂度的增加，最终这些变通的解决方案也会失效。尽管浏览器 在每个域名上打开6个连接，并且可以增大这个数，但这么做的收益较低，这也是为什么浏览器限制并发的连接数为6个，尽管站长们可以通过域名分片的方法来突破这 个限制。\n2.5 从HTTP/1.1到HTTP/2 工作组曾经展开过新版本的工作（HTTP-NG)，该工作本应对HTTP的工作方式做完全的重新设计，但是1999年该工作被中止了。人们普遍感觉这些变化太复杂，无法 推广。\n2.5.1 SPDY HTTP-NG尝试解决HTTP/1的多种问题，而SPDY的主要目标是解决HTTP/1.1的性能问题。它引入了一些关键的概念来解决HTTP/1.1的问题：\n流多路利用 —— 请求和响应使用单个TCP连接传输数据，它们被分成不同的数据包，以流的方式分组。 请求优先级 —— 在同时发送所有请求时，为了避免引入新的性能问题，引入了请求优先级的概念。 HTTP首部压缩 —— HTTP体早就可以压缩了，现在首部也可以压缩了。 SPDY在HTTP层实现了TCP的相关概念，所以它可以同时传输不同的HTTP消息。\n服务器推送这种高级功能，允许服务器返回额外的资源。如果你请求主页面，服务器可以在主页面的请求中推送所需要的CSS文件内容。这种方式可以节省浏览器再次 发送CSS请求的时间，也能避免将critical CSS变为行内样式带来的复杂度。\n图2.17　自HTTP/2发布以来，SPDY的支持率下降\n2.5.2 HTTP/2 我想要强调的是，HTTP/2已经向你走来，请尽情使用它。它已经在实际应用中得到验证，可以显著提高性能，而且它解决了本章中描述的HTTP/1.1的问题。\n2.6 HTTP/2对Web性能的影响 2.6.1 展示HTTP/2能力的绝佳示例 作者的网站\n图2.18　HTTP、HTTPS、HTTP/2性能测试\n图2.19　HTTPS测试的瀑布图。忽略第18行，其是个302响应。\n图2.20　HTTP/2测试的瀑布图\n图2.21　HTTP/2下的延迟和瀑布图\n2.6.2 对HTTP/2提升性能的期望 如果网站还有其他性能问题，那么切换到HTTP/2后可能看不到任何性能提升，这也意味着HTTP/1.1的低效率对这些网站来说问题不大。\n对于一些网站，还有两个原因会导致使用HTTP/2没什么改善。\n第一个原因是这些网站已经优化得足够好了——使用2.2节中提到的变通办法，由HTTP/1带来的缓慢问题比较少。 其他的性能问题远超HTTP/1带来的影响。 让HTTP/2变慢的其他情况还是网络丢包\n表2.2　HTTP/2可能给Amazon带来的提升\n加载时间指页面发起onload事件的时间 —— 通常指所有的CSS和阻塞式JavaScript加载完成的时间。 首字节时间指从网站收到第一个字节的时间。通常，此响应是第一个真正的响应，不是重定向。 开始渲染时间指页面开始绘制的时间。此指标是一项关键性能指标，因为如果用户没有看到正在访问的页面有更新，他们可能会离开。 视觉完整时间指页面停止变化的时间，通常在初始加载时间之后很久，异步的JavaScript可能还在更新页面。 speed index为由WebPagetest计算的页面每部分加载的平均时间，以ms为单位。 图2.22　通过HTTP/1加载Amazon主页的一个副本\n图2.23　通过HTTP/2加载Amazon主页的一个副本\n2.6.3 HTTP/1.1的一些性能变通方法可能是反模式 例如，如果网站使用域名分片并强制使用多个连接，则无法享受使用单个TCP连接加载网站带来的性能提升。HTTP/2使得在默认情况下创建一个高性能网站变得更加 简单。\n然而，事实并非如此简单，，在HTTP/2的应用更加广泛之前，完全放弃这些技术可能为时尚早。在客户端，尽管有强大的浏览器支持，一些用户仍会使用HTTP/1.1。 他们可能正在使用较旧的浏览器，或通过尚不支持HTTP/2的代理（包括防病毒扫描程序和公司代理）进行连接。\n总结 HTTP/1.1存在一些根本的性能问题，特别是在获取多个资源时。 对于这些性能问题有多种变通的解决方法（使用多个连接、域名分片，以及使用精灵图等），但它们有其自身的缺点。 可以通过WebPageTest等工具生成瀑布图，从中很容易看到性能问题。 SPDY旨在解决这些性能问题。 HTTP/2是SPDY的标准化版本。 并非所有性能问题都可以通过HTTP/2解决。 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC1%E9%83%A8%E5%88%86-%E5%90%91http2%E9%9D%A0%E6%8B%A2/%E7%AC%AC2%E7%AB%A0-%E9%80%9A%E5%90%91http2%E4%B9%8B%E8%B7%AF/","summary":"2.1 HTTP/1.1和当前的万维网 图2.1 网站加载内容平均大小（2014年—2018年） 表2.1 美国访问量排名前10网站 2.1.1 HTTP/1.1根本","title":"第2章 通向http2之路"},{"content":"1.1 万维网的原理 HTTP是访问远程Web应用和资源的关键技术。\n1.1.1 因特网与万维网 因特网(Internet)和万维网(World Wide Web或Web)的区别\n因特网是使用IP（Internet Protocol，因特网协议）连接在一起实现消息传递的计算机构成的网络。因特网上有很多服务，包括万维网，以及电子邮件、 文件共享、因特网电话等。 因此万维网（注意，是World Wide Web，简称Web）只是因特网上的一种服务形式，但其却是人们最常看到的形式，因为人们经常会通过Web应用（如 Gmail、Hotmail和Yahoo!）来收发邮件。我们日常所说的上网，既可以理解为上万维网，也可以理解为上因特网。 Tim Berners-Lee当初发明万维网时，一共创造了三项核心技术\nHTTP URL HTML 1.1.2 打开网页时会发生什么 假设我们打开浏览器访问www.google.com。在接下来的几秒钟内，会发生下面这些事情\n图1.1　浏览器请求网页时的典型交互过程\n由于因特网是全球性的，所以大公司通常会把服务器部署在世界各地。我们在向DNS查询IP地址时，通常会得到一个距离你最近的服务器的IP地址，以便你能快 速访问。\n怎么没有IPv5? IP包的前4位表示版本，理论上限是15个版本。在被广泛使用的IPv4以前，出现过0～3共4个实验性版本。但是，直到第4版，这几个版本一直没有被标准化（参 见: https://tools.ietf.org/html/rfc760 , 这个协议后来被升级和替换了，见 https://tools.ietf.org/html/rfc791 )。此后，第5个版本被 指定为Internet Stream Protocol，其主要在实时音频和视频流应用中使用，与VoIP（Voice over IP，IP语音）后来的发展类似。可是，这个版本一直 没启用，原因之一就是存在与第4版一样的地址限制。后来第6版出来的时候，第5版的工作被叫停，于是IPv6就成了IPv4的后续版本。据说一开始由于人们以为 6也被占用了，所以IPv6最早被称为第7版(参见 https://archive.is/QqU73#selection-417.1-417.15 )。版本7、8、9同样也被占用，而且以后也不 会再使用了。假如IPv6还有后续版本，很可能会是IPv10或更高的版本。到时候，无疑还会导致与今天类似的疑惑。\n你的浏览器会自动将简短的网址（www.google.com）扩展为语法上更为准确的URL地址（http://www.google.com）。 而包含端口在内的完整URL应该是http://www.google.com:80，只不过在使用标准端口（80用于HTTP，443用于HTTPS）的情况下，浏览器会隐藏端口号。 如果使用的是非标准端口，端口就会被显示出来。比如在某些环境特别是开发环境下，HTTP可以使用8080端口，HTTPS则可以使用8443端口。\n1.2 什么是HTTP OSI模型（Open System Interconnection，开放式系统互联通信参考模型）\n图1.2　网络数据传输的分层\n1.3 HTTP的语法和历史 1.3.1 HTTP/0.9 HTTP的第一个规范是1991年发布的0.9版本。\n该规范指定\n通过TCP/IP（或类似的面向连接的服务）与服务器和端口（可选的，如果未指定端口，则使用80）建立连接。 客户端应发送一行ASCII文本，包括GET、文档地址（无空格）、回车符和换行符（回车是可选的）。 服务器使用HTML格式的消息进行响应，该消息被定义为“ASCII字符的字节流”。规范还指定，“通过服务器关闭连接来终止消息”，所以在每个请求之后 都关闭连接。 在处理错误时，规范声明：“错误响应以可读的文本显示，使用HTML语法。除了文本的内容，没有办法区分错误响应和正确响应。” 在文档结尾处，规范指出：“请求是幂等的。服务器不需要在断开连接后存储关于请求的任何信息。”本规范为我们提供了HTTP的无状态特性，这是一把双刃 剑，有利（这很简单）也有弊（因为必须附加HTTP cookies等技术以允许状态跟踪，这对于复杂的应用程序是必需的）。 HTTP/0.9可能仅有的指令\nGET /section/page.html↵ 1.3.2 HTTP/1.0 HTTP/1.0新增了一些关键特性\n更多的请求方法。除了先前定义的GET方法，新增了HEAD和POST方法。 为所有的消息添加HTTP版本号字段。此字段是可选的，为了向后兼容，默认情况下使用HTTP/0.9。 HTTP首部。它可以与请求和响应一起发送，以提供与正在执行的请求或发送的响应相关的更多信息。 一个三位整数的响应状态码，（例如）用来表示响应是否成功。此状态码还可以用来表示重定向请求、条件请求和错误状态 HTTP/1.0旨在记录现实世界中多数Web服务器上已经发生的事情，而不是定义新的功能/语法。\nHTTP/1.0的方法\nGET方法与HTTP/0.9中的基本相同，但是新增的首部允许客户端发送条件GET（仅当在客户端上次请求之后，资源发生变化时，才请求资源内容；否则，告诉 客户端资源没变化，继续使用旧的副本）。此外，用户可以使用GET方法获取更多的资源，而不仅仅是超文本文档，比如使用HTTP下载图像、视频或其他 类型的媒体内容。 HEAD方法允许客户端获取资源的所有元信息（例如HTTP头）而无须下载资源本身。 POST方法允许客户端发送数据到Web服务器。也就是说，POST方法允许将内容作为HTTP请求的一部分从客户端发送到服务器，这表示 HTTP请求终于和HTTP响应一样，拥有了正文部分。 GET方法允许将数据包含在URL尾部指定的查询参数中发送，通常放在?字符之后。 URL受到长度和内容方面的限制（例如，无法发送二进制数据），并且某些机密数据（密码、信用卡数据等）也不应出现在URL中，因为很容易就可以在屏幕和 浏览器历史记录中看到这些数据。 POST方法通常是一种更好的数据发送方式，其中的数据也不是那么显而易见（尽管在通过透明的HTTP而不是安全的HTTPS发送时仍应小心）。 是GET请求是幂等的，而POST请求不是。 HTTP请求首部\n没有首部的情况\n可以发送具有相同名称的多个首部\n等于\n一个经典的HTTP/1.0 GET请求\nHTTP响应状态码\n表1.1　HTTP/1.0响应码\nHTTP响应首部\n1.3.3 HTTP/1.1 HTTP/1.1更像是对HTTP/1.0的调整，它没有从根本上改变协议。从0.9到1.0是一个较大的变化，增加了HTTP首部。HTTP/1.1做了进一步的改进，以便充分 利用HTTP协议（例如，持久连接、强制响应首部、更好的缓存选项和分块编码）。更重要的是，它提供了一个正式标准，后来的万维网正是基于它构筑。虽然 HTTP的基础知识很容易理解，但是里面许多错综复杂的细节、实现方式的不同，以及正式标准的缺乏使得它难以扩展。\n强制添加Host首部\n如今，很多Web服务器上面有多个网站（虚拟主机托管），所以告诉服务器要访问哪个网站和访问哪个相对URL同样重要。此功能可以通过下面的方法实现：将 HTTP请求中的URL修改为完整的包含绝对路径的URL。但如果采用这种方法，则很多现有的Web服务器和客户端都不能正常运行。所以，我们在请求首部中添加 Host来实现该功能：\n指定强制Host首部字段，而不是将相对URL更改为绝对URL，带来了一些争论。HTTP/1.1引入的HTTP代理允许通过中间HTTP服务器连接到目标HTTP服务器。 代理的语法要求所有的请求使用完整的绝对URL，但实际的Web服务器（也称为源服务器）要求强制使用Host首部。\n持久连接（也就是KEEP-ALIVE）\nHTTP/1.0服务器是支持持久连接的, 但不在HTTP/1.0规范中\n服务器像往常一样响应，但如果它支持持久连接，它会在响应中包含一个Connection: Keep-Alive首部\nHTTP/1.1不仅将持久连接添加到文档标准中，还将其作为默认行为。即使响应中没有Connection:Keep-Alive首部，也可以假定任何HTTP/1.1连接都 使用持久连接。如果服务器确实想要关闭连接，无论出于何种原因，则它必须在响应中显式包含Connection:close HTTP首部\n在此基础上，HTTP/1.1增加了管道的概念，因此应该可以通过同一个持久连接发送多个请求并按顺序获取响应。\n由于某些原因，管道化并没有流行起来，并且客户端（浏览器）和服务器对管道化的支持都很差。因此，虽然持久连接允许在同一个TCP上顺序发出多个请 求，这也是一个很好的性能改进，但大多数HTTP/1.1的实现仍然是遵循请求响应再请求再响应的模式的。当一个请求被处理时，HTTP连接被阻塞，不能用于其 他请求。\n其他新功能\nHTTP/1.1又定义了新的方法，如PUT、OPTIONS和比较少见的CONNECT、TRACE及DELETE。 更好的缓存方法。这些方法允许服务器指示客户端将资源（例如CSS文件）存储在浏览器的缓存中，以便在以后需要时重复使用。在HTTP/1.1中引入的 Cache-Control HTTP首部比HTTP/1.0中的Expires首部的选项更多。 HTTP cookies，允许HTTP维护状态。 引入字符集（如本章的一些例子所示），在HTTP响应中新增语言选项。 支持代理。 支持权限验证。 新的状态码。 尾随首部 1.4 HTTPS简介 HTTPS是HTTP的安全版本，它使用TLS（Transport Layer Security，传输层加密）协议对传输中的消息进行加密，TLS的前身是我们熟知的SSL（Secure Sockets Layer，安全套接字层）\nHTTPS对HTTP消息添加了三个重要概念\n加密——传输过程中第三方无法读取消息。 完整性校验——消息在传输过程中未被更改，因为整个加密消息已经过数字签名，并且该签名在解密之前已通过加密验证。 身份验证——服务器不是伪装的。 SSL、TLS、HTTPS和HTTP\nHTTPS使用SSL或TLS加密。SSL是由Netscape发明的。SSLv1从未在Netscape之外发布，因此第一个生产版本是1995年发布的SSLv2。1996年发布的 SSLv3解决了一些安全漏洞。 由于SSL由Netscape拥有，因此它不是正式的互联网标准，尽管它随后由IETF作为历史文档发布。SSL被标准化为TLS（传输层加密）。 TLSv1.0与SSLv3类似，但它们不兼容。 TLSv1.1和TLSv1.2分别于2006年和2008年推出，并且它们更加安全。 TLSv1.3在2018年被批准为标准。虽然还需要一些时间它才能普及，但它更安全，更高效。 在2014年，在SSLv3中发现了重大漏洞，SSLv3因此被要求停止使用，并且浏览器也停止对它的支持。从这时人们才开始大量向TLS迁移。在TLSv1.0中发 现类似的漏洞后，安全专家强烈建议使用TLSv1.1或更高版本。 HTTPS使用公钥加密，服务器在用户首次连接时以数字证书的形式提供公钥。\nHTTPS的一个重大问题是，它只保证你正在连接到该服务器，而不能保证服务器值得信任。 HTTPS站点通常在Web浏览器中显示为绿色挂锁，许多用户认为这意味着安全，但其实它仅仅意味着加密。 OpenSSL提供了一个s_client命令，可使用该命令将HTTP命令发送到HTTPS服务器，和使用Telnet类似：\n1.5 查看、发送和接收HTTP消息的工具 1.5.1 浏览器开发者工具 1.5.2 发送HTTP请求 Advanced REST Client\n1.5.3 其他工具 curl, wget, httpie, SOAP-UI, Chrome的net-internals页面, Fiddler, Wireshark\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC1%E9%83%A8%E5%88%86-%E5%90%91http2%E9%9D%A0%E6%8B%A2/%E7%AC%AC1%E7%AB%A0-%E4%B8%87%E7%BB%B4%E7%BD%91%E4%B8%8Ehttp/","summary":"1.1 万维网的原理 HTTP是访问远程Web应用和资源的关键技术。 1.1.1 因特网与万维网 因特网(Internet)和万维网(World Wide Web或Web)","title":"第1章 万维网与HTTP"},{"content":"谓词逻辑中的层级、集合论中的层级 对于EXISTS来说，层级的差别与EXISTS谓词及其参数有关，因此属于谓词逻辑中的阶。而GROUP BY中的阶与元素和集合的区别有关，因此属于集合论中的阶。\n为什么聚合后不能再引用原表中的列 Teams\n首先，我们还是以组为单位进行聚合查询。\n1 2 3 4 5 6 7 8 9 10 11 12 --以组为单位进行聚合查询 SELECT team, AVG(age) FROM Teams GROUP BY team; team AVG(age) ---- -------- A 23.3 B 34.5 C 30.0 D 25.5 那么如果我们把它改成下面这样，结果会怎么样呢？\n1 2 3 4 --以组为单位进行聚合查询？ SELECT team, AVG(age), age FROM Teams GROUP BY team; 标准SQL规定，在对表进行聚合查询的时候，只能在SELECT子句中写下面3种内容。\n通过GROUP BY子句指定的聚合键 聚合函数（SUM、AVG等） 常量 表Teams中的“age”列存储了每位成员的年龄信息。但是需要注意的是，这里的年龄只是每个人的属性，而不是小组的属性。所谓小组，指的是由多个人组成的 集合。因此，小组的属性只能是平均或者总和等统计性质的属性。\nGROUP BY的作用是将一个个元素划分成若干个子集。这样看的话，关系模型中“列”的正式名称叫作“属性”，其实也是有道理的。\n下面这条语句的错误也是相同的原因造成的。\n1 2 3 4 --错误 SELECT team, AVG(age), member FROM Teams GROUP BY team; 向小组询问姓名是不会得到回答的。如果非要在结果中包含“member”列的值，那么只能像下面这样使用聚合函数。\n1 2 3 4 --正确 SELECT team, AVG(age), MAX(member) FROM Teams GROUP BY team; MAX(member)会计算出小组成员中以字典序排序后最后一个人的姓名，因此这无疑是小组的属性。\n如果稍微扩展一下这条查询语句，我们还可以求出“小组中年龄最大的成员”，SQL语句如下所示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 SELECT team, MAX(age), (SELECT MAX(member) FROM Teams T2 WHERE T2.team = T1.team AND T2.age = MAX(T1.age)) AS oldest FROM Teams T1 GROUP BY team; team max(age) oldest ----- -------- ------ A 28 大木 B 40 山田 C 30 桥田 D 28 野野宫 这条语句的关键点有两个。\n第一个是，子查询中的WHERE子句里使用了MAX(T1.age)这样的聚合函数作为条件。我们在初学SQL时，会学到不可以在WHERE子句中使用聚合函数，但是在 本题中却是可以的。原因是，这里对外层的表T1也进行了聚合，这样一来我们就可以在SELECT子句中通过聚合函数来引用“age”列了（不能反过来在子查询 中直接引用“age”列）。 另一个是，当一个小组中年龄最大的成员有多人时，必须选出其中一个人作为代表。这个是通过子查询中SELECT子句里的MAX(member)来实现的。例如，D 小组中野野宫和鬼塚两人的年龄都是最大的，但是结果中只出现了野野宫一人。如果不使用MAX函数，那么子查询会返回多条数据，这样就会出现执行错误。 单元素集合也是集合 只有一个元素的集合，在集合论中叫作单元素集合（singleton）。一般来说，单元素集合的属性和其唯一元素的属性是一样的。\n现在的集合论认为单元素集合是一种正常的集合。单元素集合和空集一样，主要是为了保持理论的完整性而定义的。因此对于以集合论为基础的SQL来说，当然也 需要严格地区分元素和单元素集合。因此，元素a和集合{a}之间存在着非常醒目的层级差别。\n1 a ≠ {a} 这两个层级的区别分别对应着SQL中的WHERE子句和HAVING子句的区别。\nWHERE子句用于处理“行”这种0阶的对象 而HAVING子句用来处理“集合”这种1阶的对象。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-10-sql%E4%B8%AD%E7%9A%84%E5%B1%82%E7%BA%A7/","summary":"谓词逻辑中的层级、集合论中的层级 对于EXISTS来说，层级的差别与EXISTS谓词及其参数有关，因此属于谓词逻辑中的阶。而GROUP BY中的","title":"2-10 SQL中的层级"},{"content":"~告全体数据库工程师书~ NULL这个怪物最可怕的地方：一开始会让我们觉得很好用，于是在设计系统时，我们会非常自然地保留它，但当注意到问题的时候，系统已经变得非常复杂、低 效、不符合预期了，开发和维护也变得非常困难。\n为什么NULL如此惹人讨厌 在进行SQL编码时，必须考虑违反人类直觉的三值逻辑。 在指定IS NULL、IS NOT NULL的时候，不会用到索引，因而SQL语句执行起来性能低下。 如果四则运算以及SQL函数的参数中包含NULL，会引起“NULL的传播”。 在接收SQL查询结果的宿主语言中，NULL的处理方法没有统一标准。 与一般列的值不同，NULL是通过在数据行的某处加上多余的位（bit）来实现的。因此NULL会使程序占据更多的存储空间，使得检索性能变差。 对于第3个原因，我们来稍微解释一下。例如，如果四则运算中包含NULL，那么运算结果也肯定都是NULL。\n1 2 3 4 5 1 + NULL = NULL 2- NULL = NULL 3 ＊ NULL = NULL 4 / NULL = NULL NULL / 0 = NULL 并不能完全消除NULL 无法完全消除NULL的原因是它扎根于关系数据库的底层中。仅仅靠在表中所有列加上NOT NULL的约束是不够的。因为即使这样做，在使用外连接，或者SQL-99 中添加的带CUBE或ROLLUP的GROUP BY时，还是很容易引入NULL的。\n编号：使用异常编号 标志性编号, 例如性别\n使用varchar/char not null类型 1: 男性, 2: 女性, 0: 未知, 9: 不适用 名字：使用“无名氏” 一般来说，与编号相比，名字被用于聚合的频度很低，大多时候只作为冗余列使用。我们不用刻意地消除其中的NULL，但是最好还是让NULL从名字列中消失。\n数值：用0代替 转换为0。 如果一定要区分0和NULL，那么允许使用NULL。 日期：用最大值或最小值代替 当需要表示开始日期和结束日期这样的“期限”的时候，我们可以使用0000-01-01或者9999-12-31这样可能存在的最大值或最小值来处理。\n当默认值原本就不清楚的时候，例如历史事件发生的日期，或者某人的生日等，也就是当NULL的含义是“未知”的时候，这时可以允许使用NULL。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-9-%E6%B6%88%E7%81%ADnull%E5%A7%94%E5%91%98%E4%BC%9A/","summary":"~告全体数据库工程师书~ NULL这个怪物最可怕的地方：一开始会让我们觉得很好用，于是在设计系统时，我们会非常自然地保留它，但当注意到问题的时","title":"2-9 消灭NULL委员会"},{"content":"适当地抛开命题的真假吧 历史上最早提出三值逻辑（three-valued-logic）体系的是波兰的著名逻辑学家卢卡西维茨（Jan Lukasiewicz, 1878—1956）。\n卢卡西维茨考虑的“可能”这一真值的本质，其实是对未来不确定性的描述，丝毫没有Codd提出的“不适用”的含义。 第二个论点突破了一个命题只能有一个固定真值的观念，开拓出了新的思路，认为命题的真值可能会随时间发生“可能”→“真”，或者“可能”→“假”这样的变 化。 逻辑学的革命 除了三值逻辑，还有布劳威尔（Luitzen Egbertus Jan Brouwer）和海廷（Arend Heyting）等人创立的直觉主义逻辑学。三值逻辑通过导入第三个真值， 从语义学的角度对二值逻辑发起了挑战；而直觉主义逻辑从语法学的角度对二值逻辑发起了挑战。\n人类的逻辑学 在这种新的逻辑学中，命题的真值不仅有“真”和“假”，还可以有“无意义”“当前未知”“矛盾”等反映各种认知的值。于是诞生了三值逻辑，而且允许三个以上的真 值的多值逻辑学（many-valued logic）的研究也在进行中。没有神的逻辑学——人类的逻辑学诞生了。\n数据库的使用者当然是人类，而不是神。因此，数据的表达方式也应该基于有限而且不完善的人类的认知，而不是神的完美无缺的认知。这就是关系数据库采用 三值逻辑的原因。\n但是，这种面向人类的思维方式是一把双刃剑。确实，通过采用三值逻辑（主要是NULL和unknown），正如Codd所说，关系数据库变得非常接近人类的认知， 而且具有非常灵活的表达能力。但讽刺的是，人类又不得不引入许多不太直观的奇怪的逻辑运算。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-8-%E4%BA%BA%E7%B1%BB%E7%9A%84%E9%80%BB%E8%BE%91%E5%AD%A6/","summary":"适当地抛开命题的真假吧 历史上最早提出三值逻辑（three-valued-logic）体系的是波兰的著名逻辑学家卢卡西维茨（Jan Lukasiewicz, 1878—","title":"2-8 人类的逻辑学"},{"content":"实际工作中的递归集合 冯·诺依曼究竟是如何想到“用集合定义自然数”这样非同寻常的方法的呢？\n冯·诺依曼的前辈们 冯·诺依曼提出用递归集合定义自然数，是在1923年发表的论文《关于超限序数的引入》中。这是他发表的第二篇论文。从论文标题中的“序数”可以看出，实际 上冯·诺依曼提出的与其说是“自然数的定义”，还不如说是“序数的定义”。序数可以理解成自然数的别称，即在强调0的下一个是1,1的下一个是2,2的下一个是3 ……这种顺序时的名称（相反，在不强调顺序时，自然数有“基数”这样一个别称）。\n冯·诺依曼提出的自然数的递归定义\n各种自然数的递归定义\n按照冯·诺依曼方法，集合中的元素个数等于想要定义的数。\nSQL可以通过COUNT函数计算出元素个数，与冯·诺依曼方法的定义方式兼容性很好。\n相反，策梅洛方法不太适合在SQL中使用（SQL本来就不使用括号表示集合）。 数是什么 皮亚诺公理\n存在起到0的作用的东西 没有在0前面的自然数 每一个自然数a，都具有后继自然数（successor） 像这样得出某个自然数的后继自然数的函数叫作后继函数，写作suc(x)。于是有suc(5) ＝6、suc(17)＝18。因此，使用后继函数生成自然数时，可以像下面 这样嵌套使用。\n1 2 3 4 5 6 7 0 = 0 1 = suc(0) 2 = suc(suc(0)) 3 = suc(suc(suc(0))) · · · 这里需要着重理解的是，我们并没有指定该后继函数的内部实现。无论什么样的内部实现，只要能够生成下一个自然数就可以，这是一个比较宽松的条件。\n冯·诺依曼方法和弗雷格方法的后继函数：suc(a) = a∪{a} 策梅洛方法的后继函数：suc(a) = {a} 自然数的定义是由皮亚诺列举的5个条件给出的，冯·诺依曼等人只是根据皮亚诺公理生成了自然数而已。这样看来，冯·诺依曼等人的工作可以称为“构建”。\n构建自然数并不一定要使用集合。在计算机科学相关领域还有一种使用λ演算函数来构建自然数的方法。\n使用λ演算构建的自然数被阿隆佐·邱奇（Alonzo Church）以自己的姓氏命名为了“邱奇数”。不过，虽然取名叫“数”，其本质却是输入输出均为函数的高阶 函数。 0:=λ fx.x 1:=λ fx.fx 2:=λ fx.f(fx) 3:=λ fx.f(f(fx)) SQL的魔术与科学 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-7-sql%E5%92%8C%E9%80%92%E5%BD%92%E9%9B%86%E5%90%88/","summary":"实际工作中的递归集合 冯·诺依曼究竟是如何想到“用集合定义自然数”这样非同寻常的方法的呢？ 冯·诺依曼的前辈们 冯·诺依曼提出用递归集合定义自然数","title":"2-7 SQL和递归集合"},{"content":"不管是面向过程语言还是文件系统，都是将复杂的东西看成是由简单单元组合而成的——这是一种还原论的思维方式。\nSQL中没有赋值或者循环的处理，数据也不以记录为单位进行处理，而以集合为单位进行处理。SQL和关系数据库的思维方式更像是一种整体论的思维方式。\n1．用CASE表达式代替IF语句和CASE语句。SQL更像一种函数式语言 之所以叫它CASE“表达式”而不是CASE“语句”（statement），是因为CASE表达式与1+(2-4)或者(x＊y)/z一样，都是表达式，在执行时会被整体当作一个值 来处理。既然同样是表达式，那么能写1+1这样的表达式的地方就都能写CASE表达式，而且因为CASE表达式最终会作为一个确定的值来处理，所以我们也可以把 CASE表达式当作聚合函数的参数来使用。\n1 2 3 4 5 \u0026#39;Lisp中使用cond函数进行条件分支 cond( ((= x 1)\u0026#39;x是1\u0026#39;) ((= x 2)\u0026#39;x是2\u0026#39;) (t \u0026#39;x是1和2以外的数’)) 1 2 3 4 5 --SQL中使用CASE表达式进行条件分支 CASE WHEN x = 1 THEN\u0026#39;x是1\u0026#39; WHEN x = 2 THEN\u0026#39;x是2\u0026#39; ELSE \u0026#39;x是1和2以外的数’ END 参考→1-3节\n2．用GROUP BY和关联子查询代替循环 SQL中没有专门的循环语句。虽然可以使用游标实现循环，但是这样的话还是面向过程的做法，和纯粹的SQL没有关系。SQL在设计之初，就有意地避免了循环。\n参考→1-6节、 1-7节\n3．表中的行没有顺序 将表看成文件的最大问题是会误认为表中的行是有顺序的。\n在关系数据库中，从表中读取数据时的的确确会发生这样的情况。读出的数据不一定是按照INSERT的顺序排列的，因为SQL在处理数据时不需要它们这样。 SQL在处理数据时可以完全不依赖顺序。 在定义视图时指定ORDER BY子句（如果某种数据库支持这种写法，那么它本身就有问题），或者轻易地使用Oracle中的rownum这样依赖具体实现的 “行编号”列，都是典型的依赖顺序的不好的写法。 参考→1-4节、 1-9节、 1-10节\n4．将表看成集合 实际上，一张表并非对应一个文件，读取表时也并不是像读取文件一样一行一行地进行的。\n参考→1-2节\n5．理解EXISTS谓词和“量化”的概念 在SQL中，谓词逻辑的主要应用场景是“将多行数据作为整体”处理的时候。谓词逻辑中具有能将多个对象作为一个整体来处理的工具“量化符”。对于SQL来说， 量化符就是EXISTS谓词。\n参考→1-8节、 1-9节\n6．学习HAVING子句的真正价值 HAVING子句是集中体现了SQL之面向集合理念的功能。\n参考→1-4节、 1-10节\n7．不要画长方形，去画圆 传统的结构图(structure diagram), 数据流图(data flow diagram)用于描述动态数据, 而SQL只是用来描述所需数据的查询条件的，并不能描述动态的 处理过程。\n能够准确描述静态数据模型的标准工具是维恩图\n能否深刻理解并灵活使用嵌套子集（=递归集合），可以说是衡量SQL编程能力是否达到中级水平的关键。\n参考→1-4节、 1-7节\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-6-%E4%BB%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/","summary":"不管是面向过程语言还是文件系统，都是将复杂的东西看成是由简单单元组合而成的——这是一种还原论的思维方式。 SQL中没有赋值或者循环的处理，数据","title":"2-6 从面向过程思维向声明式思维, 面向集合思维转变的7个关键点"},{"content":"写在前面 关系数据库中不存在编程语言中一般被称为“指针”的物理性数据结构。但是严格来说，它其实是存在的，只不过被隐藏了，因而对用户不可见。\n不过，如果这么说，可能会有人列举出用户可以使用的指针，比如Oracle中的rowid或PostgreSQL中的oid来反对。确实，用户可以使用这些指针，但是它们 都是个别数据库厂商违反SQL标准而进行的扩展，而标准SQL一直在努力摆脱指针。\n关系模型是为摆脱地址而生 在关系模型中，我们通过完全关联的编址来代替位置编址。\n在关系数据库中，每个数据可以借助于关系名、主键的值以及属性名唯一地编址。这种形式的关联地址使用户（是的，也使得程序员）把以下两点留给系统来 完成： 确定要插入数据库的一块新信息的放置细节； 当检索数据时选择适当的存取通路。 这里说的“地址”不仅包括指针操作的地址，还包括数组下标等。 数据库中的关系无论如何都不能具有指针的那些属性。众所周知，关系数据库出现以前，数据库中充满了指针的概念，为了访问到想要的数据必须借助很多指 针。对这些数据库进行应用程序编程时很容易出现错误，而且数据不能由终端用户直接访问，这些问题都是指针导致的。 放弃地址的深刻意义是，通过放弃掉系统中没有意义的东西，创造出一个易于人类理解的有意义的世界。\n所以写代码也要偏向于易读而不是易写.\n编程中泛滥的地址 是的，变量——它正是编程语言中地址的化身。所有的变量都由没有实际意义的地址管理着。而且，要想在面向过程语言中处理数据，只能通过把数据赋值给变量。 只要使用变量，就无法逃出地址的魔咒。反过来说，之所以SQL能成为不依赖于地址的自由的语言，也是因为它不使用变量。\n不曾远去的老将——J.Backus的梦想 声明式语言SQL和函数式语言Lisp在当今的编程世界里都处于边缘，而且从来没有成为主流语言过。但是最近SQL中增加了许多丰富的功能，渐渐到了需要重新 评价SQL和函数式语言优点的时候了。“地址的解放战争”最终有怎样的归宿，现在还不好预测，但是笔者期待能够在不久的将来写一写它。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-4-%E5%9C%B0%E5%9D%80%E8%BF%99%E4%B8%80%E5%B7%A8%E5%A4%A7%E7%9A%84%E6%80%AA%E7%89%A9/","summary":"写在前面 关系数据库中不存在编程语言中一般被称为“指针”的物理性数据结构。但是严格来说，它其实是存在的，只不过被隐藏了，因而对用户不可见。 不过","title":"2-4 地址这一巨大的怪物"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/di/","summary":"原文","title":"Go工程化 - 手摸手带你理解依赖注入"},{"content":"了解啥是libcontainer、runc、containerd、CRI、OCI\n原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9Acontainerd%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"了解啥是libcontainer、runc、containerd、CRI、OCI 原文","title":"一文搞定Containerd的使用"},{"content":"从运算角度审视集合 “封闭性”（closure property）, 这个性质简单地说就是“运算的输入和输出都是关系”\n多亏了关系的封闭性，这些运算的输出才可以直接作为其他运算的输入。 与unix管道类比\n按照对四则运算是否封闭，我们可以把集合分为下面几类。\n群（group）：对加法和减法（或者乘法和除法）封闭 环（ring）：对加法、减法、乘法封闭 域（filed）：对加法、减法、乘法、除法封闭，即可以自由进行四则运算 如果要举个关于“群”的具体示例，那么最简单的就是整数集了，因为任何两个整数之间进行加法或者减法运算，结果一定还是整数。整数集也是环，但却不是域\n比如1÷2的结果是小数，不满足封闭性。 如果将整数集扩展成有理数集或者实数集的话，那么结果就满足域的条件了。 实践和原理 关系支持加法（UNION）运算和减法（EXCEPT）运算，因此满足群的条件。关系还支持相当于乘法运算的CROSS JOIN，所以也满足环的条件。关系中没有除法 运算符，所以不满足域的条件。\nSQL中没有除法运算符。但是我们在1-4节中说过，除法运算的定义是有的。因此，关系也满足域的条件。 Theory is practical.\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-3-%E5%BC%80%E5%A7%8B%E4%BA%8E%E5%85%B3%E7%B3%BB-%E7%BB%93%E6%9D%9F%E4%BA%8E%E5%85%B3%E7%B3%BB/","summary":"从运算角度审视集合 “封闭性”（closure property）, 这个性质简单地说就是“运算的输入和输出都是关系” 多亏了关系的封闭性，这些运算","title":"2-3 开始于关系, 结束于关系"},{"content":"为什么不叫“表”模型 Codd:\n当初思考关系模型的时候，从事数据处理工作的人们有一种普遍的观点，即认为多个对象之间的关系（或者关联）必须通过一种链接数据结构来表示。为了纠 正这个误解，我特意选择了“关系模型”这个词作为名字； 与关系相比，表的抽象度更低，容易给人可以像数组一样操作的印象，而n元关系就不会了。还有，数据库表中数据的内容和行的顺序没有关系，在这一点上表 更容易带来误解。尽管表有这样的小缺点，但依然是表达关系概念时最重要的手段。毕竟表的概念人们更熟悉一些。 关系的定义 数据库采用了关系模型，因此才被称为关系数据库。\n关系模型之父Codd本人也表示时不时地会收到这样的疑问，并给出了前文中的两个解释。\n其中(1)与现在的数据库工程师没有什么关系。“链接数据结构”指的是使用指针连接数据的链表结构，这是分层模型和网状模型数据结构流行的时期特有 的。 而(2)现在仍然有思考的价值，因为它触及了“关系”这一概念的本质。简单概括的话，关系和表看起来很相似，实质却不相同。 关系和表比较典型的区别。\n关系中不允许存在重复的元组（tuple），而表中可以存在。即，关系是通常说的不允许存在重复元素的集合，而表是多重集合（multiset） 关系中的元组没有从上往下的顺序，而表中的行有从上往下的顺序 关系中的属性没有从左往右的顺序，而表中的列有从左往右的顺序 关系中所有的属性的值都是不可分割的，而表中列的值是可以分割的。换句话说，关系中的属性满足第一范式，而表中的列不满足第一范式 元组和属性是关系模型中较为正式的术语，与非正式的日常用语有以下对应关系\n关系的定义可以用下面这样一个公式来给出。\n关系用符号R表示，属性用符号Ai表示，属性的定义域用符号Di表示 R ⊆（D1×D2×D3 · · · ×Dn） 这个公式读作“关系R是定义域D1, D2, …, Dn的笛卡儿积的子集”。\n我们假设属性a1可以取1种值，属性a2可以取2种值，属性a3可以取3种值。各属性对应的定义域分别叫作d1、d2、d3。\nd1 = { 1 } d2 = { 男 , 女 } d3 = { 红 , 绿 , 黄 } 使用这3个定义域生成关系时，最大的元组数是多少？答案是6。计算方法很简单，就是1×2×3＝6。\n关系就是定义域间的组合?\n定义域的忧虑 一段用Pascal语言写的代码\ntype Day = { Sun, Mon, Tue, Wed, Thu, Fri, Sat }; var Today : Day; 现在的DBMS是具备简单的定义域功能的，只不过比较初级. 这些定义域主要是字符型、数值型等叫作标量类型的数据类型。因为它们对属性的取值范围有约束， 所以尽管有局限性，但是标量类型也是定义域的一种。\n关系值和关系变量 值（value）和变量（variable）是很容易混淆的概念，在讨论和数据库相关的话题时，两者经常会被混用。一般提到“关系”这个词时，如果不加特殊说明， 指的都是“关系变量”。而关系值指的是关系变量在某一时刻取的值。实际上或许我们也可以说，值就是变量的时间切片（time-slice）。\n这与数学或者编程语言中变量和值之间的关系是一样的。在编程语言中，整数型变量存储整数值。同样，在关系模型中，关系型变量存储关系值。理解了这一点， 我们应该就不会像刚接触这些概念时那样觉得不可思议了。关键在于我们在学校中学到的变量和值基本上都是标量型的单一类型值，所以只是不习惯把关系 这样的复合型结构看成一个值。FROM子句中写的表名正是变量的名称\n存在“关系的关系”吗 这个问题可以替换成“存在递归的关系吗”或者“定义域中可以包含关系吗”。\n“关系的关系”在逻辑上是可能存在的。但是，为此必须定义能够使定义域包含关系的谓词，而且如果再考虑对关系的量化，就需要实现二阶谓词逻辑，因此实现 “关系的关系”非常困难。\n因此这里我们只简单地了解一下描述这种现实中还不存在的“关系的关系”的关系模型大概是什么样子。首先请看一个具体的表。\n如果接受了这种“关系的关系”，那么自然就能进一步扩展到“关系的关系的关系”或者“关系的关系的关系的关系”这样更高阶的关系。当然它们也都是嵌套式的递 归结构。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/","summary":"为什么不叫“表”模型 Codd: 当初思考关系模型的时候，从事数据处理工作的人们有一种普遍的观点，即认为多个对象之间的关系（或者关联）必须通过一种链接数","title":"2-2 为什么叫关系模型"},{"content":"8.1 为什么中国没有本土大型连锁便利店 电商改变了中国零售行业的发展路径 图8-1 2021年我国消费品零售渠道分布\n电商的出现改变了我国零售行业的发展路径。\n国外零售行业的发展路径从传统零售开始，发展出连锁零售（A\u0026amp;P等），进化到现代大型商超（沃尔玛等），再到仓储店（开市客等）与便利店（7-11等）， 最后发展出电商（亚马逊等）。 而国内零售行业的发展路径，是在连锁零售尚未发展完善时，就出现了电商；电商出现后不久就实现了极其迅速的增长，并且一定程度上挤压了传统线下零售 的生存空间。 图8-2 我国网民整体及手机网民规模\n图8-3 我国电商行业与全渠道消费品零售额增速\n图8-4 我国现代线下零售、传统线下零售和电商的市场份额变化\n图8-5 我国超市、便利店与消费品零售业整体增速对比\n电商改变渠道拓扑结构 电商的变革并不是单纯把交易场景从线下搬到线上、省去房租和人工费用、提升经营效率、把流通成本做到更低。以上变化都只是表象，电商改变的是整个交易 的思维和逻辑，并给商家集中度、品类结构等方面带来种种变化。\n商家的边界变得不同，线上商家的马太效应会越来越高 线下零售是区域竞争，每家店的辐射范围都不同。对于线下零售而言，门店的“点位”至关重要。 线上生意就不同了。网店的展现对于全国各地的消费者一视同仁，消费者距离某家网店的距离都是一样的。 适合线上、线下销售的品类会变得不同 电商适合的消费类型是标准化、重复消费的大众商品. 比如，数码、护肤品等产品就适合线上销售，因为它们是标准化且重复消费的产品； 线下渠道适合具备一定体验感、即时性需求的品类。生鲜、软饮、奢侈品就适合线下消费，因为生鲜、软饮对即时性有要求，奢侈品对消费过程中的体验 有要求。 图8-6 2020年各品类电商渗透率\n电商变革改变了中国零售的发展路径 电商难以解决“最后一公里”履约的成本和时效问题，其实并不太适合销售生鲜产品。所以在超市、便利店发展比较一般的情况下，生鲜就这样被留在了农贸市场。\n图8-7 2019年部分国家生鲜分销渠道\n8.2 为什么“美国的淘宝”eBay争不过亚马逊 图8-8 2020年中国电商平台市场份额\n美国的电商市场格局和我国很不一样\n美国电商的市场集中度远远低于我国。 品牌自营电商、连锁超市电商很难在我国占据一席之地，但在美国可以 头部平台的经营模式有所不同，我国排名第一的阿里巴巴是一个平台模式的电商，而美国排名第一的亚马逊是一个自营模式的电商。 图8-9 美国2020年电商前10名销售额\n中美电商在历史、环境上的差异，还导致了品牌和电商平台间话语权的不同。在渠道和品牌的博弈过程之中，中国电商平台的地位要比美国电商平台的地位更强。\n其一，流量高度集中于少数头部电商平台，这类平台的分发方式较为中心化，拥有较强的话语权。 其二，由于我国广阔的国土面积、多样的地域特色、复杂的城市层级，现阶段品牌方很难实现完全的渠道自主、数据自主，或多或少需要依附于头部电商平台。 因此，未来品牌与平台的博弈将始终存在。对于品牌来说，研究如何在电商平台上获取、转化、留存流量至关重要。 8.3 再论马太效应：社交电商、熟人经济、推荐算法使电商马太效应降低了吗 淘系平台转向信息流推荐之后，仍然由大商家主导；熟人电商发展势头一直比较一般；社交种草、直播带货主要还是肥了头部达人……这是为什么？\n电商平台转向信息流推荐并没有阻断马太效应形成的链条。推荐算法也会给头部商品较大的权重倾斜，使销量高的商品得到更多的曝光。 熟人经济很可能是一个伪命题。熟人之间互相推荐商品非常有效，但熟人关系可能不适合用来做电商。从熟人手上买东西，如果买贵了、买回来不好用，非常 不好处理，买家向卖家索要退款或其他售后的过程很可能损害朋友关系。 大多数直播带货实质上并非兴趣电商，而是折扣电商。这类电商显然与“去中心化”没有任何关系。主播成交额越高能拿到的折扣越高，拿到的折扣越高成交额 越高，这分明是另一个马太效应循环。 社交种草的直接收益通常并不明显，中腰部达人生态不佳。用户会对过于频繁的广告产生反感 现在的电商环境仍然呈现头部集中的态势。在一定程度上实现了“去中心化”的其实是抖音，但这个“去中心化”一定程度上建立在平台设法使用推荐算法抑制中心 化趋势的基础之上。\n8.4 结语 未来商家有可能持续加大在电商平台上的投入，使得部分品类在电商平台的费用率高于线下渠道。 对于电商平台来说，其未来的广告货币化率仍有可观的提升空间，并带动平台利润持续提升。 对于能够线上化的品类，我们可以投资线上渠道做得不错的品牌和商家；对于餐饮、旅游这类消费，继续押注线下消费的发展也是一个不错的选择。 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC8%E7%AB%A0-%E6%B8%A0%E9%81%93%E5%8F%98%E9%9D%A9%E7%9A%84%E7%9C%9F%E7%9B%B8/","summary":"8.1 为什么中国没有本土大型连锁便利店 电商改变了中国零售行业的发展路径 图8-1 2021年我国消费品零售渠道分布 电商的出现改变了我国零售行业的发展","title":"第8章 渠道变革的真相"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/mktindex/","summary":"主页","title":"魔镜市场情报"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/mobduos/","summary":"主页","title":"多多情报通"},{"content":"写在前面 关系模型的创始人E.F.Codd（1923—2003）。\n下面的内容主要依据C.J.Date的著作The Database Relation Model。\n两篇论文 Codd写了两篇与关系模型相关的论文。第一篇是写于1969年的《大型数据库中关系存储的可推导性、冗余与一致性》。遗憾的是，这篇论文发表在IBM公司内部 期刊IBM Research Report上了，因此并没有引起外界的注意。\n在接下来的1970年，Codd又在权威学术杂志Communications of ACM上，以《大型共享数据库的关系模型》为题发表了第二篇论文。至此，关系模型 真正地问世了。现在人们读到的论文基本上都是这一篇。\nCodd的贡献 Codd这两篇论文的主要贡献可以归纳为以下3点。\n定义了关系运算（relational calculus）。// todo 定义了关系代数（relational algebra）。选择、投影、并、交等8种运算 采用谓词逻辑作为数据库操作的基础。逻辑体系 1969年——一切从这里开始 1969年的论文不仅给出了关系的定义，还考虑到了主键的概念, Codd此时提出的“主键”这个词并非我们现在所说的“主键”，而更像是“超键”。因为Codd允许主 键存在冗余，而且一张表中可以存在多个主键。1970年的论文又追加了“外键”的概念。\n1969年的论文中有一句非常重要的话\n将数据看作关系后，有可能创造出以二阶谓词逻辑为基础的用于查询一般数据的子语言。 由于关系数据库以谓词逻辑作为基础，逻辑学的研究成果才可以直接应用于数据管理系统。\n“Codd最具决定性的重要思想就是把数据看成关系的集合，然后再把关系看成（真）命题的集合。这样，在创造出基于谓词逻辑的语言之后，就能直接使用这 种语言查询数据了”——C.J.Date的这句评论说到了关键点上。 1970年——远离地址 在Codd提出关系模型之前，数据库系统的主流模型是分层模型和网状模型。这两种模型在查找数据时都需要使用索引（指针），因此用户必须知道数据的存储位 置，抽象程度非常低。正因如此，Codd的首要目标就是将用户从这种毫无意义的烦恼中解放出来。于是“数据库中不再包含索引，字段间也没有顺序了”。\n范式 1970年的论文除了强调数据的独立性之外，还有一个重要的变化，那就是出现了范式的概念。\n“按照第一范式进行规范化的关系”其实就是“定义域只包含原子值（atomic value）的关系”（Codd）。这里所说的原子值，我们今天称为标量值。它指的是 不能再进行细分的最小单位的数据结构\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-1-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8E%86%E5%8F%B2/","summary":"写在前面 关系模型的创始人E.F.Codd（1923—2003）。 下面的内容主要依据C.J.Date的著作The Database Relation Model。 两篇论文 Cod","title":"2-1 关系数据库的历史"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/feigua/","summary":"主页","title":"飞瓜数据"},{"content":"","permalink":"https://jdxj.github.io/posts/articles/coonav/","summary":"","title":"小葫芦大数据"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/bihukankan/","summary":"主页","title":"壁虎看看"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/qianzhan/","summary":"主页","title":"前瞻产业研究院"},{"content":"写在前面 下面两张卡片上各画了几个圆圈，哪个更容易数清楚呢？\n编程行为就像是一种沟通方式。因此，对编程风格的研究也可以看成是对提高系统开发中沟通效率的方法的研究（因此在只有一个人编程的项目中，很难注意到 代码风格的重要性）。\n表的设计 名字和意义 名称既包括用来指代具体东西的固有名称，也包括用来指代概念或者集合的一般名称。 地址没有指代任何具有实际意义的概念或者事物。 命名时允许的字符有以下3种\n英文字母 阿拉伯数字 下划线“_” 属性和列 在数据库中，列代表的是“属性”，因此应该具有一贯性。\n有些时候指代的是年龄，有些时候指代的是体重, 这种设计是不允许的 编程的方针 注释 就SQL而论，最好还是写注释。这样说主要有两个原因：\nSQL是声明式语言，即使表达同样的处理过程，逻辑仍然比面向过程语言凝练得多； SQL很难进行分步的执行调试。分析代码时主要需要进行桌面调试。 注释的写法有以下两种\n1 2 3 4 -- 单行注释 -- 从SomeTable中查询col_1 SELECT col_1 FROM SomeTable; 1 2 3 4 5 6 /＊ 多行注释 从SomeTable中查询col_1 ＊/ SELECT col_1 FROM SomeTable; SQL语句中不能有空行，却可以像下面这样加入注释。\n1 2 3 4 5 6 SELECT col_1 FROM SomeTable WHERE col_1 =\u0026#39;a\u0026#39; AND col_2 =\u0026#39;b\u0026#39; -- 下面的条件用于指定col_3的值是’c’或者’d\u0026#39; AND col_3 IN (\u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;); 注释也可以与代码在同一行\n1 2 SELECT col_1 -- 从SomeTable中查询col_1 FROM SomeTable; 缩进 1 2 3 4 5 6 7 8 9 10 11 12 13 14 --√好的示例 SELECT col_1, col_2, col_3, COUNT(＊) FROM tbl_A WHERE col_1 =\u0026#39;a\u0026#39; AND col_2 = ( SELECT MAX(col_2) FROM tbl_B WHERE col_3 = 100 ) GROUP BY col_1, col_2, col_3 1 2 3 4 5 6 7 8 9 --×坏的示例 SELECT col_1, col_2, col_3, COUNT(＊) FROM tbl_A WHERE col_1 =\u0026#39;a\u0026#39; AND col_2 = ( SELECT MAX(col_2) FROM tbl_B WHERE col_3 = 100 ) GROUP BY col_1, col_2, col_3 比起①这种所有关键字都顶格左齐的写法，②这种让关键字右齐的写法更好。\n①左齐\n1 2 3 4 5 6 SELECT FROM WHERE GROUP BY HAVING ORDER BY ②右齐\n1 2 3 4 5 6 7 SELECT FROM WHERE GROUP BY HAVING ORDER BY 空格 1 2 3 4 5 --√好的示例 SELECT col_1 FROM tbl_A A, tbl_B B WHERE ( A.col_1 \u0026gt;= 100 OR A.col_2 IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) ) AND A.col_3 = B.col_3; 1 2 3 4 5 --×坏的示例 SELECT col_1 FROM tbl_A A, tbl_B B WHERE (A.col_1\u0026gt;=100 OR A.col_2 IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;)) AND A.col_3=B.col_3; 大小写 在SQL里，关于应该如何区分使用大小写字母有着不成文的约定：关键字使用大写字母，列名和表名使用小写字母\n1 2 3 4 5 6 7 8 9 --√大小写有区分，易读 SELECT col_1, col_2, col_3, COUNT(＊) FROM tbl_A WHERE col_1 =\u0026#39;a\u0026#39; AND col_2 = ( SELECT MAX(col_2) FROM tbl_B WHERE col_3 = 100 ) GROUP BY col_1, col_2, col_3; 1 2 3 4 5 6 7 8 9 --×大小写没有区分，难读：全是小写 select col_1, col_2, col_3, count(＊) from tbl_a where col_1 =\u0026#39;a\u0026#39; and col_2 = ( select max(col_2) from tbl_b where col_3 = 100 ) group by col_1, col_2, col_3; 1 2 3 4 5 6 7 8 9 --×大小写没有区分，难读：全是大写 SELECT COL_1, COL_2, COL_3, COUNT(＊) FROM TBL_A WHERE COL_1 =\u0026#39;A\u0026#39; AND COL_2 = ( SELECT MAX(COL_2) FROM TBL_B WHERE COL_3 = 100 ) GROUP BY COL_1, COL_2, COL_3; 逗号 前置逗号\n1 2 3 4 5 SELECT col_1 , col_2 , col_3 , col_4 FROM tbl_A; 这种写法有优点有缺点, 这里列出仅供参考\n不使用通配符 写出所需的字段\n1 2 × SELECT ＊ FROM SomeTable; √ SELECT col_1, col2, col3 ... FROM SomeTable; ORDER BY中不使用列编号 前面讲过的通配符一样，一般来说会受列的顺序和位置影响的写法都应该避免\n1 2 × SELECT col_1, col2 FROM SomeTable ORDER BY 1, 2; √ SELECT col_1, col2 FROM SomeTable ORDER BY col_1, col2; SQL编程方法 请说普通话 SQL是一种有多种方言的语言，各种数据库实现都为我们做了各种扩展, 在日常开发中养成使用标准语法的习惯, 避免影响移植性\n不使用依赖各种数据库实现的函数和运算符 很多依赖数据库实现的函数都是转换函数或字符串处理函数。不要使用这些函数：DECODE(Oracle)、IF(MySQL)、NVL(Oracle)、STUFF(SQL Server)等。 请使用CASE表达式或者COALESCE、NULLIF等标准函数代替它们。此外，像SIGN或ABS、REPLACE这些，虽然标准SQL没有定义它们，但是几乎所有的数据库都 实现了它们，所以使用一下也没关系。\n连接操作使用标准语法 在很早的时候，连接条件和普通的查询条件一样，都是写在WHERE子句里的。\n1 2 3 4 SELECT ＊ FROM Foo F, Bar B WHERE F.state = B.state AND F.city =’东京’; 标准SQL使用INNER或CROSS等表明连接类型的关键字，连接条件可以使用ON子句分开写。\n1 2 3 4 5 --内连接，而且一眼就能看明白连接条件是F.state = B.state SELECT ＊ FROM Foo F INNER JOIN Bar B ON F.state = B.state WHERE F.city =’东京’; 外连接请使用LEFT OUTER JOIN、RIGHT OUTER JOIN或者FULL OUTER JOIN来写。使用(+)运算符(Oracle)、＊=运算符(SQL Server)等依赖数据库实 现的写法会降低代码的可移植性，而且表达能力也有限，所以还是尽量避免吧。标准SQL中允许省略关键字OUTER，但是这个关键字便于我们理解它是外连接而非 内连接，所以还是写上吧。\n“左派”和“右派” 外连接有左连接、右连接和全连接三种类型。其中，左连接和右连接的表达能力是一样的，理论上讲使用哪个都可以。\n在代码风格方面，左连接有一个优势：一般情况下表头都出现在左边。使用左边的表作为主表的话，SQL就能和执行结果在格式上保持一致。\n一般表头都在左边\n表头在右边的话看起来有点奇怪\n从FROM子句开始写 大家在写SQL语句时，是按照什么顺序写的呢？笔者想，大部分人都会说是从SELECT子句开始写的。他们可能会觉得“SELECT子句在开头，难道不该从它开始写 吗？”\n原因是SELECT子句是SQL语句中最后执行的部分，写的时候根本没有必要太在意。SQL中各部分的执行顺序是：FROM→WHERE→GROUP BY→HAVING→SELECT (→ORDER BY)。严格地说，ORDER BY并不是SQL语句的一部分，因此可以排除在外。这样一来，SELECT就是最后才被执行的部分了。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-12-sql%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95/","summary":"写在前面 下面两张卡片上各画了几个圆圈，哪个更容易数清楚呢？ 编程行为就像是一种沟通方式。因此，对编程风格的研究也可以看成是对提高系统开发中沟通","title":"1-12 SQL编程方法"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/tracing/","summary":"原文","title":"链路追踪（Tracing）的前世今生（上）"},{"content":"最终方案\n原文\n","permalink":"https://jdxj.github.io/posts/articles/xuning/redis/","summary":"最终方案 原文","title":"高可用Redis服务架构分析与搭建"},{"content":"边缘节点应该用以下方法来设置\nproxy_set_header X-Forwarded-For $remote_addr; 原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/ip/","summary":"边缘节点应该用以下方法来设置 proxy_set_header X-Forwarded-For $remote_addr; 原文","title":"如何获取客户端真实 IP？从 Gin 的一个 \"Bug\" 说起"},{"content":"使用高效的查询 参数是子查询时，使用EXISTS代替IN Class_A\nClass_B\n从Class_A表中查出同时存在于Class_B表中的员工, 使用EXISTS的SQL语句更快一些\n1 2 3 4 5 6 7 8 9 10 11 12 13 --慢 SELECT ＊ FROM Class_A WHERE id IN (SELECT id FROM Class_B); --快 SELECT ＊ FROM Class_A A WHERE EXISTS (SELECT ＊ FROM Class_B B WHERE A.id = B.id); 两个结果都如下所示\n1 2 3 4 id name -- ---- 1 田中 2 铃木 使用EXISTS时更快的原因有以下两个。\n如果连接列（id）上建立了索引，那么查询Class_B时不用查实际的表，只需查索引就可以了。 如果使用EXISTS，那么只要查到一行数据满足条件就会终止查询，不用像使用IN时一样扫描全表。在这一点上NOT EXISTS也一样。 其他\n使用in会生成临时表, exists不会 in的可读性更好 如果确信in也能很快, 就没必要改成exists 很多数据库改善了in的性能 参数是子查询时，使用连接代替IN 1 2 3 4 --使用连接代替IN SELECT A.id, A.name FROM Class_A A INNER JOIN Class_B B ON A.id = B.id; 至少用到了id上的索引\n避免排序 会排序的运算\nGROUP BY子句 ORDER BY子句 聚合函数（SUM、COUNT、AVG、MAX、MIN） DISTINCT 集合运算符（UNION、INTERSECT、EXCEPT） 窗口函数（RANK、ROW_NUMBER等） 灵活使用集合运算符的ALL可选项 SQL中有UNION、INTERSECT、EXCEPT三个集合运算符。在默认的使用方式下，这些运算符会为了排除掉重复数据而进行排序。\n1 2 3 SELECT ＊ FROM Class_A UNION SELECT ＊ FROM Class_B; 1 2 3 4 5 6 id name -- ----- 1 田中 2 铃木 3 伊集院 4 西园寺 如果不在乎结果中是否有重复数据，或者事先知道不会有重复数据，请使用UNION ALL代替UNION。这样就不会进行排序了。\n1 2 3 SELECT ＊ FROM Class_A UNION ALL SELECT ＊ FROM Class_B; 集合运算符ALL可选项的实现情况\nOracle使用MINUS代替EXCEPT MySQL连INTERSECT和EXCEPT运算本身还没有实现 mysql8 了, 应该再搜一下看有没有\n使用EXISTS代替DISTINCT 如果需要对两张表的连接结果进行去重，可以考虑使用EXISTS代替DISTINCT，以避免排序。\nItems\nSalesHistory\n使用distinct\n1 2 3 SELECT I.item_no FROM Items I INNER JOIN SalesHistory SH ON I. item_no = SH. item_no; 1 2 3 4 5 6 7 8 9 item_no ------- 10 10 20 20 30 30 30 为了排除重复数据，我们需要使用DISTINCT。\n1 2 3 4 5 6 7 8 9 SELECT DISTINCT I.item_no FROM Items I INNER JOIN SalesHistory SH ON I. item_no = SH. item_no; item_no ------- 10 20 30 使用exists\n1 2 3 4 5 6 SELECT item_no FROM Items I WHERE EXISTS (SELECT ＊ FROM SalesHistory SH WHERE I.item_no = SH.item_no); 在极值函数中使用索引（MAX/MIN） 使用这两个函数时都会进行排序。但是如果参数字段上建有索引，则只需要扫描索引，不需要扫描整张表。\n1 2 3 --这样写需要扫描全表 SELECT MAX(item) FROM Items; 1 2 3 --这样写能用到索引 SELECT MAX(item_no) FROM Items; 对于联合索引，只要查询条件是联合索引的第一个字段，索引就是有效的，所以也可以对表SalesHistory的sale_date字段使用极值函数。\n能写在WHERE子句里的条件不要写在HAVING子句里 下面两条SQL语句返回的结果是一样的。\n1 2 3 4 5 --聚合后使用HAVING子句过滤 SELECT sale_date, SUM(quantity) FROM SalesHistory GROUP BY sale_date HAVING sale_date = \u0026#39;2007-10-01\u0026#39;; 1 2 3 4 5 --聚合前使用WHERE子句过滤 SELECT sale_date, SUM(quantity) FROM SalesHistory WHERE sale_date = \u0026#39;2007-10-01\u0026#39; GROUP BY sale_date; 1 2 3 sale_date sum(quantity) -------------- -------------- \u0026#39;2007-10-01\u0026#39; 17 从性能上来看，第二条语句写法效率更高。原因通常有两个。\n第一个是在使用GROUP BY子句聚合时会进行排序，如果事先通过WHERE子句筛选出一部分行，就能够减轻排序的负担。 第二个是在WHERE子句的条件里可以使用索引。HAVING子句是针对聚合后生成的视图进行筛选的，但是很多时候聚合后的视图都没有继承原表的索引结构。 在GROUP BY子句和ORDER BY子句中使用索引 特别是，在一些数据库中，如果操作对象的列上建立的是唯一索引，那么排序过程本身都会被省略掉。\n真的用到索引了吗 假设我们在一个叫作col_1的列上建立了索引，然后来看一看下面这条SQL语句。这条SQL语句本来是想使用索引，但实际上执行时却进行了全表扫描。\n在索引字段上进行运算 1 2 3 SELECT ＊ FROM SomeTable WHERE col_1 ＊ 1.1 \u0026gt; 100; 把运算的表达式放到查询条件的右侧，就能用到索引了\n1 WHERE col_1 \u0026gt; 100 / 1.1 在查询条件的左侧使用函数时，也不能用到索引\n1 2 3 SELECT ＊ FROM SomeTable WHERE SUBSTR(col_1, 1, 1) = \u0026#39;a\u0026#39;; 使用IS NULL谓词 通常，索引字段是不存在NULL的，所以指定IS NULL和IS NOT NULL的话会使得索引无法使用，进而导致查询性能低下。\n1 2 3 SELECT ＊ FROM SomeTable WHERE col_1 IS NULL; 关于索引字段不存在NULL的原因，简单来说是NULL并不是值。非值不会被包含在值的集合中\n如果需要使用类似IS NOT NULL的功能，又想用到索引，那么可以使用下面的方法，假设“col_1”列的最小值是1。\n1 2 3 4 --IS NOT NULL的代替方案 SELECT ＊ FROM SomeTable WHERE col_1 \u0026gt; 0; 使用否定形式 下面这几种否定形式不能用到索引。\n\u0026lt;\u0026gt; != NOT IN 下面的SQL语句也会进行全表扫描。\n1 2 3 SELECT ＊ FROM SomeTable WHERE col_1 \u0026lt;\u0026gt; 100; 使用OR 在col_1和col_2上分别建立了不同的索引，或者建立了（col_1, col_2）这样的联合索引时，如果使用OR连接条件，那么要么用不到索引，要么用到了但是 效率比AND要差很多。\n1 2 3 4 SELECT ＊ FROM SomeTable WHERE col_1 \u0026gt; 100 OR col_2 = \u0026#39;abc\u0026#39;; 如果无论如何都要使用OR，那么有一种办法是位图索引。但是这种索引的话更新数据时的性能开销会增大，所以使用之前需要权衡一下利弊。\n使用联合索引时，列的顺序错误 假设存在这样顺序的一个联合索引“col_1, col_2, col_3”。\n1 2 3 4 5 ○ SELECT ＊ FROM SomeTable WHERE col_1 = 10 AND col_2 = 100 AND col_3 = 500; ○ SELECT ＊ FROM SomeTable WHERE col_1 = 10 AND col_2 = 100 ; × SELECT ＊ FROM SomeTable WHERE col_1 = 10 AND col_3 = 500 ; × SELECT ＊ FROM SomeTable WHERE col_2 = 100 AND col_3 = 500 ; × SELECT ＊ FROM SomeTable WHERE col_2 = 100 AND col_1 = 10 ; 联合索引中的第一列（col_1）必须写在查询条件的开头，而且索引中列的顺序不能颠倒。有些数据库里顺序颠倒后也能使用索引，但是性能还是比顺序正确时 差一些。\n如果无法保证查询条件里列的顺序与索引一致，可以考虑将联合索引拆分为多个索引。\n使用LIKE谓词进行后方一致或中间一致的匹配 使用LIKE谓词时，只有前方一致的匹配才能用到索引。\n1 2 3 × SELECT ＊ FROM SomeTable WHERE col_1 LIKE\u0026#39;%a\u0026#39;; × SELECT ＊ FROM SomeTable WHERE col_1 LIKE\u0026#39;%a%\u0026#39;; ○ SELECT ＊ FROM SomeTable WHERE col_1 LIKE\u0026#39;a%\u0026#39;; 进行默认的类型转换 对char类型的“col_1”列指定条件的示例\n1 2 3 × SELECT ＊ FROM SomeTable WHERE col_1 = 10; ○ SELECT ＊ FROM SomeTable WHERE col_1 =\u0026#39;10\u0026#39;; ○ SELECT ＊ FROM SomeTable WHERE col_1 = CAST(10, AS CHAR(2)); 默认的类型转换不仅会增加额外的性能开销，还会导致索引不可用 在需要类型转换时显式地进行类型转换吧（别忘了转换要写在条件表达式的右边）。 减少中间表 频繁使用中间表会带来两个问题，一是展开数据需要耗费内存资源，二是原始表中的索引不容易使用到\n灵活使用HAVING子句 不习惯使用HAVING子句的数据库工程师可能会倾向于像下面这样先生成一张中间表，然后在WHERE子句中指定筛选条件。\n1 2 3 4 5 sale_date tot_qty ------------ --------- 07-10-01 10 07-10-03 32 07-10-04 22 对聚合结果指定筛选条件时不需要专门生成中间表\n1 2 3 4 SELECT sale_date, MAX(quantity) FROM SalesHistory GROUP BY sale_date HAVING MAX(quantity) \u0026gt;= 10; HAVING子句和聚合操作是同时执行的，所以比起生成中间表后再执行的WHERE子句，效率会更高一些，而且代码看起来也更简洁。\n需要对多个字段使用IN谓词时，将它们汇总到一处 SQL-92中加入了行与行比较的功能。这样一来，比较谓词＝、＜、＞和IN谓词的参数就不能是标量值，而应是值列表了。\n这里对多个字段使用了IN谓词，“id”列是主键。\n1 2 3 4 5 6 7 8 SELECT id, state, city FROM Addresses1 A1 WHERE state IN (SELECT state FROM Addresses2 A2 WHERE A1.id = A2.id) AND city IN (SELECT city FROM Addresses2 A2 WHERE A1.id = A2.id); 如果像下面这样把字段连接在一起，那么就能把逻辑写在一处了。\n1 2 3 4 5 SELECT ＊ FROM Addresses1 A1 WHERE id || state || city IN (SELECT id || state|| city FROM Addresses2 A2); 这样一来，子查询不用考虑关联性，而且只执行一次就可以。此外，如果所用的数据库实现了行与行的比较，那么我们也可以像下面这样，在IN中写多个字段的 组合。\n1 2 3 4 5 SELECT ＊ FROM Addresses1 A1 WHERE (id, state, city) IN (SELECT id, state, city FROM Addresses2 A2); 这种方法与前面的连接字段的方法相比有两个优点。\n一是不用担心连接字段时出现的类型转换问题 二是这种方法不会对字段进行加工，因此可以使用索引。 先进行连接再进行聚合 连接和聚合同时使用时，先进行连接操作可以避免产生中间表。原因是，从集合运算的角度来看，连接做的是“乘法运算”。连接表双方是一对一、一对多的关系 时，连接运算后数据的行数不会增加。而且，因为在很多设计中多对多的关系都可以分解成两个一对多的关系，因此这个技巧在大部分情况下都可以使用。\n合理地使用视图 如果没有经过深入思考就定义复杂的视图，可能会带来巨大的性能问题。特别是视图的定义语句中包含以下运算的时候，SQL会非常低效，执行速度也会变得非常 慢。\n聚合函数（AVG、COUNT、SUM、MIN、MAX） 集合运算符（UNION、INTERSECT、EXCEPT等） 越来越多的数据库为了解决视图的这个缺点，实现了物化视图（materialized view）等技术。当视图的定义变得复杂时，可以考虑使用一下。\n本节小结 不管是减少排序还是使用索引，抑或是避免中间表的使用，都是为了减少对硬盘的访问。\n下面是本节要点。\n参数是子查询时，使用EXISTS或者连接代替IN。 使用索引时，条件表达式的左侧应该是原始字段。 在SQL中排序无法显式地指定，但是请注意很多运算都会暗中进行排序。 尽量减少没用的中间表。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-11-%E8%AE%A9sql%E9%A3%9E%E8%B5%B7%E6%9D%A5/","summary":"推荐看","title":"1-11 让SQL飞起来"},{"content":"各队，全体点名 你需要做的是查出现在可以出勤的队伍。可以出勤即队伍里所有队员都处于“待命”状态。\nTeams\n“所有队员都处于‘待命’状态”这个条件是全称量化命题，所以可以用NOT EXISTS来表达。\n1 2 3 4 5 6 7 8 -- 用谓词表达全称量化命题 SELECT team_id, member FROM Teams T1 WHERE NOT EXISTS (SELECT ＊ FROM Teams T2 WHERE T1.team_id = T2.team_id AND status \u0026lt;\u0026gt;’待命’); 执行结果\n1 2 3 4 5 6 team_id member ------- ------ 3 简 3 哈特 3 迪克 4 贝斯 使用HAVING子句\n1 2 3 4 5 6 7 -- 用集合表达全称量化命题(1) SELECT team_id FROM Teams GROUP BY team_id HAVING COUNT(＊) = SUM(CASE WHEN status =’待命’ THEN 1 ELSE 0 END); 执行结果\n1 2 3 4 team_id ------- 3 4 第一步还是使用GROUP BY子句将Teams集合以队伍为单位划分成几个子集。\nHAVING子句中的条件还可以像下面这样写。\n1 2 3 4 5 6 -- 用集合表达全称量化命题(2) SELECT team_id FROM Teams GROUP BY team_id HAVING MAX(status) =’待命’ AND MIN(status) =’待命’; 极值函数可以使用参数字段的索引，所以这种写法性能更好（当然本例中只有3种值，建立索引也并没有太大的意义）。\n也可以把条件放在SELECT子句里，以列表形式显示出各个队伍是否所有队员都在待命\n1 2 3 4 5 6 7 -- 列表显示各个队伍是否所有队员都在待命 SELECT team_id, CASE WHEN MAX(status) =’待命’AND MIN(status) =’待命’ THEN ’全都在待命’ ELSE’队长！人手不够’END AS status FROM Teams GROUP BY team_id; 1 2 3 4 5 6 7 team_id status ------- -------------------------- 1 队长！人手不够 2 队长！人手不够 3 全都在待命 4 全都在待命 5 队长！人手不够 单重集合与多重集合 关系数据库中的集合是允许重复数据存在的多重集合。与之相反，通常意义的集合论中的集合不允许数据重复，被称为“单重集合”（这是笔者自己造的词，并非 公认的术语）。\n生产地的材料库存的表\nMaterials\n为了在各生产地之间调整重复的材料，我们需要调查出存在重复材料的生产地。\n按生产地分组\n“排除掉重复元素后和排除掉重复元素前元素个数不相同”。如果不存在重复的元素，不管是否加上DISTINCT可选项，COUNT的结果都是相同的。\n1 2 3 4 5 -- 选中材料存在重复的生产地 SELECT center FROM Materials GROUP BY center HAVING COUNT(material) \u0026lt;\u0026gt; COUNT(DISTINCT material); 执行结果\n1 2 3 4 center ------ 东京 名古屋 显示哪种材料重复\n1 2 3 4 5 6 7 8 9 10 11 12 SELECT center, CASE WHEN COUNT(material) \u0026lt;\u0026gt; COUNT(DISTINCT material) THEN’存在重复’ ELSE’不存在重复’END AS status FROM Materials GROUP BY center; center status ---------- ---------- 大阪 不存在重复 东京 存在重复 福冈 不存在重复 名古屋 存在重复 这个问题也可以通过将HAVING改写成EXISTS的方式来解决。\n1 2 3 4 5 6 7 8 9 --存在重复的集合：使用EXISTS SELECT center, material FROM Materials M1 WHERE EXISTS (SELECT ＊ FROM Materials M2 WHERE M1.center = M2.center AND M1.receive_date \u0026lt;\u0026gt; M2.receive_date AND M1.material = M2.material); 1 2 3 4 5 6 7 8 center material ------- --------- 东京 锌 东京 锌 名古屋 钛 名古屋 钢 名古屋 钢 名古屋 钛 寻找缺失的编号：升级版 1-4节介绍过下面这样一条查询数列的缺失编号的查询语句\n1 2 3 4 -- 如果有查询结果，说明存在缺失的编号 SELECT’存在缺失的编号’AS gap FROM SeqTbl HAVING COUNT(＊) \u0026lt;\u0026gt; MAX(seq); 这条SQL语句有一个前提条件，即数列的起始值必须是1。\n放宽这个限制条件，思考一下不管数列的最小值是多少，都能用来判断该数列是否连续的SQL语句。\n(1)不存在缺失编号（起始值＝1）\n(2)存在缺失编号（起始值＝1）\n(3)不存在缺失编号（起始值\u0026lt;\u0026gt;1）\n(4)存在缺失编号（起始值\u0026lt;\u0026gt;1）\n如果数列的最小值和最大值之间没有缺失的编号，它们之间包含的元素的个数应该是“最大值－最小值+1”。\n1 2 3 4 -- 如果有查询结果，说明存在缺失的编号：只调查数列的连续性 SELECT’存在缺失的编号’ AS gap FROM SeqTbl HAVING COUNT(＊) \u0026lt;\u0026gt; MAX(seq) - MIN(seq) + 1 ; 不论是否存在缺失的编号，都想要返回结果\n1 2 3 4 5 6 7 -- 不论是否存在缺失的编号都返回一行结果 SELECT CASE WHEN COUNT(＊) = 0 THEN ’表为空’ WHEN COUNT(＊) \u0026lt;\u0026gt; MAX(seq) - MIN(seq) + 1 THEN ’存在缺失的编号’ ELSE’连续’END AS gap FROM SeqTbl; 改进一下查找最小的缺失编号的SQL语句，去掉起始值必须是1的限制。\n1 2 3 4 5 6 7 8 9 10 11 -- 查找最小的缺失编号：表中没有1时返回1 SELECT CASE WHEN COUNT(＊) = 0 OR MIN(seq) \u0026gt; 1 -- 最小值不是1时→返回1 THEN 1 ELSE (SELECT MIN(seq +1) -- 最小值是1时→返回最小的缺失编号 FROM SeqTbl S1 WHERE NOT EXISTS (SELECT ＊ FROM SeqTbl S2 WHERE S2.seq = S1.seq + 1)) END FROM SeqTbl; 这条SQL语句会返回下面这样的结果\n情况(1):6（没有缺失的编号，所以返回最大值5的下一个数） 情况(2):3（最小的缺失编号） 情况(3):1（因为表中没有1） 情况(4):1（因为表中没有1） 为集合设置详细的条件 学生考试成绩的表\nTestResults\n第1题：请查询出75%以上的学生分数都在80分以上的班级。\n1 2 3 4 5 6 7 SELECT class FROM TestResults GROUP BY class HAVING COUNT(＊) ＊ 0.75 \u0026lt;= SUM(CASE WHEN score \u0026gt;= 80 THEN 1 ELSE 0 END) ; 执行结果\n1 2 3 class ------- B 第2题：请查询出分数在50分以上的男生的人数比分数在50分以上的女生的人数多的班级。\n1 2 3 4 5 6 7 8 9 SELECT class FROM TestResults GROUP BY class HAVING SUM(CASE WHEN score \u0026gt;= 50 AND sex =’男’ THEN 1 ELSE 0 END) \u0026gt; SUM(CASE WHEN score \u0026gt;= 50 AND sex =’女’ THEN 1 ELSE 0 END) ; 执行结果\n1 2 3 4 class ------- B C 第3题：请查询出女生平均分比男生平均分高的班级。\n1 2 3 4 5 6 7 8 9 10 -- 比较男生和女生平均分的SQL语句(1)：对空集使用AVG后返回0 SELECT class FROM TestResults GROUP BY class HAVING AVG(CASE WHEN sex =’男’ THEN score ELSE 0 END) \u0026lt; AVG(CASE WHEN sex =’女’ THEN score ELSE 0 END) ; 执行结果\n1 2 3 4 class ------- A D 根据标准SQL的定义，对空集使用AVG函数时，结果会返回NULL\n1 2 3 4 5 6 7 8 9 10 -- 比较男生和女生平均分的SQL语句(2)：对空集求平均值后返回NULL SELECT class FROM TestResults GROUP BY class HAVING AVG(CASE WHEN sex =’男’ THEN score ELSE NULL END) \u0026lt; AVG(CASE WHEN sex =’女’ THEN score ELSE NULL END) ; 这回D班男生的平均分是NULL。因此不管女生的平均分多少，D班都会被排除在查询结果之外。\n本节小结 用于调查集合性质的常用条件及其用途\n在SQL中指定搜索条件时，最重要的是搞清楚搜索的实体是集合还是集合的元素。\n如果一个实体对应着一行数据→那么就是元素，所以使用WHERE子句。 如果一个实体对应着多行数据→那么就是集合，所以使用HAVING子句。 HAVING子句可以通过聚合函数（特别是极值函数）针对集合指定各种条件。 如果通过CASE表达式生成特征函数，那么无论多么复杂的条件都可以描述。 HAVING子句很强大。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-10-having%E5%AD%90%E5%8F%A5%E5%8F%88%E5%9B%9E%E6%9D%A5%E4%BA%86/","summary":"各队，全体点名 你需要做的是查出现在可以出勤的队伍。可以出勤即队伍里所有队员都处于“待命”状态。 Teams “所有队员都处于‘待命’状态”这个条件是全称","title":"1-10 HAVING子句又回来了"},{"content":"生成连续编号 谜题：00～99的100个数中，0, 1, 2, …, 9这10个数字分别出现了多少次？\n00～99的数中，数字0～9各出现了20次\n无论多大的数，都可以由这张表中的10个数字组合而成。\nDigits\n通过对两个Digits集合求笛卡儿积而得出0～99的数字\n1 2 3 4 --求连续编号(1)：求0~99的数 SELECT D1.digit + (D2.digit ＊ 10) AS seq FROM Digits D1 CROSS JOIN Digits D2 ORDER BY seq; 执行结果\n1 2 3 4 5 6 7 8 9 10 seq --- 0 1 2 ： ： ： 98 99 笛卡儿积：得到所有可能的组合\n如果只想生成从1开始，或者到542结束的数，只需在WHERE子句中加入过滤条件就可以了。\n1 2 3 4 5 6 7 --求连续编号(2)：求1~542的数 SELECT D1.digit + (D2.digit ＊ 10) + (D3.digit ＊ 100) AS seq FROM Digits D1 CROSS JOIN Digits D2 CROSS JOIN Digits D3 WHERE D1.digit + (D2.digit ＊ 10) + (D3.digit ＊ 100) BETWEEN 1 AND 542 ORDER BY seq; 通过将这个查询的结果存储在视图里，就可以在需要连续编号时通过简单的SELECT来获取需要的编号。\n1 2 3 4 5 6 7 8 9 10 11 --生成序列视图（包含0~999） CREATE VIEW Sequence (seq) AS SELECT D1.digit + (D2.digit ＊ 10) + (D3.digit ＊ 100) FROM Digits D1 CROSS JOIN Digits D2 CROSS JOIN Digits D3; --从序列视图中获取1~100 SELECT seq FROM Sequence WHERE seq BETWEEN 1 AND 100 ORDER BY seq; 求全部的缺失编号 假设存在下面这样一张编号有缺失的表。\nSeqtbl\n利用序列视图\n1 2 3 4 5 6 7 8 9 10 11 12 --EXCEPT版 SELECT seq FROM Sequence WHERE seq BETWEEN 1 AND 12 EXCEPT SELECT seq FROM SeqTbl; --NOT IN版 SELECT seq FROM Sequence WHERE seq BETWEEN 1 AND 12 AND seq NOT IN (SELECT seq FROM SeqTbl); 执行结果\n1 2 3 4 5 seq --- 3 9 10 可能像下面这么做性能会有所下降，但是通过扩展BETWEEN谓词的参数，我们可以动态地指定目标表的最大值和最小值。\n1 2 3 4 5 6 7 --动态地指定连续编号范围的SQL语句 SELECT seq FROM Sequence WHERE seq BETWEEN (SELECT MIN(seq) FROM SeqTbl) AND (SELECT MAX(seq) FROM SeqTbl) EXCEPT SELECT seq FROM SeqTbl; 这种写法在查询上限和下限未必固定的表时非常方便。两个自查询没有相关性，而且只会执行一次。 如果在“seq”列上建立索引，那么极值函数的运行可以变得更快速。 三个人能坐得下吗 火车座位预订情况的表\nSeats\n问题是，从1～15的座位编号中，找出连续3个空位的全部组合。\n希望得到的结果是\n3～5 7～9 8～10 9～11 假设所有的座位排成了一条直线。\n7～11的序列包含3个子序列\n借助上面的图表我们可以知道，需要满足的条件是，以n为起点、n+(3-1)为终点的座位全部都是未预订状态\n1 2 3 4 5 6 7 8 9 --找出需要的空位(1)：不考虑座位的换排 SELECT S1.seat AS start_seat, \u0026#39;~\u0026#39;, S2.seat AS end_seat FROM Seats S1, Seats S2 WHERE S2.seat = S1.seat + (:head_cnt -1) --决定起点和终点 AND NOT EXISTS (SELECT ＊ FROM Seats S3 WHERE S3.seat BETWEEN S1.seat AND S2.seat AND S3.status \u0026lt;\u0026gt;’未预订’); 发生换排的情况。假设这列火车每一排有5个座位。我们在表中加上表示行编号“row_id”列。\nSeats2\n因为发生换排，所以9~11的序列不符合条件\n1 2 3 4 5 6 7 8 9 10 --找出需要的空位(2)：考虑座位的换排 SELECT S1.seat AS start_seat, \u0026#39;~\u0026#39;, S2.seat AS end_seat FROM Seats2 S1, Seats2 S2 WHERE S2.seat = S1.seat + (:head_cnt -1) --决定起点和终点 AND NOT EXISTS (SELECT ＊ FROM Seats2 S3 WHERE S3.seat BETWEEN S1.seat AND S2.seat AND ( S3.status \u0026lt;\u0026gt;’未预订’ OR S3.row_id \u0026lt;\u0026gt; S1.row_id)); 执行结果\n1 2 3 4 5 start_seat \u0026#39;~\u0026#39; end_seat ---------- --- -------- 3 ~ 5 8 ~ 10 11 ~ 13 序列内的点需要满足的条件是，“所有座位的状态都是‘未预订’，且行编号相同”。这里新加的条件是“行编号相同”，等价于“与起点的行编号相同”（当然，与终 点的行编号相同也可以）。把这个条件直接写成SQL语句的话，就是像下面这样。\n1 S3.status =’未预订’AND S3.row_id = S1.row_id 由于SQL中不存在全称量词，所以我们必须使用这个条件的否定，即改成下面这样的否定形式。\n1 2 NOT (S3.status =’未预订’AND S3.row_id = S1.row_id) = S3.status \u0026lt;\u0026gt;’未预订’OR S3.row_id \u0026lt;\u0026gt; S1.row_id 最多能坐下多少人 这次要查询的是“按现在的空位状况，最多能坐下多少人”。换句话说，要求的是最长的序列。\nSeats3\n要想保证从座位A到另一个座位B是一个序列，则下面的3个条件必须全部都满足。\n条件1：起点到终点之间的所有座位状态都是“未预订”。 条件2：起点之前的座位状态不是“未预订”。 条件3：终点之后的座位状态不是“未预订”。 不符合条件1的情况\n不符合条件2的情况\n不符合条件3的情况\n先生成一张下面这样的视图。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --第一阶段：生成存储了所有序列的视图 CREATE VIEW Sequences (start_seat, end_seat, seat_cnt) AS SELECT S1.seat AS start_seat, S2.seat AS end_seat, S2.seat - S1.seat + 1 AS seat_cnt FROM Seats3 S1, Seats3 S2 WHERE S1.seat \u0026lt;= S2.seat --第一步：生成起点和终点的组合 AND NOT EXISTS --第二步：描述序列内所有点需要满足的条件 (SELECT ＊ FROM Seats3 S3 WHERE ( S3.seat BETWEEN S1.seat AND S2.seat AND S3.status \u0026lt;\u0026gt;’未预订’) --条件1的否定 OR (S3.seat = S2.seat + 1 AND S3.status =’未预订’) --条件3的否定 OR (S3.seat = S1.seat -1 AND S3.status =’未预订’)); --条件2的否定 这个视图包含以下的内容。\n1 2 3 4 5 start_seat end_seat seat_cnt ------------ ---------- ---------- 2 5 4 7 7 1 9 10 2 我们从这个视图中找出座位数（seat_cnt）最大的一行数据。\n1 2 3 4 --第二阶段：求最长的序列 SELECT start_seat, \u0026#39;~\u0026#39;, end_seat, seat_cnt FROM Sequences WHERE seat_cnt = (SELECT MAX(seat_cnt) FROM Sequences); 单调递增和单调递减 某公司股价动态的表\nMyStock\n求一下股价单调递增的时间区间。从上表来看，目标结果是下面两个。\n2007-01-06～2007-01-08 2007-01-14～2007-01-17 首先进行第一步——通过自连接生成起点和终点的组合。\n1 2 3 4 5 --生成起点和终点的组合的SQL语句 SELECT S1.deal_date AS start_date, S2.deal_date AS end_date FROM MyStock S1, MyStock S2 WHERE S1.deal_date \u0026lt; S2.deal_date; 第二步——描述起点和终点之间的所有点需要满足的条件。\n对于区间内的任意两个时间点，命题“较晚时间的股价高于较早时间的股价”都成立。 然后，我们将这个条件反过来，得到需要的条件——区间内不存在两个时间点使得较早时间的股价高于较晚时间的股价。 1 2 3 4 5 6 7 8 9 10 11 12 --求单调递增的区间的SQL语句：子集也输出 SELECT S1.deal_date AS start_date, S2.deal_date AS end_date FROM MyStock S1, MyStock S2 WHERE S1.deal_date \u0026lt; S2.deal_date --第一步：生成起点和终点的组合 AND NOT EXISTS ( SELECT ＊ --第二步：描述区间内所有日期需要满足的条件 FROM MyStock S3, MyStock S4 WHERE S3.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S4.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S3.deal_date \u0026lt; S4.deal_date AND S3.price \u0026gt;= S4.price); 执行结果\n1 2 3 4 5 6 start_date end_date ------------ ------------- 2007-01-06 2007-01-08 2007-01-14 2007-01-16 2007-01-14 2007-01-17 2007-01-16 2007-01-17 最后，我们要把这些不需要的子集排除掉。使用极值函数很容易就能实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --排除掉子集，只取最长的时间区间 SELECT MIN(start_date) AS start_date, --最大限度地向前延伸起点 end_date FROM (SELECT S1.deal_date AS start_date, MAX(S2.deal_date) AS end_date --最大限度地向后延伸终点 FROM MyStock S1, MyStock S2 WHERE S1.deal_date \u0026lt; S2.deal_date AND NOT EXISTS (SELECT ＊ FROM MyStock S3, MyStock S4 WHERE S3.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S4.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S3.deal_date \u0026lt; S4.deal_date AND S3.price \u0026gt;= S4.price) GROUP BY S1.deal_date) TMP GROUP BY end_date; 执行结果\n1 2 3 4 start_date end_date ------------ ------------- 2007-01-06 2007-01-08 2007-01-14 2007-01-17 本节小结 SQL处理数据的方法有两种。\n第一种是把数据看成忽略了顺序的集合。 第二种是把数据看成有序的集合，此时的基本方法如下。 首先用自连接生成起点和终点的组合 其次在子查询中描述内部的各个元素之间必须满足的关系 要在SQL中表达全称量化时，需要将全称量化命题转换成存在量化命题的否定形式，并使用NOT EXISTS谓词。这是因为SQL只实现了谓词逻辑中的存在量词。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-9-%E7%94%A8sql%E5%A4%84%E7%90%86%E6%95%B0%E5%88%97/","summary":"生成连续编号 谜题：00～99的100个数中，0, 1, 2, …, 9这10个数字分别出现了多少次？ 00～99的数中，数字0～9各出现了20次 无论多大的","title":"1-9 用SQL处理数列"},{"content":"理论篇 什么是谓词 谓词是一种特殊的函数，返回值是真值。\ntrue false unknown 在关系数据库里，表中的一行数据可以看作是一个命题。\nTbl_A\n实体的阶层 同样是谓词，但是与=、BETWEEN等相比，EXISTS的用法还是大不相同的。概括来说，区别在于“谓词的参数可以取什么值”。\n1 2 3 4 5 6 SELECT id FROM Foo F WHERE EXISTS (SELECT ＊ FROM Bar B WHERE F.id=B.id ); 看一下EXISTS()的括号中的内容\n1 2 3 SELECT ＊ FROM Bar B WHERE A.id = T2.id 在EXISTS的子查询里，SELECT子句的列表可以有下面这三种写法。\n通配符：SELECT ＊ 常量：SELECT ‘这里的内容任意’ 列名：SELECT col 不管采用上面这三种写法中的哪一种，得到的结果都是一样的。\n=或者BETWEEEN等输入值为一行的谓词叫作“一阶谓词”，而像EXISTS这样输入值为行的集合的谓词叫作“二阶谓词”。阶（order）是用来区分集合或谓词的阶 数的概念。\n三阶谓词＝输入值为“集合的集合”的谓词 四阶谓词＝输入值为“集合的集合的集合”的谓词 …… 我们可以像上面这样无限地扩展阶数，但是SQL里并不会出现三阶以上的情况\nEXISTS因接受的参数是集合这样的一阶实体而被称为二阶谓词，但是谓词也是函数的一种，因此我们也可以说EXISTS是高阶函数。\n全称量化和存在量化 “所有的x都满足条件P”或者“存在（至少一个）满足条件P的x”。前者称为“全称量词”，后者称为“存在量词”，分别记作∀、∃。这两个符号看起来很奇怪。其 实，全称量词的符号其实是将字母A上下颠倒而形成的，存在量词则是将字母E左右颠倒而形成的。\nsql没有实现全称量词, 但是没有全称量词并不算是SQL的致命缺陷。因为全称量词和存在量词只要定义了一个，另一个就可以被推导出来。\n∀ xPx = ¬ ∃ x¬P（所有的x都满足条件P＝不存在不满足条件P的x） ∃ xPx = ¬ ∀ x¬Px（存在x满足条件P＝并非所有的x都不满足条件P） 实践篇 查询表中“不”存在的数据 在有些情况下，我们不得不从表中查找出“不存在的数据”。\nMeetings\n目标结果如下所示\n1 2 3 4 5 6 meeting person ---------- -------- 第1次 宫田 第2次 坂东 第2次 水岛 第3次 伊藤 思路是先假设所有人都参加了全部会议，并以此生成一个集合，然后从中减去实际参加会议的人。这样就能得到缺席会议的人。\n所有人都参加了全部会议的集合可以通过下面这样的交叉连接来求得。\n1 2 SELECT DISTINCT M1.meeting, M2.person FROM Meetings M1 CROSS JOIN Meetings M2; 所有人都参加了全部会议时\n然后我们从这张表中减掉实际参会者的集合\n1 2 3 4 5 6 7 8 --求出缺席者的SQL语句(1)：存在量化的应用 SELECT DISTINCT M1.meeting, M2.person FROM Meetings M1 CROSS JOIN Meetings M2 WHERE NOT EXISTS (SELECT ＊ FROM Meetings M3 WHERE M1.meeting = M3.meeting AND M2.person = M3.person); 这道例题还可以用集合论的方法来解答，即像下面这样使用差集运算。\n1 2 3 4 5 6 ----求出缺席者的SQL语句(2)：使用差集运算 SELECT M1.meeting, M2.person FROM Meetings M1, Meetings M2 EXCEPT SELECT meeting, person FROM Meetings; 全称量化(1)：习惯“肯定⇔双重否定”之间的转换 学生考试成绩的表\nTestScores\n请查询出“所有科目分数都在50分以上的学生”\n将查询条件“所有科目分数都在50分以上”转换成它的双重否定“没有一个科目分数不满50分”，然后用NOT EXISTS来表示转换后的命题。\n1 2 3 4 5 6 7 SELECT DISTINCT student_id FROM TestScores TS1 WHERE NOT EXISTS --不存在满足以下条件的行 (SELECT ＊ FROM TestScores TS2 WHERE TS2.student_id = TS1.student_id AND TS2.score \u0026lt; 50); --分数不满50分的科目 执行结果\n1 2 3 4 5 student_id ----------- 100 200 400 查询出满足下列条件的学生。\n数学的分数在80分以上。 语文的分数在50分以上。 针对同一个集合内的行数据进行了条件分支后的全称量化。\n“某个学生的所有行数据中，如果科目是数学，则分数在80分以上；如果科目是语文，则分数在50分以上。” 1 2 3 CASE WHEN subject =’数学’AND score \u0026gt;= 80 THEN 1 WHEN subject =’语文’AND score \u0026gt;= 50 THEN 1 ELSE 0 END 首先，数学和语文之外的科目不在我们考虑范围之内，所以通过IN条件进行一下过滤。然后，通过子查询来描述“数学80分以上，语文50分以上”这个条件。\n1 2 3 4 5 6 7 8 9 10 SELECT DISTINCT student_id FROM TestScores TS1 WHERE subject IN (’数学’, ’语文’) AND NOT EXISTS (SELECT ＊ FROM TestScores TS2 WHERE TS2.student_id = TS1.student_id AND 1 = CASE WHEN subject =’数学’AND score \u0026lt; 80 THEN 1 WHEN subject =’语文’AND score \u0026lt; 50 THEN 1 ELSE 0 END); 排除掉没有语文分数的学号为400的学生。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 SELECT student_id FROM TestScores TS1 WHERE subject IN (’数学’, ’语文’) AND NOT EXISTS (SELECT ＊ FROM TestScores TS2 WHERE TS2.student_id = TS1.student_id AND 1 = CASE WHEN subject =’数学’AND score \u0026lt; 80 THEN 1 WHEN subject =’语文’AND score \u0026lt; 50 THEN 1 ELSE 0 END) GROUP BY student_id HAVING COUNT(＊) = 2; --必须两门科目都有分数 student_id ---------- 100 200 全称量化(2)：集合VS谓词——哪个更强大？ 项目工程管理表\nProjects\n从这张表中查询出哪些项目已经完成到了工程1\nJoe Celko曾经借助HAVING子句用面向集合的方法进行过解答\n1 2 3 4 5 6 7 --查询完成到了工程1的项目：面向集合的解法 SELECT project_id FROM Projects GROUP BY project_id HAVING COUNT(＊) = SUM(CASE WHEN step_nbr \u0026lt;= 1 AND status =’完成’THEN 1 WHEN step_nbr \u0026gt; 1 AND status =’等待’THEN 1 ELSE 0 END); 执行结果\n1 2 3 project_id ----------- CS300 针对每个项目，将工程编号为1以下且状态为“完成”的行数，和工程编号大于1且状态为“等待”的行数加在一起，如果和等于该项目数据的总行数，则该项目符合 查询条件。\n用谓词逻辑\n1 2 3 4 5 6 7 8 9 10 --查询完成到了工程1的项目：谓词逻辑的解法 SELECT ＊ FROM Projects P1 WHERE NOT EXISTS (SELECT status FROM Projects P2 WHERE P1.project_id = P2. project_id --以项目为单位进行条件判断 AND status \u0026lt;\u0026gt; CASE WHEN step_nbr \u0026lt;= 1 --使用双重否定来表达全称量化命题 THEN ’完成’ ELSE ’等待’ END); 执行结果\n1 2 3 4 5 6 7 project_id step_nbr status ----------- -------- ------ CS300 0 完成 CS300 1 完成 CS300 2 等待 CS300 3 等待 对列进行量化：查询全是1的行 ArrayTbl\n在使用这种模拟数组的表时遇到的需求一般都是下面这两种形式。\n查询“都是1”的行。 查询“至少有一个9”的行。 1 2 3 4 5 6 7 8 9 --“列方向”的全称量化：不优雅的解答 SELECT ＊ FROM ArrayTbl WHERE col1 = 1 AND col2 = 1 · · · AND col10 = 1; SQL语言其实还准备了一个谓词，帮助我们进行“列方向”的量化。\n1 2 3 4 --“列方向”的全称量化：优雅的解答 SELECT ＊ FROM ArrayTbl WHERE 1 = ALL (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 1 2 3 key col1 col2 col3 col4 col5 col6 col7 col8 col9 col10 --- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----- C 1 1 1 1 1 1 1 1 1 1 如果想表达“至少有一个9”这样的存在量化命题，可以使用ALL的反义谓词ANY。\n1 2 3 4 --列方向的存在量化(1) SELECT ＊ FROM ArrayTbl WHERE 9 = ANY (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 1 2 3 4 key col1 col2 col3 col4 col5 col6 col7 col8 col9 col10 --- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----- D 9 E 3 1 9 9 或者也可以使用IN谓词代替ANY。\n1 2 3 4 --列方向的存在量化(2) SELECT ＊ FROM ArrayTbl WHERE 9 IN (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 如果左边不是具体值而是NULL，这种写法就不行了。\n1 2 3 4 --查询全是NULL的行：错误的解法 SELECT ＊ FROM ArrayTbl WHERE NULL = ALL (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 不管表里的数据是什么样的，这条SQL语句的查询结果都是空。这是因为，ALL谓词会被解释成col1 = NULL AND col2 = NULL AND ……col10 = NULL。 这种情况下，我们需要使用COALESCE函数。\n1 2 3 4 --查询全是NULL的行：正确的解法 SELECT ＊ FROM ArrayTbl WHERE COALESCE(col1, col2, col3, col4, col5, col6, col7, col8, col9, col10) IS NULL; 1 2 3 key col1 col2 col3 col4 col5 col6 col7 col8 col9 col10 --- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----- A 本节小结 SQL中的谓词指的是返回真值的函数。 EXISTS与其他谓词不同，接受的参数是集合。 因此EXISTS可以看成是一种高阶函数。 SQL中没有与全称量词相当的谓词，可以使用NOT EXISTS代替。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-8-exists%E8%B0%93%E8%AF%8D%E7%9A%84%E7%94%A8%E6%B3%95/","summary":"理论篇 什么是谓词 谓词是一种特殊的函数，返回值是真值。 true false unknown 在关系数据库里，表中的一行数据可以看作是一个命题。 Tbl_A 实体的阶层 同样是谓词，但是与=","title":"1-8 EXISTS谓词的用法"},{"content":"导入篇：集合运算的几个注意事项 注意事项1: SQL能操作具有重复行的集合，可以通过可选项ALL来支持\n一般的集合论不允许集合中存在重复元素 关系数据库允许存在重复行, 称为多重集合（multiset, bag） SQL的集合运算符也提供了允许重复和不允许重复的两种用法。如果直接使用UNION或INTERSECT，结果里就不会出现重复的行。如果想在结果里留下重复行， 可以加上可选项ALL，写作UNION ALL。 集合运算符为了排除掉重复行，默认地会发生排序，而加上可选项ALL之后，就不会再排序，所以性能会有提升。 注意事项2：集合运算符有优先级\n标准SQL规定，INTERSECT比UNION和EXCEPT优先级更高。 注意事项3：各个DBMS提供商在集合运算的实现程度上参差不齐\nSQL Server从2005版开始支持INTERSECT和EXCEPT，而MySQL还都不支持（包含在“中长期计划”里）。 还有像Oracle这样，实现了EXCEPT功能但却命名为MINUS的数据库。 注意事项4：除法运算没有标准定义\n四则运算里的和（UNION）、差（EXCEPT）、积（CROSS JOIN）都被引入了标准SQL。但是很遗憾，商（DIVIDE BY）因为各种原因迟迟没能标准化\n比较表和表：检查集合相等性之基础篇 “相等”指的是行数和列数以及内容都相同\n名字不同但内容相同的两张表\ntbl_A\ntbl_B\n如果这个查询的结果与tbl_A及tbl_B的行数一致，则两张表是相等的\n需要事先确认表tbl_A和表tbl_B的行数是一样的 1 2 3 4 5 6 SELECT COUNT(＊) AS row_cnt FROM ( SELECT ＊ FROM tbl_A UNION SELECT ＊ FROM tbl_B ) TMP; 执行结果\n1 2 3 row_cnt ------- 3 如果集合运算符里不加上可选项ALL，那么重复行就会被排除掉。因此，如果表tbl_A和表tbl_B是相等的，排除掉重复行后，两个集合是完全重合的。\nkey列为B的一行数据不同：结果会变为4\ntbl_A tbl_B\n前面的SQL语句可以用于包含NULL数据的表，而且不需要指定列数、列名和数据类型等就能使用\n对于任意的表S，都有下面的公式成立。\n1 S UNION S = S 同一个集合无论加多少次结果都相同\n1 S UNION S UNION S UNION S …… UNION S = S UNION的这个优雅而强大的幂等性只适用于数学意义上的集合，对SQL中有重复数据的多重集合是不适用的。\n比较表和表：检查集合相等性之进阶篇 在集合论里，判定两个集合是否相等时\n(A ∩ B )且(A ∩ B) ⇔ (A = B) 如果集合A包含集合B，且集合B包含集合A，则集合A和集合B相等 (A ∪ B ) = (A ∩ B) ⇔ (A = B) 除了UNION之外，另一个具有幂等性的运算符就是INTERSECT。\n如果A = B，则(A UNION B) EXCEPT (A INTERSECT B)的结果是空集\n1 2 3 4 5 6 7 8 9 10 11 --两张表相等时返回“相等”，否则返回“不相等” SELECT CASE WHEN COUNT(＊) = 0 THEN ’相等’ ELSE’不相等’END AS result FROM ((SELECT ＊ FROM tbl_A UNION SELECT ＊ FROM tbl_B) EXCEPT (SELECT ＊ FROM tbl_A INTERSECT SELECT ＊ FROM tbl_B)) TMP; 这条SQL语句与上一部分中的SQL语句具有同样的优点，也不需要知道列名和列数，还可以用于包含NULL的表，而且，这个改进版连事先查询两张表的行数这种 准备工作也不需要了。\n虽然功能改进了，却也带来了一些缺陷。由于这里需要进行4次排序（3次集合运算加上1次DISTINCT），所以性能会有所下降（不过这条SQL语句也不需要频繁 执行，所以这点缺陷也不是不能容忍）。\n因为这里使用了INTERSECT和EXCEPT，所以目前这条SQL语句不能在MySQL里执行。\n把不同的行输出\n1 2 3 4 5 6 7 8 --用于比较表与表的diff (SELECT ＊ FROM tbl_A EXCEPT SELECT ＊ FROM tbl_B) UNION ALL (SELECT ＊ FROM tbl_B EXCEPT SELECT ＊ FROM tbl_A); 执行结果\n1 2 3 4 key col_1 col_2 col_3 --- ----- ----- ----- B 0 7 9 B 0 7 8 因为A－B和B－A之间不可能有交集，所以合并这两个结果时使用UNION ALL也没有关系。 在A和B一方包含另一方时，这条SQL语句也是成立的（这时A－B或者B－A有一个会是空集）。 需要注意的是，在SQL中，括号决定了运算的先后顺序，非常重要，如果去掉括号，结果就会不正确。 用差集实现关系除法运算 实现除法的方法\n嵌套使用NOT EXISTS。 使用HAVING子句转换成一对一关系。 把除法变成减法。 本节将介绍一下第三种方法。\n两张员工技术信息管理表\nSkills\nEmpSkills\n问题是，从表EmpSkills中找出精通表Skills中所有技术的员工。也就是说，答案是相田和神崎。\n1 2 3 4 5 6 7 8 9 10 --用求差集的方法进行关系除法运算（有余数） SELECT DISTINCT emp FROM EmpSkills ES1 WHERE NOT EXISTS (SELECT skill FROM Skills EXCEPT SELECT skill FROM EmpSkills ES2 WHERE ES1.emp = ES2.emp); 执行结果\n1 2 3 4 emp --- 相田 神崎 从需求的技术的集合中减去每个员工自己的技术的集合，如果结果是空集，则说明该员工具备所有的需求的技术，否则说明该员工不具备某些需求的技术。\n相田\n平井\n寻找相等的子集 供应商及其经营的零件的表\nSupParts\n我们需要求的是，经营的零件在种类数和种类上都完全相同的供应商组合。\nSQL并没有提供任何用于检查集合的包含关系或者相等性的谓词。IN谓词只能用来检查元素是否属于某个集合（∈），而不能检查集合是否是某个集合的子集 （∪）。\n首先，我们来生成供应商的全部组合。\n1 2 3 4 5 --生成供应商的全部组合 SELECT SP1.sup AS s1, SP2.sup AS s2 FROM SupParts SP1, SupParts SP2 WHERE SP1.sup \u0026lt; SP2.sup GROUP BY SP1.sup, SP2.sup; 执行结果\n1 2 3 4 5 6 7 8 9 10 s1 s2 ---- ---- A B A C A D ： ： ： D E E F 接下来，我们检查一下这些供应组合是否满足以下公式：[插图]且[插图]。这个公式等价于下面两个条件。\n条件1：两个供应商都经营同种类型的零件 条件2：两个供应商经营的零件种类数相同（即存在一一映射） 条件1只需要简单地按照“零件”列进行连接，而条件2需要用COUNT函数来描述。\n1 2 3 4 5 6 7 8 9 10 11 SELECT SP1.sup AS s1, SP2.sup AS s2 FROM SupParts SP1, SupParts SP2 WHERE SP1.sup \u0026lt; SP2.sup --生成供应商的全部组合 AND SP1.part = SP2.part --条件1：经营同种类型的零件 GROUP BY SP1.sup, SP2.sup HAVING COUNT(＊) = (SELECT COUNT(＊) --条件2：经营的零件种类数相同 FROM SupParts SP3 WHERE SP3.sup = SP1.sup) AND COUNT(＊) = (SELECT COUNT(＊) FROM SupParts SP4 WHERE SP4.sup = SP2.sup); 因为要比较任意两个供应商的零件, 所以用笛卡儿积\n执行结果\n1 2 3 4 s1 s2 ---- ---- A C B D 用于删除重复行的高效SQL 1-2节介绍的解法是使用关联子查询\n1 2 3 4 5 6 --删除重复行：使用关联子查询 DELETE FROM Products WHERE rowid \u0026lt; ( SELECT MAX(P2.rowid) FROM Products P2 WHERE Products.name = P2. name AND Products.price = P2.price ) ; 上面这条语句的思路是，按照“商品名，价格”的组合汇总后，求出每个组合的最大rowid，然后把其余的行都删除掉。\n假设表中加上了“rowid”列\n1 2 3 4 5 6 7 8 --用于删除重复行的高效SQL语句(1)：通过EXCEPT求补集 DELETE FROM Products WHERE rowid IN ( SELECT rowid --全部rowid FROM Products EXCEPT --减去 SELECT MAX(rowid) --要留下的rowid FROM Products GROUP BY name, price) ; 使用EXCEPT求补集的逻辑如下面的图表所示。\n把EXCEPT改写成NOT IN也是可以实现的。\n1 2 3 4 5 --删除重复行的高效SQL语句(2)：通过NOT IN求补集 DELETE FROM Products WHERE rowid NOT IN ( SELECT MAX(rowid) FROM Products GROUP BY name, price); ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-7-%E7%94%A8sql%E8%BF%9B%E8%A1%8C%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97/","summary":"导入篇：集合运算的几个注意事项 注意事项1: SQL能操作具有重复行的集合，可以通过可选项ALL来支持 一般的集合论不允许集合中存在重复元素 关系数","title":"1-7 用SQL进行集合运算"},{"content":"使用SQL进行行间比较时，发挥主要作用的技术是关联子查询，特别是与自连接相结合的“自关联子查询”\n增长、减少、维持现状 Sales\n年营业额的趋势\n使用SQL输出与上一年相比营业额是增加了还是减少了，抑或是没有变化。\n先试试求出“不变”这种情况\n1993 1995 用面向过程语言来解决，应该是下面这样的思路\n按年份递增的顺序排序。 循环地将每一行与前一行的“sale”列进行比较。 使用SQL时的解题思路需要用面向集合的方式进行思考\n在表Sales的基础上，再加一个存储了上一年数据的集合（S2） 1 2 3 4 5 6 7 --求与上一年营业额一样的年份(1)：使用关联子查询 SELECT year, sale FROM Sales S1 WHERE sale = (SELECT sale FROM Sales S2 WHERE S2.year = S1.year -1) ORDER BY year; 今年的sale==去年的sale\n执行结果\n1 2 3 4 year sale ----- ---- 1993 52 1995 50 使用自连接\n1 2 3 4 5 6 7 --求与上一年营业额一样的年份(2)：使用自连接 SELECT S1.year, S1.sale FROM Sales S1, Sales S2 WHERE S2.sale = S1.sale AND S2.year = S1.year -1 ORDER BY year; 接下来请将这个例子扩展一下，求出每一年相比上一年营业额是增加了还是减少了，抑或是没有变化。\n用列表展示与上一年的比较结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --求出是增长了还是减少了，抑或是维持现状(1)：使用关联子查询 SELECT S1.year, S1.sale, CASE WHEN sale = (SELECT sale FROM Sales S2 WHERE S2.year = S1.year -1) THEN\u0026#39;→\u0026#39;--持平 WHEN sale \u0026gt; (SELECT sale FROM Sales S2 WHERE S2.year = S1.year -1) THEN\u0026#39;↑\u0026#39;--增长 WHEN sale \u0026lt; (SELECT sale FROM Sales S2 WHERE S2.year = S1.year -1) THEN\u0026#39;↓\u0026#39;--减少 ELSE\u0026#39;—\u0026#39;END AS var FROM Sales S1 ORDER BY year; 执行结果\n1 2 3 4 5 6 7 8 9 10 year sale var ------ ---- --- 1990 50 — 1991 51 ↑ 1992 52 ↑ 1993 52 → 1994 50 ↓ 1995 50 → 1996 49 ↓ 1997 55 ↑ 用自连接来实现\n1 2 3 4 5 6 7 8 9 --求出是增长了还是减少了，抑或是维持现状(2)：使用自连接查询（最早的年份不会出现在结果里） SELECT S1.year, S1.sale, CASE WHEN S1.sale = S2.sale THEN\u0026#39;→\u0026#39; WHEN S1.sale \u0026gt; S2.sale THEN\u0026#39;↑\u0026#39; WHEN S1.sale \u0026lt; S2.sale THEN\u0026#39;↓\u0026#39; ELSE\u0026#39;—\u0026#39;END AS var FROM Sales S1, Sales S2 WHERE S2.year = S1.year -1 ORDER BY year; 结果没有1990年之前的数据\n时间轴有间断时：和过去最临近的时间进行比较 Sales2：有年份缺失\n“过去最临近的年份”需要满足下面两个条件\n与该年份相比是过去的年份。 在满足条件1的年份中，年份最早的一个。 1 2 3 4 5 6 7 8 9 10 11 --查询与过去最临近的年份营业额相同的年份 SELECT year, sale FROM Sales2 S1 WHERE sale = (SELECT sale FROM Sales2 S2 WHERE S2.year = (SELECT MAX(year) --条件2：在满足条件1的年份中，年份最早的一个 FROM Sales2 S3 WHERE S1.year \u0026gt; S3.year)) --条件1：与该年份相比是过去的年份 ORDER BY year; 执行结果\n1 2 3 4 year sale ----- ---- 1992 50 1997 55 查询与过去最临近的年份营业额相同的年份：同时使用自连接\n1 2 3 4 5 6 7 8 SELECT S1.year AS year, S1.year AS year FROM Sales2 S1, Sales2 S2 WHERE S1.sale = S2.sale AND S2.year = (SELECT MAX(year) FROM Sales2 S3 WHERE S1.year \u0026gt; S3.year) ORDER BY year; 查询每一年与过去最临近的年份之间的营业额之差\n1 2 3 4 5 6 7 8 9 10 11 --求每一年与过去最临近的年份之间的营业额之差(1)：结果里不包含最早的年份 SELECT S2.year AS pre_year, S1.year AS now_year, S2.sale AS pre_sale, S1.sale AS now_sale, S1.sale - S2.sale AS diff FROM Sales2 S1, Sales2 S2 WHERE S2.year = (SELECT MAX(year) FROM Sales2 S3 WHERE S1.year \u0026gt; S3.year) ORDER BY now_year; 执行结果\n1 2 3 4 5 6 pre_year now_year pre_sale now_sale diff -------- -------- -------- -------- ---- 1990 1992 50 50 0 --50-50 = 0 1992 1993 50 52 2 --52-50 = 2 1993 1994 52 55 3 --55-52 = 3 1994 1997 55 55 0 --55-55 = 0 如果想让结果里出现1990年的数据，可以使用“自外连接”来实现。\n1 2 3 4 5 6 7 8 9 --求每一年与过去最临近的年份之间的营业额之差(2)：使用自外连接。结果里包含最早的年份 SELECT S2.year AS pre_year, S1.year AS now_year, S2.sale AS pre_sale, S1.sale AS now_sale, S1.sale - S2.sale AS diff FROM Sales2 S1 LEFT OUTER JOIN Sales2 S2 ON S2.year = (SELECT MAX(year) FROM Sales2 S3 WHERE S1.year \u0026gt; S3.year) ORDER BY now_year; 执行结果\n1 2 3 4 5 6 7 pre_year now_year pre_sale now_sale diff -------- -------- -------- -------- ----- 1990 50 --1990年也会出现 1990 1992 50 50 0 1992 1993 50 52 2 1993 1994 52 55 3 1994 1997 55 55 0 移动累计值和移动平均值 Accounts\n求截止到那个时间点的账户余额。我们首先可以使用窗口函数来实现。\n1 2 3 4 --求累计值：使用窗口函数 SELECT prc_date, prc_amt, SUM(prc_amt) OVER (ORDER BY prc_date) AS onhand_amt FROM Accounts; 如果使用标准SQL-92，我们可以像下面这样写SQL语句。\n1 2 3 4 5 6 7 --求累计值：使用冯·诺依曼型递归集合 SELECT prc_date, A1.prc_amt, (SELECT SUM(prc_amt) FROM Accounts A2 WHERE A1.prc_date \u0026gt;= A2.prc_date ) AS onhand_amt FROM Accounts A1 ORDER BY prc_date; 执行结果\n1 2 3 4 5 6 7 8 9 prc_date prc_amt onhand_amt ---------- ------- ---------- 2006-10-26 12000 12000 --12000 2006-10-28 2500 14500 --12000 + 2500 2006-10-31 -15000 -500 --12000 + 2500 + (-15000) 2006-11-03 34000 33500 --12000 + 2500 + (-15000) + 34000 2006-11-04 -5000 28500 -- 下同 2006-11-06 7200 35700 -- ： 2006-11-11 11000 46700 -- ： 移动累计值。所谓移动，指的是将累计的数据行数固定（本例中为3行），一行一行地偏移，如下表所示。\n滑动窗口, 窗口大小为3行\n目标区间一行一行地偏移\n如果使用窗口函数，可以像下面这样通过指定ROWS关键字来指定数据行数。\n1 2 3 4 5 --求移动累计值(1)：使用窗口函数 SELECT prc_date, prc_amt, SUM(prc_amt) OVER (ORDER BY prc_date ROWS 2 PRECEDING) AS onhand_amt FROM Accounts; 如果使用关联子查询，我们还可以像下面这样用标量子查询来计算行数。\n1 2 3 4 5 6 7 8 9 10 11 12 --求移动累计值(2)：不满3行的时间区间也输出 SELECT prc_date, A1.prc_amt, (SELECT SUM(prc_amt) FROM Accounts A2 WHERE A1.prc_date \u0026gt;= A2.prc_date AND (SELECT COUNT(＊) FROM Accounts A3 WHERE A3.prc_date BETWEEN A2.prc_date AND A1.prc_date ) \u0026lt;= 3 ) AS mvg_sum FROM Accounts A1 ORDER BY prc_date; 执行结果\n1 2 3 4 5 6 7 8 9 prc_date prc_amt mvg_sum ---------- ------- ------- 2006-10-26 12000 12000 --12000 2006-10-28 2500 14500 --12000 + 2500 2006-10-31 -15000 -500 --12000 + 2500 + (-15000) 2006-11-03 34000 21500 --2500 + (-15000) + 34000 2006-11-04 -5000 14000 --下同 2006-11-06 7200 36200 -- ： 2006-11-11 11000 13200 -- ： 使用HAVING子句找出元素数刚好为3行的集合\n1 2 3 4 5 6 7 8 9 10 11 12 --移动累计值(3)：不满3行的区间按无效处理 SELECT prc_date, A1.prc_amt, (SELECT SUM(prc_amt) FROM Accounts A2 WHERE A1.prc_date \u0026gt;= A2.prc_date AND (SELECT COUNT(＊) FROM Accounts A3 WHERE A3.prc_date BETWEEN A2.prc_date AND A1.prc_date ) \u0026lt;= 3 HAVING COUNT(＊) =3) AS mvg_sum --不满3行数据的不显示 FROM Accounts A1 ORDER BY prc_date; 执行结果\n1 2 3 4 5 6 7 8 9 prc_date prc_amt mvg_sum ---------- ------- ------- 2006-10-26 12000 --不满3行数据，所以不显示 2006-10-28 2500 --不满3行数据，所以不显示 2006-10-31 -15000 -500 --凑够了3行，所以输出 2006-11-03 34000 21500 2006-11-04 -5000 14000 2006-11-06 7200 36200 2006-11-11 11000 13200 去掉聚合后的明细数据\n1 2 3 4 5 6 7 8 9 10 --去掉聚合并输出 SELECT A1.prc_date AS A1_date, A2.prc_date AS A2_date, A2.prc_amt AS amt FROM Accounts A1, Accounts A2 WHERE A1.prc_date \u0026gt;= A2.prc_date AND (SELECT COUNT(＊) FROM Accounts A3 WHERE A3.prc_date BETWEEN A2.prc_date AND A1.prc_date ) \u0026lt;= 3 ORDER BY A1_date, A2_date; 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 A1_date A2_date amt ---------- ---------- ------- 2006-10-26 2006-10-26 12000 2006-10-28 2006-10-26 12000 2006-10-28 2006-10-28 2500 2006-10-31 2006-10-26 12000 2006-10-31 2006-10-28 2500 …S1:-500 2006-10-31 2006-10-31 -15000 2006-11-03 2006-10-28 2500 2006-11-03 2006-10-31 -15000 …S2:21500 2006-11-03 2006-11-03 34000 2006-11-04 2006-10-31 -15000 2006-11-04 2006-11-03 34000 …S3:14000 2006-11-04 2006-11-04 -5000 2006-11-06 2006-11-03 34000 2006-11-06 2006-11-04 -5000 …S4:36200 2006-11-06 2006-11-06 7200 2006-11-11 2006-11-04 -5000 2006-11-11 2006-11-06 7200 …S5:13200 2006-11-11 2006-11-11 11000 存在部分交集的集合簇\n到目前为止，我们主要思考了累计值的求法，所以使用的是SUM函数。如果求移动平均值（moving average），那么将SUM函数改写成AVG函数就可以了。\n查询重叠的时间区间 Reservations\n日期的重叠类型\n1 2 3 4 5 6 7 8 9 10 11 12 --求重叠的住宿期间 SELECT reserver, start_date, end_date FROM Reservations R1 WHERE EXISTS (SELECT ＊ FROM Reservations R2 WHERE R1.reserver \u0026lt;\u0026gt; R2.reserver --与自己以外的客人进行比较 AND ( R1.start_date BETWEEN R2.start_date AND R2.end_date --条件(1)：自己的入住日期在他人的住宿期间内 OR R1.end_date BETWEEN R2.start_date AND R2.end_date)); --条件(2)：自己的离店日期在他人的住宿期间内 执行结果\n1 2 3 4 5 6 reserver start_date end_date -------- ---------- ---------- 荒木 2006-10-28 2006-10-31 堀 2006-10-31 2006-11-01 山本 2006-11-03 2006-11-04 内田 2006-11-03 2006-11-05 如果想求“与任何住宿期间都不重叠的日期”，我们只需要把EXISTS谓词改写成NOT EXISTS谓词就可以了。\n如果山本的入住日期不是11月3号，而是推迟了一天，即11月4号，那么查询结果里将不会出现内田。这是因为，内田的入住日期和离店日期都不再与任何人重叠， 于是条件(1)和条件(2)就都不满足了。换句话说，像内田这种自己的住宿期间完全包含了他人的住宿期间的情况，会被这条SQL语句排除掉。如果想把这样的住 宿期间也输出，我们需要追加条件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --升级版：把完全包含别人的住宿期间的情况也输出 SELECT reserver, start_date, end_date FROM Reservations R1 WHERE EXISTS (SELECT ＊ FROM Reservations R2 WHERE R1.reserver \u0026lt;\u0026gt; R2.reserver AND ( ( R1.start_date BETWEEN R2.start_date AND R2.end_date OR R1.end_date BETWEEN R2.start_date AND R2.end_date) OR ( R2.start_date BETWEEN R1.start_date AND R1.end_date AND R2.end_date BETWEEN R1.start_date AND R1.end_date))); ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-6-%E7%94%A8%E5%85%B3%E8%81%94%E5%AD%90%E6%9F%A5%E8%AF%A2%E6%AF%94%E8%BE%83%E8%A1%8C%E4%B8%8E%E8%A1%8C/","summary":"使用SQL进行行间比较时，发挥主要作用的技术是关联子查询，特别是与自连接相结合的“自关联子查询” 增长、减少、维持现状 Sales 年营业额的趋势 使用SQ","title":"1-6 用关联子查询比较行与行"},{"content":"本节将以集合论和群论中的“类”这一重要概念为核心，阐明GROUP BY和PARTITION BY的意义。\nSQL的语句中具有分组功能的是GROUP BY和PARTITION BY，它们都可以根据指定的列为表分组。区别仅仅在于，GROUP BY在分组之后会把每个分组聚合成一 行数据。\nTeams\n1 2 3 4 5 6 SELECT member, team, age , RANK() OVER(PARTITION BY team ORDER BY age DESC) rn, DENSE_RANK() OVER(PARTITION BY team ORDER BY age DESC) dense_rn, ROW_NUMBER() OVER(PARTITION BY team ORDER BY age DESC) row_num FROM Members ORDER BY team, rn; 执行结果\n分割后的子集\n重点关注一下划分出的子集\n它们全都是非空集合。 所有子集的并集等于划分之前的集合。 任何两个子集之间都没有交集。 对3取余给自然数集合N分类\n余0的类：M1 = {0, 3, 6, 9, …} 余1的类：M2 = {1, 4, 7, 10, …} 余2的类：M2 = {2, 5, 8, 11, …} 从类的第2个性质我们知道，这3个类涵盖了全部自然数。\nM1 + M2 + M3 = N MOD函数\n1 2 3 4 5 --对从1到10的整数以3为模求剩余类 SELECT MOD(num, 3) AS modulo, num FROM Natural ORDER BY modulo, num; 执行结果\n随机地将数据减为原来的五分之一\n1 2 3 4 5 6 7 8 9 10 11 12 --从原来的表中抽出（大约）五分之一行的数据 SELECT ＊ FROM SomeTbl WHERE MOD(seq, 5) = 0; --表中没有连续编号的列时，使用ROW_NUMBER函数就可以了 SELECT ＊ FROM (SELECT col, ROW_NUMBER() OVER(ORDER BY col) AS seq FROM SomeTbl) WHERE MOD(seq, 5) = 0; ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-5-group-by%E5%92%8Cpartition-by/","summary":"本节将以集合论和群论中的“类”这一重要概念为核心，阐明GROUP BY和PARTITION BY的意义。 SQL的语句中具有分组功能的是GROUP","title":"2-5 GROUP BY和PARTITION BY.md"},{"content":"用外连接进行行列转换(1)（行→列）：制作交叉表 员工学习过的培训课程的表Courses\n课程学习记录一览表（表头：课程；侧栏：员工姓名）\n用外连接的思路来思考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --水平展开求交叉表(1)：使用外连接 SELECT C0.name, CASE WHEN C1.name IS NOT NULL THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;SQL入门\u0026#34;, CASE WHEN C2.name IS NOT NULL THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;UNIX基础\u0026#34;, CASE WHEN C3.name IS NOT NULL THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;Java中级\u0026#34; FROM (SELECT DISTINCT name FROM Courses) C0 --这里的C0是侧栏 LEFT OUTER JOIN (SELECT name FROM Courses WHERE course = \u0026#39;SQL入门’) C1 ON C0.name = C1.name LEFT OUTER JOIN (SELECT name FROM Courses WHERE course = \u0026#39;UNIX基础’) C2 ON C0.name = C2.name LEFT OUTER JOIN (SELECT name FROM Courses WHERE course = \u0026#39;Java中级’) C3 ON C0.name = C3.name; C0：主表\nC1:SQL\nC2:UNIX\nC3:Java\n一般情况下，外连接都可以用标量子查询替代\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --水平展开(2)：使用标量子查询 SELECT C0.name, (SELECT \u0026#39;○\u0026#39; FROM Courses C1 WHERE course = \u0026#39;SQL入门’ AND C1.name = C0.name) AS \u0026#34;SQL入门\u0026#34;, (SELECT \u0026#39;○\u0026#39; FROM Courses C2 WHERE course = \u0026#39;UNIX基础’ AND C2.name = C0.name) AS \u0026#34;UNIX基础\u0026#34;, (SELECT \u0026#39;○\u0026#39; FROM Courses C3 WHERE course = \u0026#39;Java中级’ AND C3.name = C0.name) AS \u0026#34;Java中级\u0026#34; FROM (SELECT DISTINCT name FROM Courses) C0; --这里的C0是表侧栏 例如想加入第4列“PHP入门”时，只需要在SELECT子句的最后加上下面这条语句就可以了（如果采用前面的写法，则必需修改SELECT子句和FROM子句两个地方）。\n1 2 3 4 (SELECT \u0026#39;○\u0026#39; FROM Courses C4 WHERE course = \u0026#39;PHP入门’ AND C4.name = C0.name ) AS \u0026#34;PHP入门\u0026#34; 这种做法不仅利于应对需求变更，对于需要动态生成SQL的系统也是很有好处的。缺点是性能不太好，目前在SELECT子句中使用标量子查询（或者关联子查询） 的话，性能开销还是相当大的。\n嵌套使用CASE表达式\n1 2 3 4 5 6 7 8 9 10 --水平展开(3)：嵌套使用CASE表达式 SELECT name, CASE WHEN SUM(CASE WHEN course = \u0026#39;SQL入门’THEN 1 ELSE NULL END) = 1 THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;SQL入门\u0026#34;, CASE WHEN SUM(CASE WHEN course = \u0026#39;UNIX基础’THEN 1 ELSE NULL END) = 1 THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;UNIX基础\u0026#34;, CASE WHEN SUM(CASE WHEN course = \u0026#39;Java中级’THEN 1 ELSE NULL END) = 1 THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;Java中级\u0026#34; FROM Courses GROUP BY name; 用外连接进行行列转换(2)（列→行）：汇总重复项于一列 一张让数据库工程师想哭的表Personnel：员工子女信息\n使用UNION ALL来实现。\n1 2 3 4 5 6 --列数据转换成行数据：使用UNION ALL SELECT employee, child_1 AS child FROM Personnel UNION ALL SELECT employee, child_2 AS child FROM Personnel UNION ALL SELECT employee, child_3 AS child FROM Personnel; 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 employee child ---------- ------- 赤井 一郎 赤井 二郎 赤井 三郎 工藤 春子 工藤 夏子 工藤 铃木 夏子 铃木 铃木 吉田 吉田 吉田 希望得到员工子女列表\n来生成一个存储子女列表的视图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 CREATE VIEW Children(child) AS SELECT child_1 FROM Personnel UNION SELECT child_2 FROM Personnel UNION SELECT child_3 FROM Personnel; child ----- 一郎 二郎 三郎 春子 夏子 员工列表为主表进行外连接操作\n1 2 3 4 5 --获取员工子女列表的SQL语句（没有孩子的员工也要输出） SELECT EMP.employee, CHILDREN.child FROM Personnel EMP LEFT OUTER JOIN Children ON CHILDREN.child IN (EMP.child_1, EMP.child_2, EMP.child_3); 在交叉表里制作嵌套式表侧栏 年龄层级主表：TblAge\n性别主表：TblSex\n人口分布表：TblPop\n包含嵌套式表侧栏的统计表\n目标表的侧栏是年龄层级和性别，所以我们需要使用表TblAge和表TblSex作为主表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --使用外连接生成嵌套式表侧栏：错误的SQL语句 SELECT MASTER1.age_class AS age_class, MASTER2.sex_cd AS sex_cd, DATA.pop_tohoku AS pop_tohoku, DATA.pop_kanto AS pop_kanto FROM (SELECT age_class, sex_cd, SUM(CASE WHEN pref_name IN (’青森’, ’秋田’) THEN population ELSE NULL END) AS pop_tohoku, SUM(CASE WHEN pref_name IN (’东京’, ’千叶’) THEN population ELSE NULL END) AS pop_kanto FROM TblPop GROUP BY age_class, sex_cd) DATA RIGHT OUTER JOIN TblAge MASTER1--外连接1：和年龄层级主表进行外连接 ON MASTER1.age_class = DATA.age_class RIGHT OUTER JOIN TblSex MASTER2--外连接2：和性别主表进行外连接 ON MASTER2.sex_cd = DATA.sex_cd; 内部的sql先生成age_class, sex_cd, pop_tohoku, pop_kanto, 之后再关联名称\n执行结果\n1 2 3 4 5 6 age_class sex_cd pop_tohoku pop_kanto --------- ------ ---------- --------- 1 m 1100 1800 1 f 1300 2500 3 m 1000 3 f 1800 2100 结果里没有年龄层为2的原因是TblPop没有数据.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --停在第1个外连接处时：结果里包含年龄层级为2的数据 SELECT MASTER1.age_class AS age_class, DATA.sex_cd AS sex_cd, DATA.pop_tohoku AS pop_tohoku, DATA.pop_kanto AS pop_kanto FROM (SELECT age_class, sex_cd, SUM(CASE WHEN pref_name IN (’青森’, ’秋田’) THEN population ELSE NULL END) AS pop_tohoku, SUM(CASE WHEN pref_name IN (’东京’, ’千叶’) THEN population ELSE NULL END) AS pop_kanto FROM TblPop GROUP BY age_class, sex_cd) DATA RIGHT OUTER JOIN TblAge MASTER1 ON MASTER1.age_class = DATA.age_class; 执行结果\n1 2 3 4 5 6 7 age_class sex_cd pop_tohoku pop_kanto --------- ------ ---------- --------- 1 m 1100 1800 1 f 1300 2500 2 --存在年龄层级为2的数据 3 m 1000 3 f 1800 2100 原因也不难理解。表TblPop里本来就没有年龄层级为2的数据，自然也没有相应的性别信息m或f，于是“性别编号”列只能是NULL。因此与性别主表进行外连接时， 连接条件会变成ON MASTER2.sex_cd =NULL，结果是unknown\n如果不允许进行两次外连接，那么调整成一次就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --使用外连接生成嵌套式表侧栏：正确的SQL语句 SELECT MASTER.age_class AS age_class, MASTER.sex_cd AS sex_cd, DATA.pop_tohoku AS pop_tohoku, DATA.pop_kanto AS pop_kanto FROM (SELECT age_class, sex_cd FROM TblAge CROSS JOIN TblSex ) MASTER --使用交叉连接生成两张主表的笛卡儿积 LEFT OUTER JOIN (SELECT age_class, sex_cd, SUM(CASE WHEN pref_name IN (’青森’, ’秋田’) THEN population ELSE NULL END) AS pop_tohoku, SUM(CASE WHEN pref_name IN (’东京’, ’千叶’) THEN population ELSE NULL END) AS pop_kanto FROM TblPop GROUP BY age_class, sex_cd) DATA ON MASTER.age_class = DATA.age_class AND MASTER.sex_cd = DATA.sex_cd; 执行结果\n1 2 3 4 5 6 7 8 age_class sex_cd pop_tohoku pop_kanto --------- ------ ---------- --------- 1 m 1100 1800 1 f 1300 2500 2 m 2 f 3 m 1000 3 f 1800 2100 作为乘法运算的连接 交叉连接相当于乘法运算\nItems\nSalesHistory\n先使用这两张表生成一张统计表，以商品为单位汇总出各自的销量。我们期望的结果是像下面这样的。\n1 2 3 4 5 6 item_no total_qty ------- --------- 10 36 20 32 30 22 40 恐怕很多人会想到下面这种做法。\n1 2 3 4 5 6 7 --解答(1)：通过在连接前聚合来创建一对一的关系 SELECT I.item_no, SH.total_qty FROM Items I LEFT OUTER JOIN (SELECT item_no, SUM(quantity) AS total_qty FROM SalesHistory GROUP BY item_no) SH ON I.item_no = SH.item_no; 以商品编号为主键的临时视图（SH）\n1 2 3 4 5 --解答(2)：先进行一对多的连接再聚合 SELECT I.item_no, SUM(SH.quantity) AS total_qty FROM Items I LEFT OUTER JOIN SalesHistory SH ON I.item_no = SH.item_no 一对多的连接 GROUP BY I.item_no; 一对一或一对多关系的两个集合，在进行连接操作后行数不会（异常地）增加。\n全外连接 标准SQL里定义了外连接的三种类型\n左外连接（LEFT OUTER JOIN） 右外连接（RIGHT OUTER JOIN） 全外连接（FULL OUTER JOIN） 左外连接和右外连接没有功能上的区别。用作主表的表写在运算符左边时用左外连接，写在运算符右边时用右外连接。\n全外连接\nClass_A\nClass_B\n可以理解成“把两张表都当作主表来使用”的连接。\n1 2 3 4 5 6 --全外连接保留全部信息 SELECT COALESCE(A.id, B.id) AS id, A.name AS A_name, B.name AS B_name FROM Class_A A FULL OUTER JOIN Class_B B ON A.id = B.id; 执行结果\n1 2 3 4 5 6 id A_name B_name ---- ------ ------ 1 田中 田中 2 铃木 铃木 3 伊集院 4 西园寺 COALESCE是SQL的标准函数，可以接受多个参数，功能是返回第一个非NULL的参数。\n如果所用的数据库不支持全外连接，可以分别进行左外连接和右外连接，再把两个结果通过UNION合并起来，也能达到同样的目的\n1 2 3 4 5 6 7 8 9 --数据库不支持全外连接时的替代方案 SELECT A.id AS id, A.name, B.name FROM Class_A A LEFT OUTER JOIN Class_B B ON A.id = B.id UNION SELECT B.id AS id, A.name, B.name FROM Class_A A RIGHT OUTER JOIN Class_B B ON A.id = B.id; 我们还可以换个角度，把表连接看成集合运算。内连接相当于求集合的积（INTERSECT，也称交集），全外连接相当于求集合的和（UNION，也称并集）。\n内连接相当于求集合的积（INTERSECT）\n全外连接相当于求集合的和（UNION）\n用外连接进行集合运算 用外连接求差集：A－B 1 2 3 4 SELECT A.id AS id, A.name AS A_name FROM Class_A A LEFT OUTER JOIN Class_B B ON A.id = B.id WHERE B.name IS NULL; 执行结果\n1 2 3 id A_name ---- ------ 3 伊集院 用外连接求差集（A-B）\n用外连接求差集：B－A 1 2 3 4 SELECT B.id AS id, B.name AS B_name FROM Class_A A RIGHT OUTER JOIN Class_B B ON A.id = B.id WHERE A.name IS NULL; 执行结果\n1 2 3 id B_name ---- ------ 4 西园寺 用外连接求差集（B-A）\n用全外连接求异或集 SQL没有定义求异或集的运算符，如果用集合运算符，可以有两种方法。\n一种是(A UNION B) EXCEPT (A INTERSECT B) 另一种是(A EXCEPT B) UNION (B EXCEPT A)。两种方法都比较麻烦，性能开销也会增大。 1 2 3 4 5 6 SELECT COALESCE(A.id, B.id) AS id, COALESCE(A.name , B.name ) AS name FROM Class_A A FULL OUTER JOIN Class_B B ON A.id = B.id WHERE A.name IS NULL OR B.name IS NULL; 执行结果\n1 2 3 4 id name ---- ----- 3 伊集院 4 西园寺 用全外连接求异或集\n关系除法运算也可以通过外连接来实现。使用1-4节里的表Items和表ShopItems\n1 2 3 4 5 6 7 8 9 --用外连接进行关系除法运算：差集的应用 SELECT DISTINCT shop FROM ShopItems SI1 WHERE NOT EXISTS (SELECT I.item FROM Items I LEFT OUTER JOIN ShopItems SI2 ON I.item = SI2.item AND SI1.shop = SI2.shop WHERE SI2.item IS NULL) ; 执行结果\n1 2 3 4 shop ---- 仙台 东京 本节小结 SQL不是用来生成报表的语言，所以不建议用它来进行格式转换。 必要时考虑用外连接或CASE表达式来解决问题。 生成嵌套式表侧栏时，如果先生成主表的笛卡儿积再进行连接，很容易就可以完成。 从行数来看，表连接可以看成乘法。因此，当表之间是一对多的关系时，连接后行数不会增加。 外连接的思想和集合运算很像，使用外连接可以实现各种集合运算。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-5-%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%94%A8%E6%B3%95/","summary":"用外连接进行行列转换(1)（行→列）：制作交叉表 员工学习过的培训课程的表Courses 课程学习记录一览表（表头：课程；侧栏：员工姓名） 用外连","title":"1-5 外连接的用法"},{"content":"sql是面向集合的语言\n寻找缺失的编号 SeqTbl\n用面向过程语言查询缺失的编号的过程\n对“连续编号”列按升序或者降序进行排序。 循环比较每一行和下一行的编号。 将表整体看作一个集合\n1 2 3 4 -- 如果有查询结果，说明存在缺失的编号 SELECT’存在缺失的编号’AS gap FROM SeqTbl HAVING COUNT(＊) \u0026lt;\u0026gt; MAX(seq); 执行结果\n1 2 3 gap ---------- \u0026#39;存在缺失的编号’ 上面的SQL语句里没有GROUP BY子句，此时整张表会被聚合为一行。这种情况下HAVING子句也是可以使用的。\n再来查询一下缺失编号的最小值。\n1 2 3 4 -- 查询缺失编号的最小值 SELECT MIN(seq + 1) AS gap FROM SeqTbl WHERE (seq+ 1) NOT IN ( SELECT seq FROM SeqTbl); 执行结果\n1 2 3 gap --- 4 上面展示了通过SQL语句查询缺失编号的最基本的思路，然而这个查询还不够周全，并不能涵盖所有情况。例如，如果表SeqTbl里没有编号1，那么缺失编号的 最小值应该是1，但是这两条SQL语句都不能得出正确的结果\n用HAVING子句进行子查询：求众数 Graduates（毕业生表）\n从这个例子可以看出，简单地求平均值有一个缺点，那就是很容易受到离群值（outlier）的影响。这种时候就必须使用更能准确反映出群体趋势的指标—— 众数（mode）就是其中之一。\n1 2 3 4 5 6 7 --求众数的SQL语句(1)：使用谓词 SELECT income, COUNT(＊) AS cnt FROM Graduates GROUP BY income HAVING COUNT(＊) \u0026gt;= ALL ( SELECT COUNT(＊) FROM Graduates GROUP BY income); 执行结果\n1 2 3 4 income cnt ------ --- 10000 3 20000 3 1-3节提到过ALL谓 词用于NULL或空集时会出现问题，可以用极值函数来代替。\n1 2 3 4 5 6 7 8 --求众数的SQL语句(2)：使用极值函数 SELECT income, COUNT(＊) AS cnt FROM Graduates GROUP BY income HAVING COUNT(＊) \u0026gt;= ( SELECT MAX(cnt) FROM ( SELECT COUNT(＊) AS cnt FROM Graduates GROUP BY income) TMP ) ; 用HAVING子句进行自连接：求中位数 用面向集合的方式，来查询位于集合正中间的元素。\n将集合里的元素按照大小分为上半部分和下半部分两个子集，同时让这2个子集共同拥有集合正中间的元素。 中位数求法的思路\n1 2 3 4 5 6 7 8 9 10 11 12 --求中位数的SQL语句：在HAVING子句中使用非等值自连接 SELECT AVG(DISTINCT income) FROM (SELECT T1.income FROM Graduates T1, Graduates T2 GROUP BY T1.income --S1的条件 HAVING SUM(CASE WHEN T2.income \u0026gt;= T1.income THEN 1 ELSE 0 END) \u0026gt;= COUNT(＊) / 2 --S2的条件 AND SUM(CASE WHEN T2.income \u0026lt;= T1.income THEN 1 ELSE 0 END) \u0026gt;= COUNT(＊) / 2 ) TMP; 查询不包含NULL的集合 count(*)和count(column)的区别\n第一个是性能上的区别；第二个是COUNT（＊）可以用于NULL，而COUNT（列名）与其他聚合函数一样，要先排除掉NULL的行再进行统计。 第二个区别也可以这么理解：COUNT（＊）查询的是所有行的数目，而COUNT（列名）查询的则不一定是。 一张全是NULL的表NullTbl\n1 2 3 --在对包含NULL的列使用时，COUNT（＊）和COUNT（列名）的查询结果是不同的 SELECT COUNT(＊), COUNT(col_1) FROM NullTbl; 执行结果\n1 2 3 count(＊) count(col_1) -------- ------------ 3 0 Students\n所有学生都提交了报告的学院有哪些\n1 2 3 4 5 --查询“提交日期”列内不包含NULL的学院(1)：使用COUNT函数 SELECT dpt FROM Students GROUP BY dpt HAVING COUNT(＊) = COUNT(sbmt_date); 执行结果\n1 2 3 4 dpt -------- 理学院 经济学院 使用CASE表达式也可以实现同样的功能\n1 2 3 4 5 6 7 --查询“提交日期”列内不包含NULL的学院(2)：使用CASE表达式 SELECT dpt FROM Students GROUP BY dpt HAVING COUNT(＊) = SUM(CASE WHEN sbmt_date IS NOT NULL THEN 1 ELSE 0 END); 用关系除法运算进行购物篮分析 我们假设有这样两张表：全国连锁折扣店的商品表Items，以及各个店铺的库存管理表ShopItems。\nItems\nShopItems\n查询囊括了表Items中所有商品的店铺\n1 2 3 4 --查询啤酒、纸尿裤和自行车同时在库的店铺：错误的SQL语句 SELECT DISTINCT shop FROM ShopItems WHERE item IN (SELECT item FROM Items); 执行结果\n1 2 3 4 5 shop ---- 仙台 东京 大阪 1 2 3 4 5 6 --查询啤酒、纸尿裤和自行车同时在库的店铺：正确的SQL语句 SELECT SI.shop FROM ShopItems SI, Items I WHERE SI.item = I.item GROUP BY SI.shop HAVING COUNT(SI.item) = (SELECT COUNT(item) FROM Items); 执行结果\n1 2 3 4 shop ---- 仙台 东京 请注意，如果把HAVING子句改成HAVING COUNT(SI.item)=COUNT(I.item)，结果就不对了。\n1 2 3 4 5 -- COUNT(I.item)的值已经不一定是3了 SELECT SI.shop, COUNT(SI.item), COUNT(I.item) FROM ShopItems SI, Items I WHERE SI.item = I.item GROUP BY SI.shop; 执行结果\n1 2 3 4 5 shop COUNT(SI.item) COUNT(I.item) ----- --------------- -------------- 仙台 3 3 东京 3 3 大阪 2 2 如何排除掉仙台店（仙台店的仓库中存在“窗帘”，但商品表里没有“窗帘”），让结果里只出现东京店。\n这类问题被称为“精确关系除法”（exact relational division），即只选择没有剩余商品的店铺 与此相对，前一个问题被称为“带余除法”（division with a remainder）。 1 2 3 4 5 6 7 --精确关系除法运算：使用外连接和COUNT函数 SELECT SI.shop FROM ShopItems SI LEFT OUTER JOIN Items I ON SI.item=I.item GROUP BY SI.shop HAVING COUNT(SI.item) = (SELECT COUNT(item) FROM Items) --条件1 AND COUNT(I.item) = (SELECT COUNT(item) FROM Items); --条件2 执行结果\n1 2 3 shop ---- 东京 表ShopItems和表Items外连接后的结果\n一般来说，使用外连接时，大多会用商品表Items作为主表进行外连接操作，而这里颠倒了一下主从关系，表使用ShopItems作为了主表，这一点比较有趣。\n本节小结 表不是文件，记录也没有顺序，所以SQL不进行排序。 SQL不是面向过程语言，没有循环、条件分支、赋值操作。 SQL通过不断生成子集来求得目标集合。SQL不像面向过程语言那样通过画流程图来思考问题，而是通过画集合的关系图来思考。 GROUP BY子句可以用来生成子集。 WHERE子句用来调查集合元素的性质，而HAVING子句用来调查集合本身的性质。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-4-having%E5%AD%90%E5%8F%A5%E7%9A%84%E5%8A%9B%E9%87%8F/","summary":"sql是面向集合的语言 寻找缺失的编号 SeqTbl 用面向过程语言查询缺失的编号的过程 对“连续编号”列按升序或者降序进行排序。 循环比较每一行和下一行的编号","title":"1-4 HAVING子句的力量"},{"content":"7.1 定价能力是衡量品牌力的重要标准 既然不赚钱，为何商家要花大力气宣传、促销、做销售额、发战报呢？\n答案是：“卖货”和“卖价格带”是品牌经营的两大目标。卖货即提高销量获取利润，卖价格带即维持知名度和品牌价格带。品牌商家在大促中行动的主要目的是提 升知名度和价格带，更多是营销维度的考量，而非获利行为。\n卖货赚钱关乎品牌的生存和短期业绩表现，保持一定的销量和规模是品牌的生存基础。 品牌认知建立在销售规模之上，若商家达不到一定的规模，就很难被称为“品牌”。 而卖价格带则关乎品牌商长期的定位、形象与价值。 比如我们常见的许多消费品品牌，毛利率可高达40%以上，它们为什么不降价20%～30%，在保证毛利为正的前提下薄利多销、抢占更多市场？\n因为价格带一旦降下去，就很难重新抬起来了。降价在短期能带来丰厚的业绩，但长期来看，却是一种毁灭品牌价值的行为。 这也是为何有一部分大品牌会抵制新兴渠道。部分新兴渠道（如拼多多、早期的淘宝等）以低价位为核心竞争力，并没有渠道管控、帮助大品牌稳住价格带的 能力。 品牌的定价能力有时体现在产品售价的稳定性上\n定价能力强的品牌，其产品的价格一般比较稳定，很少打折，打折幅度也不大； 反之，若产品上市一段时间后总通过大幅打折出货，则体现出产品定价能力不足。 图7-1 部分国内外美妆护肤品牌大单品2020年11～12月天猫旗舰店价格\n任何一个优秀的品牌，都应该具备定价能力（不打折）、溢价能力、涨价能力。我们可以通过品牌对于价格的掌控能力找到品牌力出众的优秀企业。\n7.2 品牌分级体系：从1.0到4.0，提价能力逐级增强 不同消费品品牌的经营壁垒和品牌价值天差地别。其中，溢价能力是一个非常重要的指标，它能够直接反映品牌的质地以及未来发展潜力。\n根据定价能力的不同，消费品品牌可分为1.0到4.0四个阶段：\n品牌1.0是“品牌即认知”，代表品牌提供了基础的质量保障，并做到了规模化生产； 品牌2.0是“品牌即优选”，代表品牌具备基础的溢价能力； 品牌3.0是“品牌即品类”，行业大部分自然流量导向少数品牌； 品牌4.0是“品牌即身份”，这类品牌拥有极高的溢价，其定价几乎完全脱离成本。 品牌1.0对应第4章中提到的省心型品牌，品牌2.0到品牌4.0对应悦己型品牌。省心型品牌面向只想快速找到具备基础质量保障且价格公道的商品的消费者，而 悦己型品牌则面向以购物为乐趣，期望买到高品质商品，或期望彰显身份与格调的消费者。\n品牌1.0：品牌即认知 我们生活中接触的大多数大众消费品品牌，属于品牌1.0的范畴。这类品牌的核心价值是组织生产，实现规模化降本增效，并且保证产品质量合格。这些品牌的存 在大幅提升了消费品产业的运转效率，并提供了质量背书，降低了消费者的搜索成本。\n怡宝 优衣库 从如此多的工厂中采购商品，同时保证各个型号和尺码的产品的质量与库存，这体现了优衣库作为一个省心型品牌所起到的组织生产功能。\n表7-1 优衣库部分核心代工厂\n优衣库在国内市场取得成功的原因包括：\n拥有领先的分销渠道 一方面是门店数量, 767家 另一方面是线上线下渠道的协同优衣库提供无缝的购物体验，其天猫旗舰店支持下单后到附近门店自提，这极大满足了顾客对即时性的需求。 品质稳定、性价比高 接地气，快反（快速反应），对本土文化理解度高 能做到快反的原因则是强大的供应链管理和库存管控能力。 品牌2.0：品牌即优选 这个层级以上的品牌，都具备较为突出的溢价能力。换句话说，“是否具备溢价能力”这一要素决定了品牌能否进入2.0以上的层级。当然，品牌在具备一定销量 和认知的基础上产生的溢价才有意义。如果一个品牌没有达到一定的规模，那就连品牌1.0都算不上。\n品牌溢价不会凭空产生，大多数产品产生溢价的原因可归结为：①文化属性认同感；②功能性区隔差异性。\n文化属性认同感来自品牌，每个品牌背后都代表一种精神，比如“Just do it”“Nothing is impossible”“一切皆有可能”“永不止步”等，对于精神文化 的认可会转为对于品牌的忠诚度。 功能性区隔差异性来自产品本身，运动鞋可以分成篮球鞋、跑步鞋等多个品种，每个品种下又有多种细分，比如跑步鞋分成缓冲、支撑、控制等条线。这样的 细分带来了功能性区隔差异性，不同的人、不同的用途，适用不同的产品。 图7-2 溢价来自文化属性认同感和功能性区隔差异性\n跻身2.0阶段的一个国货品牌是安踏旗下的FILA。\n图7-3 FILA、耐克、阿迪达斯运动产品价格带对比（2021年7月）\n品牌3.0：品牌即品类 如何简单地理解“品牌即品类”？\n一想到某些细分品类、特定功能，就自然而然地想到某个品牌。比如很多消费者提起羽绒服就想到波司登，提起智能手机就想到苹果和华为，提起电动车就想到 特斯拉，这都是品牌3.0的体现。这类品牌的特点是与品类强绑定，并且具备较高的溢价。\n有一些品牌有很高的市占率，却没有涨价空间，它们并不属于3.0品牌，可以称其为“伪3.0品牌”。事实上，这类品牌很容易陷入“价格涨不动、市占率已经饱和、 行业规模没有扩张空间”的增长瓶颈。区分伪3.0品牌和真3.0品牌的核心要素，是品牌的涨价能力。\n2020年，我国功能性护肤品龙头品牌薇诺娜牢牢占据国内功能性护肤品市场份额第一的地位，其品牌在一定程度上代表了针对敏感肌的功能性护肤品品类。\n图7-4 薇诺娜在功能性护肤品中的市占率逐年提升\n薇诺娜的一部分产品是先由合作医院的医生提出临床需求，之后联合当地高校共同研发的。新品诞生后，由合作医院用于临床辅助治疗，结合临床的良好反馈将 产品推向市场。\n图7-5 薇诺娜的“产学研”合作机制\n总而言之，品牌3.0的核心在于通过与品类实现强绑定，得到较高的溢价能力。我们可以在日常生活中留意这类“提起品类想到品牌”的现象，在这类品牌里不乏 具备独特壁垒和较强涨价能力的重要标的。\n品牌4.0：品牌即身份 “品牌即身份”指的是拥有或使用某个品牌的商品，就能够拥有某种身份。此类现象常见于奢侈品品牌以及某些品牌的限量产品\n品牌要达到4.0阶段，文化属性认同感可能会比功能性区隔差异性更为重要。\n拥有极高溢价的品类往往集合了社交属性和彰显格调两个因素，因为具备这两个因素的产品更容易形成文化属性认同感。 当然大多数4.0品牌仍然拥有功能性区隔差异性。如很多奢侈品品牌都有其精通的领域： 爱马仕之于皮具，劳力士之于手表，巴宝莉之于大衣，等等。 功能性区隔差异性一定程度上也是品牌打造文化属性认同感的一个基础条件。 4.0品牌的产品通常会形成稳定交易的二级市场。\n对于一般的消费品，二手商品的价格相比原价会有明显折让，且流动性不佳； 但某些强势品牌的产品却能够产生广泛流通的二级市场（即玩家间相互交易），甚至产生做市商（比如二手奢侈品专卖店）。这意味着这些产品已经具备 “通货”属性，具备极强的价格认知。随着时间的推移，一部分产品在二级市场上的流通价格甚至可能超过产品的原始定价。我们将这类现象称为“品牌4.0+”。 7.3 案例一：直播电商带来了什么 直播电商的规模有多大？根据艾瑞咨询的预测，2021年我国直播电商市场规模约为2.27万亿元（见图7-7），在整个线上消费市场中的渗透率约为15.5%。这意 味着每6～7个包裹中，可能就有一个来自直播电商渠道。\n图7-7 中国直播电商市场规模\n很多人会认为直播电商的火热仅仅是因为直播平台的流量大，这是一个非常典型的误解。在分析直播电商的时候，我们要放下“销售量=流量×转化率”的思路。这 个思路过于简单，会让我们忽略很多重要的问题，进而得到错误的结论。在商品销售的商业模型中，曝光次数、转化率、价格、毛利率、复购次数都是关键的指 标，只关注流量（曝光次数）而忽略了价格和复购，是常见的误区。定价格带、通过品牌宣传带来自然流量乃至复购，都是品牌经营中的重要环节。商家对价格 带和复购的追求，会在相当大的程度上影响其商业行为。事实上，很多直播电商的商家不赚钱（甚至亏本），他们参与直播电商的原因是希望提升知名度，并最 终通过复购和自然流量赚钱。\n图7-8 2020～2021年各大主要直播电商品平台GMV\n淘宝直播的特点是头部主播占据极高的话语权，品牌商家几乎难以通过头部主播赚钱。 快手主播的头部化也比较明显，主播通过私域流量销售亲民品牌或产业带品牌； 抖音的特色则在于品牌自播，品牌通过自播实现营销和变现是相对比较容易的，没有特别突出的头部主播。 淘宝头部主播带货：商家核心诉求是品宣而非盈利 为什么这些主播能够拥有如此之强的议价能力？\n播之间“强者愈强”的马太效应循环就此形成：主播成交额高—议价能力强—品牌给的折扣低—成交额更高。 图7-9 2021年9月淘宝直播平台前10名主播带货GMV\n商家请淘宝头部主播带货很难直接盈利，一方面是因为头部主播要求的折扣力度大，另一方面是这些头部主播通常会向品牌方收取高额的佣金。\n头部主播通常通过“坑位费+佣金”的形式向品牌商家收费。\n坑位费是只要开播上架了商品就会收取的费用，而不论实际成交额的多少； 佣金则按实际成交额的百分比来收取。 那么品牌商家为何还要让主播来帮他们带货？主要还是品宣的考量。\n淘宝店铺自播：主要作用是转化而非引流 图7-10 在截至2021年9月的12个月内，淘宝直播的商家自播占比达60%\n引流和转化有什么区别？核心在于是否能够让用户产生计划以外的选择。\n比如某消费者计划在A和B两个品牌的产品中购买其一，最终不论买了A还是B，都属于这两个品牌的“转化”。但若是发现并购买了C，就相当于品牌C做了一次 成功的“引流”。 一个渠道是否有这样的引流功能，会直接决定渠道的获利空间，引流功能越强的渠道，通常盈利能力也越强。 淘宝的店铺自播如何促进转化？\n第一，直播能比图文带来更好的展示效果，从而促进用户下单。 第二，直播互动能起到一部分“客服”的职能，效果也优于传统的客服。 第三，有的店家会在直播间中发放专属的直播优惠，这也能起到促进转化的效果。 淘宝店铺自播和抖音、快手自播的最大区别在于引流的能力。\n大多数用户点进自播间之前就应进入了相应品牌或店铺的首页，这意味着其实淘宝的店铺自播引流能力并不强。 而抖音、快手的店铺自播则是用户“刷”出来的，用户在进入直播间之前可能并不认识这些品牌或店家，这类店铺自播能帮助商家起到较强的引流效果。 快手直播：头部主播帮助亲民品牌和产业带品牌卖货 在前文中，我们就提到了消费产业链有三个主要环节：供应链（提供商品）、品牌（提供认知和信任）、渠道（提供流通和触达）。\n快手直播的特殊之处在于：快手头部主播充当的是品牌环节 而淘宝、抖音等平台上的主播主要属于渠道环节。 首先，快手是一个以主播带货为主、主播头部化程度较高的平台。\n快手的调性和文化是比较独特的，对比过快手、抖音、淘宝直播的人会很容易发现，快手直播的内容给人的感觉是很不一样的。很多商家难以把握快手的口味 和调性，很难做好自播，他们只能依靠达人带货来进驻快手。 快手的主播集中程度似乎远低于淘宝平台，但我们要注意，其中很多大主播都属于“辛巴家族”, 如果把“辛巴家族”所有主播的成交额都算到一起，那么快手带 货主播的集中程度非常之高。 图7-11 2021年9月快手直播平台前10名主播带货GMV\n其次，快手直播下单用户的流量来源主要是私域流量，这和淘宝、抖音等平台有很大不同。如果消费者下单之前就已经是主播的粉丝了，那就将其归为私域流量， 否则是公域流量。\n快手直播达人的下单客户大多是其粉丝，这是由：\n①快手主播充当了“品牌”这件事情导致的，消费者一般都会是其信任的主播的粉丝； ②快手平台的页面设计导致的，在快手App里通过“关注”页面进入直播间是最方便的方法，而在用户离开某个直播间时，系统也会弹出窗口提醒用户关注主播， 这样的设计增加了用户关注他们感兴趣的主播的概率。 最后，快手头部主播销售的很多商品是亲民品牌的商品，或产业带品牌的商品。\n对于很多产业带品牌而言，其在品牌认知上是有所欠缺的。这些品牌的产品可能拥有不错的质量，但由于缺乏品牌认知，很多消费者没有足够的信心去购买这 些商品。快手的主播在直播过程中充当了“品牌”，用其自身的名誉为这些产品提供了背书。 这个环境并不适合大多数品牌\n一是因为其去品牌化的平台调性 二是因为品牌自身也很难在这样的生态中展开自播带货（公域流量池小，难以和主播私域流量竞争）。 抖音直播：品牌化+去中心化的直播平台，是品牌崛起的好土壤 抖音是三大直播电商平台中中心化程度最低的。平衡的主播生态使得每个主播相对品牌的议价权都比较适中，因此品牌商家找抖音主播带货的费用率显著低于淘 宝电商的头部主播，这样就有了更好的盈利能力。\n图7-12 2021年9月抖音直播平台前10名主播带货GMV\n店铺自播是抖音平台的亮点所在，也是抖音平台的重点发展方向。\n对于平台而言，直接向商家收费、绕开达人这个中间环节有利于提升盈利能力； 对于商家而言，摆脱达人意味着其将能够完全拥有直播带来的流量，并可以随心所欲地定制直播内容，甚至可起到提升品牌形象的效果。 未来抖音平台内的自播不会完全取代达人播，达人播的趣味性一般强于自播，达人播的存在有助于平衡平台的内容生态和商业生态，是连接内容与商业的一座桥 梁。\n图7-13 抖音自播与达人播的市场份额（以GMV计）\n抖音直播的环境使其成为上佳的品牌化舞台。\n第一，品牌有直接盈利的可能，这一方面源于达人播较为平衡的费率，另一方面源于自播生态的完善。 第二，在抖音开设自播间并实现冷启动并不难，抖音有公平高效的付费推广系统，同时拥有较为完善的代运营体系（品牌商家很难独自完成直播的相关事务， 很多工作需要在代运营商的帮助之下完成）。 第三，抖音具备品牌化的心智，平台的调性和主要受众适合大多数的知名品牌。 同样作为品牌化的直播电商平台，抖音和淘宝的区别在何处？本质上在于用户的目的性。\n淘宝的用户通常带有较强的购物目的，他们上淘宝的目的就是买东西，所以能够接受头部主播“报价格”的直播方式； 抖音更注重内容，很多用户上抖音的最初目的是找乐子，因此若想要获得成交，销售的内容就要足够吸引人。 直播电商的增长驱动力之一：用户数量的增长 直播电商用户数还有很大的提升空间\n图7-14 2021年6月中国网民、直播电商用户数结构\n直播电商的增长驱动力之二：核心品类渗透率提升 直播电商聚焦的品类有如下特点：①毛利润高；②需要一定的展示效果。这些品类包括服装、化妆品、珠宝、零食酒水等。只有毛利润足够高的产品，才能支撑 得起直播带来的相关费用。而需要展示效果的产品，更能够发挥视频直播在商品展示效果上的优势。\n图7-15 2021年四季度抖音品类结构（按成交额）\n总之，从品类的视角看，直播电商的增长逻辑在于提升了线上购物的体验感，从而拿到了一些本来属于线下渠道的市场份额。从这个角度看，随着人们对直播电 商接受程度的提升和用户习惯的养成，未来直播电商的市场还有很大的增长空间。\n拆解各方诉求，分析渠道影响，发掘投资机会 对新渠道的分析，最重要的是对各个参与方的分析。了解各个参与方之间的联系与诉求，是理解渠道、发现投资机会的关键所在。\n红人环节：很难产生明显的机会 主播环节主要包括红人本身、MCN机构、相关中介机构等。\nMCN机构真的能成为好的长期投资标的吗？恐怕很难。\n直播电商行业主播的马太效应是很强的，主播的体量和议价权呈两极分化的态势。 MCN机构基本可以分为两类：\n一类是绑定了头部主播的MCN机构，另一类是服务中腰部主播的MCN机构。 前者在头部主播之下，基本上没有像样的话语权；而后者手中的主播在行业中的地位不强，因此也不具备显著的投资价值，且如果后者手中的中小主播长成了 头部主播，MCN机构将很可能失去话语权，沦为头部主播的依附。 平台与产业工厂环节：选择有限 平台有可能成为非常好的投资方向，但主要问题在于选择有限。\n2021年直播电商行业的三巨头是淘宝、快手、抖音。\n对于阿里巴巴，看好淘宝直播的发展不构成投资阿里巴巴的直接理由，淘宝直播在阿里巴巴集团中占据的体量比较小，远不如天猫的分量大。此外，淘宝头部 主播话语权过强、经营生态一般的事实，也给淘宝直播的投资价值打了折扣。 对于快手而言，中国强大的消费品供应链是其稳定发展的坚实后盾，而足够接地气的平台氛围也使其成为足够独特的资产。但商业化内容与平台体验之间的天 然冲突如何处理，以及头部主播群体如何提高抽佣率，都会是未来的重要问题。 字节跳动的抖音各方面都非常优秀，可惜并没有上市。 快手直播电商的崛起给优秀的产业带工厂带来了重要的发展机遇，不过这里也很难产生投资机会。一般而言，找主播带货的企业大多为中小型的产业工厂，绝大 部分没有上市；而成功上市的头部代工企业（如申洲国际、华利集团等）都绑定了稳定的大客户，它们一般不会把自己的产品放到快手上销售，因此不构成直播 电商的直接受益对象。\n品牌：重要的投资机会所在 总之，国产品牌通过各方面竞争实力的逐渐释放逐渐蚕食国外传统大牌的份额，将会是未来数年服装、化妆品等消费品领域的发展大趋势，而像直播电商这样的 新兴渠道，将会成为这一趋势的重要加速器。未来，我们不但要关注国产品牌在各个渠道，尤其是直播电商这样的新兴渠道中的发展情况，也要关注其他重要渠 道变革带来的品牌投资机会。\n7.4 案例二：为何拼多多难跑出新品牌 拼多多还是一个社交电商吗 从商业模式、运营模式、流量分发、营销工具、品类结构等方面来看，拼多多都在向淘系电商靠近。可以认为，拼多多并没有成为多年前人们想象的“社交电商”， 而是逐渐变成了另一个“货架电商”。\n什么是社交电商，什么是货架电商 零售生意可以简单划归为流量获取和转化、成交履约、形成复购三个环节\n社交电商中的“社交”二字主要体现在流量获取和转化上，即通过熟人之间的分享介绍促成交易。 货架电商会把商品摆在各种展示位, 在购物决策的过程中，货架电商的消费者一般较少依赖他们的社交关系。 淘宝、天猫、京东显然不属于社交电商，我们一般称之为“货架电商”或“搜索电商”。 拼多多平台内的流量结构与淘宝越来越相似，以搜索为主导 一般判断电商平台流量来源的方式是看用户如何进入“商品详情”页面。\n与其说拼多多是个社交电商，不如说它也是一个搜索电商。\n图7-18 2020年拼多多流量结构\n拼多多的流量结构与淘宝已经非常相似，两个平台自然流量的前两大来源都是搜索和推荐。\n图7-19 2018～2020年淘宝流量结构\n从流量结构上看，拼多多和淘宝相比，最大的差异在于活动流量。\n淘宝和拼多多拥有相似的运营逻辑 淘宝和拼多多在运营上的相似之处在于：\n第一，二者都看重商品的展现排位，都采用通过付费流量提权重、通过免费流量以及复购盈利的模式； 第二，二者的投放工具大体上比较相似； 第三，付费流量投放的计价方式比较相似。 在中心化的电商平台里，商品在搜索和推荐结果中的排位越靠前，曝光量就越高。\n图7-20 电商平台中的商品展现排位影响其点击率\n自然流量（免费展位）的排位主要由“期望展现收益”决定。\n期望收益可以是GMV、广告收入（针对付费流量），也可以是顾客停留时间、访问深度、购物体验等。 在不同的阶段，平台会根据自身需求动态调整各项指标的权重，并把“期望展现收益”高的商品放在前排增加展示，从而实现平台综合效用的最大化。 图7-21 做投放是在淘宝、拼多多这类平台上经营的必选项\n投放的核心目的是改善权重，进而使自然流量占比提升，最终通过免费的自然流量获利。\n以手机搜索为例，在淘宝和拼多多搜索结果中，一般每5～7个会有一个广告，这意味着投放流量占比最高仅为20%，可见自然流量带来的销售额总量是远远高 于付费流量的。 因此，对于淘宝和拼多多而言，其运营投放的共性是：通过付费投放积攒数据，提升商品在自然展位中的排位，最后通过自然流量的提升赚钱。\n拼多多和淘宝的投放工具比较类似 拼多多主要的底层投放工具包括多多搜索、多多场景、多多进宝、明星店铺、合约推广等。\n多多搜索提供付费搜索信息服务，和淘系的直通车较为相似； 多多场景相当于淘系的超级推荐，对应信息流推荐位中的流量； 多多进宝相当于淘宝客，是达人使用平台外链分享带来的流量； 淘宝和拼多多都有明星店铺，用于在搜索结果的上方展示店铺及热销商品。 这些主要的投放工具在两大平台上的收费方式也基本相同：\n搜索和信息流广告的收费方式都按用户点击次数收费（CPC） 淘宝客和多多进宝都按照成交额百分比收费（CPS） 明星店铺都按千次展示收费（CPM）。 两个平台CPC类投放（搜索、信息流）的定价方式是相似的，都是竞价\n图7-22 淘宝直通车计费方式\n在这套竞价体系下：\n①流量的价格在商家之间的博弈中产生，取决于商家的付费意愿，而非由平台直接掌控，流量价格将随着商家之间竞争的激烈程度而水涨船高； ②不是出价高就一定能获得展现，平台通过质量分把控投放商品的质量，保证用户体验，质量分体系使得积淀较少的新商品、新商家的投放费用更高，加剧了 马太效应； ③CPC广告是点击了才扣费，质量分能确保较稳定的广告点击率，维持平台广告消耗的平稳。 两个平台主要的不同在于一些级别更高的自动投放工具。拼多多的OCPX工具有自动投放的功能，会自动帮助商家调整投放的参数，尝试出比较好的投放方案。\n淘宝、拼多多的商品构成大同小异 二者的核心差异点在于，淘系电商（尤其是天猫平台）拥有极强的品牌化能力，而拼多多几乎没有品牌化能力。因此，品牌认知较为重要的品类（如化妆品等） 在天猫上占比更高，而品牌认知不那么重要的品类（比如家纺、日用品等）在拼多多上的占比较高。\n数码电器在拼多多上占比较高的原因，在于拼多多“百亿补贴”重点补贴大牌数码类产品\n图7-23 2021年四季度拼多多品类结构\n我们知道化妆品是一个非常看重品牌的品类，中高端化妆品的出厂价可能只有售价的10%，溢价主要来自品牌。化妆品占比的差异，一定程度上反映了两个平台品 牌化能力的差异。\n图7-24 天猫2020年“双11”大促品类结构\n在分析这两大电商平台的时候，我们基本上可以套用同样的分析框架，即把分析的重心放在对成交额、用户数、货币化率等关键指标，以及平台整体生态和活力 等重要的经营细节的跟踪上。\n平台排名机制解析：为何拼多多的商品看上去比淘宝的便宜 主要原因在于：\n①我国拥有强大的商品供应链，能提供大量物美价廉的消费品； ②拼多多的排序机制使得低价爆款商品更容易获得前排展示； ③拼多多的补贴和商家的主动让利进一步拉低了价格。 其中最核心的一条在于，拼多多和淘系电商在排位权重的分配上有所不同，拼多多更看重“品”，而淘系电商更看重“店”，因此拼多多上的高性价比爆品有更大的 机会拿到高排位。\n淘宝上不是没有便宜的商品，但是有些低价商品在平台中得不到前排展示。在一些“埋得更深”的地方，常常会出现更具性价比的商品。 图7-25 在淘宝上排名靠后的商品也有好价格\n造成天猫品牌化能力强、拼多多难跑出新品牌这个差异的直接原因，在于平台的排序机制。\n拼多多上的便宜商品能够很快得到前排展现，而淘系电商的头部商家在平台上的展现排序更为稳固。 拼多多上的头部商家如果失去了价格优势，就有可能很快被新的商家挤下去； 而淘宝上的头部商家就算涨价，也能维持其在平台中的展现排位。 这不但使拼多多前排展示的商品看起来比淘宝的更便宜，也使两个平台的用户心智出现较大差异。 这对我们的消费品投资分析有何影响？\n首先，要判断一个品牌在电商上经营得是否成功，我们会更重视其在天猫、抖音等品牌化平台上的表现，而不怎么关注其在拼多多、社区团购乃至快手这类非 品牌化平台上的表现。 其次，在分析拼多多等这类平台上的大品牌时，我们更关注其在组织效率、基础质量保障等方面的实力，而非溢价能力。 最后，拼多多品牌化能力弱并不意味着平台变现能力差，向产业带品牌和经销商收费，也可实现较高的货币化率。 7.5 案例三：波司登的品牌升级之路 波司登是如何成功实现品牌升级的？\n第一，国货崛起的核心是“国”崛起，其次才是“货”崛起，我国国力日趋强盛，这使消费者对国产品牌的倾向性持续提升； 第二，羽绒服这类功能性服饰是一个天然的好赛道，容易出现市占率高、品牌溢价高的品牌； 第三，Moncler、加拿大鹅等品牌进驻中国，成功提升了消费者对于羽绒服的价格认知，这为波司登的品牌跃升打开了空间； 第四，波司登本身具备超凡的品牌运营能力，在适当的时机通过明星代言、登山队科考队背书等宣传，配合完成度高、实力强的产品，成功实现品牌跃迁。 国牌崛起的两条典型路径是功能性路径和效率性路径，波司登很明显走的是功能性路径。\n功能性路径专注于细分领域，给产品打上的标签，让消费者感受到品牌的专业度，从而抢占消费者的心智。 效率性路径则强调高周转、高性价比、快速反映用户需求、良好的终端触达等，让消费者能够省力放心地买到中意的商品。 波司登所在的功能性服饰赛道，是一个容易走出好品牌的优质赛道。所谓功能性服饰就是有特殊用途、特殊要求的服饰，比如羽绒服、运动服等。羽绒服赛道兼 具功能性和社交属性两个优质特性，容易诞生大品牌。\n2016～2017年，国际羽绒服大品牌Moncler、加拿大鹅在中国市场吸引了众多的消费者认购，中高端羽绒服消费开始崛起，波司登适时完成提价。\n图7-27 波司登在国内中高端羽绒服市场中一枝独秀\n波司登成功实现品牌升级和其自身的品牌实力也有脱不开的关系。\n第一，波司登有自己的羽绒服工厂，可从源头上把控生产工艺的每一个细节，实现精益求精。依托领先的制造工艺，波司登的产品在用料和做工上无可挑剔。 第二，波司登多年深耕羽绒服，其服装面料和工艺经历了多轮迭代，技术专业程度处于业内领先水平，产品质量的优异性久经考验。 第三，波司登的设计做得非常到位。 一是与迪士尼、漫威等大IP联名推出时尚羽绒服，获得年轻消费者的青睐； 二是与国际知名设计师合作，推出“高定羽绒服”“新一代羽绒服”系列，合作的设计师包括爱马仕黄金时代的缔造者让·保罗·戈尔捷。 第四，波司登在品牌宣传上也下了大功夫。一方面邀请杨幂等头部明星代言，另一方面积极赞助登山、科考等专业团队。 7.6 结语 品牌力就是品牌对其价格带的控制能力，包括定价能力、溢价能力、涨价能力。价格带就是品牌的生命线，降价容易提价难，品牌在保证一定销售规模的前提下， 保持价格带稳定要远远比多卖些货重要。历史上成功实现品牌升级、价格带提升的案例非常少，而能够持续实现价格提升的消费品更为稀缺，这些具备提价能力 的公司，都是消费行业中一等一的优秀公司。\n","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC7%E7%AB%A0-%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%81%E7%89%8C%E5%8A%9B/","summary":"7.1 定价能力是衡量品牌力的重要标准 既然不赚钱，为何商家要花大力气宣传、促销、做销售额、发战报呢？ 答案是：“卖货”和“卖价格带”是品牌经营的两大","title":"第7章 什么是品牌力"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/commerce/","summary":"主页","title":"U.S. Department of Commerce"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/iresearch/","summary":"主页","title":"艾瑞咨询"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/zhiyan/","summary":"主页","title":"智研咨询"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/swsresearch/","summary":"主页","title":"申万宏源研究"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/frost/","summary":"主页","title":"FROST \u0026 SULLIVAN"},{"content":"SQL是三值逻辑(three-valued logic)\n理论篇 两种NULL、三值逻辑还是四值逻辑\n未知(unknown). 以“不知道戴墨镜的人眼睛是什么颜色”这种情况为例，这个人的眼睛肯定是有颜色的，但是如果他不摘掉眼镜，别人就不知道他的眼睛是什 么颜色。 不适用(not applicable, inapplicable). 而“不知道冰箱的眼睛是什么颜色”则属于“不适用”。因为冰箱根本就没有眼睛 关系数据库中“丢失的信息”的分类\n四值逻辑真值表\n为什么必须写成“IS NULL”，而不是“＝NULL”\n对NULL使用比较谓词后得到的结果总是unknown。 1 2 3 4 5 6 --以下的式子都会被判为 unknown 1 = NULL 2 \u0026gt; NULL 3 \u0026lt; NULL 4 \u0026lt;\u0026gt; NULL NULL = NULL 为什么对NULL使用比较谓词后得到的结果永远不可能为真呢？\n因为NULL既不是值也不是变量。NULL只是一个表示“没有值”的标记，而比较谓词只适用于值。因此，对并非值的NULL使用比较谓词本来就是没有意义的 unknown、第三个真值\n书中用unknown表示三值逻辑的第三个值 书中用UNKNOWN表示NULL 1 2 3 4 5 --这个是明确的真值的比较 unknown = unknown → true --这个相当于NULL = NULL UNKNOWN = UNKNOWN → unknown 三值逻辑的真值表（NOT）\n三值逻辑的真值表（AND）\n三值逻辑的真值表（OR）\n记忆方法\nAND的情况： false ＞ unknown ＞ true OR的情况： true ＞ unknown ＞ false 优先级高的真值会决定计算结果。例如true AND unknown，因为unknown的优先级更高，所以结果是unknown。而true OR unknown的话，因为true优 先级更高，所以结果是true。 特别需要记住的是，当AND运算中包含unknown时，结果肯定不会是true（反之，如果AND运算结果为true，则参与运算的双方必须都为true）。 实践篇 1. 比较谓词和NULL(1)：排中律不成立 “把命题和它的否命题通过‘或者’连接而成的命题全都是真命题”这个命题在二值逻辑中被称为排中律（Law of Excluded Middle）。顾名思义，排中律就是 指不认可中间状态，对命题真伪的判定黑白分明，是古典逻辑学的重要原理。“是否承认这一原理”被认为是古典逻辑学和非古典逻辑学的分界线。\n如果排中律在SQL里也成立，那么下面的查询应该能选中表里的所有行。\n1 2 3 4 5 --查询年龄是20岁或者不是20岁的学生 SELECT ＊ FROM Students WHERE age = 20 OR age \u0026lt;\u0026gt; 20; 遗憾的是，在SQL的世界里，排中律是不成立的。假设表Students里的数据如下所示。\nStudents\n这条SQL语句无法查询到约翰，因为约翰年龄不详。\nSQL语句的查询结果里只有判断结果为true的行。要想让约翰出现在结果里，需要添加下面这样的“第3个条件”。\n1 2 3 4 5 6 --添加第3个条件：年龄是20岁，或者不是20岁，或者年龄未知 SELECT ＊ FROM Students WHERE age = 20 OR age \u0026lt;\u0026gt; 20 OR age IS NULL; 2. 比较谓词和NULL(2):CASE表达式和NULL 1 2 3 4 5 --col_1为1时返回○、为NULL时返回×的CASE表达式？ CASE col_1 WHEN 1 THEN\u0026#39;○\u0026#39; WHEN NULL THEN\u0026#39;×\u0026#39; END 这个CASE表达式一定不会返回×。这是因为，第二个WHEN子句是col_1 = NULL的缩写形式。这个式子的真值永远是unknown。\n正确写法\n1 2 3 CASE WHEN col_1 = 1 THEN\u0026#39;○\u0026#39; WHEN col_1 IS NULL THEN\u0026#39;×\u0026#39; END 3. NOT IN和NOT EXISTS不是等价的 Class_A\nClass_B\n考虑一下如何根据这两张表查询“与B班住在东京的学生年龄不同的A班学生”。\n希望查询到的是拉里和伯杰。因为布朗与齐藤年龄相同，所以不是我们想要的结果。 如果单纯地按照这个条件去实现，则SQL语句如下所示。 1 2 3 4 5 6 --查询与B班住在东京的学生年龄不同的A班学生的SQL语句？ SELECT ＊ FROM Class_A WHERE age NOT IN ( SELECT age FROM Class_B WHERE city =’东京’); 上面的sql查不到任何数据\n分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 --1．执行子查询，获取年龄列表 SELECT ＊ FROM Class_A WHERE age NOT IN (22, 23, NULL); --2．用NOT和IN等价改写NOT IN SELECT ＊ FROM Class_A WHERE NOT age IN (22, 23, NULL); --3．用OR等价改写谓词IN SELECT ＊ FROM Class_A WHERE NOT ( (age = 22) OR (age = 23) OR (age = NULL) ); --4．使用德·摩根定律等价改写 SELECT ＊ FROM Class_A WHERE NOT (age = 22) AND NOT(age = 23) AND NOT (age = NULL); --5．用\u0026lt;\u0026gt;等价改写NOT和= SELECT ＊ FROM Class_A WHERE (age \u0026lt;\u0026gt; 22) AND (age \u0026lt;\u0026gt; 23) AND (age \u0026lt;\u0026gt; NULL); --6．对NULL使用\u0026lt;\u0026gt;后，结果为unknown SELECT ＊ FROM Class_A WHERE (age \u0026lt;\u0026gt; 22) AND (age \u0026lt;\u0026gt; 23) AND unknown; --7．如果AND运算里包含unknown，则结果不为true（参考“理论篇”中的矩阵） SELECT ＊ FROM Class_A WHERE false或unknown; 如果NOT IN子查询中用到的表里被选择的列中存在NULL，则SQL语句整体的查询结果永远是空。\n为了得到正确的结果，我们需要使用EXISTS谓词。\n1 2 3 4 5 6 7 --正确的SQL语句：拉里和伯杰将被查询到 SELECT ＊ FROM Class_A A WHERE NOT EXISTS ( SELECT ＊ FROM Class_B B WHERE A.age = B.age AND B.city = ’东京’); 执行结果\n1 2 3 4 name age city ----- ---- ---- 拉里 19 埼玉 伯杰 21 千叶 分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 --1．在子查询里和NULL进行比较运算 SELECT ＊ FROM Class_A A WHERE NOT EXISTS ( SELECT ＊ FROM Class_B B WHERE A.age = NULL AND B.city =’东京’); --2．对NULL使用“=”后，结果为 unknown SELECT ＊ FROM Class_A A WHERE NOT EXISTS ( SELECT ＊ FROM Class_B B WHERE unknown AND B.city =’东京’); --3．如果AND运算里包含unknown，结果不会是true SELECT ＊ FROM Class_A A WHERE NOT EXISTS ( SELECT ＊ FROM Class_B B WHERE false或unknown); --4．子查询没有返回结果，因此相反地，NOT EXISTS为true SELECT ＊ FROM Class_A A WHERE true; 4. 限定谓词和NULL any与in等价\nClass_A\nClass_B\n思考一下用于查询“比B班住在东京的所有学生年龄都小的A班学生”的SQL语句。\n1 2 3 4 5 6 --查询比B班住在东京的所有学生年龄都小的A班学生 SELECT ＊ FROM Class_A WHERE age \u0026lt; ALL ( SELECT age FROM Class_B WHERE city =’东京’); 执行结果\n1 2 3 name age city ----- ---- ---- 拉里 19 埼玉 如果山田的年龄仍是NULL时的分析\nALL谓词其实是多个以AND连接的逻辑表达式的省略写法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --1．执行子查询获取年龄列表 SELECT ＊ FROM Class_A WHERE age \u0026lt; ALL ( 22, 23, NULL ); --2．将ALL谓词等价改写为AND SELECT ＊ FROM Class_A WHERE (age \u0026lt; 22) AND (age \u0026lt; 23) AND (age \u0026lt; NULL); --3．对NULL使用“\u0026lt;”后，结果变为 unknown SELECT ＊ FROM Class_A WHERE (age \u0026lt; 22) AND (age \u0026lt; 23) AND unknown; --4. 如果AND运算里包含unknown，则结果不为true SELECT ＊ FROM Class_A WHERE false 或 unknown; 5. 限定谓词和极值函数不是等价的 如果用极值函数重写刚才的SQL\n1 2 3 4 5 6 --查询比B班住在东京的年龄最小的学生还要小的A班学生 SELECT ＊ FROM Class_A WHERE age \u0026lt; ( SELECT MIN(age) FROM Class_B WHERE city =’东京’); 执行结果\n1 2 3 4 name age city ----- ---- ---- 拉里 19 埼玉 伯杰 21 千叶 没有问题。即使山田的年龄无法确定，这段代码也能查询到拉里和伯杰两人。这是因为，极值函数在统计时会把为NULL的数据排除掉。\nALL谓词和极值函数表达的命题含义\nALL谓词：他的年龄比在东京住的所有学生都小——Q1 极值函数：他的年龄比在东京住的年龄最小的学生还要小——Q2 还有一种情况下它们也是不等价的\n谓词（或者函数）的输入为空集的情况 Class_B没有住在东京的学生！\n使用ALL谓词的SQL语句会查询到A班的所有学生 然而用极值函数查询时一行数据都查询不到。 1 2 3 4 5 6 7 8 9 --1．极值函数返回NULL SELECT ＊ FROM Class_A WHERE age \u0026lt; NULL; --2．对NULL使用“\u0026lt;”后结果为 unknown SELECT ＊ FROM Class_A WHERE unknown; 6. 聚合函数和NULL COUNT以外的聚合函数在输入为空表时都返回NULL\n1 2 3 4 5 6 --查询比住在东京的学生的平均年龄还要小的A班学生的SQL语句？ SELECT ＊ FROM Class_A WHERE age \u0026lt; ( SELECT AVG(age) FROM Class_B WHERE city =’东京’); 本节小结 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-3-%E4%B8%89%E5%80%BC%E9%80%BB%E8%BE%91%E5%92%8Cnull/","summary":"SQL是三值逻辑(three-valued logic) 理论篇 两种NULL、三值逻辑还是四值逻辑 未知(unknown). 以“不知道戴墨镜的人眼睛是什么颜","title":"1-3 三值逻辑和NULL"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/moffatt/sql-joins/","summary":"原文","title":"Visual Representation of SQL Joins"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/codinghorror/sql-joins/","summary":"原文","title":"A Visual Explanation of SQL Joins"},{"content":"可重排列、排列、组合 Products\n有序对(排列)\n\u0026lt;1, 2\u0026gt; != \u0026lt;2, 1\u0026gt; 无序对(组合)\n{1, 2} == {2, 1} 通过交叉连接生成笛卡儿积（直积）生成有序对\n1 2 3 --用于获取可重排列的SQL语句 SELECT P1.name AS name_1, P2.name AS name_2 FROM Products P1, Products P2; 执行结果\n1 2 3 4 5 6 7 8 9 10 11 name_1 name_2 ------ ------ 苹果 苹果 苹果 橘子 苹果 香蕉 橘子 苹果 橘子 橘子 橘子 香蕉 香蕉 苹果 香蕉 橘子 香蕉 香蕉 去掉\u0026lt;苹果, 苹果\u0026gt;这种\n1 2 3 4 --用于获取排列的SQL语句 SELECT P1.name AS name_1, P2.name AS name_2 FROM Products P1, Products P2 WHERE P1.name \u0026lt;\u0026gt; P2.name; 执行结果\n1 2 3 4 5 6 7 8 name_1 name_2 ------ ------ 苹果 橘子 苹果 香蕉 橘子 苹果 橘子 香蕉 香蕉 苹果 香蕉 橘子 不能有（苹果，苹果）这样的组合\n去掉\u0026lt;苹果, 橘子\u0026gt;, \u0026lt;橘子, 苹果\u0026gt;这种\n1 2 3 4 --用于获取组合的SQL语句 SELECT P1.name AS name_1, P2.name AS name_2 FROM Products P1, Products P2 WHERE P1.name \u0026gt; P2.name; 执行结果\n1 2 3 4 5 name_1 name_2 ------ ------ 苹果 橘子 香蕉 橘子 香蕉 苹果 获取3个以上元素的组合\n1 2 3 4 5 --用于获取组合的SQL语句：扩展成3列 SELECT P1.name AS name_1, P2.name AS name_2, P3.name AS name_3 FROM Products P1, Products P2, Products P3 WHERE P1.name \u0026gt; P2.name AND P2.name \u0026gt; P3.name; 执行结果\n1 2 3 name_1 name_2 name_3 ------- -------- -------- 香蕉 苹果 橘子 删除重复行 删除重复行\n使用由数据库独自实现的行ID\n只有Oracle(rowid)和PostgreSQL(oid)才能使用, 其他数据库需要自己创建主键 1 2 3 4 5 6 --用于删除重复行的SQL语句(1)：使用极值函数 DELETE FROM Products P1 WHERE rowid \u0026lt; ( SELECT MAX(P2.rowid) FROM Products P2 WHERE P1.name = P2. name AND P1.price = P2.price ) ; 1 2 3 4 5 6 7 --用于删除重复行的SQL语句(2)：使用非等值连接 DELETE FROM Products P1 WHERE EXISTS ( SELECT ＊ FROM Products P2 WHERE P1.name = P2.name AND P1.price = P2.price AND P1.rowid \u0026lt; P2.rowid ); 查找局部不一致的列 假设有下面这样一张住址表，主键是人名\nAddresses\n前田夫妇。这两个人并没有分居，只是夫人的住址写错了而已, 需要修改一下\n所以这个表结构设计的不对\n找出像前田夫妇这样的“是同一家人但住址却不同的记录”, 用非等值自连接来实现，代码会非常简洁\n1 2 3 4 5 --用于查找是同一家人但住址却不同的记录的SQL语句 SELECT DISTINCT A1.name, A1.address FROM Addresses A1, Addresses A2 WHERE A1.family_id = A2.family_id AND A1.address \u0026lt;\u0026gt; A2.address ; 感觉这里的DISTINCT没什么用.\n从下面这张商品表里找出价格相等的商品的组合。\nProducts\n1 2 3 4 5 --用于查找价格相等但商品名称不同的记录的SQL语句 SELECT DISTINCT P1.name, P1.price FROM Products P1, Products P2 WHERE P1.price = P2.price AND P1.name \u0026lt;\u0026gt; P2.name; 执行结果\n1 2 3 4 5 6 7 name price ------ ------ 苹果 50 葡萄 50 草莓 100 橘子 100 香蕉 100 这里确实应该用DISTINCT.\n排序 按照价格从高到低的顺序, 让价格相同的商品位次也一样\nProducts\n使用窗口函数\n1 2 3 4 5 --排序：使用窗口函数 SELECT name, price, RANK() OVER (ORDER BY price DESC) AS rank_1, DENSE_RANK() OVER (ORDER BY price DESC) AS rank_2 FROM Products; 商品则有两种排序方法，一种是跳过之后的位次，另一种是不跳过之后的位次。\nrank_1跳过了之后的位次，rank_2没有跳过 MySQL8支持窗口函数 执行结果\n1 2 3 4 5 6 7 8 name price rank_1 rank_2 ------- ------ ------- ------- 橘子 100 1 1 西瓜 80 2 2 苹果 50 3 3 香蕉 50 3 3 葡萄 50 3 3 柠檬 30 6 4 不依赖于具体数据库来实现的方法\n1 2 3 4 5 6 7 8 --排序从1开始。如果已出现相同位次，则跳过之后的位次 SELECT P1.name, P1.price, (SELECT COUNT(P2.price) FROM Products P2 WHERE P2.price \u0026gt; P1.price) + 1 AS rank_1 FROM Products P1 ORDER BY rank_1; 查询比当前水果价格还要大的水果数n, n+1就是rank\n执行结果\n1 2 3 4 5 6 7 8 name price rank ----- ------ ------ 橘子 100 1 西瓜 80 2 苹果 50 3 葡萄 50 3 香蕉 50 3 柠檬 30 6 如果使用COUNT(DISTINCT P2.price)可以实现不跳过之后的位次\n自连接的写法\n1 2 3 4 5 6 7 8 --排序：使用自连接 SELECT P1.name, MAX(P1.price) AS price, COUNT(P2.name) +1 AS rank_1 FROM Products P1 LEFT OUTER JOIN Products P2 ON P1.price \u0026lt; P2.price GROUP BY P1.name ORDER BY rank_1; 查询当前水果价格能连接多少个n(p1.price\u0026lt;p2.price), n+1就是排名.\n本节小结 与多表之间进行的普通连接相比，自连接的性能开销更大（特别是与非等值连接结合使用的时候），因此用于自连接的列推荐使用主键或者在相关列上建立索引。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-2-%E8%87%AA%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%94%A8%E6%B3%95/","summary":"可重排列、排列、组合 Products 有序对(排列) \u0026lt;1, 2\u0026gt; != \u0026lt;2, 1\u0026gt; 无序对(组合) {1, 2} == {2, 1} 通过交叉连接生成笛卡儿积（直积）生成有序对 1 2 3 --用于获取可重排列的","title":"1-2 自连接的用法"},{"content":"CASE表达式概述 CASE表达式的写法\n1 2 3 4 5 6 7 8 9 10 --简单CASE表达式 CASE sex WHEN \u0026#39;1\u0026#39; THEN ’男’ WHEN \u0026#39;2\u0026#39; THEN ’女’ ELSE ’其他’ END --搜索CASE表达式 CASE WHEN sex =\u0026#39;1\u0026#39;THEN’男’ WHEN sex =\u0026#39;2\u0026#39;THEN’女’ ELSE ’其他’ END 剩余的WHEN子句被忽略的写法示例\n1 2 3 4 --例如，这样写的话，结果里不会出现“第二” CASE WHEN col_1 IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) THEN’第一’ WHEN col_1 IN (\u0026#39;a\u0026#39;) THEN’第二’ ELSE ’其他’ END 注意\n注意事项1：各分支返回的数据类型要一致, 否则报错 注意事项2：不要忘了写END 注意事项3：养成写ELSE子句的习惯 不写可能会造成“语法没有错误，结果却不对”这种不易追查原因的麻烦 养成这样的习惯后，我们从代码上就可以清楚地看到这种条件下会生成NULL，而且将来代码有修改时也能减少失误。 将已有编号方式转换为新的方式并统计 统计数据源表PopTbl\n统计结果\n用县名（pref_name）代替编号作为GROUP BY的列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 --把县编号转换成地区编号(1) SELECT CASE pref_name WHEN ’德岛’ THEN ’四国’ WHEN ’香川’ THEN ’四国’ WHEN ’爱媛’ THEN ’四国’ WHEN ’高知’ THEN ’四国’ WHEN ’福冈’ THEN ’九州’ WHEN ’佐贺’ THEN ’九州’ WHEN ’长崎’ THEN ’九州’ ELSE’其他’END AS district, SUM(population) FROM PopTbl GROUP BY CASE pref_name WHEN ’德岛’ THEN ’四国’ WHEN ’香川’ THEN ’四国’ WHEN ’爱媛’ THEN ’四国’ WHEN ’高知’ THEN ’四国’ WHEN ’福冈’ THEN ’九州’ WHEN ’佐贺’ THEN ’九州’ WHEN ’长崎’ THEN ’九州’ ELSE ’其他’ END; 将数值按照适当的级别进行分类统计\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 --按人口数量等级划分都道府县 SELECT CASE WHEN population \u0026lt; 100 THEN\u0026#39;01\u0026#39; WHEN population \u0026gt;= 100 AND population \u0026lt; 200 THEN\u0026#39;02\u0026#39; WHEN population \u0026gt;= 200 AND population \u0026lt; 300 THEN\u0026#39;03\u0026#39; WHEN population \u0026gt;= 300 THEN\u0026#39;04\u0026#39; ELSE NULL END AS pop_class, COUNT(＊) AS cnt FROM PopTbl GROUP BY CASE WHEN population \u0026lt; 100 THEN\u0026#39;01\u0026#39; WHEN population \u0026gt;= 100 AND population \u0026lt; 200 THEN\u0026#39;02\u0026#39; WHEN population \u0026gt;= 200 AND population \u0026lt; 300 THEN\u0026#39;03\u0026#39; WHEN population \u0026gt;= 300 THEN\u0026#39;04\u0026#39; ELSE NULL END; pop_class cnt --------- ---- 01 1 02 3 03 3 04 2 上面两种方式都要在select和group by中写相同的case, 在变更时可能会忘记同步, 下面的写法更方便\n严格来说，这种写法是违反标准SQL的规则的。因为GROUP BY子句比SELECT语句先执行，所以在GROUP BY子句中引用在SELECT子句里定义的别称是不被允 许的。事实上，在Oracle、DB2、SQL Server等数据库里采用这种写法时就会出错。 不过也有支持这种SQL语句的数据库，例如在PostgreSQL和MySQL中，这个查询语句就可以顺利执行。这是因为，这些数据库在执行查询语句时，会先对 SELECT子句里的列表进行扫描，并对列进行计算。 用一条SQL语句进行不同条件的统计 统计源表PopTbl2\n统计结果\n通常的做法是写两个sql, 可能然后再用union合并\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 男性人口 SELECT pref_name, SUM(population) FROM PopTbl2 WHERE sex =\u0026#39;1\u0026#39; GROUP BY pref_name; -- 女性人口 SELECT pref_name, SUM(population) FROM PopTbl2 WHERE sex =\u0026#39;2\u0026#39; GROUP BY pref_name; 用一条sql实现\n1 2 3 4 5 6 7 SELECT pref_name, --男性人口 SUM( CASE WHEN sex =\u0026#39;1\u0026#39;THEN population ELSE 0 END) AS cnt_m, --女性人口 SUM( CASE WHEN sex =\u0026#39;2\u0026#39;THEN population ELSE 0 END) AS cnt_f FROM PopTbl2 GROUP BY pref_name; 用CHECK约束定义多个列的条件关系 假设某公司规定“女性员工的工资必须在20万日元以下”，而在这个公司的人事表中，这条无理的规定是使用CHECK约束来描述的\n1 2 3 4 5 6 7 8 9 CONSTRAINT check_salary CHECK ( CASE WHEN sex =\u0026#39;2\u0026#39; THEN CASE WHEN salary \u0026lt;= 200000 THEN 1 ELSE 0 END ELSE 1 END = 1 ) 用逻辑与改写的CHECK约束如下所示。\n1 2 CONSTRAINT check_salary CHECK ( sex =\u0026#39;2\u0026#39;AND salary \u0026lt;= 200000 ) 这两个约束的程序行为不一样(第二个如果是男雇员也返回false了, 不符合命题)\n逻辑与和蕴含式的真值表\nU表示unknown 在UPDATE语句里进行条件分支 Salaries\n假设现在需要根据以下条件对该表的数据进行更新。\n对当前工资为30万日元以上的员工，降薪10%。 对当前工资为25万日元以上且不满28万日元的员工，加薪20%。 按照这些要求更新完的数据应该如下表所示。\n乍一看，分别执行下面两个UPDATE操作好像就可以做到，但这样的结果却是不正确的。\n1 2 3 4 5 6 7 8 9 --条件1 UPDATE Salaries SET salary = salary ＊ 0.9 WHERE salary \u0026gt;= 300000; --条件2 UPDATE Salaries SET salary = salary ＊ 1.2 WHERE salary \u0026gt;= 250000 AND salary \u0026lt; 280000; 正确的写法\n注意最后的else必须写, 否则返回null 1 2 3 4 5 6 7 --用CASE表达式写正确的更新操作 UPDATE Salaries SET salary = CASE WHEN salary \u0026gt;= 300000 THEN salary ＊ 0.9 WHEN salary \u0026gt;= 250000 AND salary \u0026lt; 280000 THEN salary ＊ 1.2 ELSE salary END; 调换主键值的方便写法\nSomeTable\n不使用case\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --1．将a转换为中间值d UPDATE SomeTable SET p_key =\u0026#39;d\u0026#39; WHERE p_key =\u0026#39;a\u0026#39;; --2．将b调换为a UPDATE SomeTable SET p_key =\u0026#39;a\u0026#39; WHERE p_key =\u0026#39;b\u0026#39;; --3．将d调换为b UPDATE SomeTable SET p_key =\u0026#39;b\u0026#39; WHERE p_key =\u0026#39;d\u0026#39;; 使用case\n适用于Oracle, DB2, SQL Server 不适用于PostgreSQL, MySQWL 1 2 3 4 5 6 7 8 --用CASE表达式调换主键值 UPDATE SomeTable SET p_key = CASE WHEN p_key =\u0026#39;a\u0026#39; THEN \u0026#39;b\u0026#39; WHEN p_key =\u0026#39;b\u0026#39; THEN \u0026#39;a\u0026#39; ELSE p_key END WHERE p_key IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;); 表之间的数据匹配 课程一览 CourseMaster\n开设的课程 OpenCourses\n我们要用这两张表来生成下面这样的交叉表\ncourse_name 6月 7月 8月 ----------- ---- ---- ---- 会计入门 ○ × × 财务知识 × × ○ 簿记考试 ○ × × 税务师 ○ ○ ○ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 --表的匹配：使用IN谓词 SELECT course_name, CASE WHEN course_id IN (SELECT course_id FROM OpenCourses WHERE month = 200706) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;6月\u0026#34;, CASE WHEN course_id IN (SELECT course_id FROM OpenCourses WHERE month = 200707) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;7月\u0026#34;, CASE WHEN course_id IN (SELECT course_id FROM OpenCourses WHERE month = 200708) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;8月\u0026#34; FROM CourseMaster; --表的匹配：使用EXISTS谓词 SELECT CM.course_name, CASE WHEN EXISTS (SELECT course_id FROM OpenCourses OC WHERE month = 200706 AND OC.course_id = CM.course_id) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;6月\u0026#34;, CASE WHEN EXISTS (SELECT course_id FROM OpenCourses OC WHERE month = 200707 AND OC.course_id = CM.course_id) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;7月\u0026#34;, CASE WHEN EXISTS (SELECT course_id FROM OpenCourses OC WHERE month = 200708 AND OC.course_id = CM.course_id) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;8月\u0026#34; FROM CourseMaster CM; 无论使用IN还是EXISTS，得到的结果是一样的，但从性能方面来说，EXISTS更好。通过EXISTS进行的子查询能够用到“month, course_id”这样的主键索引， 因此尤其是当表OpenCourses里数据比较多的时候更有优势。\n在CASE表达式中使用聚合函数 假设这里有一张显示了学生及其加入的社团的一览表。如表StudentClub所示，这张表的主键是“学号、社团ID”，存储了学生和社团之间多对多的关系。\nStudentClub\n我们按照下面的条件查询这张表里的数据。\n获取只加入了一个社团的学生的社团ID。 获取加入了多个社团的学生的主社团ID。 条件1的SQL\n1 2 3 4 5 --条件1：选择只加入了一个社团的学生 SELECT std_id, MAX(club_id) AS main_club FROM StudentClub GROUP BY std_id HAVING COUNT(＊) = 1; 执行结果1\n1 2 3 4 5 std_id main_club ------ ---------- 300 4 400 5 500 6 条件2的SQL\n1 2 3 4 --条件2：选择加入了多个社团的学生 SELECT std_id, club_id AS main_club FROM StudentClub WHERE main_club_flg =\u0026#39;Y\u0026#39;; 执行结果2\n1 2 3 4 std_id main_club ------ ---------- 100 1 200 3 如果使用CASE表达式，下面这一条SQL语句就可以了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 SELECT std_id, CASE WHEN COUNT(＊) = 1 --只加入了一个社团的学生 THEN MAX(club_id) ELSE MAX(CASE WHEN main_club_flg =\u0026#39;Y\u0026#39; THEN club_id ELSE NULL END) END AS main_club FROM StudentClub GROUP BY std_id; std_id main_club ------ ---------- 100 1 200 3 300 4 400 5 500 6 本节小结 最后说一点细节的东西。CASE表达式经常会因为同VB和C语言里的CASE“语句”混淆而被叫作CASE语句。但是准确来说，它并不是语句，而是和1+1或者a/b一样 属于表达式的范畴。结束符END确实看起来像是在标记一连串处理过程的终结，所以初次接触CASE表达式的人容易对这一点感到困惑。“表达式”和“语句”的名称 区别恰恰反映了两者在功能处理方面的差异。\n作为表达式，CASE表达式在执行时会被判定为一个固定值，因此它可以写在聚合函数内部；也正因为它是表达式，所以还可以写在SELECE子句、GROUP BY 子句、WHERE子句、ORDER BY子句里。简单点说，在能写列名和常量的地方，通常都可以写CASE表达式。从这个意义上来说，与CASE表达式最接近的不是面向 过程语言里的CASE语句，而是Lisp和Scheme等函数式语言里的case和cond这样的条件表达式。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-1-case%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"CASE表达式概述 CASE表达式的写法 1 2 3 4 5 6 7 8 9 10 --简单CASE表达式 CASE sex WHEN \u0026#39;1\u0026#39; THEN ’男’ WHEN \u0026#39;2\u0026#39; THEN ’女’ ELSE ’其他’ END --搜索CASE表达","title":"1-1 CASE表达式"},{"content":"8.1 内存分配 在Go的runtime中，有一系列函数被用来分配内存。\n例如与new语义相对应的有newobject()函数和newarray()函数，分别负责单个对象的分配和数组的分配。 与make语义相对应的有makeslice()函数、makemap()函数及makechan()函数及一些变种，分别负责分配和初始化切片、map和channel。 无论是new系列还是make系列，这些函数的内部无一例外都会调用runtime.mallocgc()函数，它就是Go语言堆分配的关键函数。\n8.1.1 sizeclasses Go的堆分配采用了与tcmalloc内存分配器类似的算法，tcmalloc是谷歌公司开发的一款针对C/C++的内存分配器，在对抗内存碎片化和多核性能方面非常优秀\n参考tcmalloc实现的内存分配器，内部针对小块内存的分配进行了优化。这类分配器会按照一组预置的大小规格把内存页划分成块，然后把不同规格的内存块放 入对应的空闲链表中\n图8-1 tcmalloc内存分配器预置不同规格的链表\n在Go源代码runtime包的sizeclasses.go文件中，给出了一组预置的大小规格。\n表8-1 sizeclasses预置的大小规格\n续表\nsizeclasses.go\n第一列是所谓的sizeclass，实际上就是所有规格按空间大小升序排列的序号。 第二列是规格的空间大小，单位是字节。 第三列表示需要申请多少字节的连续内存，目的是保证划分成目标大小的内存块以后，尾端因不能整除而剩余的空间要小于12.5%。Go使用8192字节作为页面 大小，底层内存分配的时候都是以整页面为单位的，所以第三列都是8192的整数倍。 第四列是第三列与第二列做整数除法得到的商 第五列则是余数，分别表示申请的连续内存能划分成多少个目标大小的内存块，以及尾端因不能整除而剩余的空间，也就是在内存块划分的过程中浪费掉的空 间。 最后一列表示的是最大浪费百分比，结合了内存块划分时造成的尾端浪费和内存分配时向上对齐到最接近的块大小造成的块内浪费。 sizeclasses.go文件是被程序生成出来的，源码就在 mksizeclasses.go文件中\n8.1.2 heapArena Go语言的runtime将堆地址空间划分成多个arena，在amd64架构的Linux环境下，每个arena的大小是64MB，起始地址也是对齐到64MB的。每个arena都有一 个与之对应的heapArena结构，用来存储arena的元数据\n图8-2 area与heapArena的关系\nheapArena是在Go的堆之外分配和管理的\nbitmap字段是个位图\n它用两个二进制位来对应arena中一个指针大小的内存单元，所以对于64MB大小的arena来讲，heapArenaBitmapBytes的值是 64MB/8/8×2＝2MB(64MB/8B=8M, 8M*2b/8=2MB)，这个位图在GC扫描阶段会被用到。 bitmap第一字节中的8个二进制位，对应的就是arena起始地址往后32字节的内存空间。 用来描述一个内存单元的两个二进制位当中，低位用来区分内存单元中存储的是指针还是标量，1表示指针，0表示标量，所以也被称为指针／标量位。 高位用来表示当前分配的这块内存空间的后续单元中是否包含指针，例如在堆上分配了一个结构体，可以知道后续字段中是否包含指针，如果没有指针就不需 要继续扫描了，所以也被称为扫描／终止位。 为了便于操作，一个位图字节中的指针／标量位和扫描／终止位被分开存储，高4位存储4个扫描／终止位，低4位存储4个指针／标量位。 图8-3 arena起始处分配一个slice对应的bitmap标记\nspans数组用来把当前arena中的页面映射到对应的mspan，暂时先认为一个mspan管理一组连续的内存页面\npagesPerArena表示arena中共有多少个页面，用arena大小(64MB)除以页面大小(8KB)得到的结果是8192\n图8-4 arena中的页面到mspan的映射\npageInUse是个长度为1024的uint8数组，实际上被用作一个8192位的位图\n通过它和spans可以快速地找到那些处于mSpanInUse状态的mspan。 虽然pageInUse位图为arena中的每个页面都提供了一个二进制位，但是对于那些包含多个页面的mspan，只有第1个页面对应的二进制位会被用到，标记的 是整个span。 图8-5 pageInUse位图标记使用中的span\npageMarks表示哪些span中存在被标记的对象\n与pageInUse一样用与起始页面对应的一个二进制位来标记整个span。 在GC的标记阶段会原子性地修改这个位图，标记结束之后就不会再进行改动了。 清扫阶段如果发现某个span中不存在任何被标记的对象，就可以释放整个span了。 不是被标记的才释放吗?\npageSpecials又是一个与pageInUse类似的位图，只不过标记的是哪些span包含特殊设置，目前主要指的是包含finalizers，或者runtime内部用来存储 heap profile数据的bucket。\ncheckmarks是一个大小为1MB的位图，其中每个二进制位对应arena中一个指针大小的内存单元。当开启调试debug.gccheckmark的时候，checkmarks位图 用来存储GC标记的数据。该调试模式会在STW的状态下遍历对象图，用来校验并发回收器能够正确地标记所有存活的对象。\nzeroedBase记录的是当前arena中下个还未被使用的页面的位置，相对于arena起始地址的偏移量。页面分配器会按照地址顺序分配页面，所以zeroedBase之 后的页面都还没有被用到，因此还都保持着清零的状态。通过它可以快速判断分配的内存是否还需要进行清零。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC8%E7%AB%A0-%E5%A0%86/","summary":"8.1 内存分配 在Go的runtime中，有一系列函数被用来分配内存。 例如与new语义相对应的有newobject()函数和newarray()函","title":"第8章 堆"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/docs/keepachangelog/","summary":"原文","title":"如何维护更新日志"},{"content":"代码地址\n","permalink":"https://jdxj.github.io/posts/docs/syslist/","summary":"代码地址","title":"Go交叉编译支持的系统与架构"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/karllhughes/the-best-golang-blogs/","summary":"原文","title":"The Best Golang Blogs"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/cch123/plan9/","summary":"原文","title":"Plan9 Assembly"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/docs/conventionalcommits/","summary":"原文","title":"约定式提交"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/fillmem/intellij-ideavim-repeat-key/","summary":"ideavim中没法长按按键重复字符解决办法","title":"Intellij Ideavim Repeat Key"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/alikhll/golang-developer-roadmap/","summary":"原文","title":"Golang Developer Roadmap"},{"content":"7.1 Happens Before 多核情况下避免并发读写的条件\nw happens before r。 没有其他针对v的写操作happens after w且before r。 图7-1 多线程并发事件示意图\n7.1.1 并发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 第7章 package main import ( \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { var data int var ok bool someValue := rand.Int() // 第7章 code_7_1 go func() { for { if !ok { data = someValue ok = true } } }() var sum int // 第7章 code_7_2 go func() { for { if ok { sum += data ok = false } } }() time.Sleep(time.Second * 10) } 如果编译器生成的指令与源码中语句的顺序严格一致，上述生产者协程和消费者协程在单核CPU上并发执行是可以保证结果正确的。一旦编译器对生成指令的顺序 进行优化调整，或者程序在多核CPU上执行，就不能保证结果正确了\n7.1.2 并行 抽象地解释并发，指的是多个事件在宏观上是同时发生的，但是并不一定要在同一时刻发生，而并行就不一样了，从微观角度来看，并行的两个事件至少有某一 时刻是同时发生的，所以在单核CPU上的多线程只存在并发，不存在并行。只有在多核CPU上，线程才有可能并行执行。\n7.2 内存乱序 处理器普遍具有乱序执行的特性，目的都是为了更优的性能。 编译器和CPU都会考虑指令间的依赖关系，在不会改变当前线程行为的前提下进行顺序调整，因此在单个线程内依然是逻辑有序的，语句间原本满足的 happens before条件不会被破坏，但这种有序性只是在单个线程内，并不会保证线程间的有序性。 7.2.1 编译期乱序 指的是编译器对最终生成的机器指令进行了顺序调整\n7.2.2 执行期乱序 CPU在执行期间也可能会对指令的顺序进行调整\n协程一和协程二中的两条赋值语句形式相似，对应到x86汇编就是三条内存操作指令，按照顺序及分类分别是Store、Load、Store\n图7-2 协程一和协程二的赋值语句对应的汇编指令\n一般的内存属于write-back cacheable内存，简称WB内存。对于WB内存而言，Store和Load指令并不是直接操作内存中的数据的，而是先把指定的内存单元 填充到高速缓存中，然后读写高速缓存中的数据。\nLoad指令的大致流程是，先尝试从高速缓存中读取，如果缓存命中，则读操作就完成了。如果缓存未命中，则先填充对应的Cache Line， 然后从Cache Line中读取\n图7-3 Load指令的执行流程\nStore指令的大致流程类似，先尝试写高速缓存，如果缓存命中，则写操作就完成了。如果缓存未命中，则先填充对应的Cache Line，然后写到Cache Line中\n图7-4 Store指令执行流程\n在多核心的CPU上，Store操作会变得更复杂一些。\n每个CPU核心都拥有自己的高速缓存，例如x86的L1 Cache。写操作会修改当前核心的高速缓存, 被修改的数据可能存在于多个核心的高速缓存中，CPU需要 保证各个核心间的缓存一致性。 目前主流的缓存一致性协议是MESI协议，MESI这个名字取自缓存单元可能的4种状态，分别是已修改的Modified，独占的Exclusive，共享的Shared和无 效的Invalid。 当一个CPU核心要对自身高速缓存的某个单元进行修改时，它需要先通知其他CPU核心把各自高速缓存中对应的单元置为Invalid，再把自己的这个单元置为 Exclusive，然后就可以进行修改了。\n图7-5 一个CPU核心修改高速缓存数据单元的过程\n这个过程涉及多核间的内部通信，是一个相对较慢的过程，为了避免当前核心因为等待而阻塞，CPU在设计上又引入了Store Buffer。当前核心向其他核心发出 通知以后，可以先把要写的值放在Store Buffer中，然后继续执行后面的指令，等到其他核心完成响应以后，当前核心再把Store Buffer中的值合并到高速 缓存中\n图7-6 引入Store Buffer后CPU修改高速缓存数据单元的过程\n虽然高速缓存会保证多核一致性，但是Store Buffer却是各个核心私有的，因此对其他核心不可见。在Store-Load乱序中，从微观时序上，Load指令可能是 在另一个线程的Store之后执行，但此时多核间通信尚未完成，对应的缓存单元还没有被置为Invalid，Store Buffer也没有被合并到高速缓存中，所以Load 读到的是修改前的值。\n图7-7 写入Store Buffer后合并到高速缓存前Load数据\n当协程一执行最后一条Store指令时，b就被赋值为0。同样地，协程二会将a赋值为0。即使Store Buffer合并到高速缓存，x和y都被修改为新值，也已经晚了\n图7-8 合并到高速缓存后的数据状态\n理论上可能出现的乱序有4种\nLoad-Load，相邻的两条Load指令，后面的比前面的先读到数据。 Load-Store，Load指令在前，Store指令在后，但是Store操作先变成全局可见，Load指令在此之后才读到数据。 Store-Load，Store指令在前，Load指令在后，但是Load指令先读到了数据，Store操作在此之后才变成全局可见。这个我们已经在x86平台见证过了。 Store-Store，相邻的两条Store指令，后面的比前面的先变成全局可见。 所谓的全局可见，指的是在多核CPU上对所有核心可见。\n7.2.3 内存排序指令 执行期乱序会给结果带来很大的不确定性，这对于应用程序来讲是不能接受的，完全按照指令顺序执行又会使性能变差。为了解决这一问题，CPU提供了内存排序 指令，应用程序在必要的时候能够通过这些指令来避免发生乱序。以目前的Intel x86处理器为例，提供了LFENCE、SFENCE和MFENCE这3条内存排序指令\n难以理解\n7.3 常见的锁 锁需要将所有线程（或协程）对临界区的访问进行串行化处理，需要同时保证两点要求：\n同时只能有一个线程获得锁，持有锁才能进入临界区。 当线程离开临界区释放锁后，线程在临界区内做的所有操作都要全局可见。 7.3.1 原子指令 如果CMP, JNE, MOV不在一条指令中执行, 那么加锁会出问题\n图7-9 同步问题\nx86就提供了CMPXCHG指令, 是Compare and Exchange的缩写，该指令有两个操作数，用于实现锁的时候，第一操作数通常是个内存地址，也称为目的操作 数，第二操作数是个通用寄存器。CMPXCHG会将AX寄存器和第一操作数进行比较，如果相等就把第二操作数复制到目的操作数中，若不相等就把目的操作数复制 到AX寄存器中。\n在多核环境下，运行在不同CPU核心上的线程可能会并行加锁，不同核心同时执行CMPXCHG又会造成多个线程同时获得锁。\n如何解决这个问题呢？\n一种思路是，在当前核心执行CMPXCHG时，阻止其他核心执行CMPXCHG，x86汇编中的LOCK前缀用于实现这一目的。\nLOCK前缀能够应用于部分内存操作指令，最简单的解释就是LOCK前缀会让当前CPU核心在当前指令执行期间独占总线，这样其他的CPU核心就不能同时操作内 存了。 事实上，只有对于不在高速缓存中的数据才会这样，对于高速缓存中的数据，LOCK前缀会通过MESI协议处理多核间缓存一致性。 在多核环境下，这种带有LOCK前缀的指令也被称为原子指令。 在x86CPU上，LOCK前缀同时具有内存排序的作用，相当于在应用LOCK前缀的指令之后紧接着执行了一条MFENCE指令。综上所述，原子指令既能保证只允许一个 线程进入临界区，又具有内存排序的作用，能够保证在锁的状态发生变化时，临界区中所有的修改随锁的状态一起变成全局可见。\n7.3.2 自旋锁 自旋锁得以实现的基础是原子性的CAS操作，CAS即Compare And Swap，在x86平台上对应带有LOCK前缀的CMPXCHG指令。之所以称作自旋锁，是因为它会一 直循环尝试CAS操作直到成功，看起来就像是一直在自旋等待。\n尝试一下用汇编语言基于CMPXCHG指令实现一把自旋锁\nlock()和unlock()这两个函数用汇编实现\nlock()函数把锁的地址放在了BX寄存器中，把用来比较的旧值old放到了DX寄存器中，把要写入的新值new放到了CX寄存器中。 从标签again处开始是一个循环，每次循环开始前，把DX寄存器的值复制给AX寄存器，因为CMPXCHG隐含使用AX寄存器中的值作为比较用的旧值，并且可能会 修改AX寄存器，所以每次循环需要重新赋值 这个循环不断尝试通过CMPXCHG进行加锁，成功后会通过JE指令跳出循环。能够通过JE跳出循环，这是因为CMP操作会影响标志寄存器。 unlock()函数通过XCHG指令将锁清零，实现了解锁操作。细心的读者可能会注意到这里没有LOCK前缀，根据Intel开发者手册所讲，XCHG指令隐含了LOCK 前缀，所以代码中不用写，依然能够起到独占总线和内存排序的作用。 事实上，atomic包中的CompareAndSwapInt32()函数和StoreInt32()函数是基于CMPXCHG和XCHG这两条汇编指令实现的，所以上述的自旋锁可以改成完全 用Go实现\n在锁竞争比较激烈的场景下，这种自旋会造成CPU使用率很高，所以还要进行优化。x86专门为此提供了PAUSE指令，它一方面能够提示处理器当前正处于自旋循 环中，从而在退出循环的时候避免因检测到内存乱序而造成性能损失。另一方面，PAUSE能够大幅度减小自旋造成的CPU功率消耗，从而达到节能和减少发热的效 果。\n可以把PAUSE指令加入我们汇编版本的lock()函数实现中\n可以把PAUSE指令单独放在一个函数中，这样就能够跟atomic包中的函数结合使用了\n自旋锁的适用场景\n不适用于单核, 因为单核系统上任一时刻只能有一个线程在运行，当前线程一直在自旋等待，而持有锁的线程得不到运行，锁就不可能被释放 即使是在多核环境下, 在持有锁的时间占比很小，并且活跃线程数接近CPU核心数量时，自旋锁比较高效，也就是自旋的代价小于线程切换的代价。 7.3.3 调度器对象 指操作系统提供的线程间同步原语\n这些调度器对象与自旋锁的不同主要是有一个等待队列。 当线程获取锁失败时不会一直在那里自旋，而是挂起后进入等待队列中等待，然后系统调度器会切换到下一个可运行的线程。 等到持有锁的线程释放锁的时候，会按照一定的算法从等待队列中取出一个线程并唤醒它，被唤醒的线程会获得所有权，然后继续执行。 这些同步原语是由内核提供的，直接与系统的调度器交互，能够挂起和唤醒线程，这一点是自旋锁做不到的。 等待队列可以实现支持FIFO、FILO，甚至支持某种优先级策略，但是也正是由于是在内核中实现的，所以应用程序需要以系统调用的方式来使用它，这就造 成了一定的开销。在获取锁失败的情况下还会发生线程切换，进一步增大开销。 7.3.4 优化的锁 将自旋锁和调度器对象结合，理论上就可以得到一把优化的锁了。加锁时首先经过自旋锁，但是需限制最大自旋次数，如果在有限次数内加锁成功也就成功了， 否则就进一步通过调度器对象将当前线程挂起。等到持有锁的线程释放锁的时候，会通过调度器对象将挂起的线程唤醒。这样就结合了二者的优点，既避免了加 锁失败立即挂起线程造成过多的上下文切换，又避免了无限制地自旋而空耗CPU，这也是如今主流的锁实现思路。\n7.4 Go语言的同步 推荐看极客时间的Go并发编程实战课\n7.5 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC7%E7%AB%A0-%E5%90%8C%E6%AD%A5/","summary":"7.1 Happens Before 多核情况下避免并发读写的条件 w happens before r。 没有其他针对v的写操作happens after w且before r。 图7-1 多线程并发事件示意图 7.1.1 并发 1 2","title":"第7章 同步"},{"content":"COUNT函数用于统计在符合搜索条件的记录中，指定的表达式expr不为NULL的行数有多少。\n对于COUNT(*)、COUNT(常数)、COUNT(主键)形式的COUNT函数来说，优化器可以选择最小的索引执行查询，从而提升效率，它们的执行过程是一样的，只不 过在判断表达式是否为NULL时选择不同的判断方式，这个判断为NULL的过程的代价可以忽略不计，所以我们可以认为COUNT(*)、COUNT(常数)、COUNT(主键) 所需要的代价是相同的。\n而对于COUNT(非主键列)来说，server层必须要从InnoDB中读到包含非主键列的记录，所以优化器并不能随心所欲的选择最小的索引去执行。\n原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/mysql%E7%9A%84count%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/","summary":"COUNT函数用于统计在符合搜索条件的记录中，指定的表达式expr不为NULL的行数有多少。 对于COUNT(*)、COUNT(常数)、COU","title":"MySQL的COUNT是怎么执行的"},{"content":"6.1 数解中国供应链 在我国强大的商品供应链之下，质量过硬的商品能以低廉的成本大量产出。\n图6-1 拼多多、1688上有许多高性价比的消费品\n图6-2 2010年全球奢侈品皮具代工市场份额（以销售额计）\n在效率方面，我国供应链工厂“小单快反”的响应能力领先世界。\n我国制造业具备较高的完善程度，形成了多个发达的产业集群，大部分原料都能在国内完成采购。\n图6-3 2016年各国制造业海外增加值占总出口之比\n图6-4 2016年中外制造业上游原材料能在国内购买的比重对比\n国内完备的制造业体系和稳定的经营环境，使得我国制造业具备无与伦比的韧性和抗打击能力。\n图6-5 疫情期间中外制造业PMI对比（以50%作为经济强弱的分界点，越高越好）\n我国拥有多个成型的产业集群，多个细分产品的产量世界领先。\n图6-6 2019年世界鞋类产量份额前10的国家\n图6-7 2019年全球家电出口额占比前六的国家\n6.2 亲临中国制造一线：南通家纺调研实录 叠石桥简介 叠石桥的支柱产业是制造与销售家纺产品，即大家通常所说的“床上四件套”，主要包括枕头和抱枕、床单、被单、被芯等。整个地方几乎就是一个家纺产业链集 群，差不多所有人都围着家纺产业链上下游工作，从各类原材料的供给、成品加工，到展示招商、快递收发，乃至线上店铺的经营培训，一应俱全。\n图6-8 叠石桥地理位置\n全球大约60%的家纺产品产自这个地方。可以认为，在全球家纺领域，“中国制造”几乎等价为“叠石桥制造”。\n叠石桥具备完整的家纺产业链 几乎整个叠石桥都围绕着家纺产业。从上游原料，到整件制造批发，再到与家纺制造销售有关的配套服务，五脏俱全。\n比“制造”更难的事情是“销售”，销售所需要的“品牌”具备护城河 能制造、缺品牌、卖不掉，是叠石桥最常见的问题。\n在叠石桥，我们能看到很多“贴牌加工、一件代发”的牌子。\n什么是贴牌加工？是我能设计，能制造，但是没有品牌，没有销路。谁如果有品牌、有渠道，那可以直接在我的产品上贴牌销售。 什么是一件代发？这是一个电商术语，如果你能够在电商平台上开店找到买家，你就不用进货，不用备库存，而是和我签协议，在你收到订单之后，我直接帮 你发货，这类似于线下零售的“代销”模式。 做品牌是一件风险相对较高的事情，品牌商品的库存会占用大量的现金流，也有失败的风险。因此对于很多工厂主而言，做一个新品牌是一件吃力不讨好的事情。\n总之，家纺产业链的难点不在于造，而在于卖。拥有好的品牌和销售渠道，比制造更重要。这也说明，在服装等产业中，销路往往比生产能力更值钱。\n6.3 如何兑现中国消费品供应链的真正价值 优质供应链品牌化或是未来消费行业的重要机会 产业链里的大多数工厂主，对于自己做品牌这件事热情并不大，他们一方面垂涎大品牌丰厚的利润，另一方面希望能够安安心心地搞生产，希望能够得到大品牌 的垂青。做出一个大品牌比生产出质量过硬的商品更难，因为品牌的经营涉及品牌营销、渠道管理、供应链管理等多方面的细节，对于中小企业主而言是一件比 较难的事情，同时也会占用较大的资金，带来较高的经营风险。\n成为大品牌的核心供应商，是供应链企业的重要成长方向 大品牌对其供应商的要求更高\n第一，代工厂要保证稳定的质量和足够的合格率，因为质量低下的产品有可能会一夜之间毁掉大品牌多年以来积累的口碑。 第二，代工厂要保证出货的效率，天下武功唯快不破，在互联网时代，品牌方也需要快速响应市场动态以保持竞争力。 第三，代工厂也要保证其经营的正规性，因为品牌方一定不会希望因为代工厂的经营和管理问题而使得自己的口碑受到影响。 管理能力是供应商的一个核心壁垒。\n供应商通常需要聘用大量的员工作为制造人员，而为了保证成本，大部分制造人员的学历并不高。 考虑到工人的熟练度会随着生产逐渐提升，企业不但要打造完善的员工培训体系，还要尽可能保证工人的留存率。如果工人流动太快，熟练度不高，生产效率 和质量将会受到影响。 品牌方构建的合作关系也是一个重要壁垒。\n为了保障质量的稳定和管理的便利，大品牌的供应商构成会相对比较稳定。有时候品牌方甚至会主动向供应商输出管理方法和制造工艺，以提升产品的总体质 量。 因此，在没有出现重大问题的情况下，品牌方通常较少更换其核心供应商。这样一来，与品牌方建立的合作关系就成了供应商的重要经营壁垒：稳定的合作关 系意味着稳定的订单，同时这种关系也为供应商挡住了部分潜在竞争对手。 跨境电商是我国优质供应链突围的另一个重要方向 图6-10 中国跨境电商市场规模与增长率\n为什么是电商，而非传统的线下渠道？第一，海外的电商渠道尚未成型，存在弯道超车的空间；第二，线上渠道的开店成本低，且我国商家在电商渠道上具备更 强大的竞争优势。\n国内商家在对互联网和电商的理解上具备领先优势。我国的电商规模和电商渗透率在世界范围内处于领先地位，也拥有大量经过激烈竞争后沉淀下来的电商从 业人员，他们在剖析平台规则的方法论、对电商消费者心理的把控、对互联网的理解等方面，都展现出一定的优势。 国外电商渠道里的机会更大。它们的线下渠道发展已经基本进入成熟期，而线上渠道仍在发展过程中。 图6-11 美国电商渗透率\n跨境电商大致分为三类，从出现的先后顺序上来说：第一类是只做渠道的“大卖家”，这是跨境电商初期的形式；第二类是做跨境品牌的“品牌商”；第三类是同时 做品牌和线上渠道的“独立站”。品牌商和独立站是现阶段的主流形式\n表6-1 跨境电商的主要形式\n海外电商行业的市场格局和我国的最大不同，在于独立站的份额比较大。在美国，除了亚马逊之外，其他平台的份额都不高，用户也习惯于在各个品牌的官 方网站上购买产品，因此在国外，独立站有较大发展空间。\n做独立站还有一个好处，就是可以做出更加精美的展示页面，这对于服饰类商家来说是比较重要的。亚马逊、eBay的展现页面总体上比较简约，展现服饰类商品 时有所不足，而海外用户2021年也暂时没有养成在社交媒体上下单的购物习惯（事实上他们非常在意购物的隐私，因此海外用户是否会像我国用户一样在抖音上 下单，需要多久养成这个习惯，都需要时间观察）。因此，独立站对于服装等一些品类而言，是一个非常好的选择。\n独立站的启动难度和经营风险都是最高的。\n第一，海外网购的主要支付方式是信用卡的安全码，用户由于害怕卡片被盗刷，因此很少在自己不信任的平台上下单。 第二，亚马逊等平台上的大卖家和品牌商可以直接使用平台提供的仓储服务，但独立站通常需要自建海外仓库，所有的东西都从国内跨境发货，时效性和用户 体验都会很差。由于难度大、风险高，独立站在最近几年才逐渐发展起来。 6.4 结语 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC6%E7%AB%A0-%E4%BE%9B%E5%BA%94%E9%93%BE-%E4%B8%AD%E5%9B%BD%E6%B6%88%E8%B4%B9%E7%9A%84%E5%BA%95%E6%B0%94/","summary":"6.1 数解中国供应链 在我国强大的商品供应链之下，质量过硬的商品能以低廉的成本大量产出。 图6-1 拼多多、1688上有许多高性价比的消费品 图6-2 2","title":"第6章 供应链 中国消费的底气"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/cnnic/","summary":"主页","title":"中国互联网络信息中心"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/euromonitor/","summary":"主页","title":"Euromonitor"},{"content":"6.1 进程、线程与协程 6.1.1 进程 现代操作系统利用硬件提供的页表机制，通过为不同进程分配独立的页表，实现进程间地址空间的隔离。\n图6-1 进程间地址空间的隔离\nLinux通过clone系统调用来创建新的进程。\n6.1.2 线程 为什么要有一个用户栈和一个内核栈呢？\n因为我们的线程在执行过程中经常需要在用户态和内核态之间切换，通过系统调用进入内核态使用系统资源。 对于内核来讲，任何的用户代码都被视为不安全的，可能有Bug或者带有恶意的代码，所以操作系统不允许用户态的代码访问内核数据。 图6-2 线程的用户栈和内核栈\n调度系统切换线程时，如果两个线程属于同一个进程，开销要比属于不同进程时小得多\n因为不需要切换页表，相应地，TLB缓存也就不会失效。 同一个进程中的多个线程，因为共享同一个虚拟地址空间，所以线程间数据共享变得十分简单高效 图6-3 同进程间线程切换\n在线程切换频繁时，调度本身的开销会占用大量CPU资源，造成系统吞吐量严重下降。\n6.1.3 协程 从具体实现来看，纤程就是一个由入口函数地址、参数和独立的用户栈组成的任务，相当于让线程可以有多个用户栈\n图6-4 纤程概念示意图\n6.2 IO多路复用 6.2.1 3种网络IO模型 把一个常见的TCP socket的recv请求分成两个阶段：一是等待数据阶段，等待网络数据就绪；二是数据复制阶段，把数据从内核空间复制到用户空间。\n对于阻塞式IO来讲，整个IO过程是一直阻塞的，直至这两个阶段都完成。\n图6-5 经典的阻塞式网络IO模型\n如果想要启用非阻塞式IO，需要在代码中使用fcntl()函数将对应socket的描述符设置成O_NONBLOCK模式。\n在非阻塞模式下，线程等待数据的时候不会阻塞，从编程角度来看就是recv()函数会立即返回，并返回错误代码EWOULDBLOCK（某些平台的SDK也可能是 EAGAIN），表明此时数据尚未就绪，可以先去执行别的任务。 程序一般会以合适的频率重复调用recv()函数，也就是进行轮询操作。在数据就绪之前，recv()函数会一直返回错误代码EWOULDBLOCK。 等到数据就绪后，再进入复制数据阶段，从内核空间到用户空间。 因为非阻塞模式下的数据复制也是同步进行的，所以可以认为第二阶段也是阻塞的。 图6-6 非阻塞式网络IO模型\n有了非阻塞式IO是不是就万事大吉了呢？\n虽然第一阶段不会阻塞，但是需要频繁地进行轮询。一次轮询就是一次系统调用，如果轮询的频率过高就会空耗CPU，造成大量的额外开销 如果轮询频率过低，就会造成数据处理不及时，进而使任务的整体耗时增加。 IO多路复用技术就是为解决上述问题而诞生的\n与非阻塞式IO相似，从socket读写数据不会造成线程挂起。 在此基础之上把针对单个socket的轮询改造成了批量的poll操作，可以通过设置超时时间选择是否阻塞等待。 只要批量socket中有一个就绪了，阻塞挂起的线程就会被唤醒，进而去执行后续的数据复制操作。 图6-7 IO多路复用\n6.2.2 示例对比 6.3 巧妙结合 把每个网络请求放到一个单独的协程中去处理，底层的IO事件循环在处理不同的socket时直接切换到与之关联的协程栈\n图6-10 协程与IO多路复用的结合\n这样一来，就把IO事件循环隐藏到了runtime内部，开发者可以像阻塞式IO那样平铺直叙地书写代码逻辑，尽情地把数据存放在栈帧上的局部变量中，代码执行 网络IO时直接触发协程切换，切换到下一个网络数据已经就绪的协程。当底层的IO事件循环完成本轮所有协程的处理后，再次执行netpoll，如此循环往复，开 发者不会有任何感知，程序却得以高效执行。\n6.4 GMP模型 6.4.1 基本概念 G指的就是goroutine；M是Machine的缩写，指的是工作线程；P则是指处理器Processor，代表了一组资源，M要想执行G的代码，必须持有一个P才行。\n6.4.2 从GM到GMP 在早期版本的Go实现中（1.1版本之前），是没有P的，只有G和M\n图6-11 GM调度模型\nGM调度模型有几个明显的问题\n用一个全局的mutex保护着一个全局的runq（就绪队列），所有goroutine的创建、结束，以及调度等操作都要先获得锁，造成对锁的争用异常严重。 G的每次执行都会被分发到随机的M上，造成在不同M之间频繁切换，破坏了程序的局部性 每个M都会关联一个内存分配缓存mcache，造成了大量的内存开销，进一步使数据的局部性变差。 在存在系统调用的情况下，工作线程经常被阻塞和解除阻塞，从而增加了很多开销。 为了解决上述这些问题，新的调度器被设计出来。\n总体的优化思路就是将处理器P的概念引入runtime，并在P之上实现工作窃取调度程序。 M仍旧是工作线程，P表示执行Go代码所需的资源。当一个M在执行Go代码时，它需要有一个关联的P，当M执行系统调用或者空闲时，则不需要P。 图6-12 GMP调度模型\n本地runq和全局runq 当一个G从等待状态变成就绪状态后，或者新创建了一个G的时候，这个G会被添加到当前P的本地runq。 当M执行完一个G后，它会先尝试从关联的P的本地runq中取下一个，如果本地runq为空，则到全局runq中去取 如果全局runq也为空，就会去其他的P那里窃取一半的G过来。 图6-13 本地runq为空到全局runq获取G\n图6-14 全局runq也为空窃取其他P的G\nM的自旋 当一个M进入系统调用时，它必须确保有其他的M来执行Go代码。新的调度器设计引入了一定程度的自旋，就不用再像之前那样过于频繁地挂起和恢复M了，这 会多消耗一些CPU周期，但是对整体性能的影响是正向的。 自旋分两种：第一种是一个有关联P的M，自旋寻找可执行的G；第二种是一个没有P的M，自旋寻找可用的P。这两种自旋的M的个数之和不超过GOMAXPROCS， 当存在第二种自旋的M时，第一种自旋的M不会被挂起(因为P不够)。 当一个新的G被创建出来或者M即将进行系统调用，或者M从空闲状态变成忙碌状态时，它会确保至少有一个处于自旋状态的M（除非所有的P都忙碌），这样保 证了处于可执行状态的G都可以得到调度，同时还不会频繁地挂起、恢复M。 6.5 GMP主要数据结构 6.5.1 runtime.g runtime.g部分字段\n表6-1 runtime.g部分字段的用途\nstack是个结构体类型, 用来描述goroutine的栈空间的，对应的内存区间是一个左闭右开区间[lo，hi]。\n1 2 3 4 type stack struct { lo uintptr hi uintptr } sched用来存储goroutine执行上下文, 它与goroutine协程切换的底层实现直接相关，其对应的gobuf结构代码如下\nsp字段存储的是栈指针 pc字段存储的是指令指针 g用来反向关联到对应的G ctxt指向闭包对象，也就是说用go关键字创建协程的时候传递的是一个闭包，这里会存储闭包对象的地址 ret用来存储返回值，实际上是利用AX寄存器实现类似C函数的返回值，目前只发现panic-recover机制用到了该字段。lr在arm等架构上用来存储返回地址， x86没有用到该字段 bp用来存储栈帧基址。 atomicstatus描述了当前G的状态\n表6-2 atomicstatus的取值及其含义\nwaiting对应的sudog结构\n6.5.2 runtime.m runtime.m部分字段\n表6-3 runtime.m部分字段的用途\n6.5.3 runtime.p runtime.p部分字段\n表6-4 runtime.p各个字段的主要用途\nstatus字段有5种不同的取值，分别表示P所处的不同状态\n表6-5 P的不同状态\n6.5.4 schedt Go 1.16版源代码中的schedt结构定义\n表6-6 schedt部分字段的主要用途\n","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC6%E7%AB%A0-goroutine/","summary":"6.2 IO多路复用写的不是特别详细","title":"第6章 Goroutine"},{"content":" ","permalink":"https://jdxj.github.io/posts/hello/","summary":"用于测试hugo特性.","title":"Hello Hugo!"},{"content":"5.1 中国零售渠道概览 我国的零售渠道分布情况在世界范围内都很独特，其独特性主要归为两点。\n我国电商渠道无比发达。 我国传统零售渠道的占比仍然很高。 图5-1 2021年我国零售渠道份额分布, 注：由于四舍五入，相加不为100%\n电商已经成为我国零售商业的一个重要成长来源。\n我国零售商业与西方国家非常大的一个差异在于线下零售的发达程度\n西方国家在线下发展完善之后才出现了电商，因此电商的推进速度并不快 我国线下零售在发展到一半的时候就受到了电商崛起的冲击，在电商逐渐趋于成熟之后，线下零售的发展遭受到了一定的压制。 图5-2 我国各零售渠道规模增速\n目前我国零售商业的形态是比较割裂的。\n一边是先进高效、已经具备世界领先水平的电商渠道，另一边则是仍然占据较大市场份额的传统零售渠道 我国拥有复杂的城市层级结构，这些传统零售渠道遍布在广大的市井之中。这种割裂的环境未来可能仍将伴随中国消费行业不断前行。 思考零售渠道，就是思考“人”“货”“场”之间的关系。\n“人-货-场”是零售商业中一个经典的分析模型。零售生意的本质，就是把“人”和“货”通过“场”连接起来。\n具体来说，“人”指的就是消费者，对应的是消费者的画像和其消费诉求； “货”指的选品，对应的是商场中的品类结构、产品价格带、品牌阶层等； “场”指的是消费者购物的场所，场所的位置在哪儿、商品如何陈列、要放多少个SKU，都是这个环节的核心问题。 渠道需求分析框架：多快好省\n对人的分析，其实就是对消费者需求的分析。人物画像、用户层级等数据，其实最后都要归到多、快、好、省这四个维度中来。\n其中，“多”代表可选择的商品多，消费者能够找到所需要的所有商品； “快”代表方便快捷，包括购物所需时间短、门店离消费者近，以及网购时配送速度快； “好”不但代表商品的质量又好又稳定，也代表购物体验的优势； “省”则是价格便宜。 图5-3 不同渠道在多、快、好、省上有不同侧重点\n处于不同位置的渠道，分析时有不同的侧重点。\n比如，对于超市这种品类“多”的渠道，我们要考量其动销情况，并且要重点关注其经营效率； 对于便利店这种注重“快”的渠道，要密切关注门店的数量和密度； 对于京东这样通过自营物流做到“快”和“好”的渠道，则要密切关注物流的覆盖面和经营效率。 货：不同的渠道适合不同的品类，区分盈利品类和引流品类\n在渠道商业中，品类的聚集效应是一个非常重要的规律。同一类商品的门店聚集在一起，能够汇聚更多的人流量，实现相互引流，使得彼此的生意都变得更好。\n从线下线上渠道的对比上看，线上渠道适合标准化、重复消费的商品，线下渠道则适合注重体验感和即时性的品类。\n图5-4 2021年各大消费品品类的线上渗透率\n我们在分析渠道品类结构的时候，也要注意区分引流品类和利润品类。\n有的品类能够吸引很多的人流量，但不一定能够产生太高的利润； 另外一些品类不具备引流的能力，却是渠道的利润中心。 场：经销、代销、联营、租赁的商业模式解析\n租赁就是把自己的地盘租给别人经营，并收取一定的租金，业主基本不会介入太多日常经营。 经销就是自己选品，以自有资金大批量进货，赚取批发和零售之间的差价，并承担商品滞销、贬值等风险。总的来说，租赁是风险最低、介入经营程度最低的 模式，而经销是风险最高、介入经营程度最高的模式。 代销和联营是比较难以理解的两个模式，处于经销和租赁的中间。代销是指把商品放在他人的店铺中，由他人代为销售，存货风险由自己承担。 联营是指与他人联合经营，比如由他人负责提供场地，并负责装修和固定资产的购置，而己方负责进货、生产、销售等环节，并按照事先约定进行利润分成。 具体的例子, 假设小明同学要卖面包，他有如下经营方式可选\n①租下一个门店，自己装修开业，成为面包店店主，这是经销模式，而出租这家门店的业主，则以租赁模式参与了零售商业； ②把自己手中的面包放在由他人运营的超市货架上，由超市帮忙出售，每卖出一个面包就与超市分成结算，所有卖不出去的都算在小明头上，这是代销； ③盘下楼下超市的一个面包柜台，自己站在柜台前销售自己的面包，并以固定租金或扣点的形式与超市分账，这是联营。 有时我们也会简化以上分类，而用“1P”和“3P”来区分零售商业公司的经营业态。1P指的是自营，3P指的是平台。\n1P就是“1st-Party”，指的是销售商品的货值会呈现在企业报表的收入和营业成本之中；京东 3P是“3rd-Party”，指的是企业销售商品的货值不会呈现在报表的收入和成本项中。天猫 5.2 中国电商，世界第一 图5-5 2019年各国零售电商销售额\n电商也已经渗入我国居民生活的方方面面。\n图5-6 中国历年电商渗透率\n发达便利的快递网络、扎实的移动网络建设，使得身处中小城镇乃至乡村的居民，也能享受到网购带来的实惠与便利。\n图5-7 中国网购用户已突破8亿人, 注：2021H1表示2021年上半年\n新冠肺炎疫情期间，电商是国民经济的压舱石，是居民日常消费的诺亚舟。\n图5-8 电商是我国社会零售额增长的重要引擎\n我们在分析消费品品牌时，必须重点关注其互联网运营能力以及在电商渠道上的表现。\n线上营销能力强、线上渠道建设较好的商家通常具备更好的发展前景； 而不重视线上化趋势的商家则有被时代淘汰的可能。 5.3 阿里巴巴、京东、拼多多：卖货还是卖流量 阿里巴巴、京东、拼多多是我国市场份额前三的电商平台。尽管它们都被消费者称为“平台”，但盈利方式和商业实质却存在着根本上的不同。\n图5-9 2020年中国电商平台市场份额\n线下零售生意分为买卖和收租，前者卖货，后者卖流量\n平台电商≈购物中心或小商品城，自营电商≈百货商超\n简单对比平台电商和自营电商：\n平台电商更轻，自营电商更重。平台电商的核心资产在于流量本身，重点是要做好流量的聚合与分发。这些平台的实物资产可能只是一些服务器，但平台自有 流量的价值远远高于这些服务器的价值。 自营电商的核心资产是履约体系，通常包括大量的仓库、运输车辆、配送人员等。履约体系是其保证大规模、高效率、好体验的根基所在。 平台电商：更应关注GMV和货币化率\nGMV指用户下单的总金额 货币化率等于平台收入除以GMV，这是反映平台盈利能力的重要指标。 自营电商：关注收入、利润率、周转率\n一般而言，我们需要关注毛利率、履约毛利率、营业利润率等指标：\n①毛利率直接反映了平台进销差价及其变化幅度。 ②履约毛利率是毛利率减去仓储、物流的费用率，这个指标直接反映了平台的边际利润率，即每一笔订单能够赚到的钱。对于一个健康的平台而言，履约毛利 率最好为正数，否则将“做一单亏一单”。 ③营业利润率是在履约毛利率的基础上，进一步扣减营销、管理、研发费用率得来的，反映了平台的整体盈利水平。 5.4 淘宝、天猫、拼多多的利润实质是广告收入 阿里巴巴本质上是一家以广告费和佣金为主要收入来源的“线上商业地产公司”\n佣金是如何产生的？\n在交易环节，淘宝平台的商家是免佣金的；天猫平台的商家需要向阿里巴巴支付固定金额的年费，以及占成交额一定比例的佣金。佣金率主要根据品类而定，平 时很少调整，大多数品类的佣金率介于0.3%～5%之间。其中，服装、化妆品的佣金率较高，充值、3C数码产品的佣金率较低。\n表5-1 天猫平台2020年各经营类目佣金率及年费\n淘系电商有着多种多样的广告投放工具\n阿里巴巴佣金货币化率的小幅提升主要来自\n①天猫平台成交额占比的提升，淘宝平台不收取佣金，天猫占比越高，佣金货币化率越高； ②天猫高佣金货币化率品类的成交额占比提升。广告费货币化率的提升是平台货币化率增长的核心驱动力。 图5-10 阿里巴巴货币化率及构成\n为何阿里巴巴的广告费货币化率能够连续多年实现增长？\n阿里巴巴推出了B2C平台“天猫”，直接与品牌商合作。 增加移动端广告库存。广告库存可以直接理解为广告位的数量，这个指标与广告收入、货币化率都有较强的相关性。 上线“千人千面”的推荐机制。个性化算法 拼多多也是一个“卖流量”的平台\n从平台经营实质上来看，如今的拼多多与阿里巴巴差异不大，都是通过商家的投放来盈利。拼多多和阿里巴巴的主要区别在于平台上的商家构成不同，以及用户 对于这两个平台的心智定位不同，即淘宝天猫代表品牌商品，而拼多多代表非品牌商品或折扣商品。\n拼多多如果不能实现品牌化，那未来的潜在盈利能力还高吗？\n高。去品牌化不意味着没有盈利能力，拼多多的货币化率已经接近阿里巴巴了。我国的消费品制造业世界领先，在多个地区拥有多类消费品产业集群，如浙 江小商品、江苏家纺等，这些集群的产品物美价廉却缺乏销路，而拼多多是一个好的去处。\n5.5 结语 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC5%E7%AB%A0-%E6%B8%A0%E9%81%93-%E4%BA%92%E8%81%94%E7%BD%91%E5%92%8C%E7%94%B5%E5%95%86%E6%98%AF%E4%B8%AD%E5%9B%BD%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%98%E9%87%8F/","summary":"5.1 中国零售渠道概览 我国的零售渠道分布情况在世界范围内都很独特，其独特性主要归为两点。 我国电商渠道无比发达。 我国传统零售渠道的占比仍然很高。 图","title":"第5章 渠道 互联网和电商是中国消费行业的核心变量"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/bloomberg/","summary":"主页","title":"Bloomberg"},{"content":"多线程并发读/写同一个TCP socket是线程安全的，因为TCP socket的读/写操作都上锁了。虽然线程安全，但依然不建议你这么做，因为TCP本身是基于数据流的协 议，一份完整的消息数据可能会分开多次去写/读，内核的锁只保证单次读/写socket是线程安全，锁的粒度并不覆盖整个完整消息。因此建议用一个线程去 读/写TCP socket。\n多线程并发读/写同一个UDP socket也是线程安全的，因为UDP socket的读/写操作也都上锁了。UDP写数据报的行为是\u0026quot;原子\u0026quot;的，不存在发一半包或收一半包的问题， 要么整个包成功，要么整个包失败。因此多个线程同时读写，也就不会有TCP的问题。虽然如此，但还是建议用一个线程去读/写UDP socket。\n原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/socket%E6%98%AF%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97/","summary":"多线程并发读/写同一个TCP socket是线程安全的，因为TCP socket的读/写操作都上锁了。虽然线程安全，但依然不建议你这么做，因为T","title":"Socket是并发安全的吗"},{"content":"主要看下模型对比.\n原文\n","permalink":"https://jdxj.github.io/posts/articles/skychen1218/rabbitmq%E4%B8%8Ekafka%E9%80%89%E5%9E%8B%E5%AF%B9%E6%AF%94/","summary":"主要看下模型对比. 原文","title":"RabbitMQ与Kafka选型对比"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/rude3knife/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/","summary":"原文","title":"缓存与数据库一致性问题深度剖析"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/duck-and-duck/%E8%80%81%E6%9D%BF%E8%A6%81%E6%88%91%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%BC%95%E6%93%8E/","summary":"原文","title":"老板要我开发一个简单的工作流引擎"},{"content":"DDD 是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。\n原文\n","permalink":"https://jdxj.github.io/posts/articles/courage129/ddd%E5%85%B4%E8%B5%B7%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB/","summary":"DDD 是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。 原文","title":"DDD兴起的原因以及与微服务的关系"},{"content":"5.1 空接口 是指不包含任何方法的接口interface{}\n5.1.1 一个更好的void∗ 如果用unsafe.Sizeof()函数获取一个interface{}类型变量的大小，在64位平台上是16字节，在32位平台上是8字节。interface{}类型本质上是个 struct，由两个指针类型的成员组成，在runtime中可以找到对应的struct定义\n1 2 3 4 type eface struct { _type *_type data unsafe.Pointer } 还有一个专门的类型转换函数efaceOf()，该函数接受的参数是一个interface{}类型的指针，返回值是一个eface类型的指针，内部实际只进行了一下指针类 型的转换，也就说明interface{}类型在内存布局层面与eface类型完全等价。\n1 2 3 func efaceOf(ep *interface{}) *eface { return (*eface)(unsafe.Pointer(ep)) } data字段是一个unsafe.Pointer类型的指针，用来存储实际数据的地址。 unsafe.Pointer在含义上和C语言中的void∗有些类似，只用来表明这是一个指针，并不限定指向的目标数据的类型，可以接受任意类型的地址。 _type字段用来描述data的类型元数据 1 2 3 // 第5章 code_5_1.go var n int var e interface{} = \u0026amp;n 图5-1 空接口变量e与赋值变量n的关系\n就变量n本身而言，它的类型信息只会被编译器使用，编译阶段参考这种类型信息来分配存储空间、生成机器指令，但是并不会把这种类型信息写入最终生成的 可执行文件中。从内存布局的角度来讲，变量n在64位和32位平台分别占用8字节和4字节，占用的这些空间全部用来存放整型的值，没有任何空间被用来存放整 型类型信息。\n把变量n的地址赋值给interface{}类型的变量e的这个操作，意味着编译器要把∗int的类型元数据生成出来，并把其地址赋给变量e的_type字段，这些类型元 数据会被写入最终的可执行文件\n1 2 3 4 5 // 第5章 code_5_2.go func p2e(p *int) (e interface{}) { e = p return } 反编译p2e()\n等价伪代码\n对于interface{}类型的变量e，它的声明类型是interface{}, _type会随着变量e装载不同类型的数据而发生改变，所以后文中将它称为变量e的动态类型， 并相应地把变量e的声明类型称为静态类型。\n5.1.2 类型元数据 在C语言中类型信息主要存在于编译阶段，编译器从源码中得到具体的类型定义，并记录到相应的内存数据结构中，然后根据这些类型信息进行语法检查、生成 机器指令等。例如x86整数加法和浮点数加法采用完全不同的指令集，编译器根据数据的类型来选择。这些类型信息并不会被写入可执行文件，即使作为符号数 据被写入，也是为了方便调试工具，并不会被语言本身所使用。\nGo与C语言不同的是，在设计之初就支持面向对象编程，还有其他一些动态语言特征，这些都要求运行阶段能够获得类型信息，所以语言的设计者就把类型信息 用统一的数据结构来描述，并写入可执行文件中供运行阶段使用，这就是所谓的类型元数据。\nGo 1.15版本的runtime源码\n表5-1 _type各字段的含义及主要用途\n_type提供了适用于所有类型的最基本的描述，对于一些更复杂的类型，例如复合类型slice和map等，runtime中分别定义了maptype、slicetype等对应的 结构。\n1 2 3 4 type slicetype struct { typ _type elem *_type } Go语言允许为自定义类型实现方法，这些方法的相关信息也会被记录到自定义类型的元数据中，一般称为类型的方法集信息。\n1 type Integer int 图5-2 自定义类型Integer的类型元数据结构\n_type结构的tflag字段是几个标志位，当tflagUncommon这一位为1时，表示类型为自定义类型。从runtime的源码可以发现，_type类型有一个 uncommon()方法，对于自定义类型可以通过此方法得到一个指向uncommontype结构的指针\nuncommontype结构的定义代码如下：\n通过pkgpath可以知道定义该类型的包名称 mcount表示该类型共有多少个方法 xcount表示有多少个方法被导出 moff是个偏移值，那里就是方法集的元数据，也就是一组method结构构成的数组。 例如，若为自定义类型Integer定义两个方法，它的类型元数据及其method数组的内存布局如图5-3所示。\n图5-3 Integer类型元数据及其method数组的内存布局\n可以将type method struct理解为tcp封包中的header.\n图5-4 method数组排序\n通过name偏移能够找到方法的名称字符串 mtyp偏移处是方法的类型元数据，进一步可以找到参数和返回值相关的类型元数据。 ifn是供接口调用的方法地址 tfn是正常的方法地址，这两个方法地址有什么不同呢？ifn的接收者类型一定是指针，而tfn的接收者类型跟源代码中的实现一致 以上这些类型元数据都是在编译阶段生成的，经过链接器的处理后被写入可执行文件中，runtime中的类型断言、反射和内存管理等都依赖于这些元数据.\n5.1.3 逃逸与装箱 data字段是个指针，那么它是如何接收来自一个值类型的赋值的呢？\n1 2 3 // 第5章 code_5_3.go n := 10 var e interface{} = n 图5-5 interface{}类型的变量e的数据结构\n把第5章/code_5_3.go放到一个函数中\n1 2 3 4 5 // 第5章 code_5_4.go func v2e(n int) (e interface{}) { e = n return } 反汇编\n等价的伪代码\nruntime.convT64()函数的源代码\nstaticuint64s是个长度为256的uint64数组，每个元素的值都跟下标一致，存储了0～255这256个值，主要用来避免常用数字频繁地进行堆分配。\n图5-6 staticuint64s数组\n图5-7 变量e的数据结构\n值类型装箱就一定会进行堆分配吗？\n1 2 3 4 5 6 7 8 // 第5章 code_5_5.go func fn(n int) bool { return notNil(n) } func notNil(a interface{}) bool { return a != nil } 编译时需要禁止内联优化，编译器还能够通过notNil()函数的代码实现判定有没有发生逃逸，反编译fn()函数得到的汇编代码如下\n转换为等价的伪代码\n图5-8 fn()函数的调用栈\n注意局部变量v，它实际上是被编译器采用隐式方式分配的，被用作变量n的值的副本，却并没有分配到堆上。\ninterface{}在装载值的时候必须单独复制一份，而不能直接让data存储原始变量的地址，因为原始变量的值后续可能会发生改变，这就会造成逻辑错误。\n5.2 非空接口 5.2.1 动态派发 多态\n方法地址静态绑定 要进行方法（函数）调用，有两点需要确定：\n一是方法的地址，也就是在代码段中的指令序列的起始地址； 二是参数及调用约定，也就是要传递什么参数及如何传递的问题（通过栈或者寄存器），返回值的读取也包含在调用约定范畴内。 不使用接口而直接通过自定义类型的对象实例调用其方法的例子\n1 2 3 4 //go:noinline func ReadFile(f *os.File, b[]byte) (n int, err error) { return f.Read(b) } 反编译\n伪代码\n从汇编语言的角度来看，上述方法的调用是通过CALL指令＋相对地址实现的，方法地址在可执行文件构建阶段就确定了，一般将这种情况称为 方法地址的静态绑定。\n对于动态派发来讲，编译阶段能够确定的是要调用的方法的名字，以及方法的原型（参数与返回值列表）。\n动态查询类型元数据 让我门设计动态派发\n例子代码\n1 2 var r io.Reader = f n, err := r.Read(buf) 首先，可以通过变量r得到∗os.File的类型元数据 然后根据方法名称Read以二分法查找匹配的method结构 找到后再根据method.mtyp得到方法本身的类型元数据 最后对比方法原型是否一致（参数和返回值的类型、顺序是否一致）。 如果原型一致，就找到了目标方法，通过method.ifn字段得到方法的地址，然后就像调用普通函数一样调用就可以了。 图5-9 ∗os.File的类型元数据\n单就动态派发而言，这种方式确实可以实现，但是有一个明显的问题，那就是效率低，或者说性能差。\n跟地址静态绑定的方法调用比起来，原本一条CALL指令完成的事情，这里又多出了一次二分查找加方法原型匹配，增加的开销不容小觑，可能会造成动态派发 的方法比静态绑定的方法多一倍开销甚至更多，所以必须进行优化。 不能在每次方法调用前都到元数据中去查找，尽量做到一次查找、多次使用，这里可以一定程度上参考C++的虚函数表实现。 C++虚函数机制 C++中的虚函数机制跟接口的思想很相似，编程语言允许父类指针指向子类对象，当通过父类的指针来调用虚函数时，就能实现动态派发。\n具体实现原理就是\n编译器为每个包含虚函数的类都生成一张虚函数表，实际上是个地址数组，按照虚函数声明的顺序存储了各个虚函数的地址。 此外还会在类对象的头部安插一个虚指针（GCC安插在头部，其他编译器或有不同），指向类型对应的虚函数表。 运行阶段通过类对象指针调用虚函数时，会先取得对象中的虚指针，进一步找到对象类型对应的虚函数表，然后基于虚函数声明的顺序，以数组下标的方式从 表中取得对应函数的地址，这样整个动态派发过程就完成了。 测试代码\n输出\nA,8 B,16 图5-10 C++虚函数动态派发示例\n参考C++的虚函数表思想，再回过头来看Go语言中接口的设计，如果把这种基于数组的函数地址表应用在接口的实现中，基本就能消除每次查询地址造成的性能 开销。显然这里需要对eface结构进行扩展，加入函数地址表相关字段，经过扩展的eface姑且称作efacex\n怪不得叫tab (table)\n图5-11 参照C++虚函数机制修改后的非空接口数据结构\n什么时候为fun数组赋值呢？当然是在为整个efacex结构赋值的时候最合适\n1 2 3 4 // 第5章 code_5_9.go f, _ := os.Open(\u0026#34;gom.go\u0026#34;) var rw io.ReadWriter rw = f 从f到rw这个看似简单的赋值，至少要展开成如下几步操作：\n①根据rw接口中方法的个数动态分配tab结构，这里有两个方法，fun数组的长度是2。 ②从∗os.File的方法集中找到Read()方法和Write()方法，把地址写入fun数组对应下标。 ③把∗os.File的元数据地址赋值给tab._type。 ④把f赋值给data，也就是数据指针。 图5-12 基于efacex设计的非空接口变量rw赋值后的数据结构\n实际上，fun数组也不用每次都重新分配和初始化，从指定具体类型到指定接口类型变量的赋值，运行阶段无论发生多少次，每次生成的fun数组都是相同的。例 如从∗os.File到io.ReadWriter的赋值，每次都会生成一个长度为2的fun数组，数组的两个元素分别用于存储(∗os.File).Read和(∗os.File).Write的 地址。也就是说通过一个确定的接口类型和一个确定的具体类型，就能够唯一确定一个fun数组，因此可以通过一个全局的map将fun数组进行缓存，这样就能进 一步减少方法集的查询，从而优化性能。\n5.2.2 具体实现 实际上在Go语言的runtime中与非空接口对应的结构类型是iface\n因为也是通过数据指针data来装载数据的，所以也会有逃逸和装箱发生。其中的itab结构就包含了具体类型的元数据地址_type，以及等价于虚函数表的方法地 址数组fun，除此之外还包含了接口本身的类型元数据地址inter\n接口类型元数据 除去最基本的typ字段，pkgpath表示接口类型被定义在哪个包中，mhdr是接口声明的方法列表。\n比自定义类型的method结构少了方法地址，只包含方法名和类型元数据的偏移。\n这些偏移的实际类型为int32，与指针的作用一样，但是64位平台上比使用指针节省一半空间。 以ityp为起点，可以找到方法的参数（包括返回值）列表，以及每个参数的类型信息，也就是说这个ityp是方法的原型信息。 图5-13 io.ReadWriter类型的变量rw的数据结构\n如何获得itab 运行阶段可通过runtime.getitab函数来获得相应的itab，该函数被定义在runtime包中的iface.go文件中\n1 func getitab(inter *interfacetype, typ *_type, canfail bool) *itab 前两个参数inter和typ分别是接口类型和具体类型的元数据，canfail表示是否允许失败。如果typ没有实现inter要求的所有方法，则canfail为true时函 数返回nil，canfail为false时就会造成panic。对应到具体的语法就是comma ok风格的类型断言和普通的类型断言\n1 2 r, ok := a.(io.Reader) // comma ok r := a.(io.Reader) //有可能造成panic getitab()函数的代码摘抄自Go语言runtime源码\n函数的主要逻辑如下：\n①校验inter的方法列表长度不为0，为没有方法的接口生成itab是没有意义的。 ②通过typ.tflag标志位来校验typ为自定义类型，因为只有自定义类型才能有方法集。 ③在不加锁的前提下，以inter和typ作为key查找itab缓存itabTable，找到后就跳转到⑤。 ④加锁后再次查找缓存，如果没有就通过persistentalloc()函数进行持久化分配，然后初始化itab并调用itabAdd添加到缓存中，最后解锁。 ⑤通过itab的fun[0]是否为0来判断typ是否实现了inter接口，如果没实现，则根据canfail决定是否造成panic，若实现了，则返回itab地址。 判断itab.fun[0]是否为零，也就是判断第一个方法的地址是否有效，因为Go语言会把无效的itab也缓存起来，主要是为了避免缓存穿透。缓存中查不到对应 的itab，就会每次都查询元数据的方法列表，从而显著影响性能，所以Go语言会把有效、无效的itab都缓存起来，通过fun[0]加以区分。\nfun[0] 相当于标记.\n图5-14 interfacetype和_type与itab的对应关系\nitab缓存 itabTable就是runtime中itab的全局缓存，它本身是个itabTableType类型的指针\nentries是实际的缓存空间 size字段表示缓存的容量，也就是entries数组的大小 count表示实际已经缓存了多少个itab。 entries的初始大小是通过itabInitSize指定的，这个常量的值为512。当缓存存满以后，runtime会重新分配整个struct，entries数组是 itabTableType的最后一个字段，可以无限增大它的下标来使用超出容量大小的内存，只要在struct之后分配足够的空间就够了，这也是C语言里常用的手法。\nitabTableType被实现成一个散列表。查找和插入操作使用的key是由接口类型元数据与动态类型元数据组合而成的，哈希值计算方式为接口类型元数据哈希值 inter.typ.hash与动态类型元数据哈希值typ.hash进行异或运算。\n图5-15 itabTableType哈希表\n方法find()和add()分别负责实现itabTableType的查找和插入操作，方法add()操作内部不会扩容存储空间，重新分配操作是在外层实现的，因此 对于find()方法而言，已经插入的内容不会再被修改，所以查找时不需要加锁。方法add()操作需要在加锁的前提下进行，getitab()函数是通过调用 itabAdd()函数来完成添加缓存的，itabAdd()函数内部会按需对缓存进行扩容，然后调用add()方法。因为缓存扩容需要重新分配itabTableType结构，为 了并发安全，使用原子操作更新itabTable指针。加锁后立刻再次查询也是出于并发的考虑，避免其他协程已经将同样的itab添加至缓存。\n通过persistentalloc()函数分配的内存不会被回收\nitab类型的init方法\ninit()函数内部就是遍历接口的方法列表和具体类型的方法集，来寻找匹配的方法的地址。 虽然遍历操作使用了两层嵌套循环，但是方法列表和方法集都是有序的，两层循环实际上都只需执行一次。 匹配方法时还会考虑方法是否导出，以及接口和具体类型所在的包。如果是导出的方法则直接匹配成功，如果方法未导出，则接口和具体类型需要定义在同一 个包中，方可匹配成功。 最后需要再次强调的是，对于匹配成功的方法，地址取的是method结构中的ifn字段 5.2.3 接收者类型 具体类型方法元数据中的ifn字段，该字段存储的是专门供接口使用的方法地址。所谓专门供接口使用的方法，实际上就是个接收者类型为指针的方法。\n还记不记得第4章中分析OBJ文件时，发现编译器总是会为每个值接收者方法包装一个指针接收者方法？这也就说明，接口是不能直接使用值接收者方法的， 这是为什么呢？\n5.2.2节已经看过了接口的数据结构iface，它包含一个itab指针和一个data指针，data指针存储的就是数据的地址。对于接口来讲，在调用指针接收者方法 时，传递地址是非常方便的，也不用关心数据的具体类型，地址的大小总是一致的。假如通过接口调用值接收者方法，就需要通过接口中的data指针把数据的值 复制到栈上，由于编译阶段不能确定接口背后的具体类型，所以编译器不能生成相关的指令来完成复制，进而无法调用值接收者方法。\n如果基于reflectcall()函数，能不能实现通过接口调用值接收者方法呢？\n肯定是可以实现的，接口的itab中有具体类型的元数据，确实能够应用reflectcall()函数 但是有个明显的问题，那就是性能太差。跟几条用于传参的MOV指令加一条普通的CALL指令相比，reflectcall()函数的开销太大了，所以Go语言选择为值 接收者方法生成包装方法。 对于代码中的值接收者方法，类型元数据method结构中的ifn和tfn的值是不一样的，指针接收者方法的ifn和tfn是一样的。 从类型元数据来看，T和∗T是不同的两种类型。\n接收者类型为T的所有方法，属于T的方法集。 因为编译器自动包装指针接收者方法的关系，∗T的方法集包含所有方法，也就是所有接收者类型为T的方法加上所有接收者类型为∗T的方法。 第1行输出打印出了Integer类型的方法集，String()和Value()这两个方法各自的IFn和TFn都不相等，这是因为IFn指向接收者为指针类型的方法代码， 而TFn指向接收者为值类型的方法代码。 第2行输出打印出了∗Integer类型的方法集，这两个方法各自的IFn和TFn是相等的，都与第1条指令中同名方法的IFn的值相等。 第3行输出打印出了Number接口itab中fun数组中的两个方法地址，与第1行输出Integer方法集中对应方法的IFn的值一致。 图5-16 Integer和∗Integer类型的方法集\n5.2.4 组合式继承 从方法集的角度进行分析\n看一下B、C、∗B和∗C会继承哪些方法\n表5-2 示例程序中各自定义类型包含的方法的情况\nGo语言不允许为T和∗T定义同名方法，实际上并不是因为不支持函数重载，前面已经看到了A.Value()方法和(∗A).Value()方法是可以区分的。其根本原因就 是编译器要为值接收者方法生成指针接收者包装方法，要保证两者的逻辑一致，所以不允许用户同时实现，用户可能会实现成不同的逻辑。\n5.3 类型断言 5.3.1 E To具体类型 1 2 3 func normal(a interface{}) int { return a.(int) } 反编译\n等价的伪代码\ncomma ok风格的断言\n1 2 3 4 func commaOk(a interface{}) (n int, ok bool) { n, ok = a.(int) return } 反编译\n等价的伪代码\n从interface{}到具体类型的断言基本上就是一个指针比较操作加上一个具体类型相关的复制操作\n图5-17 从interface{}到具体类型的断言\n5.3.2 E To I 1 2 3 func normal(a interface{}) io.ReadWriter { return a.(io.ReadWriter) } 反编译\n伪代码\nruntime.assertE2I()函数代码\n函数先校验了E的具体类型元数据指针不可为空，没有具体类型的元数据是无法进行断言的 然后通过调用getitab()函数来得到对应的itab，data字段直接复制。 注意调用getitab()函数时最后一个参数为false，根据之前的源码分析已知这个参数是canfail。canfail为false时，如果t没有实现inter要求的所有 方法，getitab()函数就会造成panic。 comma ok风格的断言\n1 2 3 4 func commaOk(a interface{}) (i io.ReadWriter, ok bool) { i, ok = a.(io.ReadWriter) return } 反编译\n伪代码\nruntime.assertE2I2()函数代码\nE To I形式的类型断言，主要通过runtime中的assertE2I()和assertE2I2()这两个函数实现，底层的主要任务如图5-18所示，都是通过getitab()函数 完成的方法集遍历及itab分配和初始化。因为getitab()函数中用到了全局的itab缓存，所以性能方面应该也是很高效的。\n图5-18 从interface{}到非空接口的类型断言\n5.3.3 I To具体类型 1 2 3 func normal(i io.ReadWriter) *os.File { return i.(*os.File) } 反汇编\n伪代码\n其中的go.itab.∗os.File，io.ReadWriter指的就是全局itab缓存中与∗os.File和io.ReadWriter这一对类型对应的itab。这个itab是在编译阶段就 被编译器生成的，所以代码中可以直接链接到它的地址。 这个断言的核心逻辑就是比较iface中tab字段的地址是否与目标itab地址相等。如果不相等就调用panicdottypeI，如果相等就把iface的data字段返回。 注意这里因为∗os.File是指针类型，所以不涉及自动拆箱，也就没有与具体类型相关的复制操作，如果具体类型为值类型就不然了。 comma ok风格的断言\n1 2 3 4 func commaOk(i io.ReadWriter) (f *os.File, ok bool) { f, ok = i.(*os.File) return } 反编译\n伪代码\nI To具体类型的断言与E To具体类型的断言在实现上极其相似，核心逻辑如图5-19所示，都是一个指针的相等判断。\n图5-19 从非空接口到具体类型的类型断言\n5.3.4 I To I 1 2 3 func normal(rw io.ReadWriter) io.Reader { return rw.(io.ReadWriter) } 反编译\n伪代码\nruntime.assertI2I()函数代码\n先校验i.tab不为nil，否则就意味着没有类型元数据，类型断言也就无从谈起 然后检测i.tab.inter是否等于inter，相等就意味着源接口和目标接口类型相同，直接复制就可以了。 最后才调用getitab()函数，根据inter和i.tab._type获取对应的itab。canfail参数为false，所以如果getitab()函数失败就会造成panic。 comma ok风格的断言\n1 2 3 4 func commaOk(rw io.ReadWriter) (r io.Reader, ok bool) { r, ok = rw.(io.Reader) return } 反编译\n伪代码\nruntime.assertI2I2()函数代码\n如果i.tab为nil，则直接返回false。 只有在i.tab.inter与inter不相等时才调用getitab()函数，而且canfail为true，如果getitab()函数失败，则不会造成panic，而是返回nil。 I To I的类型断言，实际上是通过runtime.assertI2I()函数和runtime.assertI2I2()函数实现的，底层也都是基于getitab()函数实现的。\n图5-20 从非空接口到非空接口的类型断言\n5.4 反射 5.4.1 类型系统 1. 类型信息的萃取 TypeOf()函数所做的事情如图5-21所示，就是找到传入参数的类型元数据，并以reflect.Type形式返回。\n图5-21 由一个∗_type和一个∗itab组建一个iface\nTypeOf()函数的代码\nemptyInterface类型和5.1节介绍过的eface类型在内存布局上等价，emptyInterface类型定义\n其中的rtype类型与runtime._type类型在内存布局方面也是等价的，只不过因为无法使用其他包中未导出的类型定义，所以需要在reflect包中重新定义一下。 代码中的eface.typ实际上就是从interface{}变量中提取出的类型元数据地址\n先判断了一下传入的rtype指针是否为nil，如果不为nil就把它作为Type类型返回，否则返回nil。 从这里可以知道∗rtype类型肯定实现了Type接口，之所以要加上这个nil判断，需要考虑到Go的接口类型是个双指针结构，一个指向itab，另一个指向实际 的数据对象。只有在两个指针都为nil的时候，接口变量才等于nil。 图5-22 萃取前判断非空\n通过代码说明接口何时为空\n在上述代码中第1个if处判断结果为真，所以会打印出1。第2个if处rw不再为nil，所以不会打印2。\ninterface{}中的类型元数据地址是从哪里来的呢？\n当然是在编译阶段由编译器赋值的，实际的地址可能是由链接器填写的，也就是说源头还是要追溯到最初的源码中。 2.类型系统的初始化 5.5 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC5%E7%AB%A0-%E6%8E%A5%E5%8F%A3/","summary":"5.1 空接口 是指不包含任何方法的接口interface{} 5.1.1 一个更好的void∗ 如果用unsafe.Sizeof()函数获取一个interfac","title":"第5章 接口"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 第4章 code_4_1.go package gom type Point struct { x float64 } func (p Point) X() float64 { return p.x } func (p *Point) SetX(x float64) { p.x = x } 4.1 接收者类型 为了排除编译器内联优化造成的干扰，下面采用只编译不链接的方式来得到OBJ文件，然后对编译得到的OBJ文件进行反编译分析\n1 $ go tool compile -trimpath=\u0026#34;`pwd`=\u0026gt;\u0026#34; -l -p gom point.go 通过go tool nm可以查看该文件中实现了哪些函数，nm会输出OBJ文件中定义或使用到的符号信息\npoint.o中一共实现了3个方法\n第1个是Point的SetX()方法，它的接收者类型是∗Point 第3个是Point的X()方法，它的接收者类型是Point 第二个方法是一个接收者类型为∗Point的X()方法 4.1.1 值类型 反编译Point.X()\n第4行代码用SP作为基址并加上8字节偏移，把该地址处的一个float64复制到X0寄存器中。 第5行代码用SP作为基址并加上16字节偏移，把X0中的float64复制到该地址处。 第6行代码就是普通的返回指令。 图4-1 调用Point.X()方法后的栈帧布局\n值类型的接收者实际上是作为第1个参数通过栈来传递的，与普通的函数调用并没有什么不同。\nGo语言允许通过方法的完全限定名称(Full Qualified Name)把方法当成一个普通函数那样调用，只不过需要把接收者作为第1个参数显式地传递\n1 2 p := Point{x: 10} Point.X(p) 可以认为p.X()这种写法只是编译器提供的语法糖，本质上会被转换为Point.X(p)这种普通的函数调用，而接收者就是隐含的第1个参数。\n4.1.2 指针类型 反编译SetX()\n第4行代码用SP作为基址加上16字节偏移，把该地址处的一个float64复制到X0寄存器中。 第5行代码用SP作为基址加上8字节偏移，把该地址处的一个64位数值复制到AX寄存器中。 第6行代码用AX作为基址，把X0寄存器中的float64复制到该地址处。 第8行是返回指令 图4-2 调用Point.SetX()方法后的栈帧布局\n跟值类型接收者类似，指针类型的接收者也是作为第1个参数来传递的，只不过传递的是一个地址。\n可以通过完全限定名称把指针接收者方法作为一个普通函数那样调用\n1 2 p := \u0026amp;Point{} (*Point).SetX(p, 10) 4.1.3 包装方法 查看自动生成的(*Point).X方法的汇编\n有autogenerated字样\n汇编(*Point).X的伪代码\n第1个if语句块通过比较栈指针SP和gp.stackguard0来判断是否需要栈增长。 第2个if用于检测是否正处于panic流程中，这种情况下当前方法应该是被某个defer直接或间接地调用了，要按需修改gp._panic.argp的值，因为当前方 法是编译器自动包装的，通过修改argp来跳过包装方法的栈帧，使后面调用的原始方法中的recover能够生效。 第3个if用于检测p是否为nil，因为包装方法需要根据p的地址得到∗p的值，如果地址为nil就调用runtime.panicwrap。 最后一步才是调用原始的Point.X()方法并传递∗p的值作为参数。 编译器会为代码中定义的值接收者方法生成指针接收者的包装方法，这在语义上是可行的，但反过来却不可以，因为通过传递的值是无法得到原始变量的地址的。\n看一下实际调用的是不是包装方法, 先添加一个函数\n1 2 3 func PointX(p *Point) float64 { return p.X() } 反编译\n可以看到p.X()实际上会在调用端对指针解引用，然后调用值接收者方法，并没有调用编译器生成的包装方法。\n栈分析\n28 return value of PointX (float64) 20 arg of PointX (address of p) 18 return address of PointX 10 bp -| 08 return value of X (float64) | stack of PointX 00 arg of X (p) -| 4.2 Method Value 把一个函数存储在一个变量中，这个变量就是一个Function Value。相应地，把一个方法存储在一个变量中，这个变量就是个Method Value。\n4.2.1 基于类型 1 x := Point.X 方法其实就是个普通的函数，接收者是隐含的第1个参数，所以这里可以推断，基于类型的Method Value就是个普通的Function Value，本质上是个两级指 针，而且第二级的指针是在编译阶段静态分配的。\n1 2 3 func GetX() func(Point) float64 { return Point.X } 上述代码可以成功编译，说明Point.X()函数可以被赋值给func(Point)float64类型的Function Value。接下来反编译GetX()函数\n第4行代码用IP作为基址加上一个偏移0来得到一个地址，这个0只作为预留的一个32位整数，等到链接阶段，链接器会填写上实际的偏移值。第4行代码得到的 地址被用作返回值，也就是最终的Function Value，而该地址处就是第二级指针\n4.2.2 基于对象 可以把一个对象的某个方法赋值给一个变量，这样就会得到一个基于对象的Method Value\n1 2 p := Point{x: 10} x := p.X 从语义角度来看，与基于类型的Method Value不同，基于对象的Method Value隐式地包含了对象的数据，所以在上述代码中调用x时不需要再显式地传递接 收者参数。第3章中已经了解了闭包的实现原理，所以这里推断x是个指向闭包对象的指针，通过闭包的捕获列表捕获了对象p。\n示例函数\n1 2 3 func X(p Point) func() float64 { return p.X } 反编译\n伪代码\n编译器为返回值自动定义了一个struct，第1个成员是一个函数指针，第2个成员是一个Point对象。对应到闭包对象的结构，捕获列表中是Point类型的对象， 闭包函数是gom.Point.X-fm()函数，也是由编译器自动生成的。反编译这个闭包函数\n伪代码\n主要逻辑就是通过DX寄存器得到闭包对象的地址，再以捕获列表里的Point对象的值作为参数调用Point.X()方法，并把Point.X()方法的返回值作为自己的 返回值。\n进一步探索会发现，闭包是捕获对象的值还是捕获地址，跟Method Value对应的方法接收者类型一致。上述示例中Point.X()方法的接收者为值类型，所以闭 包捕获的也是值类型，如果换成接收者为指针类型的∗Point.SetX()方法，闭包捕获列表中就会相应地变成指针类型。\n至此可以进行一下总结，基于类型的Method Value和基于对象的Method Value本质上都是Function Value，只不过前者是简单的两级指针，而后者通常是 个闭包（考虑编译器优化）。\n4.3 组合式继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 第4章 code_4_2.go package gom type Point2dV struct { Point y float64 } func (p Point2d) Y() float64 { return p.y } func (p *Point2d) SetY(y float64) { p.y = y } 4.3.1 嵌入值 图4-3 Point2d内存布局示意图\n再次用nm命令查看一下OBJ文件中为Point2d类型实现了哪些函数和方法\n最后一个函数是由编译器自动生成的，用于判断两个Point2d对象是否相等\n反编译Point2d.X()后的伪代码\n以p.Point为参数来调用Point.X()方法的代码，也就说明这是个包装方法，因此可以推测，编译器对于继承来的方法都是通过生成相应的包装方法来调用原始 方法的方式实现的。\n反编译(∗Point2d).SetX()\n第1条指令把接收者的值复制到AX寄存器中。 第2条指令尝试访问AX存储的地址处的数据，如果接收者为空指针就会触发空指针异常。 第3条指令把AX的值复制到栈上接收者参数的位置，这一行其实可以优化掉。 第4条指令用于跳转到(∗Point).SetX()方法的起始地址。 反编译一下(∗Point2d).X()方法，对照汇编整理出的伪代码如下：\n可以看到除了接收者为指针类型外，代码逻辑与Point2d.X()方法基本一致\n4.3.2 嵌入指针 1 2 3 4 5 6 7 // 第4章 code_4_3.go package gom type Point2dP struct { *Point y float64 } 图4-4 Point2d与Point的内存布局关系\n再用nm命令查看一下OBJ文件中为Point2d类型实现了哪些函数和方法\n这里值得注意的是Point2d.SetX()方法，它的存在意味着虽然接收者Point2d是通过值的形式传递的，但是通过Point2d的值可以得到原始Point对象的地址， 所以依然可以对原始Point对象进行修改。\n看一下在嵌入指针的情况下(∗Point2d).SetX()方法还会不会被优化处理\n编译器还进行了优化处理，第1行指令把栈上的接收者参数复制到AX寄存器中，其实也就是Point2d对象的地址。 第2行指令把Point2d的第1个字段的值复制到AX寄存器中，也就是Point对象的地址。 第3行指令把AX的值复制回栈上的接收者参数处。 第4行指令用于跳转到(∗Point).SetX()方法的起始地址。 至于其他3种方法，编译器都会生成相应的包装方法, 伪代码\n因为在嵌入指针的情况下总是能够得到基类对象的地址，所以子类中的值接收者方法可以调用基类中的指针接收者方法，编译器会尽可能把符合逻辑的包装方法 都生成出来。\n4.3.3 多重继承 首先定义两种类型A和B\n定义一种类型C，将A和B以值的形式嵌入\n通过nm命令查看编译生成的OBJ文件中都实现了哪些方法\n发现只有A和B的方法，编译器没有为C生成任何方法。结合Go语言官方文档的说明，因为同时嵌入A和B而且嵌套的层次相同，所以编译器不知道应该让包装方法 继承自谁，这种情况只能由程序员手工实现。\n定义一种类型D，把A以嵌入值的形式嵌入D中，然后把C中的A改成D\n再次通过nm命令查看\n这次类型C成功地继承了这一组方法，对这些方法进行反编译就能确定是继承自类型B，因为B的嵌套层次比A要浅，编译器优先选择短路径。\n4.4 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC4%E7%AB%A0-%E6%96%B9%E6%B3%95/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 第4章 code_4_1.go package gom type Point struct { x float64 } func (p Point) X() float64 { return p.x } func (p *Point) SetX(x float64) { p.x = x } 4.1 接收者类型 为了排除编译器内联优化造成的干扰，","title":"第4章 方法"},{"content":"2.1 车身规格 Body Specification 车宽尺寸包括后视镜吗？\n现在，全世界各汽车厂商在汽车车身规格的标注方面基本上都统一了，尤其是车身总长、轴距、轮距、前悬和后悬等规格上都完全一样。但是，在车身总宽和总 高上稍有区别\n车身尺寸标注示意图\n什么是汽车的通过性？\n指汽车通过各种坏路和无路地带以及克服各种障碍的能力。汽车的外形尺寸甚至直接决定了汽车的通过性能，如最小离地间隙、接近角和离去角、纵向通过角等。\n最大爬坡度\n一种是百分比坡度，它是指坡道的垂直高度与坡道的水平距离之比值，如30%，即表示此坡度为每前进100米，坡度便升高30米； 另一种表述方法是坡道的倾角度。 2.2 车身构造 Body Structure 为什么车身要由面板和骨架组成？\n车身面板只是汽车的“皮肤”，其实它的厚薄甚至强度如何，对汽车的安全性没有太大影响。 骨架的形状，基本决定了车身的造型。为了使车身更加安全，分散来自各方向的撞击力，现在的汽车厂商在设计汽车时往往都要把车身做成像一个鸟笼子那样， 也称为“网状交叉式设计”。 奥迪R8车身构造\n大众高尔夫汽车鸟笼车身骨架图\n什么是承载式车身和非承载式车身？\n承载式车身的汽车没有刚性车架，发动机、前后悬架、传动系统的一部分总成部件都装配在车身上，车身负载通过悬架装置传给车轮。\n承载式车身的优点是：公路行驶非常平稳，整个车身为一体，固有频率振动低，噪声小，重量轻，比较省油。 缺点：底盘强度远不如有大梁结构的非承载式车身；当四个车轮受力不均匀时，车身易发生变形。 承载式车身示意图\n非承载式车身的汽车有一刚性车架，又称底盘大梁，发动机、传动系统、车身等总成部件都固定在车架上，车架通过前后悬架与车轮连接。\n非承载式车身的优点是：底盘强度较高，抗颠簸性能好；四个车轮受力即使再不均匀，也是由车架承担，而不会传递到车身上去，因此车身不易扭曲变形。 缺点是：车身比较笨重。非承载式车身多用在货车、客车和越野车上，但也有部分高级轿车使用，这是因为非承载式车身具有较好的平稳性和安全性。 非承载式车身示意图\n为什么说车门防撞杠非常重要？\n当汽车受到侧面撞击时，可减轻车门的变形程度，从而起到对驾乘人员的保护作用。\n车门防撞杠示意图\n车身安全设计\n车身结构示意图\n奥迪TT车身结构\n什么是NVH特性？\nNVH是Noise（噪声）、Vibration（振动）和Harshness（声振粗糙度，通俗地称为不舒适性或不平顺性）的缩写。噪声是由振动引起的，通过振动波来传递， 因此噪声、振动和声振粗糙度三者在汽车等机械振动中是同时出现且密不可分的\n车辆在行驶时的振动源主要有三个：发动机、传动系统和不平的路面。 车辆在行驶时的噪声主要有四个：发动机产生的噪声、空气流过车身时的噪声、轮胎滚动和振动时的噪声，以及车身和底盘结构振动时产生的噪声。 汽车NVH设计示意图\n发动机噪声主要包括燃烧噪声、机械噪声和排气噪声。\n燃烧噪声是指气缸燃烧压力通过活塞、连杆、曲轴、缸体等途径向外辐射产生的噪声； 机械噪声是指活塞、齿轮、配气机构等运动件之间机械撞击产生的振动噪声； 排气噪声是指发动机排气产生的声音。一般情况下，低转速时燃烧噪声占主要地位，高转速时机械噪声占主要地位。 轮胎噪声主要来自泵气效应和轮胎振动。\n泵气效应是指轮胎高速滚动时引起轮胎变形，使得轮胎花纹与路面之间的空气受压挤，随着轮胎滚动，空气又在轮胎离开接触面时被释放，这样连续的“压挤 释放”，空气就迸发出噪声。 轮胎运行时的振动也会产生噪声，而且刚性越大或阻尼越小的轮胎，其振动噪声越大。 汽车上的空气噪声主要包括风阻噪声和风笛噪声。\n风阻噪声是指空气流过车身时与车身之间的摩擦声，而且风阻越大的汽车，其风阻噪声越大，因此现在轿车都要设计成流线形，以减少空气噪声； 风笛噪声是指空气进入或流出车身钣金缝隙时产生的噪声。车门、车窗等密封性越好的汽车，其风笛噪声越小。 车身和底盘结构噪声\n汽车在运动时，尤其是行驶在不平路面时，车身会产生一定的扭曲，此时车身钣金件在各种力的作用下就会产生一定的扭曲和振动，从而产生一定的噪声。 底盘中的部件，尤其是传动和悬架结构等运动部件，在运行时也会因转动、扭动或振动而产生一定的噪声，尤其是汽车行驶在不平路面或高速行驶时，底盘噪 声可能更大。这些噪声可能会通过底盘而传入车内。 2.3 车身材料 Body Material 什么是车身刚性？\n刚性是指物体受力后抗变形的能力。车身刚性则是指在施加不至毁坏车身的普通外力时车身不容易变形的能力。高刚性车身具有极高的抗扭曲和抗弯曲的能力， 反之亦然。当汽车行驶在凹凸不平的地面时，刚性差的汽车车身会发出“嘎吱嘎吱”的响声，因为这样的车身此时扭曲较严重，从而使一些装配部位产生摩擦。\n2018款奥迪A8车身结构\n在汽车高速转弯时，车身的刚性优劣也会暴露无遗。车身刚性好的车辆在过弯时，其行驶稳定性会比较好，反之亦然。\n为了保证车身具有较高的刚性，最可靠的手段就是采用高强度钢材来打造车身的关键部位，而在对刚性没有影响或影响较小的部位，则采用普通钢材或材质来制 作。\n奔驰CL双门轿车轻量化车身设计构造图\n怎样减轻车身重量？\n车身越重，其制动能力和操控能力可能受到的影响越大。 对车身轻量化起作用最大的还是广泛采用铝质材料。 保时捷车身用材料强度示意图\n奥迪TT铝质车身构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC2%E7%AB%A0-%E8%BD%A6%E8%BA%AB/","summary":"2.1 车身规格 Body Specification 车宽尺寸包括后视镜吗？ 现在，全世界各汽车厂商在汽车车身规格的标注方面基本上都统一了，尤其是车身总长、轴距、轮距、前悬和后悬等规","title":"第2章 车身 Body"},{"content":"4.1 品牌是一种什么样的资产 图4-1 时代集团控股的手袋及小皮具平均出厂价\n总之，奢侈品包的制造成本，与其定价相去甚远。\n奢侈品皮具代工行业相对分散，中国是全球最大的供应地\n图4-2 全球奢侈品皮具代工市场份额（以销售额计）\n奢侈品溢价的来源是设计吗，设计的重要性有多高？\n奢侈品包的高价并非来自物料成本：售价上万元的奢侈品包，平均出厂价仅约200元。 奢侈品包的高价并非来自特殊制造工艺：皮具的生产以代工为主，代工费用已计入出厂价；中国是全球的奢侈品皮具主要代工地。 奢侈品的高价并非来自设计：有一部分奢侈品包是由代工厂设计、品牌“贴牌”生产的，主流消费者显然无法轻易分辨奢侈品包的设计方（否则“贴牌”奢侈品的 相关信息早就传遍网络，而不会被深埋在招股说明书中）。 品牌溢价来自品牌认知，即品牌过去的所有动作给消费者留下的整体印象\n品牌本质上还是认知。认知一方面是动态反馈形成的，另一方面是要靠时间积淀的。 品牌认知的形成，是品牌的各种动作在不同环境下，不断和周围环境相互反馈，并形成动态认知的过程。 譬如，品牌标识、品牌设计特色、品牌销售渠道、品牌营销广告、品牌粉丝互动等，都属于品牌动作，并不断产生动态变化。而在这个动态变化的过程中，消 费者对品牌产生各种各样的印象，长时间积累下来形成的动态认知的集合，就是品牌认知，也是品牌溢价的来源。 品牌溢价=品牌认知=品牌所有的动作反馈在时间上的积分\n图4-3 “品牌计分板”理论下的品牌溢价公式\n“品牌计分板”具备三重含义：\n品牌认知并非由单一因素形成，而由各种因素综合构成。 品牌认知是有时间维度的，需要经过时间积淀。 在对的时候做对的事情，方能得分，切忌刻舟求剑。 4.2 我们为何会为品牌溢价买单 消费者为品牌商品额外支付的溢价，就是在购买品牌背后的信用契约。\n信用契约的作用可以从两个方面理解：降低搜索成本、赋予文化认同\n图4-4 品牌（信用契约）的作用\n文化认同常见于奢侈品，也是奢侈品溢价的主要来源。\n赋予文化价值和降低搜索成本这两种作用，大致对应了两种行为模式的消费者。前者我们称之为悦己型消费者，后者为省心型消费者\n图4-5 悦己型消费者和省心型消费者\n悦己型消费者和省心型消费者并不是完全割裂的，二者之间没有严格界限。\n所以消费升级并不意味着省心型品牌会被淘汰；同样，消费降级也不意味着悦己型品牌的消亡。消费升级的大趋势并不会使得高端品牌取代大众品牌，因为格调 需要通过对比来体现，所以只属于少部分人；反之，若经济持续低迷，高端品牌也不见得会全部消失，因为对于炫耀、身份展示和自我满足的追求，不见得会随 着经济低迷而退散。\n对于悦己型公司，我们更应关注其品牌形象的维持，以及定价能力的不断提升；对于省心型公司，我们更应关注其经营规模的增长，以及渠道覆盖范围的演进。\n4.3 品牌化或是未来中国消费品投资最重要的机会之一 品牌是消费品产业链中利润空间最大的一环\n图4-6 品牌、供应链、渠道的毛利率（2019年）\n图4-7 品牌、供应链、渠道的净利率（2019年）\n国牌崛起的必要条件：发达的消费品供应链，特殊的渠道环境\n我国拥有强大的供应链，能够产出物美价廉高质量的产品。国产品牌使用本土供应链，就能生产出品质不亚于（甚至超过）海外大牌的产品。 2010年全世界有42%的奢侈品手袋产自中国（以代工市场份额计） 大多数苹果数码产品也是由位于中国本土的代工厂组装生产的。 我国已经形成多个优质的产业链集群。 广东有服装、化妆品、3C电子的产业链集群； 浙江有箱包、小商品的产业链集群； 江苏有家纺等商品的产业链集群； 福建有服装、鞋的产业链集群。 在渠道方面，独特的电商和互联网文化造就了国产品牌成长的沃土。 中国整体社零电商渗透率已达20%以上，且仍在高速增长（而美国只有大约10%的电商渗透率）。 国牌崛起的核心逻辑首先是“国崛起”，其次才是“货崛起”\n表4-1 “70后”“80后”与“Z世代”的生长环境对比\n国产品牌崛起是我们研究消费行业时必须重点关注的一个行业趋势性投资机会。\n从何处找到这类正在崛起的国产品牌标的呢？\n第一，它们的产品在国内有成体系的供应链，大多数消费品都在此范围之内； 第二，这些品牌经营的品类适合线上渠道销售，或能够通过互联网营销实现快速传播，因为对线上渠道和互联网文化的理解，是国产品牌的核心领先之处。 4.4 结语 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC4%E7%AB%A0-%E5%93%81%E7%89%8C-%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A%E7%9A%84%E7%9A%87%E5%86%A0%E6%98%8E%E7%8F%A0/","summary":"4.1 品牌是一种什么样的资产 图4-1 时代集团控股的手袋及小皮具平均出厂价 总之，奢侈品包的制造成本，与其定价相去甚远。 奢侈品皮具代工行业相对分散，","title":"第4章 品牌 消费行业的皇冠明珠"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/cninfo/","summary":"主页","title":"巨潮资讯"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/stats/","summary":"主页","title":"国家统计局"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/zhangdetalk/%E8%B6%85%E5%85%A8%E9%9D%A2-mysql%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/","summary":"原文","title":"超全面 MySQL语句加锁分析"},{"content":"图3-1 函数调用发生前\nCALL指令会先把下一条指令的地址(返回地址)压入栈中, IP寄存器存储f1的地址 图3-2 CALL指令执行后\n执行f1() f1()最后有条RET指令, 弹出栈顶的返回地址(应该弹到IP中), 跳到返回地址处继续执行 图3-3 RET指令执行后\n3.1 栈帧 3.1.1 栈帧布局 函数栈帧是由编译器管理的。\n图3-4 Go语言函数栈帧布局示意图\n猜测代码逻辑在其他地方, 这里只保存函数状态.\nreturn address：函数返回地址，占用一个指针大小的空间。实际上是在函数被调用时由CALL指令自动压栈的，并非由被调用函数分配。 caller’s BP：调用者的栈帧基址，占用一个指针大小的空间。用来将调用路径上所有的栈帧连成一个链表，方便栈回溯之类的操作， 只在部分平台架构上存在。函数通过将栈指针SP直接向下移动指定大小，一次性分配caller’s BP、locals和args to callee所占用的空间， 在x86架构上就是使用SUB指令将SP减去指定大小的。 locals：局部变量区间，占用若干机器字。用来存放函数的局部变量，根据函数的局部变量占用空间大小来分配，没有局部变量的函数不分配。 args to callee：调用传参区域，占用若干机器字。这一区域所占空间大小，会按照当前函数调用的所有函数中返回值加上参数所占用的最大空 间来分配。当没有调用任何函数时，不需要分配该区间。callee视角的args from caller区间包含在caller视角的args to callee区间内，占用空间 大小是小于或等于的关系。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 第3章 code_3_1.go package main func main() { var v1, v2 int v3, v4 := f1(v1, v2) println(\u0026amp;v1, \u0026amp;v2, \u0026amp;v3, \u0026amp;v4) f2(v3) } //go:noinline func f1(a1, a2 int) (r1, r2 int) { var l1, l2 int println(\u0026amp;r2, \u0026amp;r1, \u0026amp;a2, \u0026amp;a1, \u0026amp;l1, \u0026amp;l2) return } //go:noinline func f2(a1 int) { println(\u0026amp;a1) } 实际上，代码中的println()函数会被编译器转换为多次调用runtime包中的printlock()、printunlock()、printpointer()、printsp()、 printnl()等函数。前两个函数用来进行并发同步，后3个函数用来打印指针、空格和换行。这5个函数均无返回值， 只有printpointer()函数有一个参数，会在调用者的args to callee区间占用一个机器字。\n输出结果\n表3-1 3个函数栈帧上各区间的大小\n(1+4+4)*8 = 72B = 0x48B 依次类推 图3-5 main调用f1()函数和f2()函数的栈帧布局图\n调用f2()函数时的栈，在a1和v4之间空了3个机器字。这是因为Go语言的函数是固定栈帧大小的，args to callee是按照所需的最大空间来分配的。\n3.1.2 寻址方式 图3-6 SUB指令分配整个栈帧\n如果把图3-6中整个函数栈帧视为一个struct，SP存储着这个struct的起始地址，然后就可以通过基址＋位移的方式来寻址struct的各个字段，也就是栈帧上 的局部变量、参数和返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 第3章 code_3_3.go package main func main() { fa(0) } //go:noinline func fa(n int) (r int) { r = fb(n) return } //go:noinline func fb(n int) int { return n } 图3-7 函数fa的栈帧布局\n4～7行和最后两行汇编代码主要用来检测和执行动态栈增长 倒数第4行的RET指令用于在函数执行完成后跳转回返回地址。 第8行的SUBQ指令向下移动栈指针SP，完成当前函数栈帧的分配。倒数第5行的ADDQ指令在函数返回前向上移动栈指针SP，释放当前函数的栈帧。释放与分 配时的大小一致，均为0x18，即24字节，其中BP of main占用了8字节，args to fb占用了16字节。 第9行代码把BP寄存器的值存到栈帧上的BP of main中，第10行把当前栈帧上BP of main的地址存入BP寄存器中。倒数第6行指令在当前栈帧释放前用 BP of main的值还原BP寄存器。 第12行和第13行代码，通过AX寄存器中转，把参数n的值从args to fa区间复制到args to fb区间，也就是在fa中把main()函数传递过来的参数n，复 制到调用fb()函数的参数区间。 第14行代码通过CALL指令调用fb()函数。 Go语言中函数的返回值可以是匿名的，也可以是命名的。对于匿名返回值而言，只能通过return语句为返回值赋值。对于命名返回值，可以在代码中通过其名称 直接操作，与参数和局部变量类似。无论返回值命名与否，都不会影响函数的栈帧布局。\n3.1.3 又见内存对齐 Go语言函数栈帧中返回值和参数的对齐方式与struct类似，对于有返回值和参数的函数，可以把所有返回值和所有参数等价成两个struct，一个返回值 struct和一个参数struct。因为内存对齐方式更加紧凑，所以在支持大量参数和返回值时能够做到较高的栈空间利用率。\n验证函数参数和返回值的对齐方式与struct成员的对齐方式是一致的\n栈帧上的参数和返回值到底是分开后作为两个struct，还是按照一个struct来对齐的？\n1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_5.go package main //go:noinline func f1(a int8) (b int8) { println(\u0026amp;b, \u0026amp;a) return } func main() { f1(0) } f1()函数有一个返回值和一个参数，而且都是int8类型，如果返回值和参数作为同一个struct进行内存对齐，则a和b应该是紧邻的，中间不会插入padding。 可以看到参数a和返回值b并没有紧邻，而是分别按照8字节的边界进行对齐的，也就说明返回值和参数是分别对齐的，不是合并在一起作为单个struct。 局部变量的对齐\n1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_6.go package main //go:inline func fn() { var a int8 var b int64 var c int32 var d int16 var e int8 println(\u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d, \u0026amp;e) } 1 2 3 4 5 6 7 struct { e int8 a int8 d int16 c int32 b int64 } 局部变量的顺序被重排的, 布局更紧凑\n为什么编译器会对栈帧上局部变量的顺序进行调整以优化内存利用率，但是并不会调整参数和返回值呢？\n因为函数本身就是对代码单元的封装，参数和返回值属于对外暴露的接口，编译器必须按照函数原型来呈现 局部变量属于封装在内部的数据，不会对外暴露，所以编译器按需调整局部变量布局不会对函数以外造成影响。 3.1.4 调用约定 对Go语言普通函数的调用约定进行如下总结：\n返回值和参数都通过栈传递，对应的栈空间由调用者负责分配和释放。 返回值和参数在栈上的布局等价于两个struct，struct的起始地址按照平台机器字长对齐。 验证编译器能够参照函数声明来生成传参相关指令\n1 2 3 4 5 6 7 8 9 10 11 // 第3章 code_3_7.go package main import _ \u0026#34;unsafe\u0026#34; func main() { Add(1, 2) } // 只有声明 func Add(a, b int) 编译\n反编译\n与Add()函数调用相关的几行汇编代码\n可以看到两条MOVQ指令分别复制了参数1和2，证明编译阶段参照函数声明生成了正确的传参指令，也就是调用约定在发挥作用。 CALL指令处，十六进制编码e800000000预留了32位的偏移量空间，在链接阶段会被链接器填写为实际的偏移值。 3.1.5 Go 1.17的变化 1.16版及以前的版本中都是通过栈来传递参数的，这样实现简单且能支持海量的参数传递，缺点就是与寄存器传参相比性能方面会差一些。 在1.17版本中就实现了基于寄存器的参数传递，当然只是在部分硬件架构上实现了。 结合Go自带的反编译工具，在汇编代码层面看一下1.17版本的函数调用是如何通过寄存器传递参数的。\n1. 函数入参的传递方式\n第1～9个参数是依次用AX、BX、CX、DI、SI、R8、R9、R10和R11这9个通用寄存器来传递的 从第10个参数开始使用栈来传递 (注意MOVW $0xb0a, 0(SP)直接复制了两个数字10, 11) 图3-8 Go 1.17中in12()函数入参的传递方式\n2. 函数返回值的传递方式\n反编译out12()函数\n3.2 逃逸分析 3.2.1 什么是逃逸分析 1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_10.go package main func main() { println(*newInt()) } //go:noinline func newInt() *int { var a int return \u0026amp;a } 如果局部变量a仍分配在栈中, 那么返回的地址会变成一个悬挂指针\n反编译newInt()函数\n重点关注上述汇编代码中runtime.newobject()函数调用，该函数是Go语言内置函数new()的具体实现，用来在运行阶段分配单个对象。 CALL指令之后的两条MOVQ指令通过AX寄存器中转，把runtime.newobject()函数的返回值复制给了newInt()函数的返回值，这个返回值就是动态分配的 int型变量的地址。 3.2.2 不逃逸分析 验证new()函数与堆分配是否有必然关系\n1 2 3 4 5 6 // 第3章 code_3_11.go //go:noinline func New() int { p := new(int) return *p } 反编译New()函数\nMOVQ指令直接把返回值赋值为0，其他的逻辑全都被优化掉了，所以即便是代码中使用了new()函数，只要变量的生命周期没有超过当前函数栈帧的生命周期， 编译器就不会进行堆分配。\n3.2.3 不逃逸判断 如果把局部变量的地址赋值给包级别的指针变量，应该也会造成变量逃逸\n1 2 3 4 5 6 7 8 // 第3章 code_3_12.go var pt *int //go:noinline func setNew() { var a int pt = \u0026amp;a } 反编译setNew()函数\n验证逃逸分析的依赖传递性\n1 2 3 4 5 6 7 8 9 var pp **int //go:noinline func dep() { var a int var p *int p = \u0026amp;a pp = \u0026amp;p } 反编译dep()函数\n跨包测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 第3章 code_3_14.go package inner //go:noinline func RetAry(p *int) *int { return p } // 第3章 code_3_15.go package main //go:noinline func arg() int { var a int return *inner.RetAry(\u0026amp;a) } 反编译\n阻止编译器参考函数实现的测试\n反编译arg()函数\n变量a依旧是栈分配，变量b已经逃逸了。 在上述代码中的retArg()函数只是个函数声明，没有给出具体实现，通过linkname机制让链接器在链接阶段链接到inner.RetArg()函数。 retArg()函数只有声明没有实现，而且编译器不会跟踪linkname，所以无法根据代码逻辑判定变量b到底有没有逃逸。 3.3 Function Value 3.3.1 函数指针 函数指针存储的也是地址, 该地址指向代码段中某个函数的第一条指令\n3.3.2 Function Value分析 1 2 3 4 5 6 7 8 9 10 11 // 第3章 code_3_18.go package main func main() { println(helper(nil, 0, 0)) } //go:noinline func helper(fn func(int, int) int, a, b int) int { return fn(a, b) } 反编译\n4～7行和最后两行用于栈增长，暂不需要关心。 第8～10行分配栈帧并赋值caller’s BP，RET之前的两行还原BP寄存器并释放栈帧。 CALL后面的两行用来复制返回值。 CALL连同之前的6条MOVQ指令，实现了Function Value的传参和过程调用。 MOVQ 0x30(SP)，AX和MOVQ AX，0(SP)用于把helper()函数的第2个参数a的值复制给fn()函数的第1个参数。 MOVQ 0x38(SP)，AX和MOVQ AX，0x8(SP)同理，把helper()函数第3个参数b的值复制给fn()函数的第2个参数。 MOVQ 0x28(SP)，DX把helper()函数第1个参数fn的值复制到DX寄存器，MOVQ 0(DX)，AX把DX用作基址，加上位移0，也就是从DX存储的地址处读 取出一个64位的值，存入了AX寄存器中。 CALL AX说明，上一步中AX寄存器最终存储的是实际函数的地址。 栈分析\n40(SP) return value -| 38(SP) b | stack of main 30(SP) a | 28(SP) fn -| 20(SP) return addr 18(SP) bp -| 10(SP) return value | stack of helper 8(SP) b | 0(SP) a -| 3.3.3 闭包 1 2 3 4 5 6 // 第3章 code_3_19.go func mc(n int) func() int { return func() int { return n } } 闭包的状态保存在哪里呢？\n闭包对象 反编译\n栈分析\n... | 28(SP) main arg (mc-func()int) | stack of main 20(SP) main arg (mc-n) -| 18(SP) return address of mc 10(SP) bp -| 8(SP) newobject ret | stack of mc 0(SP) newobject arg -| 推测newobject所创建的对象的结构\n1 2 3 4 5 6 7 // 闭包对象 struct { // 闭包函数 F uintptr // 捕获列表 n int } 看到闭包 newobject的原型\n1 func newobject(typ *_type) unsafe.Pointer 使用自定义的newobject实现来查看_type的布局\n运行结果\n因为start++导致start变量逃逸, 所以调用了两次newobject\nint struct { F uintptr; start *int } 图3-12 Function Value和闭包对象\n调用闭包 闭包函数在被调用的时候，必须得到当前闭包对象的地址才能访问其中的捕获列表，这个地址是如何传递的呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 第3章 code_3_22.go package main func main() { a := mc(2) a() } func mc(n int) func() int { return func() int { return n } } 反编译\n将DX寄存器用作基址，再加上位移8，把该地址处的值复制到AX寄存器中。 把AX寄存器的值复制给闭包函数的返回值。 闭包函数返回。 书中说把AX的值给闭包函数的返回值, 不太理解为啥0x8(SP)是返回值地址.\n闭包与变量逃逸 1 2 3 4 5 6 7 // 第3章 code_3_23.go func sc(n int) int { f := func() int { return n } return f() } 禁用内联优化\n1 $ go build -gcflags=\u0026#39;-l\u0026#39; 反编译\nreturn f()之前的6行汇编代码\nXORPS和MOVUPS这两行利用128位的寄存器X0，把栈帧上从位移8字节开始的16字节清零，这段区间就是sc()函数的局部变量区，正好符合捕获了一个int变 量的闭包对象大小。 LEAQ和MOVQ把闭包函数的地址复制到栈帧上位移8字节处，正是闭包对象中的函数指针。 接下来的两个MOVQ把sc()函数的参数n的值复制到栈帧上位移16字节处，也就是闭包捕获列表中的int变量。 图3-13 sc()函数中构造的闭包对象f\nreturn之后的5行汇编代码\nMOVQ把闭包函数的地址复制到AX寄存器中，LEAQ把闭包对象的地址存储到DX寄存器中。 CALL指令调用闭包函数，接下来的两条MOVQ把闭包函数的返回值复制到sc()函数的返回值。 图3-14 调用闭包函数f()\n闭包对象的捕获列表，捕获的是变量的值还是地址？\n只有在变量的值不会再改变的前提下，才可以复制变量的值，否则就会出现不一致错误。 示例, 需要禁用内联优化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 第3章 code_3_24.go // 捕获地址 func sc(n int) int { f := func() int { n++ return n } return f() } // 第3章 code_3_25.go // 捕获值 func sc(n int) int { n++ f := func() int { return n } return f() } // 第3章 code_3_26.go // 捕获地址 func sc(n int) int { f := func() int { return n } n++ return f() } 3.4 defer 3.4.1 最初的链表 使用go1.12\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 第3章 code_3_28.go package main func main() { println(df(10)) } func df(n int) int { defer func(i *int) { *i *= 2 }(\u0026amp;n) return n } 反编译df()\ndeferproc Go语言中，每个goroutine都有自己的一个defer链表，而runtime.deferproc()函数做的事情就是把defer函数及其参数添加到链表中。 编译器还会在当前函数结尾处插入调用runtime.deferreturn()函数的代码，该函数会按照FILO的顺序调用当前函数注册的所有defer函数。 如果当前goroutine发生了panic（宕机），或者调用了runtime.Goexit()函数，runtime的panic处理逻辑会按照FILO的顺序遍历当前goroutine的整 个defer链表，并逐一调用defer函数，直到某个defer函数执行了recover，或者所有defer函数执行完毕后程序结束运行。 runtime.deferproc()函数原型\n1 func deferproc(size int32, fun *funcval) Go语言用两级指针结构统一了函数指针和闭包，这个funcval结构就是用来支持两级指针的。 funcval结构中只定义了uintptr 图3-15 funcval对Function Value两级指针的支持\n参数siz表示defer函数的参数占用空间的大小，这部分参数也是通过栈传递的，虽然没有出现在deferproc()函数的参数列表里，但实际上会被编译器追加 到fn的后面 注意defer函数的参数在栈上的fn后面，而不是在funcval结构的后面。这点不符合正常的Go语言函数调用约定，属于编译器的特殊处理。 图3-16 df()函数调用deferproc时的栈帧\n基于第3章/code_3_28.go反编译得到的汇编代码，整理出等价的伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func df(n int) (v int) { r := runtime.deferproc(8, df.func1, \u0026amp;n) if r \u0026gt; 0 { goto ret } v = n runtime.deferreturn() return ret: runtime.deferreturn() return } func df.func1(i *int) { *i *= 2 } deferproc()函数的返回值为0或非0时代表不同的含义\n0代表正常流程，也就是已经把需要延迟执行的函数注册到了链表中，这种情况下程序可正常执行后续逻辑。 返回值为1则表示发生了panic，并且当前defer函数执行了recover，这种情况会跳过当前函数后续的代码，直接执行返回逻辑。 deferproc()函数的具体实现, 摘抄自runtime包的panic.go\n通过getcallersp()函数获取调用者的SP，也就是调用deferproc()函数之前SP寄存器的值。这个值有两个用途\n一是在deferreturn()函数执行defer函数时用来判断该defer是不是被当前函数注册的 二是在执行recover的时候用来还原栈指针。 基于unsafe指针运算得到编译器追加在fn之后的参数列表的起始地址，存储在argp中。\n通过getcallerpc()函数获取调用者指令指针的位置，在amd64上实际就是deferproc()函数的返回地址，从调用者df()函数的视角来看就是CALL runtime.deferproc后面的那条指令的地址。这个地址主要用来在执行recover的时候还原指令指针。\n调用newdefer()函数分配一个runtime._defer结构，newdefer()函数内部使用了两级缓冲池来避免频繁的堆分配，并且会自动把新分配的_defer结构添加 到链表的头部。\nruntime._defer的定义\nsiz表示defer参数占用的空间大小，与deferproc()函数的第1个参数一样。 started表示有个panic或者runtime.Goexit()函数已经开始执行该defer函数。 _panic的值是在当前goroutine发生panic后，runtime在执行defer函数时，将该指针指向当前的_panic结构。 link指针用来指向下一个_defer结构，从而形成链表。 _defer中没有发现用来存储defer函数参数的空间，参数应该被存储到哪里？\n实际上runtime.newdefer()函数用了和编译器一样的手段，在分配_defer结构的时候，后面额外追加了siz大小的空间，如图3-17所示，所以deferproc() 函数接下来会将fn、callerpc、sp都复制到_defer结构中相应的字段，然后根据siz大小来复制参数，最后通过return0()函数来把返回值0写入AX寄存器中。\n图3-17 deferproc执行中为_defer赋值\n通过deferproc()函数注册完一个defer函数后，deferproc()函数的返回值是0。后面如果发生了panic，又通过该defer函数成功recover，那么指令指针 和栈指针就会恢复到这里设置的pc、sp处，看起来就像刚从runtime.deferproc()函数返回，只不过返回值为1，编译器插入的if语句继而会跳过函数体，仅 执行末尾的deferreturn()函数。\ndeferreturn 在正常情况下，注册过的defer函数是由runtime.deferreturn()函数负责执行的，正常情况指的就是没有panic或runtime.Goexit()函数，即当前函数完 成执行并正常返回时。\ndeferreturn()函数的代码如下：\n值得注意的是参数arg0的值没有任何含义，实际上编译器并不会传递这个参数，deferreturn()函数内部通过它获取调用者栈帧上args to callee区间的起 始地址，从而可以将defer函数所需参数复制到该区间。defer函数的参数个数要比编译器传给deferproc()函数的参数还少两个，所以调用者的 args to callee区间大小肯定足够，不必担心复制参数会覆盖掉栈帧上的其他数据。\ndeferreturn()函数的主要逻辑如下：\n若defer链表为空，则直接返回，否则获得第1个_defer的指针d，但并不从链表中移除。 判断d.sp是否等于调用者的SP，即判断d是否由当前函数注册，如果不是，则直接返回。 如果defer函数有参数，d.siz会大于0，就将参数复制到栈上\u0026amp;arg0处。 将d从defer链表移除，链表头指向d.link，通过runtime.freedefer()函数释放d。和runtime.newdefer()函数对应，runtime.freedefer()函数 会把d放回缓冲池中，缓冲池内部按照defer函数参数占用空间的多少分成了5个列表，对于参数太多且占用空间太大的d，超出了缓冲池的处理范围则不会被 缓存，后续会被GC回收。 通过runtime.jmpdefer()函数跳转到defer函数去执行。 runtime.jmpdefer()函数是用汇编语言实现的，amd64平台下的实现代码如下：\n第2行把fn赋值给DX寄存器，3.3节中已经讲过Function Value调用时用DX寄存器传递闭包对象地址。接下来的3行代码通过设置SP和BP来还原 deferreturn()函数的栈帧，结合最后一条指令是跳转到defer函数而不是通过CALL指令来调用，这样从调用栈来看就像是deferreturn()函数的调用者直接 调用了defer函数。\njmpdefer()函数会调整返回地址，在amd64平台下会将返回地址减5，即一条CALL指令的大小，然后才会跳转到defer函数去执行。这样一来，等到defer函数 执行完毕返回的时候，刚好会返回编译器插入的runtime.deferreturn()函数调用之前，从而实现无循环、无递归地重复调用deferreturn()函数。直到当 前函数的所有defer都执行完毕，deferreturn()函数会在第1、第2步判断时返回，不经过jmpdefer()函数调整栈帧和返回地址，从而结束重复调用。\n使用deferproc()函数实现defer的好处是通用性比较强，能够适应各种不同的代码逻辑。\n因为defer函数的注册是运行阶段才进行的，可以跟代码逻辑很好地整合在一起，所以像if这种条件分支不用完成额外工作就能支持。由于每个 runtime._defer结构都是基于缓冲池和堆动态分配的，所以即使不定次数的循环也不用额外处理，多次注册互不干扰。\n但是链表与堆分配组合的最大缺点就是慢，即使用了两级缓冲池来优化runtime._defer结构的分配，性能方面依然不太乐观，所以在后续的版本中就开始了对 defer的优化之旅。\n3.4.2 栈上分配 在1.13版本中对defer做了一点小的优化，即把runtime._defer结构分配到当前函数的栈帧上。很明显这不适用于循环中的defer，循环中的defer仍然需要 通过deferproc()函数实现，这种优化只适用于只会执行一次的defer。\n编译器通过runtime.deferprocStack()函数来执行这类defer的注册，相比于runtime.deferproc()函数，少了通过缓冲池或堆分配_defer结构的步骤， 性能方面还是稍有提升的。\nruntime._defer结构中新增了一个bool型的字段heap来表示是否为堆上分配，对于这种栈上分配的_defer结构，deferreturn()函数就不会用 freedefer()函数进行释放了。因为编译器在栈帧上已经把_defer结构的某些字段包括后面追加的fn的参数都准备好了，所以deferprocStack()函数这里只 需为剩余的几个字段赋值，与deferproc()函数的逻辑基本一致。最后几行中通过unsafe.Pointer做类型转换再赋值，源码注释中解释为避免写屏障，暂时理 解成为提升性能就行了\n同样使用第3章/code_3_28.go，经过Go 1.13编译器转换后的伪代码如下：\n图3-18 df()函数调用deferprocStack()时的栈帧\n栈上分配_defer这种优化只是节省了_defer结构的分配、释放时间，仍然需要将defer函数添加到链表中，在调用的时候也还要复制栈上的参数，整体提升比 较有限。\n3.4.3 高效的open coded defer 在Go 1.14版本中又进行了一次优化，这次优化也是针对那些只会执行一次的defer。编译器不再基于链表实现这类defer，而是将这类defer直接展开为代码中 的函数调用，按照倒序放在函数返回前去执行，这就是所谓的open coded defer。\n使用第3章/code_3_28.go，在1.14版本中经编译器转换后的伪代码如下：\n1 2 3 4 5 6 7 func df(n int) (v int) { v = n func(i *int) { *i *= 2 }(\u0026amp;n) return } 两个问题：\n如何支持嵌套在if语句块中的defer？ 当发生panic时，如何保证这些defer得以执行呢？ 第1个问题其实并不难解决，可以在栈帧上分配一个变量，用每个二进制位来记录一个对应的defer函数是否需要被调用。Go语言实际上用了一字节作为标 志，可以最多支持8个defer，为什么不支持更多呢？笔者是这样理解的，open coded defer本来就是为了提高性能而设计的，一个函数中写太多defer，应该 是不太在意这种层面上的性能了。\n还需要考虑的一个问题是，deferproc()函数在注册的时候会存储defer函数的参数副本，defer函数的参数经常是当前函数的局部变量，即使它们后来被修改 了，deferproc()函数存储的副本也是不会变的，副本是注册那一时刻的状态，所以在open coded defer中编译器需要在当前函数栈帧上分配额外的空间来存 储defer函数的参数。\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_30.go package main func fn(n int) (r int) { if n \u0026gt; 0 { defer func(i int) { r \u0026lt;\u0026lt;= i }(n) } n++ return n } 经编译器转换后的等价代码如下：\n其中局部变量f就是专门用来支持if这类条件逻辑的标志位，局部变量i用作n在defer注册那一刻的副本，函数返回前根据标志位判断是否调用defer函数。\n图3-19 fn()函数通过open coded defer的方式调用defer函数\n3.5 panic 3.5.1 gopanic()函数 1.12版本的gopanic()函数的源码\n从函数原型来看，与内置函数panic()完全一致，有一个interface{}类型的参数，这使gopanic()函数可以接受任意类型的参数。函数首先通过getg()函数 得到当前goroutine的g对象指针gp，然后会进行一些校验工作，主要目的是确保处在系统栈、内存分配过程中、禁止抢占或持有锁的情况下不允许发生panic。 接下来gopanic()函数在栈上分配了一个_panic类型的对象p，把参数e赋值给p的arg字段，并把p安放到当前goroutine的_panic链表的头部，特意使用 noescape()函数来避免p逃逸，因为panic本身就是与栈的状态强相关的。\nruntime._panic结构的定义代码如下：\nargp字段用来在defer函数执行阶段指向其args from caller区间的起始地址。 arg字段保存的就是传递给gopanic()函数的参数。 link字段用来指向链表中的下一个_panic结构。 recovered字段表示当前panic已经被某个defer函数通过recover恢复。 aborted字段表示发生了嵌套的panic，旧的panic被新的panic流程标记为aborted。 gopanic()中的for循环\n每次循环开始都会从gp的_defer链表头部取一项赋值给d，直到链表为空时结束循环。 接下来判断若d.started为真则表明当前是一个嵌套的panic，也就是在原有panic或Goexit()函数执行defer函数的时候又触发了panic，因为触发 panic的defer函数还没有执行完，所以还没有从链表中移除。这里会把d关联的旧的_panic设置为aborted，然后把d从链表中移除，并通过freedefer() 函数释放。 后续的3大块逻辑就是：调用defer函数、释放_defer结构和检测recover。 调用defer函数 调用defer函数的代码如下：\n首先将d.started设置为true，这样如果defer函数又触发了panic，新的panic遍历defer链表时，就能通过started的值确定该defer函数已经被调用 过了，避免重复调用。 然后为d._panic赋值，将d关联到当前panic对象p，并使用noescape()函数避免p逃逸，这一步是为了后续嵌套的panic能够通过d._panic找到上一个 panic。 接下来，p.argp被设置为当前gopanic()函数栈帧上args to callee区间的起始地址，recover()函数通过这个值来判断自身是否直接被defer函数调用 reflectcall()函数\n1 func reflectcall(argtype *_type, fn, arg unsafe.Pointer, argsize uint32, retoffset uint32) reflectcall()函数的主要逻辑是根据argsize的大小在栈上分配足够的空间，然后把arg处的参数复制到栈上，复制的大小为argsize字节，然后调用fn() 函数，再把返回值复制回arg＋retoffset处，复制的大小为argsize-retoffset字节，如果argtype不为nil，则根据argtype来应用写屏障。\n在编译阶段，编译器无法知道gopanic()函数在运行阶段会调用哪些defer函数，所以也无法预分配足够大的args to callee区间，只能通过 reflectcall()函数在运行阶段进行栈增长。defer函数的返回值虽然也会被复制回调用者的栈帧上，但是Go语言会将其忽略，所以这里不必应用写屏障。\n释放_defer结构 调用完d.fn()函数后，不应该出现gp._defer不等于d这种情况。假如在d.fn()函数执行的过程中没有造成新的panic，那么所有新注册的defer都应该在 d.fn()函数返回的时候被deferreturn()函数移出链表。假如d.fn()函数执行过程中造成了新的panic，若没有recover，则不会再回到这里，若经 recover之后再回到这里，则所有在d.fn()函数执行过程中注册的defer也都应该在d.fn()函数返回之前被移出链表。\n检测recover 检测recover的代码如下：\n如果d.fn()函数成功地执行了recover，则当前_panic对象p的recovered字段就会被设置为true，此处通过检测后就会执行recover逻辑。\n首先把p从gp的_panic链表中移除，然后循环移除链表头部所有已经标为aborted的_panic对象。如果没有发生嵌套的panic，则此时gp._panic应该是nil， 不为nil就表明发生了嵌套的panic，而且只是内层的panic被recover。代码的最后把局部变量sp和pc赋值给gp的sigcode0和sigcode1字段，然后通过 mcall()函数执行recovery()函数。mcall()函数会切换到系统栈，然后把gp作为参数来调用recovery()函数。\nrecovery()函数负责用存储在sigcode0和sigcode1中的sp和pc恢复gp的执行状态。recovery()函数的主要逻辑代码如下：\n首先确保栈指针sp的值不能为0，并且还要在gp栈空间的上界与下界之间，然后把sp和pc赋值给gp.sched中对应的字段，并且把返回值设置为1。\n调用gogo()函数之后，gp的栈指针和指令指针就会被恢复到sp和pc的位置，而这个位置是deferproc()函数通过getcallersp()函数和getcallerpc()函 数获得的，即deferproc()函数正常返回后的位置，所以经过某个defer函数执行recover()函数后，当前goroutine的栈指针和指令指针会被恢复到deferproc()函数刚刚注册完该defer函数后返回的位置，只不过返回值是1而不是0。\n3.5.2 gorecover()函数 defer函数中调用了内置函数recover()，实际上只会设置_panic的一种状态。内置函数recover()对应runtime中的gorecover()函数，代码如下：\n编译器会把调用者的args from caller区间的起始地址作为参数传递给gorecover()函数。\n1 2 3 4 5 6 7 // 第3章 code_3_31.go func fn() { defer func(a int) { recover() println }(0) } 经编译器转换后的等价代码如下：\n1 2 3 4 5 func fn() { defer func(a int) { gorecover(uintptr(unsafe.Pointer(\u0026amp;a))) }(0) } 图3-20 p.argp和gorecover()函数参数argp的关系\n3.5.3 嵌套的panic Go语言的panic是支持嵌套的，第1个panic在执行defer函数的时候可能会注册新的defer函数，也可能会触发新的panic。如果新的panic被新注册的defer 函数中的recover恢复，则旧的panic就会继续执行，否则新的panic就会把旧的panic置为aborted。\n1 2 3 4 5 6 7 // 第3章 code_3_32.go func fn() { defer func() { panic(\u0026#34;2\u0026#34;) }() panic(\u0026#34;1\u0026#34;) } fn()函数首先将一个defer函数注册到当前goroutine的defer链表头部，记为defer1，然后当panic(＂1＂)执行时，会在当前goroutine的_panic链表中 新增一个_panic结构，记为panic1，panic1触发defer执行，defer1中started字段会被标记为true，_panic字段会指向panic1\n图3-21 panic2执行前的_defer链表和_panic链表\n然后执行到panic(＂2＂)这里，也会在当前goroutine的_panic链表中新增一项，记为panic2。panic2同样会去执行defer链表，通过defer1记录的 _panic字段找到panic1，并将其标记为aborted，然后移除defer1，处理defer链表中的后续节点。\n图3-22 panic2执行后的_defer链表和_panic链表\n在defer函数中嵌套一个带有recover的defer函数\n1 2 3 4 5 6 7 8 9 10 // 第3章 code_3_35.go func fu() { defer func() { defer func() { recover() }() panic(\u0026#34;2\u0026#34;) }() panic(\u0026#34;1\u0026#34;) } 依然把fn()函数首先注册的defer函数记为defer1，把接下来执行的panic记为panic1，此时goroutine的_defer链表和_panic链表与图3-21中的链表并 无不同。只不过当panic1触发defer1执行时，会再次注册一个defer函数，记为defer2，然后才会执行到panic(＂2＂)，这里触发第二次panic，在_panic 链表中新增一项，记为panic2。\n图3-23 defer2执行前的_defer链表和_panic链表\n然后panic2去执行_defer链表，首先执行defer2，将其started字段置为true，_panic字段指向panic2。待到defer2执行recover()函数时，只会把 panic2的recovered字段置为true，defer2结束后，从_defer链表中移除\n图3-24 defer2结束后的_defer链表和_panic链表\n接下来，panic处理逻辑检测到panic2已经被刚刚执行的defer2恢复了，所以会把panic2从_panic链表中移除，如图3-25所示，然后进入recovery()函数 的逻辑中。\n图3-25 panic2恢复后的_defer链表和_panic链表\n结合3.5.1节中的recovery()函数的介绍，panic2被recover后，当前协程会恢复到defer1中注册完defer2刚刚返回时的状态，只不过返回值被置为1，直 接跳转到最后的deferreturn()函数处，而此时defer链表中已经没有defer1注册的defer函数了，所以defer1结束返回，返回panic1执行defer链表的逻 辑中继续执行。\n3.5.4 支持open coded defer 1.14版本中runtime._defer结构的定义\n3.6 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC3%E7%AB%A0-%E5%87%BD%E6%95%B0/","summary":"本章建议最多读到3.4, 到这里已经看不太懂了","title":"第3章 函数"},{"content":"该文章展示了事务隔离级别与锁的关系, 推荐阅读\nRC/RU+条件列非索引 RC/RU+条件列是聚簇索引 RC/RU+条件列是非聚簇索引 RR/Serializable+条件列非索引 RR/Serializable+条件列是聚簇索引 RR/Serializable+条件列是非聚簇索引 原文\n","permalink":"https://jdxj.github.io/posts/articles/rjzheng/%E6%83%8A-%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E7%9A%84select%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90-mysql/","summary":"该文章展示了事务隔离级别与锁的关系, 推荐阅读 RC/RU+条件列非索引 RC/RU+条件列是聚簇索引 RC/RU+条件列是非聚簇索引 RR/Seri","title":"惊! 史上最全的select加锁分析(Mysql)"},{"content":"1.1 整车构造组成 Vehicle Structure 四大组成\n车身部分包括车身骨架、车身钣金件以及座椅、仪表、天窗、车外后视镜等车身附件。 动力系统由发动机和变速器组成。 底盘由传动系统、悬架系统、转向系统、制动系统和车轮轮胎组成。 电气电子系统包括蓄电池、发电机、空调、照明系统、行车电脑、音响以及电子控制单元、驾驶辅助系统、电信号传输系统等。 轿车车身骨架和钣金件构造示意图\n宾利汽车整车构造\n汽车主要部件构造图\n双门轿车构造示意图\n动力系统和传动系统构造示意图\n底盘组成\n传动系统包括离合器、传动轴、半轴和差速器等； 行驶系统由悬架系统、转向系统、制动系统、车轮和轮胎等组成。 轿车底盘构造示意图\n1.2 整车布局形式 Vehicle Layout 什么是前置发动机、前轮驱动车型？\n将发动机放置在前部，而且一般都是横置，并采用前轮驱动，就是前置前驱车型（简称F F）。这种传动方式简单，紧凑，传动效率高，制造和维修成本低。\n前横置发动机前轮驱动车型构造图\n前横置发动机前轮驱动\n什么是前置发动机、四轮驱动车型？\n在原来前驱车的基础上再塞进四轮驱动系统, 这样要将发动机输出的动力方向转90°才能向后传递\n前横置发动机四轮驱动车型构造图\n前横置发动机四轮驱动\n什么是前置发动机、后轮驱动车型？\n发动机放置在前部，两个后轮为驱动轮，这种布局方式称为前置后驱车型（简称FR）。豪华汽车一般采用这种前置后驱方式，因为它们通常采用大排量发动机， 发动机体积较大。如果把发动机和传动系统都放置在汽车前部，不仅布置困难，而且还会造成“一头沉”，影响汽车的操控性和安全性。\n前置后驱车型构造图\n前纵置发动机\n什么是后置发动机、后轮驱动车型？\n将发动机放置在后轴后方并采用后轮驱动，称为后置后驱车型（简称RR）。现在，这种布局方式只有保时捷汽车采用。\n后置后驱车型构造图\n保时捷GT3\n什么是前纵置发动机、四轮驱动车型？\n大排量发动机的四驱车型，一般都是从前纵置发动机、后驱车型改造来的。它的发动机采用前纵置方式，动力经变速器后由分动器一分为二，分别传递给后轴和 前轴。\n前纵置发动机、四轮驱动车型（奔驰GL）构造图\n怎样判断发动机是横置还是纵置？\n站在车头前，面向发动机，打开发动机舱盖，如果看到发动机的气缸排列方向是左右方向，则此车发动机为“横置”；如果看到发动机的气缸排列方向为前后方向， 则此车发动机为“纵置”。\n什么是后中置发动机、四轮驱动车型？\n将发动机放置在后轴前端并采用四轮驱动，称为后中置发动机、四轮驱动方式。现在，大多数超级跑车都采用这种驱动方式。\n后中置发动机、四轮驱动车型（奥迪R8）构造图\n奥迪R8超级跑车\n什么是前中置发动机、后轮驱动车型？\n将发动机放置在前轴后方、采用后轮驱动，称为前中置发动机后轮驱动布局方式（简称M R）。跑车喜欢采用这种驱动方式，因为这样可以将整车重心尽量靠近车 身中间，使车辆拥有较高的操控性能。\n奔驰SLR McLaren Roadster构造图\n出气孔\n汽车制动时，前制动盘要比后制动盘承受更大的制动力，它需要更快速地散热，尤其对于车速较快的超级跑车而言，前制动盘的散热效果更为重要。因此，多数 超级跑车上都设计有专为前制动盘散热的出气孔，以利于提高制动性能。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC1%E7%AB%A0-%E6%95%B4%E8%BD%A6/","summary":"1.1 整车构造组成 Vehicle Structure 四大组成 车身部分包括车身骨架、车身钣金件以及座椅、仪表、天窗、车外后视镜等车身附件。 动力系统由发动机和变速器组成。 底盘由传","title":"第1章 整车 Automobile"},{"content":"3.1 如何发现好赛道 必选消费中有食品饮料、日用品、卫生用品、烟酒等，可选消费有珠宝首饰、房地产、汽车\n如何从种类繁多的领域中找到成长性强、模式优秀、值得投资的赛道？\n明白行业处于其生命周期中的哪一个环节 图3-1 行业生命周期理论\n表3-1 四个阶段的行业在股票市场中的体现\n某个消费品可能会衰退，但消费行业本身不会衰退。\n表3-2 消费品三条成长逻辑与行业生命周期的关系\n我们可以参考海外成熟市场的发展历程，来寻找消费行业的投资机会 站在2022年，我们是否还能通过对标海外的方式，来提前发现消费行业的发展方向呢？答案是肯定的。比较显而易见的方向是医美和餐饮 我们可以借助统计局的统计数字，来判断各个行业的景气程度 国家统计局披露的宏观消费数据主要有三个：\n社会消费品零售（简称社零）总额 “住户调查”下的人均居民消费支出 GDP支出法口径下的最终消费支出。 一般来说，我们主要关注社零总额，这个数据反映社会企业销售非生产、非经营的实物商品以及提供餐饮服务所获得的收入。关注社零数据的原因在于：\n第一，社零数据的更新频率较快，每个月更新一次（除1～2月春节期间只更新一次以外），能够迅速地反映消费趋势的变化； 第二，它的口径更为详细，每个月都会披露不同类目下限额以上企业的零售总额及同比增速，可以帮助我们具体判断消费行业每个细分赛道的景气程度； 第三，它的统计结果准确程度相对较高，因为限额以上口径的数字是由各地的大型企业填表报送而来的，是相对直接的一手统计数据。 “限额以上企业”是指主营业务收入超过一定数额的企业，这类企业的零售额由填表报送而来，而非推算得来，具有较高的准确度。\n表3-3 各品类限额以上企业零售额增速\n在消费领域中，什么样的行业值得我们投资？\n其实这取决于我们想找什么样的投资品。\n喜欢进攻、风格犀利的投资者可以关注医美、新能源汽车等处于渗透率提升阶段的消费品； 风格稳妥的投资者可以选择成熟期的价值股（如大家电）进行投资； 均衡的消费者可以选择功能性服饰、功能性护肤品品牌这类处于市占率提升阶段的标的来投资，其具备优异的持续成长能力，也正在不断地创造利润； 而行业格局稳定、拥有持续提价能力的白酒等品类，能够跑赢通胀，也具备明显的壁垒和稀缺性，几乎适合绝大多数的投资者。 3.2 消费品公司分类体系：品牌、渠道、供应链 我们的消费研究框架：供应商-品牌商-渠道商\n按照在消费产业链上所处的环节，企业由上到下可分为供应商、品牌商、渠道商。三者分别对应产品、品牌、渠道三要素。其中， 品牌是消费者和商家间的信用契约，渠道是消费者和商家间的反馈机制，产品是商家对于消费者需求的解读。\n国内知名的渠道商包括京东集团、永辉超市等。 品牌商通常扮演着渠道和供应链的组织者，一方面要设计产品，寻找代工厂，另一方面也要管理其库存与销售渠道，此外还要负责品牌营销等，并给消费者提 供质量背书。国内知名品牌包括服装品牌李宁和安踏、白酒品牌茅台等。 对于长期投资而言，重点是看清投资标的的壁垒和护城河。 壁垒通常是企业具备的难以被复制，并能够持续创造超额利润的资产。\n供应商的壁垒包括规模化生产能力、管理与成本控制能力、研发能力、工艺改善能力等。 渠道商的壁垒包括网络效应、渠道效率、覆盖面、组织管理能力等。 品牌商的壁垒主要在于品牌认知，它的形成需要时间积淀，不可复制，是品牌溢价的基础，能够持续为企业带来利润和成长；此外也在于销售渠道的建设和管 理，这对于即时性消费品类（比如瓶装饮料）而言非常重要。 供应链：中国拥有世界上首屈一指的消费品制造业 供应链主要包括各种原材料供应商和代工厂，它们负责产品的生产环节。比如服装供应链主要包括桐昆股份、百宏实业等原料供应商，以及申洲国际、晶苑国际 等成衣制造商。消费品供应链涉及的范围很广，很多科技企业本质上都属于消费品供应链环节。\n消费行业的定价权通常由品牌和渠道环节掌控，供应链环节的议价能力比较一般，产品出厂价主要依据成本而定。因此，供应链企业的毛利率通常较低，盈利能 力短期受到上游价格波动的影响，长期受制于人工成本提升的挤压。想要持续实现盈利，需持续优化生产过程中的每个细节，并保证充足的产能利用率。\n供应链企业的核心壁垒包括规模化生产能力、管理能力、成本控制能力、研发能力和工艺改善能力等。 研发能力、工艺改善能力近年来变得越来越重要，品牌方会把一部分设计工作（如打样等）交给供应链企业负责，有时也会购买代工厂的方案，未来研发能力 或将成为供应链企业之间决出胜负的关键要素。 我国本土的消费行业在品牌环节整体较为薄弱，其一大原因是形成品牌需要时间积淀。没有品牌、没有销路是国内优质制造商遇到的最大的问题，大量工厂只能 帮海外品牌干苦力活，而拿不到品牌订单的工厂只能艰难度日，这甚至一度催生了“山寨”这种畸形业态。\n渠道：电商是中国消费行业中的核心变量 渠道包括商超、百货、经销商、电商平台等。渠道的核心作用是将终端消费者与品牌和厂家对接起来，将批量生产的商品零售给消费者。\n商超（如永辉超市等）、百货（如百联股份等）、经销商（如滔博体育等）、电商平台（如天猫、京东等）、在电商平台上开店的店家和服务商（如壹网壹创等），都属于渠道商的范畴。 渠道可分为线上渠道和线下渠道，按照经营模式又可分为自营（经销）模式和平台（租赁）模式。对于不同类型的渠道，我们的关注重点有所不同。\n对于线上渠道，我们关注规模、流量和变现能力。线上渠道的壁垒在于网络效应、变现能力、反馈效率、用户习惯等。 网络效应非常关键，用户越多，商家越多；商家越多，用户越多。在线上渠道中，消费者获得的效用与使用该平台的其他用户人数具备相关性，因此线上渠 道的规模（主要用GMV衡量）和流量（主要用活跃用户数衡量）是核心指标。 变现能力反映渠道的利润率和货币化率，直接决定了企业的盈利能力。 反馈效率指渠道把信息传递给商家、供应商的速度，这将影响渠道的整体经营效率。 用户习惯反映了消费者对渠道的倾向性，这将显著影响渠道的流量。 线下渠道的壁垒在于经营模式、规模、渠道覆盖面、经营效率、组织管理能力、用户习惯等。 我们首先要弄清楚渠道是自营的还是加盟的：自营投入高、经营杠杆大，但企业对门店的把控可以做得更到位；加盟相当于自带财务杠杆，扩店所需投入小， 但需要关注加盟协议的细节，以及企业对加盟商的管理能力。 关注门店数量的多寡以及分布情况，门店的扩张需要时间，覆盖面大是线下消费业态的重要壁垒，此外扩店是线下消费最直接的增长方式。 我们要关注门店的经营效率，核心指标包括坪效、店效等，以此考量门店经营的健康程度。 组织管理能力可通过横向对比相似企业的费用率来衡量； 用户习惯主要基于大家在日常生活中对各个渠道的理解，比如“超市的菜没有菜市场的新鲜，所以尽量去菜市场”就是一个用户习惯。 自营渠道的壁垒在于经营效率、规模、渠道覆盖面、用户体验等。所谓自营，就是企业通过低买高卖的形式获利，同时承担存货风险。 通常这个买卖价差并不会很大，因此经营效率上的微小差异，最终可能给利润带来大变化。经营效率是企业长年累月抠细节抠出来的，难以复制。 规模与渠道覆盖面之间存在联系，通常渠道覆盖面大了，规模才能上来。渠道覆盖面决定有多少消费者能前来购物；规模一方面决定了渠道议价能力，影响 进货价，另一方面对于摊薄固定成本意义重大（自营渠道的经营杠杆通常比较高）。 用户体验的好坏、用户习惯的形成与改变，是决定渠道长期存亡的重要变量。 平台模式的壁垒主要在于流量及规模（网络效应）、变现能力。 线上平台和线下商铺租赁是同一种商业模式，都在为经营者提供流量，并向其收取流量费用。收费的多少很大程度上取决于平台提供流量的价值，而平台所 具备的流量在一定程度上取决于网络效应。 线下商铺也类似，租金多少由商铺人流量而定，而人流量通常取决于聚集效应。 对于平台模式的渠道而言，运营组织能力也很重要，它将在更长的周期里决定渠道的人气，并关系到渠道的价值。 总的来说，我们要关注的指标是GMV（反映规模）、活跃用户数（反映流量）、货币化率（反映变现能力）。 表3-4 消费渠道分类\n我国的零售渠道最为特殊之处在于电商。\n图3-4 2019年各国零售电商销售额\n渠道变革永不停歇，每次渠道变革都蕴藏着巨大的机会。\n图3-5 拼多多与开市客涨幅\n品牌：品牌认知带来溢价 消费者根据品牌来评价和挑选商品，制造商在品牌的组织下完成生产，经销商在品牌的管理下销售商品，可以说品牌是消费产业链的枢纽。\n品牌的壁垒，很多时候就是品牌本身。\n图3-6 “品牌计分板”理论\n“品牌计分板”理论告诉我们：\n品牌溢价的形成并非单纯由用料成本、设计、营销中的某个单一因素造成，而是通过所有品牌动作（包括设计、制造、宣传、销售等所有环节）不断和市场交 互反馈，长年累月积淀而成的。 品牌认知具备时间维度。可以把品牌认知想象成一个计分板，有的动作得分，有的动作减分。品牌认知是品牌动作反馈的最终得分，包含动作和时间两个维度。 只有在对的时候做对的事才能得分，品牌资产难以复制。比如，商家在2000年前投放央视广告，在2010年前投放淘宝直通车（买搜索排名），大概率是高分 动作，但放在此时此刻就未必了。 品牌资产的核心在于品牌认知，主要体现在品牌的规模和溢价能力上。一个优秀的品牌不但要具备足够的规模及相应的规模增速，也要有领先的定价能力、溢价 能力、涨价能力。\n具备一定的规模是一个品牌存在的必要条件，不成规模，难言品牌。品牌的销售规模是消费者用真金白银买出来的，是品牌认可度的一个直接体现。 定价能力即“说一不二”的能力，只要定了10元的建议零售价，就不会以9元卖出去，体现为打折少、力度小。 溢价能力强是指毛利率高，比如出厂价为5元的东西，可以凭借品牌力以10元甚至20元的高价卖出。 涨价能力是指能让消费者接受持续涨价，这是最为稀缺的能力，只有部分高端白酒和传统奢侈品等极少数品牌具备这样的能力。 品牌作为一个能够持续创造利润的资产，却不被计入报表之中。ROE=净利润÷净资产，由品牌资产带来的那部分利润会抬高ROE。优秀的品牌企业通常具备较高的 ROE。品牌企业中浮现了大量的“现金牛”，因为品牌的持续经营通常并不需要持续的资本性投入，经营产生的利润基本上都是自由现金流。\n表3-5 部分品牌、渠道、供应链公司的核心优势\n3.3 读懂数字，看清公司 上市公司的数据主要包括财务数据和经营数据。\n财务数据指三张合并报表（利润表、资产负债表、现金流量表）披露的数据，比如收入、利润、存货、现金流等，以及根据报表上的数据算出来的比率，比如 毛利率、净利率、营运周期、ROE等。 经营数据指三张表之外的重要数据，如门店数量、员工数量、坪效、店效等，主要来自上市公司财报的业务概要或经营情况分析等章节，也可来自上市公司官 网、官方微信公众号等渠道。 一份财报通常包括重要提示、释义、公司简介和主要财务指标、公司业务概要、经营情况讨论与分析、重要事项、股份变动及股东情况、优先股情况、 员工情况、公司治理、债券相关情况、财务报告、备查文件目录等。\n以贵州茅台2020年年度报告为例\n标准无保留意见代表对报表的质量满意，如果未获得标准无保留意见，则说明财报中的某些地方是有问题的。 重要提示之后是目录 图3-7 贵州茅台2020年年度报告目录\n公司简介和主要财务指标关注主要会计数据，可清楚看到营业收入、归属于上市公司股东的净利润、经营活动产生的现金流量净额、总资产及它们的同比变动 情况. 我们还可以在公司简介中找到公司的联系方式，若对公司的经营情况有疑问，投资者可拨打相应的电话，或在投资者交流平台上与公司互动。 图3-8 贵州茅台2020年主要会计数据\n公司业务概要主要包含公司对其主要业务的介绍。如果公司业务没有发生重大变化，那么这一段的内容可能会连续很多年没有大变化。当然，在初次分析一家 公司的时候，可以从此处入手来了解公司的主要业务。 经营情况讨论与分析是非常重要的一节，其中最重要的当数管理层对经营情况的文字分析。本节亦会披露大量的经营数据，包括重要的收入和成本的构成， 这有助于我们厘清公司的业务条线，以及各个条线的经营情况和增长情况 主要客户、主要供应商情况也很关键，一方面看采购和销售的集中程度，另一方面也可以通过前五大供应商的构成情况来辅助判断公司主要业务的经营实质 （当然大多数时候企业只会在招股书中披露前五大客户具体是谁）。 前五大供应商、客户的成交额数据有时也可以用来做交叉验证，比如若上游企业前五大客户和下游企业前五大供应商有重合，可以对比双方报表中的数据， 这可以用来大致判断双方报表的数据质量。 图3-9 贵州茅台2020年主营业务分行业、分产品情况\n重要事项统计了公司的历史股利分配方案、承诺履行、会计师事务所聘任情况、关联交易、收并购事项等内容，这部分的很多内容在此前的公告中披露过了， 投资者可利用本节查漏补缺，同时也需关注在本节中是否有可能给经营、股价带来风险的事件。 普通股股份变动及股东情况展示了公司前十大股东、前十大流通股东的变动情况，我们一般关注实控人背景、新增大股东情况、原有大股东股份变动或质押等 信息。 董事、监事、高级管理人员和员工情况是相对比较重要但分析起来有难度的一节。所谓“事在人为”，公司经营情况的好坏很大程度上取决于员工的能力及动力。 在这部分中我们可以看到公司高管的简介、变动情况，以及员工人数及构成。人数和构成都是重点，通常一家业务不断扩张的公司，员工数量会不断增多，尤 其是业务部门的员工。 关注财报中的文字信息 财报中的文字包含了大量的经营信息，有时候能领先于统计数据，折射出企业经营环境的变化。我们在阅读各类财务经营数据之前，可以先看公司管理层对公司 自身经营的分析。这部分内容一般在第四节“经营情况讨论与分析”，当然也在各种“致股东的信”中。\n阅读经营情况讨论与分析的方法：竖着读、横着读。\n竖着读指依次阅读公司历史上各个年度的经营情况讨论与分析，弄清楚公司经营和业务发生变化的脉络，并尽量和各个时期的经济大环境对应起来，找到决定 行业、公司经营的关键变量。 横着读指阅读同一个时期行业同业企业的经营情况讨论与分析，了解彼此之间的竞争情况，并对每个时期的行业景气度进行全景扫描。 利润表：主要关注收入规模及增速、利润规模及增速、毛利率、净利率和费用率等 在利润表中，最重要的两个原始数字是营业收入和归属于母公司股东的净利润（简称归母净利润）的数字。除了关注这两个数字本身，更要关注它们的同比增速。\n利润表中其余的项目，我们主要关注其占营业收入的比率，以及比率的变动趋势。\n图3-10所示为一个基本的消费品利润表分析框架。\n收入反映企业的整体经营规模，企业的成长首先要体现在收入规模的增长上。\n对于消费品企业而言，收入上升通常意味着卖出了更多的产品，有时收入规模就是企业的壁垒所在。 于品牌企业，收入规模增长通常意味着消费者对其总体认可程度提升； 于线上渠道，收入规模增长意味着流量的增长和网络效应的扩大； 于线下渠道，收入规模增长通常来自门店数量增长、覆盖面提升，或坪效、店效的增长； 于供应链企业，收入规模增长则意味着得到更多的下游订单，并有望带来规模效应。 毛利率是非常重要的指标，具备一定的前瞻性。\n一般来说，渠道和品牌企业的利润率是比较稳定的，收入增速会与利润增速相匹配。当两个增速不匹配时，除了非经常性费用、财务费用发生改变的少数情况 外，利润率会发生变化。此时我们要去溯源，看是哪一个环节的成本、费用率发生了变化。 在行业转好时，需求会率先增长起来，但企业的产能扩充难以快速跟上，此时产品价格上涨，毛利率率先提高，此后企业扩产，兑现利润；反之，毛利率将率 先下降。 对于供应链企业而言，通常影响毛利率的因素从大到小分别是：①销售情况，当行业需求变好的时候，价格提升，体现为毛利率增长；②原材料价格，当原材 料降价幅度大于产品降价幅度时，毛利率将会增长；③规模效应降低生产成本。 对于渠道企业而言，平台模式、租赁模式、联营模式的毛利率高于自营，而自建门店的毛利率大于加盟门店。很多公司同时采用多种模式经营，且不同的品类 毛利率通常不一样。当毛利率发生变化时，要先弄清楚这是由结构变化导致的，还是因为经营基本面重大变化而产生的。 费用率反映企业综合管理水平，同类企业中管理水平高的企业，费用率通常更低。这些企业通过费用率的优势，获取了高于行业的利润率。\n费用会包含一部分固定成本，因此规模效应的提升通常将在一定程度上摊薄费用率。 品牌和渠道类消费品公司的销售费用率比较高，品牌公司的销售费用主要来自营销投放等，线下渠道公司的销售费用来自门店租金和折旧、店内员工的工资等。 在分析销售费用的时候，我们要特别注意物流费用的处理方法，在2020年1月1日开始执行的新准则中，物流相关费用从销售费用转移到了营业成本，而一部分 海外公司仍然记在销售费用中，这一点我们在做横向、纵向对比的时候要特别注意。 销售费用率有时候有前瞻指导意义 我们还要将收入和成本拆分到每个业务或每个渠道，并对其逐一分析。\n首先，按业务（产品）拆分。在这一步我们要弄清楚：① 公司的主要收入来源，每个业务的收入及收入占比；② 主要的增长点，即每个业务的增速；③ 哪个业 务利润率高，即每个业务的毛利率；④ 公司的主要利润来源，一般通过毛利构成来判断。\n表3-6 申洲国际各业务收入拆分\n其次，按渠道拆分，即按照不同的渠道进行逐一拆分，弄清楚每个渠道的收入、增速、毛利率，以及相应的收入占比和毛利占比。不同的渠道会有不同的成本和 费用结构，如果不拆清楚，分析就没有意义。\n表3-7 周大生各渠道收入拆分\n以上两个拆分步骤进行完毕之后，我们可以进一步按照“量×价”对收入进行拆分，即拆出销量和单价。有时候财报只披露了销量，这时候我们可以用销售额除以 销量来估算单价。我们可以纵向观察每个产品的销量、单价、毛利率在历史上的变动关系，以及相互之间的关联性。“量×价”也可以按其他方式来进行展开，比如 “店铺数量×单店收入”，或者“经营面积×坪效”等。这里的关键在于找出公司的增长驱动力，发掘不同经营指标之间的关系，并找出决定公司业绩的核心变量。\n资产负债表：关注营运能力指标 观察资产负债表，第一个项目是现金及现金等价物。这是一个相对重要的指标，是否有足够的现金关系到企业能否持续正常运转。\n资产负债表中的营运能力指标会耗费我们大量的分析时间，这些指标主要包括：存货、应收账款、应收票据、应付账款、应付票据、预收款项、预付款项等。对 于这些指标，除了关注其绝对值之外，更重要的是关注其周转速度指标（如周转率、周转天数，二者的区别仅为展现方式不同，乘积为365）。\n存货是一个需要特别小心的科目，其金额和周转天数都要关注。\n第一，一部分消费品存在保质期或时间价值，老库存过多将有可能导致存货减值损失，而如果清仓甩卖，则有可能带来直接亏损，并影响品牌价格带。 第二，存货过高会占用企业的运营资金，影响运营效率。 存货一般可以分为三类：原材料、在产品或半成品、产成品（包括库存商品和发出商品）。\n应收应付款项、预收预付款项代表着企业的行业地位。在产业链中地位越高，就越能够占用上下游资金，体现为预收款项和应付款项高，而预付款项和应收款项 少。\n现金流量表：消费赛道频出“现金牛” 在国内现行管理下，我们更多地关注现金流量表中的经营活动净现金流量。经营活动净现金流量的数值通常会高于净利润，因为净利润不会包括企业的折旧摊销 费用。\n如何看待消费行业的ROE ROE是一个非常重要的财务指标，由净利润除以账面净资产得来，其含义是“股东每投入1元钱，每年能够产生多少净利润”。ROE还表征企业自然增速的天花板： 假设企业新业务的ROE等于原有业务，那么如果企业将每年的利润都投入到再生产中，所能带来的业绩增速就等于该ROE，而我们知道新业务的ROE通常不会高于 原有业务，因此ROE通常被认为是企业自然增速的天花板。\n我们一般会比较看重供应链企业的ROE，而不会太关注消费品牌和加盟类、平台类渠道的ROE。\n对于供应链企业，ROE能很好地反映“每投1元钱能赚多少”，但对于品牌和渠道则不行。 品牌是在企业与消费者长年累月的不断交互中产生的，花钱并不一定能买来品牌认知； 而不同渠道企业如果采取不同的经营模式，会直接对ROE造成较大的扰动； 此外，像阿里巴巴这类电商平台的核心资产其实是平台上的用户和供应商，这些资产不会被计价放入报表中，因此也会使ROE失去意义。 数据的作用仅仅是帮助我们理解行业的景气度和企业的经营情况。在实践中，我们应当站在企业家的角度，思考整个生意的运转，这样才能够得到真实的、对投 资有意义的结论。\n3.4 探寻消费牛股的上涨驱动力 股价=P/E×EPS，股价的上涨可以由利润驱动（EPS驱动），也可以由估值驱动（P/E驱动）。从历史上看，大多数消费牛股都是由利润驱动的。\n表3-8 A股消费行业牛股股价增长拆解（2011-12-31～2021-12-31）\n论消费品估值：为何消费品企业的PEG常大于1\n消费品企业的增长持续性、确定性强。品牌力的形成、产品不断提价、用户消费习惯的转变、新消费渗透率的提升、渠道网络效应的形成，都是消费品企业增长 的根本来源。历史多次证明这些转变是缓慢但具备趋势性的，很多时候企业增速虽然不太高，但能够持续很多年，且增长具有惯性，确定性较强，因此市场乐于 给予使PEG\u0026gt;1的估值。\n再论消费品估值：什么样的企业能够实现长期估值增长\n为什么这些白酒、调味品标的能够在长周期内实现估值的增长？\n答案是：涨价逻辑。头部白酒品牌的涨价逻辑类似于奢侈品。\n首先，白酒是有社交和分享属性的商品，饮酒的场合通常是各种聚会，在这类场合下人们有溢价购买品牌商品的动力，对价格相对不敏感。 其次，在白酒品牌中，口碑最佳、最具品牌力的就是这些A股龙头白酒上市公司，市面上能够买到的最好的白酒，就出自这些品牌。 最后，白酒保质期长，越放越醇，越值钱。 图3-13 飞天茅台（53度）的经销商调货均价持续上升\n调味品在一盘菜中所占的成本比重极低，几乎可以忽略不计，但存在感高，在相当大的程度上决定了一盘菜的风味。仅几滴酱油，就能决定菜品的色香味，而如 果换了一个品牌，可能就完全不一样了。这使得用户对酱油的品种存在较强的黏性，同时对涨价相对不敏感。因此，酱油这类调味品拥有很高的涨价能力。\n为什么涨价能力如此重要？因为其代表永续增长和跑赢通胀的能力。有涨价能力意味着企业可以以超过通胀的速度逐渐提升其产品的售价，以实现实际意义上的 永续增长当然，这个永续增长的速度并不会很快。这类资产在经济增速放缓、无风险利率下降的经济环境下，将迎来估值提升。提升的本质逻辑可以用戈登模型 解释，戈登模型告诉我们，股票的P/E=1/（r-g）。如表3-9所示，永续增长率g更高的资产，在贴现率r下降时，估值的增长幅度更大。\n表3-9 在不同贴现率、永续增长率下，戈登模型预示的P/E\n3.5 结语 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC3%E7%AB%A0-%E6%B6%88%E8%B4%B9%E5%93%81%E6%8A%95%E8%B5%84%E5%89%91%E6%8B%9B/","summary":"3.1 如何发现好赛道 必选消费中有食品饮料、日用品、卫生用品、烟酒等，可选消费有珠宝首饰、房地产、汽车 如何从种类繁多的领域中找到成长性强、模式优秀","title":"第3章 消费品投资剑招"},{"content":"品牌投资的三条主要逻辑 行业规模、渗透率提升：行业增长可由消费人群的增长或人均消费的增长驱动，渗透率指的是现有消费群体在潜在消费群体中的占比，渗透率提升是品类市场 规模增长的重要驱动力。 市占率提升：如果行业原本较为分散，没有成规模、成体系的供应，这时出现了品牌公司整合资源实现规模化，就有品牌化程度提升；如果行业的龙头公司不 断扩大市场份额，品牌增速大于行业增速，就有品牌集中度提升。 价格带提升：一部分消费品具备持续提升价格带的能力，比如茅台、爱马仕等；另一些消费品公司则通过不断提升产品定位，做高端迭代来提升产品价格带， 如华为等。 2.1 消费品品牌增长逻辑之一：行业规模、渗透率提升 行业规模增长可以拆分成用户基数增长和人均消费增长\n图2-1 行业规模增长可拆分成用户基数（渗透率）增长和人均消费增长\n现阶段大多数的消费品品类已经进入了成熟期，拥有渗透率提升逻辑的并不多。这类行业通常代表新兴需求，如2021年的新能源汽车、医美、扫地机器人等行业， 都拥有渗透率提升的增长逻辑。\n医美就是一个典型的渗透率增长的行业。\n图2-2 每千人医美诊疗次数（2019年）\n图2-3 中国大众对医美的接受度调查（2018年）\n图2-4 我国不同城市层级的医美渗透率（2020年）\n图2-5 我国医美消费者年龄分布（2020年）\n2.2 消费品品牌增长逻辑之二：市占率提升 市占率提升包括品牌化程度提升和品牌集中度提升。\n品牌化程度提升指的是，把原本并不集中的行业通过品牌整合起来，如连锁餐饮行业； 品牌市占率提升指的是，行业内具备优势的品牌蚕食对手份额，提升市占率的过程 图2-6 中日美餐饮连锁化率\n海底捞崛起的逻辑是品牌化程度提升\n图2-7 2020年中国连锁餐饮市占率\n龙头企业市占率提升背后的原因包括：\n规模生产降低成本，从而提供了质量更好、更具性价比的产品； 知名度高，具备更强的消费者认知； 拥有分布更广的销售和售后服务渠道等。 通常而言，具备功能性的消费品细分赛道更容易出现市占率较高的大品牌，因为细分赛道中的龙头品牌更加容易被贴上标签，与某些特殊功能、功效形成强绑定。\n图2-8 皮肤学级护肤品行业龙头品牌市占率高于整个化妆品行业\n2.3 消费品品牌增长逻辑之三：价格带提升 在具备彰显个性和社交属性特征的消费品赛道，通常更容易出现具备持续提价能力的品牌。\n茅台 爱马仕 图2-9 飞天茅台（53度）的经销商调货价格持续上升\n根据戈登模型P/E=1/（r-g），在投资者要求的回报率r（即贴现率）保持不变的情况下，永续增长率g越高的标的，其合理P/E越高。\n表2-1 在不同贴现率、永续增长率下，戈登模型预示的P/E\n类似茅台、爱马仕这样具备直接提价能力的品牌毕竟是极少数。对于大部分消费品品牌而言，提价主要通过产品迭代完成。\n图2-10 波司登2017～2018年各价格带产品销售量分布\n图2-11 我国高端美妆个护品的市占率逐年提升\n总的来说，渗透率提升阶段的资产进攻性最强、涨得最快、风险最大，投资时要充分小心，要充分摸清公司质地，并保持对公司基本面的紧密跟踪，当增速不及 预期时要及时防范回撤风险。投资于市占率不断提升的龙头公司是一种平衡了风险和收益的好做法，关键在于对行业的景气度以及公司的成长速度保持跟踪。而 投资于具备持续涨价能力的品牌企业是一种相对稳妥的做法，理论上这类资产在当前经济增长放缓、无风险利率下行的经济环境之下，会有让人眼前一亮的表现。\n2.4 结语 行业规模与渗透率提升是稀缺逻辑。大多数消费品品类已经进入成熟期，行业规模与渗透率提升逻辑主要出现在新兴需求领域。拥有这类逻辑的消费品容易实现 持续高增长。\n市占率提升即品牌化程度提升、品牌集中度提升。品牌化程度提升指品牌把分散的行业整合起来，品牌集中度提升指龙头企业市占率提升。\n拥有持续提价能力的品牌容易成为核心资产。大多数品牌通过产品高端化迭代来提升价格带，只有极少数品牌拥有让产品直接涨价的能力。\n","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC2%E7%AB%A0-%E6%B6%88%E8%B4%B9%E5%93%81%E6%8A%95%E8%B5%84%E5%BF%83%E6%B3%95/","summary":"品牌投资的三条主要逻辑 行业规模、渗透率提升：行业增长可由消费人群的增长或人均消费的增长驱动，渗透率指的是现有消费群体在潜在消费群体中的占比，","title":"第2章 消费品投资心法"},{"content":"2.1 指针构成 1 var p *int 无论指针的元素类型是什么，指针变量本身的格式都是一致的，即一个无符号整型，变量大小能够容纳当前平台的地址。例如在386架构上是一个32位无符号整 型，在amd64架构上是一个64位无符号整型。\n有着不同元素类型的指针被视为不同类型，这是语言设计层面强加的一层安全限制，因为不同的元素类型会使编译器对同一个内存地址进行不同的解释。\n2.1.1 地址 2.1.2 元素类型 后两条指令由MOVQ变为MOVL\n2.2 相关操作 2.2.1 取地址 LEAQ指令的作用就是取得main.n的地址并装入AX寄存器中。后面的MOVQ指令则把AX的值复制到返回值p。\n这里获取的是一个包级别变量n的地址，等价于C语言的全局变量，变量n的地址是在编译阶段静态分配的，所以LEAQ指令通过位移寻址的方式得到了main.n 的地址。 LEAQ同样也支持基于基址和索引获取地址 Go语言通过逃逸分析机制避免返回局部变量地址所引发的问题, 实际上在堆上分配\n2.2.2 解引用 空指针异常 所谓空指针，就是地址值为0的指针。按照操作系统的内存管理设计，进程地址空间中地址为0的内存页面不会被分配和映射，保留地址0在程序代码中用作无效 指针判断，所以对空指针进行解引用操作就会造成程序异常崩溃 遭遇空指针异常并非语言设计方面的缺陷，而是程序逻辑上的Bug。 野指针问题 在C语言中, 未初始化的指针变量是随机值, 会绕过代码中的空指针判断逻辑，从而造成内存访问错误。 Go语言中声明的变量默认都会初始化为对应类型的零值，指针类型变量都会初始化为nil 悬挂指针问题 指程序过早地释放了内存，而后续代码又对已经释放的内存进行访问，从而造成程序出现错误或异常。 Go语言实现了自动内存管理，由GC负责释放堆内存对象。GC基于标记清除算法进行对象的存活分析，只有明确不可达的对象才会被释放 2.2.3 强制类型转换 2.2.4 指针运算 假如有一个元素类型为int的指针p，要把p移动到下一个int的位置，在C语言中可以通过指针的自增运算实现，代码如下：\n1 ++p; 在Go语言中等价的代码如下：\n1 p = (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(p))+unsafe.Sizeof(*p))) 2.3 unsafe包 经典的类型转换\n图2-1 String Header和Slice Header的结构\n如果不经意修改了slice就可能会造成程序逻辑错误。\n2.3.1 标准库与keyword ArbitraryType在这里只是用于文档目的，实际上并不属于unsafe包，它可以表示任意的Go表达式类型。 Sizeof()函数用来返回任意类型的大小 Offsetof()函数用来返回任意结构体类型的某个字段在结构体内的偏移 Alignof()函数用来返回任意类型的对齐边界 最重要的是这3个函数的返回值都是常量。 这条MOVQ指令直接向返回值o中写入了立即数8，也就说明Sizeof()函数在编译阶段就被转换成了立即数。 上述测试方法同样适用于Offsetof()函数和Alignof()函数。 2.3.2 关于uintptr 很多人都认为uintptr是个指针，其实不然。不要对这个名字感到疑惑，它只不过是个uint，大小与当前平台的指针宽度一致。因为unsafe.Pointer可 以跟uintptr互相转换，所以Go语言中可以把指针转换为uintptr进行数值运算，然后转换回原类型，以此来模拟C语言中的指针运算。\n需要注意的是，不要用uintptr来存储堆上对象的地址。具体原因和GC有关，GC在标记对象的时候会跟踪指针类型，而 uintptr不属于指针，所以会被GC忽略, 造成堆上的对象被认为不可达，进而被释放。用unsafe.Pointer就不会存在这个问题了，unsafe.Pointer类 似于C语言中的void∗，虽然未指定元素类型，但是本身类型就是个指针。\n参考聊一个string和[]byte转换问题\n2.3.3 内存对齐 硬件的实现一般会将内存的读写对齐到数据总线的宽度，这样既可以降低硬件实现的复杂度，又可以提升传输的效率。 Go语言的内存对齐规则参考了两方面因素：一是数据类型自身的大小，复合类型会参考最大成员大小；二是硬件平台机器字长。 机器字长是指计算机进行一次整数运算所能处理的二进制数据的位数，在x86平台可以理解成数据总线的宽度。当数据类型自身大小小于机器字长时，会被对齐 到自身大小的整数倍；当自身大小大于机器字长时，会被对齐到机器字长的整数倍。\n通过unsafe.Sizeof()函数和unsafe.Alignof()函数可以得到目标数据类型的大小和对齐边界\n地址应该是Alignof的倍数.\n表2-1 常见内置类型的大小和对齐边界\n通过调整结构体成员的位置，尽量避免编译器添加padding\n2.4 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC2%E7%AB%A0-%E6%8C%87%E9%92%88/","summary":"2.1 指针构成 1 var p *int 无论指针的元素类型是什么，指针变量本身的格式都是一致的，即一个无符号整型，变量大小能够容纳当前平台的地址。例如在386架构","title":"第2章 指针"},{"content":"1.1 消费行业的特点 消费涵盖了人们生活的方方面面，范围广、韧性强\n消费对应了大多数行业的终端需求\n不论是上游周期行业，还是中游科技制造行业，最终都将会以某种形式对应到终端的消费上 消费行业牛股辈出，基业长青\n具备明显的经营壁垒，能占据人们的认知和心智，通过品牌认知、网络效应不断为投资者带来超额收益\n1.2 消费研究，始于日常 在众多的行业中，消费行业可谓是最容易理解的赛道之一。理解消费行业，不需要太多的数理化专业知识，不需要相关的从业经验，甚至不一定需要第一手的行 业数据。只要能够做到对周围生活敏锐洞察和深刻理解，每个人都能够从自身周围感受、感知到投资的机会。\n1.3 中美消费行业复盘对比 总的来说，中美两国的消费品发展，都出现过三个典型的阶段。\n第一个阶段是生活必需品普及阶段，主要是食品和生活用品的普及； 第二个阶段是家庭消费阶段，体现为大家电、汽车渗透率的提升； 第三个阶段是个人消费阶段，体现为品牌商品的增长，在这个阶段，人们消费更加注重个性化的需求和消费主张的宣扬。 美国消费行业发展复盘\n第一个阶段是1900～1930年的生活必需品普及阶段 第二个阶段是1930～1960年的家庭消费阶段 第三个阶段是1960～1990年的个人消费阶段 第四个阶段是1990年至今的新消费阶段。 图1-6 美国各类主要消费品的历史渗透率 回顾改革开放以来的中国消费发展历史\n至2021年，我国的消费发展历史大致可以分为生活必需品、家庭消费、个性化消费三个阶段。 中国消费的下一个阶段\n美国的主题是新消费习惯、新消费主张的兴起，这带来了大量的新需求与新品牌崛起的机会； 日本的主题是低欲望，是对于朴素、精巧、实用、去品牌化的追求。 笔者认为，中国消费行业未来的发展会更像美国，而不像日本 1.4 欧美消费股群雄志 总的来说，欧美股市投资回报率比较高的标的主要是奢侈品、有一定溢价能力的品牌、餐饮等服务公司、持续扩张的渠道商，而投资回报率比较一般的标的主要 是市场空间趋于饱和的大众消费品、成熟渠道。在回报率较高的标的中有大量的“十倍股”，而投资回报率一般的标的也能给投资者带来两三倍的稳定回报。从风 险回报比上看，消费品投资是一个值得下注的赛道。\n消费品企业的估值存在共性：如图1-19所示，企业P/E中枢大体上稳定在15～35倍，其中奢侈品的估值较高，而大众消费品的估值较低。\n1.5 结语 第一，奢侈品具备长期的价值。 茅台 第二，有功能性、品牌力强的消费品。 李宁 安踏 珀莱雅 贝泰妮 第三，在服务消费中，能够实现连锁化、标准化的行业是好的投资方向。 第四，渠道和大众消费品的投资机会主要来源于业务的扩张。 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC1%E7%AB%A0-%E4%B8%BA%E4%BD%95%E9%80%89%E6%8B%A9%E6%B6%88%E8%B4%B9%E5%93%81%E6%8A%95%E8%B5%84/","summary":"1.1 消费行业的特点 消费涵盖了人们生活的方方面面，范围广、韧性强 消费对应了大多数行业的终端需求 不论是上游周期行业，还是中游科技制造行业，最终都将","title":"第1章 为何选择消费品投资"},{"content":"1.1 x86通用寄存器 32位x86是intel推出的,64位x86_64是amd推出的(amd64)\n1.1.1 32位架构 在汇编中使用名称来引用寄存器.\n表1-1 Intel指令编码中8个通用寄存器的编号和名称\n编号 名称 编号 名称 0 EAX 4 ESP 1 ECX 5 EBP 2 EDX 6 ESI 3 EBX 7 EDI 0~3号寄存器可以拆分\n图1-1 EAX寄存器的结构 表1-2 编号为0～3的寄存器的结构设计\n32位 16位 高8位 低8位 EAX AX AH AL ECX CX CH CL EDX DX DH DL EBX BX BH BL 4~7号寄存器没有8位独立名称\n表1-3 编号为4～7的寄存器的结构设计\n32位 16位 32位 16位 ESP SP ESI SI EBP BP EDI DI 通用寄存器的特殊用途\nEAX寄存器会被乘法和除法指令自动使用，通常称为扩展累加寄存器。 ECX被LOOP系列指令用作循环计数器，但是多数上层语言不会使用LOOP指令，一般通过条件跳转系列指令实现。 ESP用来寻址栈上的数据，很少用于普通算数或数据传输，通常称为扩展栈指针寄存器。 ESI和EDI被高速内存传输指令分别用来指向源地址和目的地址，被称为扩展源索引寄存器和扩展目标索引寄存器。 EBP在高级语言中被用来引用栈上的函数参数和局部变量，一般不用于普通算数或数据传输，称为扩展帧指针寄存器。 EFLAGS标志寄存器\n汇编语言中用于比较的CMP和TEST会修改标志寄存器里的相关标志，再结合条件跳转系列指令，就能实现上层语言中的大部分流程控制语句 EIP指令指针寄存器\n存储的是下一条将要被执行的指令的地址，而且汇编语言中不能通过名称直接引用EIP，只能通过跳转、CALL和RET等指令间接地修改EIP的值。 1.1.2 64位架构 64位架构把通用寄存器的个数扩展到16个，之前的8个通用寄存器也被扩展成了64位，每个寄存器的低8位、16位、32位都可以单独使用。\n表1-4 64位架构下16个通用寄存器的结构设计\n64位 32位 16位 8位 RAX EAX AX AL RCX ECX CX CL RDX EDX DX DL RBX EBX BX BL RSP ESP SP SPL RBP EBP BP BPL RSI ESI SI SIL RDI EDI DI DIL R8~R15 R8D~R15D R8W~R15W R8B~R15B 指令指针EIP被扩展为64位的RIP，但依然不能在代码中直接引用。标志寄存器EFLAGS被扩展为64位的RFLAGS，里面的标志位保持向前兼容。\n1.2 常用汇编指令 x86的汇编指令一般由一个opcode（操作码）和0到多个operand（操作数）组成，大多数指令包含两个操作数，一个目的操作数和一个源操作数。\n1.2.1 整数加减指令 源操作数可以是寄存器, 内存, 立即数, 目的操作数可以是寄存器, 内存. 两个操作数不能同时为内存\nADD EAX, 16 ; EAX = EAX + 16 SUB ESP, 32 ; ESP = ESP - 32 ADD AL, CL ADD AX, CX 1.2.2 数据传输指令 MOV指令主要用来在寄存器之间及寄存器和内存之间传输数据，也可以用来把一个立即数写到寄存器或内存中。\nMOV EAX, ECX ; EAX = ECX MOV EDX, 1234 ; EDX = 1234 内存寻址方式\nDisplacement：位移，是一个8位、16位或32位的值。 Base：基址，存放在某个通用寄存器中。 Index：索引，存放在某个通用寄存器中，ESP不可用作索引。 Scale：比例因子，用来与索引相乘，可以取值1、2、4、8。经过计算得到的地址称为有效地址。 Effective Address = Base + (Index x Scale) + Displacement (1-1) 基于Base和Displacement的寻址\n位移(Displacement)：一个单独的位移表示距离操作数的直接偏移量。因为位移被编码在指令中，所以一般用于编译阶段静态分配的全局变量之类。 基址(Base)：将内存地址存储在某个通用寄存器中，寄存器的值可以变化，所以一般用于运行时动态分配的变量、数据结构等。 基址＋位移(Base＋Displacement)：基址加位移，尤其适合寻址运行时动态分配的数据结构的字段，以及函数栈帧上的变量。 MOV EAX, [16] ; 位移 MOV EAX, [ESP] ; 基址 MOV EAX, [ESP + 16] ; 基址 + 位移 1.2.3 入栈和出栈指令 PUSH EAX ; 等价于 SUB ESP, 4 MOV [ESP], EAX POP EAX ; 等价于 MOV EAX, [ESP] ADD ESP, 4 1.2.4 分支跳转指令 JMP指令会修改EIP的值\n只有一个操作数, 可以是立即数, 通用寄存器, 内存位置 JMP 32 JMP EAX JMP [EAX+32] 1.2.5 过程调用指令 可以认为CALL在JMP的基础上多了一步记录返回地址的操作\nCALL指令先把返回地址入栈，然后跳转到目的地址执行 目的地址也可以经由一个立即数、通用寄存器或内存位置来给出。\nCALL EAX ; 等价于 PUSH 32 JMP EAX 子过程执行完成后通过RET指令返回，RET指令会从栈上弹出返回地址，并跳转到该地址处继续执行。\nRET 可以不带参数 RET 8 ; 等价于 RET ADD ESP, 8 1.3 内存分页机制 在分页模式下，应用程序中使用的地址被称为线性地址，需要由MMU(Memory Management Unit)基于页表映射转换为物理地址，整个转换过程对于应用程序 是完全透明的。\n1.3.2 80386两级页表 每个页面4KB, 地址总线32bit, 物理地址32bit 每个页面存1024个地址 = 4KB/32bit(4B) = 1K 图1-2 80386线性地址到物理地址的转换 1.3.3 PAE三级页表 Physical Address Extension，PAE 物理地址扩展\nPAE地址总线36bit, 使硬件能够寻址64GB 仍使用32bit线性地址宽度(进程地址空间大小不变) 每个页面4KB, PAE地址总线36bit, 物理地址64bit 每个页面存储512个地址 = 4KB/64bit(8B) = 0.5K 图1-3 PAE线性地址到物理地址的转换 1.3.4 x64四级页表 Intel推出的IA64架构因为与原来的x86架构不兼容，所以没能普及，而AMD公司通过扩展x86推出的x64架构，因为良好的向下兼容性而被广泛采用。常见的 x64、x86_64都是指amd64架构，如今的个人计算机基本是基于amd64架构的。\n在amd64上，寄存器的宽度变成了64位，而线性地址实际只用到48位，也就是最大可寻址256TB的内存。很少有单台计算机会安装如此大量的内存，所以没有必 要实现48位的地址总线，常见的个人计算机的CPU的地址总线实际还不到40位，例如笔者的计算机的Core i7实际只有36位。服务器的CPU的地址总线的宽度会 更大，例如Xeon E5系列能达到46位。\n每个页面4KB, 地址总线48bit, 物理地址64bit 每个页面存储512个地址 = 4KB/64bit(8B) = 0.5K 1.3.5 虚拟内存 猜测前面的地址转换图中的CR3是每个进程页表的起始物理地址\n进程是以页面为单位向操作系统申请内存的，操作系统一般只是对进程已申请的区间进行记账，并不会立刻映射所有页面。等到进程真正去访问某个未映射的页 面时，才会触发Page Fault异常，操作系统注册的Page Fault Handler会检查内存记账：如果目标地址已申请，就是合法访问，系统会分配一个物理页面并 完成映射，然后恢复被中断的程序，程序对这一切都是无感的；如果目标地址未申请，就是非法访问，系统一般会通过信号、异常等机制结束目标进程。\n当物理内存不够用的时候，操作系统可以把一些不常使用的物理页面写到磁盘交换分区或交换文件，从而能够将空出的页面给有需要的进程使用。当被交换到磁 盘的页面再次被访问时，也会触发Page Fault，由Page Fault Handler负责从交换分区把数据加载回内存。程序对这一切都是无感的，并不知道某个内存页 面到底是在磁盘上，还是在物理内存中，所以称为进程的虚拟内存。\n1.4 汇编代码风格 1.操作数的宽度\n在Go汇编中通过指令的后缀来判断操作数的宽度，后缀W代表16位，后缀L代表32位，后缀Q代表64位，不像Intel汇编中有AX、EAX、RAX不同的寄存器名称。 例如对于整数自增指令，Intel汇编风格的代码如下：\nINC EAX INC RCX 对应的Go汇编风格的代码如下：\nINCL AX INCQ CX 2.操作数的顺序\n对于常见的有两个操作数的指令，Go汇编中操作数的顺序与Intel汇编中操作数的顺序是相反的，源操作数在前而目的操作数在后。\n例如Intel汇编的代码如下：\nMOV EAX, ECX 转换成Go汇编的代码如下：\nMOVL CX, AX 3.地址的表示\n有效地址的计算公式如式(1-1)所示，如果要用ESP作为基址寄存器，EBX作为索引寄存器，比例系数取2，位移为16，则可以分别给出两种风格的代码。\nIntel汇编的代码如下：\n[ESP + EBX*2 + 16] Go汇编的代码如下：\n16(SP)(BX*2) 4.立即数格式\nGo汇编中的立即数类似于AT\u0026amp;T风格的立即数，需要加上$前缀。\nIntel汇编的代码如下：\nMOV EAX, 1234 Go汇编的代码如下：\nMOVL $1234, AX 1.5 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC1%E7%AB%A0-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/","summary":"1.1 x86通用寄存器 32位x86是intel推出的,64位x86_64是amd推出的(amd64) 1.1.1 32位架构 在汇编中使用名称来引用寄存器. 表","title":"第1章 汇编基础"},{"content":"构建适合自己的盈利体系 对普通投资者来说，要构建什么样的盈利体系呢？\n首先，它要适合自己的能力圈。对普通投资者来说，学习基本面投资的方法，在自己熟悉的行业或领域内坚持价值投资，是很好的盈利方法。 其次，它要逻辑自洽。 再次，它要符合市场规律和趋势。 最后，它要可持续、可复制。 投资的2.5分原则——接受不完美的股票 满足 \u0026ldquo;好赛道+好公司+好估值\u0026rdquo; 的股票几乎不存在.\n不一定非要找到得3分的股票才投资，得2.5分的股票也可以考虑。得2.5分的股票，是满足3个条件中的两个，其中一个条件不太差、不得零分的股票。 让我想起了 CAP定理\n具备常识和逻辑能力 常识例子\n在基本面不变的情况下，买入的价格越低，风险就越低，未来的投资回报就越高 “十送十”、“十送二十”这样的“高送转”，只是数字游戏，对股票的投资价值没有任何影响 投资者的持仓成本不影响股价未来的涨跌 感悟\n投资无法偷懒，想做好投资必须勤奋 做投资一定要避免管中窥豹，避免利用局部的信息直接做出投资决策，完整、详尽的研究非常有必要 要做可预测性强的决策 预测链条越长，可预测性就越差. 预测宏观经济 -\u0026gt; 预测行业周期 -\u0026gt; 预测公司基本面 影响因素越多，预测越难. 股票指数, 宏观经济、货币政策（流动性）、大国关系、海外市场、大宗商品价格、市场情绪、监管政策等 影响因素的可变性越强，预测越难. 国际关系 价值投资是预测链条短, 影响因素少且相对稳定的投资方法. 把预测变量范围缩小至单个公司，而且只选择有护城河的龙头公司进行跟踪和预测，大 大降低了预测的难度 模糊正确和精确错误. 很多时候大家会陷入过于在意细节的旋涡, 而忽视更高维度的信息 资金性质决定投资策略 如果资金期限足够长，投资策略就可以关注行业的长期趋势、企业的长期竞争力和发展空间，忽略短期的股价波动。 如果资金规模大，投资策略就要求所投资的领域有较大的市场容量，构建资产配置方案并多元化投资。 如果资金期限短、规模小，投资策略应偏向于趋势投资、短期博弈，更关注短期的机会。 投资中安全边际极度重要 股票内在价值与市场价格之间的差距，就是安全边际。 价值投资者是利用市场的非理性和错误定价，在资产价格低于其潜在价值时买入该资产，这样就获得了安全边际。 择时不靠谱 杠杆是价值投资的大敌. 如果你加了杠杆，就有期限限制，就有止损机制，这时候时间不再是你的朋友，而是你的敌人。 区分能力和运气. 当你没有至少5年的业绩来证明的时候，你就不能认为自己能力有多强。 投资中“昂贵”的一句话: 这次情况有所不同！ 不看后视镜开车，拥挤的地方不去，不懂的股票不碰 善于第二层次思维 例子 第一层次思维这样想：这是一家好公司，所以我们可以买这家公司的股票。第二层次思维这么认为：这是一家好公司，市场上很多人也认为它是好公司，所以它 的股价已经很高，它的股票不一定值得买。\n第一层次思维认为：现在经济不好，通货膨胀率很高，股市行情不好，我们要卖股票。第二层次思维认为：现在经济不好，很多人恐慌，都在卖股票，说不定有 买入的机会。\n第一层次思维认为：公司利润下跌，所以我们要卖出股票。第二层次思维认为：这家公司利润确实下跌了，但是它的下跌幅度比大家预期的小，说不定是一个投 资机会。\n第一层思维认为：A股市场是一个投机市，所以基本面研究是没有用的。第二层次思维认为：A股市场确实有很多投机者，也有定价错误，所以我们能用基本面研 究的方法找到定价错误，获得超额收益。\n第二层次思维是帮助大家发现定价错误，而不能代替系统研究和严密决策。\n《投资最重要的事》的核心观点, 霍华德从自己40多年的投资经验中，提炼总结出投资最重要的18件事。\n最重要的不是盲目相信股市总是有效或者总是无效，而是清醒认识到股市相当高效而且相当难以击败，只有真正的高手才能长期战胜市场。 最重要的投资决策不是以价格为本而是以价值为本。 最重要的不是买好的而是买得好。 最重要的不是波动性风险而是永久损失的可能性风险。 最重要的巨大风险不是人人恐惧而是人人都觉得风险很小。 最重要的不是追求高风险高收益而是追求低风险高收益。 最重要的不是趋势而是周期。 最重要的不是市场心理钟摆的中点而是终点的反转。 最重要的不是顺势而为而是逆势而为。 最重要的不是想到而是做到逆向投资。 最重要的不是价格、价值而是相对的性价比，即安全边际。 最重要的不是主动寻找机会而是耐心等待机会上门。 最重要的不是预测未来而是认识到未来无法预测但可以准备。 最重要的不是关注未来而是关注现在。 最重要的是认识短期业绩靠运气、长期业绩靠技术。 最重要的不是进攻而是防守。 最重要的不是追求伟大成功而是避免重大错误。 最重要的不是牛市跑赢市场而是熊市跑赢市场。 坚持简单实用的价值投资 第一，选择简单行业里的好公司。 消费品、公用事业等行业 第二，在股市低迷甚至恐慌时买入。这样大概率就能买到价格比较低、估值比较合理的股票。 第三，组合投资，不集中持股。 第四，耐心持有，做好公司的朋友，等待时间帮助公司实现价值。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%81%9A%E4%B8%AA%E8%81%AA%E6%98%8E%E7%9A%84%E6%8A%95%E8%B5%84%E8%80%85/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%81%AA%E6%98%8E%E6%8A%95%E8%B5%84%E8%80%85%E7%9A%84%E6%8A%95%E8%B5%84%E5%87%86%E5%88%99/","summary":"全书总结","title":"第十章 聪明投资者的投资准则"},{"content":"把股市当作赌场 资本市场的三类钱 聪明钱是那些有深刻洞察力、前瞻判断力的资金。一般来说，聪明钱赚的是上市公司成长的钱。中国A股市场有很多公司给投资者创造了丰厚回报。当然，聪明钱 有时候也会利用人的恐惧和贪婪，在市场低迷时买入，在市场疯狂时卖出，赚一部分其他投资者亏的钱。\n邪恶钱是各类游资，它们不太看公司基本面，善于制造题材和热点，吸引个人投资者跟风，并趁机获利。它们赚的不是上市公司成长的钱，赚的是博弈的钱。它 们赚的钱，基本上是个人投资者亏的钱。\n傻钱，是不懂基本面，不懂估值，无知无畏的钱。A股市场这样的资金很多，而且源源不断。\n图9-1 A股市场生态图 基于错误的原因买入股票 轻信所谓“内部消息”买入股票 因为“题材”买入股票 因为“高送转”买入股票 “高送转”只是一个数字游戏，相当于把一张20元纸币分成两张10元纸币，对投资者没有任何意义 因为股价放量突破买入股票 因为股票连续下跌买入股票 因为喜欢某公司的产品买入其股票 持仓成本影响决策 你应该继续持有还是卖出某只股票，和你的持仓成本、盈亏没有任何关系，只和这只股票未来的涨跌预期有关。\n股票的价格未来会涨还是会跌，取决于基本面和估值 对股价止损，而不是对基本面止损 投资要对基本面止损，而不是对股价止损。\n如果发现自己对一家公司的基本面判断错误，或者一家公司的基本面发生了逆转，这时候你要坚决止损，哪怕自己已经亏了很多钱。 顽固坚持已经失效的策略 表9-1 2016年年底市盈率分布情况（剔除亏损股） 小盘股是否真的意味着高成长? 不管从国内经验看，还是从国际经验看，产业在不断走向集中。而行业龙头，依靠着它的品牌、渠道、规模效应，会获得比小市值公司更高、更确定的业绩增长。\n这两年小盘股溢价正在快速消失。 表9-2 2018年年底市盈率分布情况（剔除亏损股） 随着小盘股溢价消失，小市值的公司越来越多。 表9-3 2016年年底和2018年年底市盈率对比（没有剔除亏损股） 并购或者重组策略，还是好的投资策略吗? 第一，IPO新政实施后，监管部门对并购加强了监管，不再允许随意的并购。 第二，IPO速度加快后，原来因为IPO时间久而被迫选择和上市公司并购的优秀资产，现在自己排队进行IPO。相比并购，IPO对优质资产的股东来说，收益更 大。 我们如何得知公司的并购是否合理呢？\n第一，并入资产是否具有可持续增长能力。 第二，并入资产是否具有协同效应。 第三，估值是否合理。并入资产的估值如果太高，也会损害上市公司股东的利益。 既要绝对收益，又要相对收益 很多投资者在牛市里要相对收益，希望业绩跑赢指数，在熊市里要绝对收益，自己不能亏损，这就既要相对收益，又要绝对收益。\n好公司的股价低，差公司的股价反而高，这种现象叫定价错误。\n盲目相信神秘“主力”和政策 中国股市大部分时间是“疯牛 + 股灾 + 慢熊”的组合。可见，我们不能简单地认为，中国的股市是政策市。 我国政府特别重视关键会议、关键时间点的维稳工作，在维稳工作中，股市维稳是重头戏。重要事件期间，A股却是跌多涨少。 2007年的时候，政府在上半年就开始警惕泡沫过大，2007年5月30日凌晨，财政部突然将证券交易印花税税率由1‰上调至3‰，股市暴跌。但股市短暂调整之 后，一口气从4 000点涨到6 000多点。 我们到底怎么正确看待政府在股市中的作用？\n第一，我们现在股市的盘子越来越大，总市值已经接近60万亿元，这么大的市场，政府调控起来也有难度。 第二，这些年，政府在积累经验，不断进步，大部分时间是不干预指数的，当然，也不可能控制指数的涨跌。 第三，政府要回归本源，要回到强化监管、保护投资者利益上。保护投资者利益，不是操纵股市涨跌，而是加强监管，让信息披露更加透明，让造假公司无处 遁形。当然，市场如果出现极端情况，如出现特别大的股灾，可能影响整个金融体系的稳定，政府也应该果断进行干预。 对于我们做基本面投资的人，除了政策，我们更要关心行业趋势、公司竞争力、财务健康度、估值等基本面因素，这些才是影响公司发展、影响公司长期股价的 根本性因素。\n大部分股票根本就不存在“主力”，在绝大部分情况下，“主力”是大家臆想出来的。\n市场上没有人坐庄，那还有没有所谓的“主力”？股价又是由谁决定的呢？\n股市中有一些持仓量比较大的机构投资者，它们和个人投资者臆想的“主力”是完全不一样的。因为这些机构投资者基本上用的是买入持有策略，很少会走以前 庄家吸筹、打压、拉升、出货的方法。 股价其实是千千万万投资者，即机构投资者和个人投资者共同影响、共同交易出来的。 股价的短期波动有很大的偶然性。 基本面选股，技术面择时 在现实投资中，“基本面”和“技术面”经常水火不相容，根本原因在于基本面和技术指标结论一致的时候，投资者做决策是很容易的，但大部分时候，技术指标发 出的买入或卖出信号，和投资者依据基本面做出的判断，是不一致的。\n图9-4 短线交易中基本面分析的辅助作用 图9-5 基本面投资中技术指标提示预期差 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%81%9A%E4%B8%AA%E8%81%AA%E6%98%8E%E7%9A%84%E6%8A%95%E8%B5%84%E8%80%85/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%8A%95%E8%B5%84%E8%80%85%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/","summary":"把股市当作赌场 资本市场的三类钱 聪明钱是那些有深刻洞察力、前瞻判断力的资金。一般来说，聪明钱赚的是上市公司成长的钱。中国A股市场有很多公司给投","title":"第九章 投资者常犯的错误"},{"content":"压缩其他分支提交到本分支\n1 $ git merge --squash \u0026lt;branch\u0026gt; ","permalink":"https://jdxj.github.io/posts/cmd/git/merge/","summary":"压缩其他分支提交到本分支 1 $ git merge --squash \u0026lt;branch\u0026gt;","title":"Merge"},{"content":"could not read Username for \u0026lsquo;https://github.com\u0026rsquo;: terminal prompts disabled [解决](could not read Username for \u0026lsquo;https://github.com\u0026rsquo;: terminal prompts disabled)\n1 $ git config --global --add url.\u0026#34;git@github.com:\u0026#34;.insteadOf \u0026#34;https://github.com/\u0026#34; ","permalink":"https://jdxj.github.io/posts/cmd/git/config/","summary":"could not read Username for \u0026lsquo;https://github.com\u0026rsquo;: terminal prompts disabled [解决](could not read Username for \u0026lsquo;https://github.com\u0026rsquo;: terminal prompts disabled) 1 $ git config --global --add url.\u0026#34;git@github.com:\u0026#34;.insteadOf \u0026#34;https://github.com/\u0026#34;","title":"Config"},{"content":"识别关键驱动因素 对股价有持续、重要影响的因素\n鉴别信号和噪声，就是要判断某个信息会不会对公司的收入、成本、业绩等产生比较大的持续影响。 不同的行业、不同发展阶段的公司，有不同的关键驱动因素。 驱动因素举例\n互联网初创公司，我们要关注它的App下载量、日活跃周活跃月活跃数据等 对于一些发展初期的电商公司，成交总额很重要 对于连锁行业，我们要看开店数量和坪效 对于服装行业，我们看库存 对于白酒行业，我们看预收账款 除了关心公司本身的经营情况，还要关注重要客户和重要供应商的动态。\n一般来说，上市公司的客户集中度越高，风险越大。 除了跟踪重要客户，投资者还要关心竞争对手的动态。\n对有些公司来说，政策有举足轻重的影响\nPPP公司的商业本质是“类金融公司”，一边大规模负债融资，一边投向能产生稳定回报的资产，通过加杠杆实现高净资产收益率。 PPP公司的关键驱动因素\n（1）企业的融资成本。企业的融资成本越低，PPP公司越赚钱。 （2）所投资产的回报率。企业所投资产的回报率越高，PPP公司越赚钱。 （3）坏账率。坏账率越低越好。 总之，我们寻找关键驱动因素，就要抓大放小，关注主要产品的销量和价格、主要成本的边际变化、主要客户和主要竞争对手的动态和政策的变化。\n跟踪关键驱动因素 我们跟踪关键驱动因素的变化，能帮助我们提前判断公司的业绩变动趋势。\n跟踪关键驱动因素的方法很多，可是普通投资者没有那么多资源和时间，该怎么办？\n一是尽量选择自己能力圈内的公司投资 二是尽量用好那些能得到的资源, 比如上市公司公告、券商分析师的分析报告 三是多做基本调研。跟踪贵州茅台的投资者，可以找经销商交流，这是最直接的信息渠道。 识别和利用预期差 “预期差”是市场还没有充分预期到，股价还没有充分反应。\n表8-1 信号和噪声 正确应对“黑天鹅” “黑天鹅”是负的预期差。\n图8-1 正确应对“黑天鹅”的方法 股票买卖之后，我们要做的事情是：一不“死捂”股票，二不天天盯着K线，而要跟踪关键驱动因素的变化，并结合股价变化，理性做出决策。\n","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9F%BA%E6%9C%AC%E9%9D%A2%E6%8A%95%E8%B5%84%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%B7%9F%E8%B8%AA%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E9%9D%A2%E7%9A%84%E5%8F%98%E5%8C%96/","summary":"识别关键驱动因素 对股价有持续、重要影响的因素 鉴别信号和噪声，就是要判断某个信息会不会对公司的收入、成本、业绩等产生比较大的持续影响。 不同的行","title":"第八章 跟踪股票基本面的变化"},{"content":"设定买入股票的条件 一般来说，买入股票的条件包括股价进入合理区间，一些重要的基本面因素发生积极变化（“催化剂”事件发生）。\n等股价下跌到预期价格时不能马上买入, 要分析下跌原因. 股价下跌的原因有多种，大致有以下几类：\n一是公司基本面没有任何变化，因为大盘下跌，股价跟着大盘跌下来； 二是公司发生了一些事情，这些事情对公司基本面只有很小的影响，但市场放大了悲观情绪，导致股价下跌； 三是公司基本面发生恶化，股价下跌。 经过验证之后，你发现了一家好公司，但你不太确定，需要等待一些因素（如基本面“催化剂”）更加明朗才能判断其是否有投资价值，这时候你也需要等待。\n图7-1 确定和跟踪“催化剂”的流程 只有当“催化剂”事件发生，而且还没有被市场充分消化、还没有充分反映在股价中时，才是买入的机会。\n确定合理的买入金额或者仓位 你要确定合理的买入金额或仓位，确定整体仓位和个股仓位，并事先确定动态调整仓位的方法。\n对绝大多数投资者来说，甚至对绝大多数机构投资者来说，宏观经济就是“重要但是能力圈外”的事情。\n所谓能力圈内的事情，是你能研究清楚、你能跟踪的东西，也就是股票的基本面。\n哪些是重要但不是能力圈内的东西呢？那就是宏观经济、指数、汇率、利率等，投资者花时间研究和预测这些东西，只会事倍功半。\n哪些是能力圈内但不重要的东西呢？比如投资者手中股票的盈亏状况，研究这个很容易，但它与股价未来走势没有相关性，所以我们不必过于关注。但很多投资 者会根据自己手中股票的盈亏状况来决定买卖。\n哪些是能力圈外不重要的东西呢？我认为股票市场的短期波动既不重要，也很难预测，但个人投资者偏偏喜欢预测短期涨跌，天天盯着K线做交易。把时间花在这 些既不重要又是能力圈外事情上的人，很难做好投资。\n股票市场的相对吸引力，我们可以用“全市场市盈率的倒数−5年期国债收益率”来衡量，一般来说这个值在4%以上，股票市场就有吸引力。\n表7-1 一个简明的仓位策略 两种经常被使用的仓位策略\n固定股票比例策略 背后的逻辑是“高抛低吸” 适合比较平稳的市场, 如果遇到大牛市，随着市场不断上涨，你会不断卖出股票，可能会“错失”好时机；如果遇到大熊市，随着市场不断下跌，你会不断补 仓买入股票，你可能要忍受较大幅度的套牢或亏损。 安全垫策略 背后的逻辑是本金不能发生亏损, 等组合有了盈利，再加大风险暴露程度 本质是“追涨杀跌”，适合大波动、大震荡的市场 表7-2 固定股票比例策略和安全垫策略对比 现代组合理论告诉我们，要分散风险，过度集中持股（比如只持有2～3只股票），风险太高。那么，分散到什么程度是合适的呢？有人通过实证分析得出， 20～30只股票就基本能分散非系统性风险。但对于个人投资者来说，资金、时间有限，分散到8～10只股票可能就够了。\n具体到某只股票，确定性越大，空间越大，仓位可以更高。当然，任何一只股票的仓位不要超过总仓位的15%～20%，超过这个比例，风险就有点儿高。 “3—6—9”的个股仓位配置方法\n第一步，当他觉得某公司很不错，但还不是特别确定，就先买入3%的仓位。有了3%的仓位，他就会紧密跟踪这家公司的基本面变化，增加对它的了解。 第二步，当他对这家公司理解加深、更加有信心之后，会把仓位加到6%，这是单只股票的中性仓位。 第三步，当这家公司的基本面有超预期发展，或者估值更有吸引力的时候，他会把仓位加到9%，这是他重仓个股的仓位。 然后使用固定股票比例策略, 控制比例.\n预先设定股票的卖出条件 一般来说，卖出股票的条件包括估值不再有吸引力、基本面恶化，或者你找到了更好的股票。\n道理说起来容易，但实际操作起来并不容易，为什么？\n一是公司基本面发生明显恶化的时候，你会发现股价往往已经跌了不少，因为市场上总有一些投资者比你先知先觉。这时候，你要判断坏消息是否已经充分反 映在股价中，而这很难。 二是公司股价上涨超出你预先评判的合理估值区间，有可能是公司基本面发生了超预期的变化，但你不知道。这时候如果你卖出股票，可能错失了一只大牛股。 不论止盈还是止损，核心是两点，第一要看基本面有没有变化，第二要看估值是不是已经到位了，而不是简单地在涨了多少时止盈，在跌了多少时止损\n三个卖出股票的原因，那就是你发现了一只空间更大、确定性更高的股票，投资者的资金有限，这时候选择换股也是明智之举。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9F%BA%E6%9C%AC%E9%9D%A2%E6%8A%95%E8%B5%84%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%B9%B0%E5%85%A5%E4%B9%8B%E5%89%8D%E5%81%9A%E5%A5%BD%E5%85%85%E5%88%86%E5%86%B3%E7%AD%96/","summary":"设定买入股票的条件 一般来说，买入股票的条件包括股价进入合理区间，一些重要的基本面因素发生积极变化（“催化剂”事件发生）。 等股价下跌到预期价格","title":"第七章 买入之前做好充分决策"},{"content":"Redis setup tips Linux 设置内核参数 vm.overcommit_memory = 1\n表示 Always overcommit 写到 /etc/sysctl.conf 配置中后重启 或者直接激活 sysctl vm.overcommit_memory=1 linux的vm.overcommit_memory的内存分配参数详解 理解LINUX的MEMORY OVERCOMMIT 关闭 Transparent Huge Pages\necho never \u0026gt; /sys/kernel/mm/transparent_hugepage/enabled 避免碎片化访问 page Memory 启用交换区, 大小等于物理内存 配置 maxmemory 选项, 要到达内存限制时报错而不是失败 ","permalink":"https://jdxj.github.io/posts/docs/redis/managing-redis/administration/","summary":"Redis setup tips Linux 设置内核参数 vm.overcommit_memory = 1 表示 Always overcommit 写到 /etc/sysctl.conf 配置中后重启 或者直接激活 sysctl vm.overcommit_memory=1 linux的vm.overcommit_memory的内存分配参数详解 理","title":"Redis administration"},{"content":"How is Redis different from other key-value stores? 拥有复杂的数据类型, 及其上的原子操作 是可持久化的内存型数据库, 在数据集比内存大的限制下可以权衡读写速度 What\u0026rsquo;s the Redis memory footprint? 空实例~3MB 1百万小 key 的 string 类型~85MB 1百万个有5个字段的 hash ~160MB What happens if Redis runs out of memory? 不接受写, 但是可以读 可以配置 key 淘汰策略 How can Redis use multiple CPUs or cores? Redis 通常受内存和网络的限制 如果想使用多个 CPU, 那么应该今早使用 Redis Cluster Redis 未来会越来越线程化 What is the maximum number of keys a single Redis instance can hold? What is the maximum number of elements in a Hash, List, Set, and Sorted Set? 理论上2^32个 key, 经过测试可以保存2.5亿个 key hash, list, set, sorted set 每种类型可以保存2^32个 key Where does the name \u0026ldquo;Redis\u0026rdquo; come from? REmote DIctionary Server.\nHow is Redis pronounced? /ˈrɛd-ɪs/\n","permalink":"https://jdxj.github.io/posts/docs/redis/getting-started/faq/","summary":"How is Redis different from other key-value stores? 拥有复杂的数据类型, 及其上的原子操作 是可持久化的内存型数据库, 在数据集比内存大的限制下可以权衡读写速度 What\u0026rsquo;s the Redis memory footprint? 空实例~3M","title":"Redis FAQ"},{"content":"原文\n在提问之前 尝试在你准备提问的论坛的旧文章中搜索答案。 尝试上网搜索以找到答案。 尝试阅读手册以找到答案。 尝试阅读常见问题文件（FAQ）以找到答案。 尝试自己检查或试验以找到答案。 向你身边的强者朋友打听以找到答案。 如果你是程序开发者，请尝试阅读源代码以找到答案。 在邮件列表或新闻组寻求帮助时加上一句 我在 Google 中搜过下列句子但没有找到什么有用的东西 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮 助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。\n好问题是答者的回报\n当你提问时 慎选提问的论坛 如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：\n在与主题不合的论坛上贴出你的问题。 在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。 在太多的不同新闻群组上重复转贴同样的问题（cross-post）。 向既非熟人也没有义务解决你问题的人发送私人电邮。 网站和 IRC 论坛 第二步，使用项目邮件列表 当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。\n使用有意义且描述明确的标题 一个好标题范例是目标 —— 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望 的行为不一致的地方。\n如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题\n使问题容易回复 在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你 只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如追踪此讨论串、有回复时发送邮件提醒等功能。\n使用清晰、正确、精准且合乎语法的语句 使用易于读取且标准的文件格式发送问题 别动辄声称找到 Bug 低声下气不能代替你的功课 描述问题症状而非你的猜测 按发生时间先后列出问题症状 描述目标而不是过程 问题解决后，加个简短的补充说明 如果还是搞不懂 如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需 要对方解释，记得表现出你已经从中学到了点什么。\n处理无礼的回应 很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直截了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。\n如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这没有发生而你却发火了，那么 你发火对象的言语可能在黑客社区中看起来是正常的，而你将被视为有错的一方，这将伤害到你获取信息或帮助的机会。\n另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之 前一定要非常非常的有根据。\n不该问的问题 我能在哪找到 X 程序或 X 资源？ 我怎样用 X 做 Y？ 如何设定我的 shell 提示？ 我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？ 我的程序/设定/SQL 语句没有用 我的 Windows 电脑有问题，你能帮我吗？ 我的程序不会动了，我认为系统工具 X 有问题 我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？ 如果得不到回答 如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。\n","permalink":"https://jdxj.github.io/posts/articles/ryanhanwu/how-to-ask-questions/","summary":"原文 在提问之前 尝试在你准备提问的论坛的旧文章中搜索答案。 尝试上网搜索以找到答案。 尝试阅读手册以找到答案。 尝试阅读常见问题文件（FAQ）以找到","title":"How to Ask Questions The Smart Way"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/polarisxu/go1.18%E5%BF%AB%E8%AE%AF-%E6%96%B0%E7%9A%84ip%E5%8C%85/","summary":"原文","title":"Go1.18快讯 新的IP包"},{"content":"用“望远镜”验证公司的赛道 好股票的标准可以用“好赛道+好公司+好价格（估值）”来概括\n什么是赛道？赛道是公司所处的行业或者业务领域。\n赛道吸引力是最重要的基本面之一 图6-1 2001—2017年贵州茅台和张裕的业绩和股价 白酒赛道为什么要比其他酒的赛道好？\n首先，白酒是受我国文化影响很大的行业，没有外国产品的竞争。白酒相对于其他酒有不同的地位，它具有悠久的历史和独特的民族文化内涵，这也是白酒 行业的壁垒和护城河。 其次，白酒是一种情感消费，消费者除了考虑口感等因素，更多考虑的是社交需求、面子需要。中国是一个强社交的社会，使得白酒消费呈现不完全追求 “性价比”的特点。 最后，白酒没有库存问题。白酒行业有一个与其他行业不一样的特点，消费者认为白酒储藏的时间越久，会越香醇、越值钱。所以白酒企业不用担心库存管理。 验证公司所处的“赛道”好不好，我们需要看得远一些，不能只看公司目前的收入和盈利状况。\n戴维斯双击、戴维斯双杀与赛道紧密相关。\n市盈率=股价/利润，那么股价=利润×市盈率，行业和公司的发展前景对盈利和市盈率都有影响。 判断清楚公司所处赛道的吸引力如何。我认为可以从两个维度去判断：第一个维度看它所在的赛道的空间有多大，第二个维度要看赛道中的竞争状况如何。\n评判赛道的空间 我们在评判赛道好不好的时候，先要分析赛道的发展空间。而我们评判赛道空间，则可以从目前市场容量和未来增长趋势两个维度来考虑：首先看这个行业目前 的容量，是100亿元、500亿元，还是1 000亿元。其次看未来增长的趋势，是向上、稳定，还是向下。\n我们应该怎么去判断赛道空间有多大呢？很简单，我们先上网搜索信息，对行业进行基本了解。搜索之后，我们还有4个方法：一是看招股说明书，二是看券商的 分析报告，三是看一些专业网站，四是和行业内的人谈一谈，获得更多的信息。\n招股说明书是最好的了解行业空间的帮手。招股说明书的特点是，券商和中介机构要对其严格审核，一般很难造假，所以里面的数据都是有来源和依据的，相 对来说可信度是比较高的。缺点是比较陈旧. 但是，越是新股，上市时间离现在越近，我们越要看招股说明书。 看业务和技术部分. 这个部分是讲这家公司所在行业的前景如何、行业规模有多大等。 图6-3 景旺电子所属行业状况 券商报告、专业网站及行业专家是不错的辅助工具。除了招股说明书，我们还要看券商报告，看券商研究报告的窍门是什么呢？我们看券商研究报告，基本原 则是不看它的目标价，不看它的评级，而要看它对行业和公司的分析。 关于专业的资讯网站，我推荐知乎和雪球。 最后的途径是找行业专家了解行业的情况，这个难度最大、成本最高，但效果最好。一般券商组织的策略会会邀请细分行业的专家来演讲，这是最好的积累行 业知识的机会，只是参与难度比较高。 对不同赛道的不同关注点 分析赛道的三个维度: 消费, 周期, 成长\n消费 消费品的需求是最稳定的。\n消费行业为什么容易出现长期牛股呢？\n第一，消费行业的周期属性相对较弱，经营业绩不太受宏观经济周期的影响。 第二，消费品公司经过长期经营和资金投入形成较强的品牌壁垒和规模优势，获得了行业垄断地位，且这种垄断地位相对稳定。 消费品公司一旦形成品牌护城河和规模护城河，不太需要进行持续的大规模资本支出，也不太容易被新技术、新模式颠覆 图6-4 菲利普-莫里斯国际股价走势图 在投资消费品公司的时候，要注意它们的品牌护城河是否被侵蚀（品牌老化），这是消费品公司的大敌。\n成长 在研究科技股的时候，我们要着重关注需求和技术：只有下游的应用空间足够大，公司所处的赛道才会足够宽敞；只有公司持续进行研发投入，公司才能在未来 新技术上占得先机。\n周期 周期股受宏观经济影响大，即受需求波动影响大，而产品价格和产能利用率的波动会严重影响公司业绩。\n周期性行业的强周期来自哪里？\n一是需求本身就有周期。周期性行业的需求，受宏观经济影响很大，宏观经济本身有周期，即需求本身就有周期。 二是周期性行业往往是重资本行业，沉没成本很高，虽然竞争激烈的产品已经不盈利，但只要产品价格大于变动成本，企业就有继续生产的动力。这导致周期 性行业产能退出很难。 三是周期性行业产品往往无差异化，企业属于同质化竞争，一旦供过于求，价格战是唯一手段。 四是周期性行业都是顺周期扩张产能，当宏观经济繁荣度下滑时，市场对产品需求降低，但之前的新增产能却陆续完成，供给过剩的问题越发严重，全行业陷 入恶性竞争。 评判赛道的竞争格局 关注市场集中度 市场份额是我们所说的市占率，它表示公司收入占行业收入的比重，比重越高，说明公司在行业中地位越高。 而集中度是指该行业内前几家大公司所占市场份额的总和，一般我们认为CR4（行业排名前4的公司的累计市场占有率）小于30%～40%，则该行业为竞争型； 而如果CR4大于等于30%～40%，则该行业为寡头垄断型。 图6-5 乳制品行业竞争格局 关注新进入者的挑战 即使在一个已实现寡头垄断的行业，面对全新商业逻辑的新进入者，我们同样要注意相关的竞争状况。\n图6-6 中国咖啡市场份额分布情况 图6-7 中国咖啡市场规模和平均年复合增长率 关注价格战的激烈程度 “价格战”是企业之间通过竞相降低商品的市场价格展开的一种商业竞争行为，其主要内部动力有市场拉动、成本推动和技术推动，目的是打压竞争对手、占领更 多市场份额、消化库存等。\n容易打价格战的行业\n航空 味精 黑电行业 关注上下游是否强势 强大的上下游是企业的噩梦。一家公司的上下游越集中、越强大（强大的上游客户可以随时涨价甚至断货，强大的下游客户可以随时找到竞争对手来替代），这 家公司定价权就越弱，盈利能力和盈利前景就越差。\n手机零部件 -\u0026gt; 苹果 沥青行业 -\u0026gt; 防水涂料 -\u0026gt; 房地产行业 英特尔 -\u0026gt; 浪潮信息(一个公司) -\u0026gt; 阿里云 因为议价能力都很强的上下游可能会压制赛道，所以我们在评估赛道时，一定要考虑到这一点。当你所研究的公司有强大的上下游时，你一定要想一想，这家公 司有没有反制上下游的核心能力。\n大行业小龙头和小行业大龙头 表6-2 大行业小龙头和小行业大龙头的区别 不同的股票由于它的行业空间不一样，适合的投资者也是不一样的。成长型投资者，更喜欢大行业小龙头。价值型投资者，更喜欢小行业大龙头。对于大行业小 龙头，市场往往会给更高的估值。\n用“透视镜”寻找公司的护城河 表6-3 五粮液和贵州茅台的财务数据对比 护城河指的是企业在相当长的一段时间内无法被模仿被替代的竞争优势。护城河是把竞争对手挡在外面的东西。\n当你看到一家公司盈利能力很强的时候，一定要问两个问题：“它凭什么能做得这么好？未来它是否能持续做好？”这两个问题都是关于公司护城河的。 我们判断公司有没有护城河、有什么样的护城河，一定要透过收入、利润、增长率等表象，找到真正让这家公司持续保持高盈利能力的东西。 哪些是公司的护城河呢？品牌、网络效应、成本优势、高客户转换成本以及渠道优势，是常见的护城河，一家优秀的公司至少要具备其中一项。\n品牌 品牌作为无形资产，能给企业带来宽广的护城河。有品牌影响力的企业，产品畅销，拥有强大的定价权，能让消费者为品牌支付更高的价格，利润率更高。\n贵州茅台无疑是品牌护城河最深的公司之一\n图6-8 2008—2019年贵州茅台的股价走势 图6-9 2008—2017年贵州茅台的毛利率 贵州茅台如此高的毛利率，如此强劲的利润增长，为什么没有竞争对手模仿它，和它竞争？茅台酒成本这么低，为什么有那么多消费者愿意花高价购买？核心在 于品牌影响力。贵州茅台由于悠久的历史、独特的酿造工艺，在消费者心中成为高端白酒的代名词。\n即使公司有品牌，我们还要跟踪和判断：品牌会不会老化？会不会被消费者抛弃？\n百雀羚 雅戈尔 杉杉 网络效应 网络效应，或者说“双边效应”，一旦形成，是最深的护城河。什么是网络效应？如果一家平台公司，随着用户人数的增加，用户之间发生交易的可能性和频率是 以几何级数增加的，这就是网络效应。而网络效应一旦形成，无论是供给端，还是需求端，都会被牢牢吸附在这张网络中，很难脱离，在这种黏性下，供需两端 的迁移成本都是巨大的。而这家平台公司，也构成了非常深的网络效应护城河。\n微信 滴滴 Airbnb 具有网络效应的公司面临的最大挑战，一是来自颠覆性的技术或者商业模式；二是来自监管\n“互联网思维”是近几年最热的词语之一，大致意思是“通过免费策略或者用户补贴，获得海量用户，养成用户习惯，之后基于海量用户慢慢变现”。淘宝、滴滴、 美团等互联网巨头，都是“互联网思维”的产物。\n“互联网思维”是有前提的，那就是靠补贴吸引用户，并形成强大的“网络效应”或者“双边平台效应”，才能在没有补贴的时候保持用户黏性，让用户离不开。淘宝 、支付宝、微信、滴滴、美团等，都符合这个特征。\n各种互联网金融平台因为不符合这个特征，所以没有通过“烧钱”的方式形成超级公司。 房地产中介这个行业并不适合互联网思维 第一，房地产交易金额大，又涉及很多环节，线上不能完全替代线下的信任和服务； 第二，房地产交易是较“低频”的业务，靠补贴获得的客户，很长时间才会第二次交易（大部分人一生只进行一次房地产交易）。 成本优势 成本优势, 就是一家公司的产品的成本比另一家的低。如果成本低，公司的产品就可以比竞争对手的卖得便宜，那消费者就会来买这家公司的产品。如果竞争对 手的产品价格和这家公司的一样，那该公司因为成本低能赚到更多利润，更有发展后劲。\n图6-10 格力电器的股价走势 格力电器的毛利率是30%，而行业的平均值是20%；格力电器的净利率是15%，而行业的平均值不到10%。\n格力电器为什么成本低？\n它经营的钱都是借来的，而且借来的钱都不用付利息，什么意思？格力电器的运营资本，要么是原材料供应商的垫资，因为它可以先用几个月的原材料，不付 钱；要么是下面渠道商的钱，格力电器可以先收钱再给渠道商发货。格力电器能无偿占用上下游资金，这是它低成本的秘密之一。 规模效应带来议价权，议价权带来低成本，从而形成格力电器强有力的护城河。 图6-11 海螺水泥的股价走势 海螺水泥的核心竞争力也来自成本端的绝对优势。\n2017年海螺水泥的毛利率是35%，而行业的平均值是30%；海螺水泥的净利率是22%，而行业的平均值是11%。\n海螺水泥的成本为什么这么低？\n因为低廉的矿山成本和公司的规模优势。另外，不得不提的是，海螺水泥独创的T型战略布局。 高客户转换成本 什么是客户转换成本？客户转换成本，既包括金钱，也包括学习成本等隐性成本。如果消费者学习使用新产品和新服务需要大量的时间投入，那么就会降低消费 者转用竞争对手的产品和服务的概率。\n图6-12 广联达股价走势 什么样的产品、公司和行业具有很高的客户转换成本呢？\n第一，制造业里需要经过严格品质认证的产品。比如汽车产业供应链中的公司。汽车行业对安全性要求很高，所以涉及安全的产品，都有严格的进入壁垒。但 产品一旦进入，客户就不会轻易更换供应商，供应商就能获得持续的订单和利润。 第二，消费品领域的公司通过增值服务来留住客户。比如现在的智能手机公司，它们都提供云服务，让用户把照片、通讯录、记事本等免费同步到云上，很大 一个原因是增强用户黏性。用户如果不用它的产品，要处理这些东西很麻烦。 第三，金融服务业. 银行, 因为客户重新开户要填写一大堆表格，而银行卡可能还关联了支付宝、微信、水电费账户、工资账户、房贷账户等，所以很多客户 并不愿意改变。 第四，学习成本特别高的产品，如Office软件等。 渠道优势 拥有更多的渠道，意味着企业能抢占更多与消费者接触的机会，就有可能占有更多的市场份额。所以，对消费品企业来说，渠道优势是非常深的护城河。\n图6-13 苏宁电器（苏宁易购）股价走势（后复权） 在A股市场，拥有渠道优势的公司主要有以下几种类型。\n一是占据流量入口的互联网公司，如阿里巴巴、京东。 二是占据线下流量入口的连锁超市、连锁卖场等，如高鑫零售、永辉超市。三是产品有规模效应，并且和前两者形成战略合作，抢占它们入口的产品方，如海 天味业。 技术领先是不是护城河 乐视之后，谁将可能是下一个破灭的大泡泡？！\n科大讯飞的技术领先能否持续？它的领先技术能不能转化为吸引用户的产品？能不能转化为持续赚钱的商业模式？最后的结论是，单纯的领先技术并不能保证科 大讯飞获得护城河。\n科大讯飞的股价从2017年最高点的近50元，一路下跌到2018年年底的23元 图6-15 科大讯飞股价走势 科大讯飞的领先技术为什么没有形成护城河呢？\n首先，我们来看科大讯飞引以为傲的语音识别技术。它的语音识别技术在多项比赛中蝉联第一，目前在国际领先，但是各大公司的识别率差距并不大，许多公 司的语音识别率都已经达到95%以上，这样微弱的领先优势不足以使科大讯飞形成强大的护城河。 其次，BAT等巨头开始在人工智能领域发力，快速追赶技术甚至赶超，科大讯飞的技术领先优势迅速缩小甚至消失，但BAT的流量、应用场景、资金实力等优 势，是科大讯飞远远不能比的。 最后，科大讯飞的财务报表没有体现高科技公司应有的特点。 曾有财务专家说道：“从财务报表来看，科大讯飞在经营层面是一家快速增长但含金量不高的公司； 在管理层面，是一家扩张很快但效率低下的公司；在财务层面，是一家擅长募资但却不擅长赚钱的公司； 在业绩层面，是一家大手笔花钱但股东回报率低的公司。其光鲜增长的背后，其实隐藏了巨大的风险。” 科技股为什么看上去值得持有，却不是好的长期投资标的呢？原因有以下几点。\n第一，单纯的技术公司的护城河不深。“一招鲜”的领先技术，容易被模仿甚至被超越，一般来说，两三年的技术，基本上已经没有优势。技术只有能落地为产 品能力、营销能力和品牌力，才能给公司创造可观的利润，公司再利用自己的盈利能力，建立起强大的、持续的技术研发能力，才是护城河。海康威视就 是典型的案例。在A股市场，有些公司头顶高科技的光环，如人工智能、生物技术等，但销量和利润却很少。 第二，不少科技公司，在商业模式上称雄，但在核心技术上却受制于人。某基因测序公司 第三，科技股的估值往往偏高。估值高，未来的投资回报率自然就低。 能干的管理团队非常重要 在研究一家公司的时候，我们要注重激励的有效性、长期性，激励不够和过度的短期激励都是公司治理的大敌。\n当心被侵蚀的护城河 护城河消失的原因\n第一个是技术变革。 第二个是行业变迁，即很多的商业模式发生了变化。最典型的是苏宁，原来它是一家非常有实力的公司，在电商的冲击下开始亏损。 第三个是公司的自杀性增长。这是指公司盲目扩张，之前格力电器要做半导体，这让很多投资者不明白，因为半导体需要很大的开支，同时会影响格力电器未 来的分红计划，短期的股价已经证明市场对这一想法不买单。 如何识别公司有无护城河 如何了解公司的核心竞争力呢？\n我们可以看招股说明书、券商报告、专业网站，还可以找行业专家、下游用户等谈一谈， 分析公司核心竞争力可以用指标分析\n市场占有率、主营业务收入增长率、毛利率、净利率、净资产收益率等 还要找几家对标公司进行比较分析 表6-4 不同行业和不同竞争力公司的估值情况 但是A股市场经常是反过来的情况，很多公司，所属行业很差，自身也没有竞争力，但是市盈率很高，有80倍，甚至100倍，所以从基本面投资的角度，我们就不 要购买这种股票。反过来，有些不错行业的龙头公司，有很强的核心竞争力，估值却很低，这说明市场定价是错的。 市场出错时，就是我们投资机会出现的时候。\n用“显微镜”检验公司财务状况 所有的定性研究和定性逻辑都要落实到公司的财务数据上，我们要学会用财务指标来验证公司到底经营得怎么样。\n简单了解3张报表 （1）资产负债表: 反映的是某个特定时点公司的状态。 （2）利润表: 反映了公司在这个时间段里，收入怎么样，支出怎么样，利润怎么样 （3）现金流量表: 反映了公司在这个时间段里, 现金流入和流出情况 表6-5 2017年小王的家庭资产负债表\n总资产: 541万元 净资产(股东权益): 326万元 表6-6 2018年小王的家庭资产负债表\n总资产: 525万元 净资产(股东权益): 325万元, 净资产减少1万元 表6-7 2018年小王的家庭收入支出表\n全年收入: 35万元 全年支出: 36万元 多支出1万元对应净资产减少1万元 现金流量是一个公式: 年末的现金余额=年初的现金余额 + 当年的现金流入 - 当年的现金流出\n不太明白为啥要用公式算, 年末时应该也能查到账户上有多少现金吧.\n表6-8 2018年小王的家庭现金流量表 注意\n15万元本金是要还银行的钱, 所以不在利润表 利息是成本, 要进利润表 8万元亏损要进利润表, 但没有现金流出, 所以不在现金流量表 四大维度验证公司质地 成长能力、盈利能力、经营效率和经营风险。\n判断成长能力的指标有哪些？\n比如主营业务收入增长率、营业利润增长率和净利润增长率。 反映公司盈利能力的指标有哪些？ 毛利率、净利率和净资产收益率等。 反映公司经营效率的指标有 周转率、存货周转率、应收账款周转率、固定资产周转率等。 反映公司经营风险的指标 主要是负债率等。 如何评估公司的成长能力 评估公司的成长能力的指标，主要有主营业务收入增长率、营业利润增长率和净利润增长率。\n当年的增长率和过去3～5年的平均或复合增长率的计算公式为： A股市场上市公司的平均增长率水平, 大部分年份的增长率在5%至10%这个区间。\n图6-16 A股市场上市公司增长率情况 投资者不仅要看整个A股市场，还要和同行业公司做具体比较。如果同行业公司的增长率都在30%以上，那即便是20%的增长率，也是低速增长。\n我们还要分析一些异常因素，这些异常因素会导致增长率的失真。\n借壳. 分众传媒, 2013~1014借壳七喜控股 图6-17 分众传媒归母公司净利润 重大资产重组. 天润数娱，原名是天润控股, 2016年第二季度实现并表 图6-18 天润数娱归母公司净利润 非经常性损益, 是指和企业的主营业务没有直接关系的各项收支。 广东甘化, 表6-9 广东甘化净利润 从财务角度来看，公司创造价值的最佳衡量指标是投入资本回报率，它直接反映了公司投入和产出的效果。一家公司的投入资本回报率只有大于投入资本的资金 成本时，它才真正创造价值。只有在这样的前提下，成长才是有质量的。\n如何评估公司的盈利能力 毛利率、营业利润率以及净资产收益率\n1 毛利率 =（主营业务收入 - 主营业务成本）/主营业务收入×100% 表6-10 云南白药营业收入 表6-11 云南白药营业成本 图6-19 A股市场上市公司毛利率情况 表6-12 两面针主营业务分产品情况 1 2 营业利润率=营业利润 / 营业收入 × 100% 营业利润=营业收入 - 营业成本 - 营业税金及附加 - 管理费用 - 财务费用 - 资产减值损失 + /- 公允价值变动收益/损失 + 投资收益 营业利润可以在公司的利润表里直接找到这一项\n表6-13 云南白药和两面针的营业利润率对比 图6-20 A股市场上市公司利润率情况 1 净资产收益率=净利润 / 股东权益(净资产) 这个指标反映的是股东投入资金的回报率\n表6-14 云南白药和两面针净资产收益率对比 云南白药的盈利优势\n一方面是云南白药的秘方以及它的商标权，这使得它的品牌优势比较明显，定价可以比竞品高很多； 另一方面是云南白药“轻资产 + 快速周转”的类消费公司的经营模式。 1 市净率 =股价 / 净资产 中国A股市场有很多高净资产收益率公司，它们的市净率反而低；很多低净资产收益率公司，包括很多垃圾股，它们的市净率反而高. 我们投资一定要远离那些净资产收益率很低，但市净率很高的公司。\n图6-21 A股上市公司净资产收益率情况 我们在计算净资产收益率的时候，要把非经常性损益扣除掉。\n如何评估一家公司的经营效率 用周转率衡量公司的经营效率。\n存货周转率、应收账款周转率、固定资产周转率 一般来说，存货周转率越高越好。\n1 存货周转率=销货成本 / 平均存货余额 × 100% 这个比率也是越高越好，应收账款周转率越高，表明产品销售情况越好，公司就不需要通过赊销这样的方法提高销量。\n1 应收账款周转率=赊销净收入 / 平均应收账款余额×100% 固定资产周转率反映公司固定资产的使用效率。固定资产周转率越高，表明公司对厂房和设备等固定资产的利用效率越高。\n1 固定资产周转率=营业收入 / 固定资产净值×100% 表6-15 6家调味品公司的经营指标对比 如何评估一家公司的经营风险 建议大家看两个指标，一个是资产负债率，另一个是有息负债率。\n图6-22 负债是一把双刃剑 图6-23 公司资产负债表 1 公司的资产负债率 =（无息负债 + 有息负债）/总资产×100% 一般来说，这个比例在60%以内算是合理的。如果这个比例超过80%，也就是负债金额是所有者权益的4倍以上，那么公司的经营风险就偏高了。\n无息负债在整体负债中的占比越高，说明公司对供应商和经销商的谈判地位越高、控制能力越强。\n表6-16 贵州茅台和五粮液预收账款占比 识别财务欺诈 两个概念\n盈余管理，是公司合理合法地利用制度和规则，对财务数据进行适当“美容”，这是在制度和规则允许的范围之内做的。 财务造假包括报表粉饰、管理舞弊、会计欺诈，是超出制度和规则范围的。 做高收入和做低成本是主要的造假方式 图6-24 常见的财务造假动机 提高收入的手段比较多，比如通过关联交易增加营业收入，提前确认营业收入等。 降低成本的手段也很多，比如通过管理方支付本应由公司支付的成本，延后确认成本等。 我们建议多看几年的财务报表，因为持续造假超过5年是不容易的。我们只有分析了某公司连续5年以上的财务报表，才能看清楚它的真正经营情况。\n表6-17 2013—2015年乐视研发费用资本化情况 乐视对影视剧版权采购费采取直线摊销法\n如果按照收入和成本匹配原则，它就应该使用加速法来进行摊销，也就是第一年多计算成本，以后年份少计算成本，而不是每年平均计算成本。 表6-18 2013—2015年乐视版权费用摊销情况 财务“洗澡” 公司本年度大幅计提固定资产损失，未来几年就无须再计提固定资产损失。商誉、应收账款、存货、权益投资等都可以成为业绩“大洗澡”的计提项目。\n图6-25 业绩粉饰常见方法 财务“洗澡”什么时候发生？\n一种情况，公司当年的亏损已经不可避免，反正是亏，公司就进行一次性亏损。我们的监管制度规定，上市公司不能连续亏损，连续亏损要被ST、要退市，但 监管制度未规定一次能亏多少钱。 另一种情况，公司管理层换人，首席执行官上任后，发现公司有很多问题账，就让公司在当年一次性亏损，因为责任全在前 任首席执行官身上，这种现象是 较普遍的。 表6-19 2013—2015年4家ST公司的财务数据 表6-20 2018年预告大幅商誉减值的公司 如何发现财务造假 首先，我们可以对同行业的公司进行对比分析，识别潜在的造假。 其次，我们不要只盯着利润表，也要留意资产负债表。财务造假的目标是提高收入和利润，但改变了利润表的项目，一定会对资产负债表产生影响。这是因为， 通过造假使得利润虚增，资产负债表中的所有者权益也应该增加。所有者权益增加后，相应的资产就要增加，否则资产负债表就无法配平。 最后，还有一些信号，大家一定要重视。 第一个信号是财务总监辞职，这可能说明财务总监对造假感到害怕。 第二个信号是公司更换会计师事务所，这往往意味着会计师事务所可能不愿意配合上市公司做账，或者公司另外找到一家愿意配合的会计师事务所。 第三个信号是会计师事务所发表了保留意见或者拒绝发表意见，这表明这家公司基本上是造假了。因为一般来说，会计师事务所都会出无保留意见，也就是 说报表是真实的，没有问题。会计师事务所如果发表了保留意见或拒绝发表意见，表明这家公司的财务报表应该有大问题。 用“公平秤”评估股票性价比 常见的估值方法 推荐大家看达莫达兰（Damodaran）的《估值》（The Dark Side of Valuation）这本书\n原始成本估值法\n原始成本是资产被取得时所支付的对价。 原始成本估值法是不合理的，在现实的估值中几乎用不到。 上市公司报表里的很多资产，如房地产、土地使用权等，是按照原始成本入账的，有时候这些资产是被严重低估的。 重置成本估值法\n重置成本是重新取得相同或类似资产所需要支付的对价。 房地产公司经常用重置成本估值法 也很少用 绝对估值法\n绝对估值法，也叫“地老天荒”的现金流贴现法，是把未来某只股票能产生并分配给投资者的现金流贴现到今天的价值。 做估值的时候，会假设这家公司会永续经营下去 表6-21 不同贴现率下的房子估值 绝对估值法的挑战有两个：\n一是对股票的未来现金流预测很难； 二是贴现率差一点儿，结果就会差很多。 合理的贴现率到底应该是多少呢？\n经验数据是：5年期的国债收益率 +（3%～5%）。这里的3%～5%是“风险溢价”。 绝对估值法有缺点。\n其中的假设和预测，投资者很难学习。 当你用绝对估值法去衡量股票的时候，你会发现绝大部分股票的价格，都比它算出来的绝对估值要高，这时候你找不到可买的股票。 相对估值法\n是以类似资产在市场上的定价为基础，进行比较估值。 表6-22 绝对估值和相对估值的区别 具体到股票投资，相对估值法可以分为3个步骤：\n第一，选取可比公司 选取的可比公司有两个标准：第一，要有可比性；第二，要有足够的代表性。 第二，选取并计算比较指标 市盈率（市值/净利润） 市销率（市值/营业收入） 市净率（市值/净资产） 第三，根据公司质地调整估值。 行业内公司的竞争力、发展前景、盈利稳定性的差异还是很大的，这时候你要根据公司的竞争力、发展前景、盈利稳定性等情况，对估值进行适当调整。 表6-23 白酒行业各公司的估值情况 相对估值的问题\n一旦市场整体被严重高估或者被严重低估，某家公司的估值也就会跟着被高估或者被低估 无法对公司成长能力等进行准确估值 综合应用绝对估值法和相对估值法 绝对估值法，用来确定“安全边际”，也就是确定绝对估值有吸引力的公司，长期“估值有吸引力”，才有安全边际。相对估值法用来进行“个股选择”，确定相对估 值低的公司，即在可比公司中性价比较高的公司。\n表6-25 相对估值和绝对估值的应用 影响股票估值的因素 绝对估值: 贴现率(利率水平) 公司成长能力 市盈增长比率，是市盈率除以未来的复合增长率。在计算的时候，增长率不能是1年的数据，至少是3年的复合增长率才有意义。 市盈增长比率的缺点是预测未来的复合增长率很难。 估值和盈利稳定性的关系是，一家公司的盈利越稳定，意味着投资这家公司的风险越小；投资风险越小，贴现率就可以低一点儿，估值就可以高一点儿。\n一个简单易行的“绝对估值法” 公司合理股价=3年后的预测每股利润 × 公司未来合理市盈率3年后的预测每股利润\n表6-27 合理估值区间（单位：倍） 行业成长空间\n如果行业未来8～10年能保持15%左右的增长率，那就属于超高增长行业； 如果未来8～10年能保持10%左右的增长率，那就属于高增长行业； 如果能保持5%左右的增长率，那就属于低增长行业。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9F%BA%E6%9C%AC%E9%9D%A2%E6%8A%95%E8%B5%84%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%9B%E5%A4%A7%E5%B7%A5%E5%85%B7%E9%AA%8C%E8%AF%81%E5%A5%BD%E8%82%A1%E7%A5%A8/","summary":"用“望远镜”验证公司的赛道 好股票的标准可以用“好赛道+好公司+好价格（估值）”来概括 什么是赛道？赛道是公司所处的行业或者业务领域。 赛道吸引力","title":"第六章 四大工具验证好股票"},{"content":"错误的使用uintptr转换结果可能被 GC.\n原文\n","permalink":"https://jdxj.github.io/posts/articles/huoding/%E8%81%8A%E4%B8%80%E4%B8%AAstring%E5%92%8Cbyte%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/","summary":"错误的使用uintptr转换结果可能被 GC. 原文","title":"聊一个 string 和 []byte 转换问题"},{"content":"原文 1. Primary Concerns 1.1. Usability 建立惯例使库的特性可发现 潜在的错误使用 易于完成常见任务 Case Study: net/http 看起来有些繁琐\n1 2 3 4 5 6 7 8 9 10 // import \u0026#34;net/http\u0026#34; req, err := http.NewRequest(http.MethodGet, \u0026#34;http://example.com\u0026#34;, nil /* body */) if err != nil { return err } var client http.Client res, err := client.Do(req) // ... 更简单的方法\n1 2 3 // import \u0026#34;net/http\u0026#34; res, err := http.Get(\u0026#34;http://example.com\u0026#34;) 但是不应该使用全局 HTTP Client.\n1.2. Readability 在实现之前写伪代码和文档有助于设计出可读性好的 API. 随着经验的增加可能会减少这个习惯.\n1.3. Flexibility 灵活性决定能否加入新功能来满足新用例, 允许用户自定义和扩展来适应他们的需要.\n生态系统 第三方扩展 Case Study: net/http 1 2 var client http.Client res, err := client.Get(\u0026#34;http://example.com\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 package http type Client struct { // Transport specifies the mechanism by which individual // HTTP requests are made. // If nil, DefaultTransport is used. Transport RoundTripper // ... } type RoundTripper interface { RoundTrip(*Request) (*Response, error) } 封装一层, 添加日志功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type loggingRT struct { http.RoundTripper } func (rt *loggingRT) RoundTrip(req *http.Request) (*http.Response, error) { log.Printf(\u0026#34;%v %v\u0026#34;, req.Method, req.URL) return rt.RoundTripper.RoundTrip(req) } roundTripper := \u0026amp;loggingRT{ RoundTripper: http.DefaultTransport, } client := http.Client{ Transport: roundTripper, } res, err := client.Get(\u0026#34;http://example.com\u0026#34;) 1.4. Testability 不要事后想到可测试性, 而是在设计时.\n2. Backwards compatibility 新版本软件可以使用旧版本软件的数据.\n使用某个库的重要因素是该库承诺后向兼容 绝对的后向兼容有缺点 不能使用语言特性 不能使用标准库的新 API 偿还技术债务 设置向后兼容的范围, 例子\n维护当前和前一版本的 releases 遵循 Semantic versioning 2.1. Breaking changes Go 1 and the Future of Go Programs 给出了一些 breaking changes 定义\n向公开的 interface 添加方法是 breaking change\n2.2. Semantic versioning 1.0之前被视为不稳定版本\n3. Recommendations 3.1. Work backwards 在实现之前要考虑\nAPI 可能的使用方法 能否被误用 如何测试功能符合预期 考虑灵活性以适应未来可能的新需求 API 对输入的要求是什么, 对输出的保证是什么 3.2. Minimize surface area 公开的\u0026quot;表面积\u0026quot;越小, 你的库在实现上会获得很大灵活性 公开的\u0026quot;表面积\u0026quot;越大, 需要保证稳定的东西越多 3.2.1 Internal packages 使用 internal 包减少表面积\n不要在公开的 API 中包含 internal 中的实体 3.3. Avoid unknown outputs 对输入进行严格检查 必要情况下 copy 传入的 slice/map, 以免受元素内部状态变更所导致的问题 函数出错时返回类型的零值\u0026amp;err 考虑返回的 slice 的元素顺序 3.4. No global state 全局状态的缺点\n不易测试 高耦合 减少灵活性 Bad\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var cache map[string]*Value func init() { cache = make(map[string]*Value) } func Lookup(name string) (*Value, error) { if v, ok := cache[name]; ok { return v, nil } // ... v := /* ... */ cache[name] = v return v, nil } Good\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Handle struct { cache map[string]*Value } func NewHandle() *Handle { return \u0026amp;Handle{ cache: make(map[string]*Value), } } func (h *Handle) Lookup(name string) (*Value, error) { if v, ok := h.cache[name]; ok { return v, nil } // ... v := /* ... */ h.cache[name] = v return v, nil } 3.5. Accept, don’t instantiate Bad\n1 2 3 4 func New(fname string) (*Parser, error) { f, err := os.Open(fname) // ... } Good\n1 2 3 func New(f *os.File) (*Parser, error) { // ... } 3.6. Accept interfaces Bad\n1 2 3 func New(f *os.File) (*Parser, error) { // ... } Good\n1 2 3 func New(r io.Reader) (*Parser, error) { // ... } 组合接口\n1 2 3 4 5 6 7 8 9 10 11 type Source interface { io.Reader Name() string } var _ Source = (*os.File)(nil) func New(src Source) (*Parser, error) { // ... } 3.7. Interfaces are forever 对接口的增删改都是 break change.\n3.8. Return structs 返回 struct 而不是 interface 可以获得灵活性和向后兼容能力\nBad\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Client interface { Set(k string, v []byte) error Get(k string) ([]byte, error) } type clientImpl struct { // ... } func (c *clientImpl) Set(...) error func (c *clientImpl) Get(...) ([]byte, error) func New(/* ... */) Client { return \u0026amp;clientImpl{ // ... } } Good\n1 2 3 4 5 6 7 8 9 10 11 type Client struct { // ... } func (c *Client) Set(...) error func (c *Client) Get(...) ([]byte, error) func New(/* ... */) *Client { return \u0026amp;Client{ // ... } } 3.9. Upgrade with upcasting 不能给公开的 interface 添加方法\n1 2 3 4 5 6 type Source interface { io.Reader Name() string + Offset() int64 // bad: breaking change } 要创建新的 interface\n1 2 3 4 5 type OffsetSource interface { Source Offset() int64 } 向后兼容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func New(src Source) *Parser { osrc, ok := src.(OffsetSource) if !ok { osrc = \u0026amp;nopOffsetSource{src} } return \u0026amp;Parser{ osrc: osrc, // ... } } type nopOffsetSource struct{ Source } func (*nopOffsetSource) Offset() int64 { return 0 } 3.10. Parameter objects Bad\n1 2 3 func New(url string) *Client { // ... } Good\n1 2 3 4 5 6 7 type Config struct { URL string } func New(c *Config) *Client { // ... } 3.11. Functional options 1 2 3 4 5 6 7 8 9 package db type Option /* ... */ func Connect(addr string, opts ...Option) (*Connection, error) func WithTimeout(time.Duration) Option { /* ... */ } func WithCache() Option { /* ... */ } 1 2 3 4 5 6 7 db.Connect(addr) db.Connect(addr, db.WithTimeout(time.Second)) db.Connect(addr, db.WithCache()) db.Connect(addr, db.WithTimeout(time.Second), db.WithCache(), ) 3.11.1. How to implement functional options 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 定义 option type connectOptions struct { timeout time.Duration cache bool } // 定义操作 option 的接口 type Option interface { apply(*connectOptions) } // 实现 option 接口 type timeoutOption struct{ d time.Duration } func (t timeoutOption) apply(o *connectOptions) { o.timeout = t.d } func WithTimeout(d time.Duration) Option { return timeoutOption{d: d} } // 默认值 func Connect(addr string, os ...Option) (*Connection, error) { opts := connectOptions{ timeout: time.Second, } for _, o := range os { o.apply(\u0026amp;opts) } // ... } 3.11.2. Planning for functional options 预留\n1 2 3 4 5 6 7 8 // Option configures the behavior of Connect. // // There are no options at this time. type Option interface { unimplemented() } func Connect(addr string, opts ..Option) *Connection 3.12. Result objects 向后兼容的\n1 2 3 4 5 6 7 8 9 10 type UpsertResponse struct { Entries []*Entry } func (c *Client) Upsert(ctx context.Context, req *UpsertRequest) (*UpsertResponse, error) { // ... return \u0026amp;UpsertResponse{ Entries: entries, }, nil } 3.13. Errors 要么返回 err, 要么打印 log, 不要都有 不要使用 pkg/errors, 有性能问题 3.14. Goroutines 不要无限启 goroutine\n处理一个请求所启动的 goroutine 数量应该与请求的内容无关 使用 goroutine 池 注意 goroutine 泄露 应该能够 graceful stop goroutine goleak 3.15. Reflection 谨慎地使用反射.\n3.16. Naming Effective Go \u0026gt; Names What’s in a name? 不要使用 common, util.\n3.17. Documentation 有文档也是采用某个库的重要原因.\n使用文档而不是开发文档 使用段落和列表突出信息 提供例子 不要写没用的注释 3.18. Keep a changelog 面向用户的 changelog changelog 格式 ","permalink":"https://jdxj.github.io/posts/articles/abhinavg/designing-go-libraries/","summary":"原文 1. Primary Concerns 1.1. Usability 建立惯例使库的特性可发现 潜在的错误使用 易于完成常见任务 Case Study: net/http 看起来有些繁琐 1 2 3 4 5 6 7 8 9 10 // import \u0026#34;net/http\u0026#34; req, err := http.NewRequest(http.MethodGet, \u0026#34;http://example.com\u0026#34;, nil /* body */) if err != nil","title":"Designing Go Libraries"},{"content":" A股上市公司数量接近4000只 有研究报告覆盖的公司数量也不超过2000家 第一种武器：跟着券商研报选股 基本方法: 三看两不看\n三看: 一看基本情况分析，二看推荐逻辑，三看财务预测。 两不看: 不看券商研究报告的目标价和评级。 选择研报的窍门\n选择深度报告. 页数多, 或者包含\u0026quot;深度报告\u0026quot;, \u0026ldquo;首次报告\u0026quot;字样 研究员对盈利预测或投资评级进行调整的报告, 往往意味着研究员观点的变化，可能存在“预期差”，也就是存在市场没有意识到的机会 如果有关某公司的报告很久都没有，突然有一篇报告发布，而且是深度报告，这样的报告我们要特别关注。 第二种武器：跟着财报选股 利用财务指标的组合选出潜力好公司\n净资产收益率，企业的赚钱能力 A股的净资产收益率均值现在在7%至8%之间，所以一家公司的净资产收益率能达到15%就不错了。\n表5-1 2009—2018年股价涨幅靠前公司的平均净资产收益率 经营性现金流，企业的盈利质量 一般来说，公司的经营性现金流净额和净利润的比大于1，表示盈利质量高，反之，则表示盈利质量较差。 也可以用经营性现金流入额和公司的销售收入的比值，来考察公司的盈利质量。在实际交易中，由于赊账情况的产生，实际产生的经营性现金流入额要小于销 售收入。两者的比值越接近1，就说明公司资金回笼的速度越快，反之则会造成大量资金的挤压。 表5-3 乐视2015—2017年部分财务数据 市盈率，估值的合理性 用“净资产收益率—经营性现金流—市盈率”3个指标筛选股票的例子\n过去3年净资产收益率连续高于20%，过去3年经营性现金流/净利润大于1，最新市盈率不超过25倍。 预收账款，这个指标是评估公司竞争力和行业最重要的动态指标。\n表5-4 贵州茅台预收账款 如何利用财报中的“管理层讨论”选出潜力好公司。\n财报中的“管理层讨论”主要包含公司管理层对公司过去一年经营情况的概述，以及管理层对未来的行业分析和战略规划。 图5-1 圣农发展2017年年报管理层讨论的部分内容 第三种武器：跟着聪明钱选股 股票市场上总有这样一些资金，它们能在资本市场上先知先觉，赚取很好的投资回报。这类资金被我们称为“聪明钱”。聪明钱一般来自专业机构，包括社保基金、 保险资金、外资，以及知名的公募基金、私募基金的资产等。\n聪明钱的特点\n（1）政策洞察力强。聪明钱团队往往和决策层保持紧密沟通，并对国家各种政策进行持续跟踪。简单来说，大机构对宏观政策面的把握比普通投资者更为深刻。 （2）团队实力强。聪明钱团队的研究、风险控制、投资等流程的分工有序，团队的专业知识和实践经验也是个人投资者所不能比的。所谓“好汉难敌四手”， 就是这个道理。 （3）偏好行业龙头，偏好大而美公司。由于资金庞大，聪明钱偏向选择规模大、流动性强、盈利能力强的大而美公司。如果市值很小，难以容纳大资金，这 样的股票就很难进入机构的核心股票池。 （4）长线投资。聪明钱的资金规模、资金性质决定了团队要做长线投资，大机构的持股周期一般都在2～3年以上，而我们个人投资者往往是追涨杀跌，能持 股几个月就不错了。 （5）逆向投资。聪明钱团队利用人性的贪婪、恐惧和欲望，往往会做出“在市场萧条时进场，在市场繁荣时出场”这种逆向操作的决定。而普通投资者往往会 因为贪婪或恐惧，采取追涨杀跌的方式，让操作处于被动局面。 哪些机构才是聪明钱呢？\n看机构的长期业绩 第四种武器：跟着“内部人”选股 公司内部人士最清楚公司的经营情况，所以内部人，特别是大股东、高管等的大规模增持、回购行为，通常会透露重要信息。\n投资者可以格外关注以下几点，仔细甄别增持、回购是信号还是噪声。\n第一，我们要分析增持的动机。 第二，我们需要关注增持、回购的金额或比例。 第三，我们要结合基本面进行分析。 在跟着“内部人”选股的过程中，我们要注意以下风险。\n第一，我们要注意雷声大、雨点小的增持、回购。A股市场中那些只有上限没有下限的增持回购计划，我们要警惕，因为这些计划基本都不靠谱。 第二，我们要注意假增持、假回购。 第三，我们要格外注意公司的基本面，如果公司的基本面已经恶化，不管内部人是何种意图去增持、回购公司股票，我们都应该绕道，避开风险个股。 第五种武器：跟着生活经验选股 留意日常 坚持能力圈原则 要学会区别信号和噪声 第六种武器：跟着新闻选股 看新闻，是每个投资者必备的一项技能。\n以下几类新闻值得投资者格外关注。\n第一，国家政策类新闻需要格外关注，因为政策对行业、市场可能有非常重要的影响。例: 供给侧改革 第二，国家领导人调研考察类新闻需要格外关注，因为这表明国家对某公司、行业的重视。例: 国家领导人首次调研考察徐工机械 第三，行业性新闻需要格外关注，因为行业格局的变化也会带动一大拨机会。例: 以药养医 每个人接收的投资信息却差异巨大，区别在哪里？\n一是区别信号和噪声的能力。 二是判断股价是否已经提前反应的能力。 三是从 A 推导出 B 的逻辑推理能力。 根据新闻选股，投资者需要长期的知识积累和高度的敏感性，这样才能洞察其中的机会。\n第七种武器：跟着专业投顾团队选股 股票投顾市场通常有两大派：一派是传统的投顾服务，另一派是机构研究服务。投顾和研究员之间的差别，就像全科医生和专科医生的差别。\n服务团队所在公司持有证监会颁发的证券投资咨询执照，服务人员拥有投顾职业编号，这是投顾提供服务的基本要求，投资者也可以据此排除一大批冒牌投顾。\n好的投顾\n专业的投顾服务是帮助客户做好资产配置并构建股票组合，而不是单纯推荐某只股票。 在构建股票组合的过程中，投顾要充分了解客户的风险承受能力，帮助客户构建适合自己、匹配自己的股票组合。 在资产配置和构建组合的过程中，投顾一定要坚持“长期投资”原则，而不是短线博弈。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9F%BA%E6%9C%AC%E9%9D%A2%E6%8A%95%E8%B5%84%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%80%89%E5%87%BA%E6%BD%9C%E5%8A%9B%E5%A5%BD%E8%82%A1%E7%A5%A8%E7%9A%847%E7%A7%8D%E6%AD%A6%E5%99%A8/","summary":"A股上市公司数量接近4000只 有研究报告覆盖的公司数量也不超过2000家 第一种武器：跟着券商研报选股 基本方法: 三看两不看 三看: 一看基本情况分","title":"第五章 选出潜力好股票的\"7种武器\""},{"content":"“知—择—行”，构建自己的投资体系 知\n清楚自己的能力圈, 包括专业背景, 知识结构 清楚自己的风险承受能力, 年龄, 收入, 投资占收入和其他资产的比重 形成对股票市场的正确认知, 2016年开始, 基本面的作用越来越大 择\n了解各种盈利体系的适用性 没有大涨大跌的平衡市 大幅震荡的波动行情 价值风格盛行的行情 了解各种盈利体系的风险度 评判所建立的盈利体系和你的能力圈及风险承受能力是否匹配 行\n知行合一. 在实际投资中，你遇到的最大挑战是，当你的投资方法论遭遇困难，特别是投资非常不顺的时候，你开始对自己的盈利体系产生怀疑和动摇。这时 候你该怎么办？这时我们要有良好的心态，并坚持自己的体系。 “与时俱进”要求我们经常回顾和评估自己的方法论是否满足市场的发展趋势，以及自己是否真正执行了既定策略。 股市新常态下，基本面投资体系的重要性 A股市场进入新常态的原因\n第一，中国经济进入新常态。首先，中国经济从高速增长阶段进入中速增长阶段，以前动辄8%甚至10%以上的高增长率一去不复返，取而代之的是6%甚至更低 的增长率。其次，结构优化、结构升级取代速度增长，成为中国经济的主旋律。 第二，上市公司发展进入新常态。随着中国经济进入中速增长，很多产业的增长空间变得有限，产业的竞争格局变得相对固化，行业内更多是“存量竞争”的状 态。与此同时，中国股市开始进入“良币驱逐劣币”的阶段。 第三，股市环境进入新常态。市场化、国际化、法制化正在深刻影响着中国股市的生态，推动中国股市越来越健康地发展。在这样的背景下，A股市场的投资 理念、投资风格一定会越来越向成熟市场靠拢。 投资的目的是盈利，追求长久、可持续的盈利。所以我们选择价值投资，用价值投资的可复制性来维持盈利的可持续性。而价值投资可复制的根本原因，是价 值投资逻辑简单，交易不拥挤。\n价值投资的核心逻辑是寻找“好赛道+好公司+好价格”的股票, 其需要考虑的变量相对较少，而且变量相对稳定、相对容易把控。 而其他很多投资方法论，影响决策的变量特别多，比如宏观经济、大宗商品价格、汇率和美国经济等多种“重要但难以预测”的因素。投资者考虑这些因素的难 度更大，成功更多靠运气，而不是靠体系和能力。 价值投资看上去很简单，但为什么追随巴菲特的投资者如此之多，做到的却寥寥无几呢？\n因为价值投资需要极强的忍耐力：对股价回撤的忍耐力，对股价长期不涨的忍耐力。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%8E%E6%97%B6%E4%BF%B1%E8%BF%9B%E5%8F%91%E5%B1%95%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/","summary":"“知—择—行”，构建自己的投资体系 知 清楚自己的能力圈, 包括专业背景, 知识结构 清楚自己的风险承受能力, 年龄, 收入, 投资占收入和其他资产的比重 形","title":"第四章 与时俱进发展自己的盈利体系"},{"content":"示例表 使用例子\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT 1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | No tables used | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ 1 row in set, 1 warning (0.01 sec) 各列作用\n列名 描述 id 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id select_type SELECT关键字对应的那个查询的类型 table 表名 partitions 匹配的分区信息 type 针对单表的访问方法 possible_keys 可能用到的索引 key 实际上使用的索引 key_len 实际使用到的索引长度 ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 rows 预估的需要读取的记录条数 filtered 某个表经过搜索条件过滤后剩余记录条数的百分比 Extra 一些额外的信息 例表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CREATE TABLE single_table ( id INT NOT NULL AUTO_INCREMENT, key1 VARCHAR(100), key2 INT, key3 VARCHAR(100), key_part1 VARCHAR(100), key_part2 VARCHAR(100), key_part3 VARCHAR(100), common_field VARCHAR(100), PRIMARY KEY (id), KEY idx_key1 (key1), UNIQUE KEY idx_key2 (key2), KEY idx_key3 (key3), KEY idx_key_part(key_part1, key_part2, key_part3) ) Engine=InnoDB CHARSET=utf8; 假设有两个和 single_table 表构造一模一样的 s1、s2 表，而且这两个表里边儿有10000条记录，除 id 列外其余的列都插入随机值。\n各列详解 table explain 中的每条记录对应某个单表访问方法, table 就表示所访问的表\n一条查询语句 1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) join 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | Using join buffer (Block Nested Loop) | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ 2 rows in set, 1 warning (0.01 sec) id sql 语句中每出现一个 select, 就会分配一个 id\n只有一个 select 语句 1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.03 sec) 对于连接查询来说, 一个 select 中有多个 table, 所以 explain 有多条记录, 但 id 相同 出现在前面的表是驱动表(s1) 出现在后面的表是被驱动表(s2) 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | Using join buffer (Block Nested Loop) | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ 2 rows in set, 1 warning (0.01 sec) 包含子查询的语句涉及多个 select, 所以每个 id 是不同的 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | SUBQUERY | s2 | NULL | index | idx_key1 | idx_key1 | 303 | NULL | 9954 | 100.00 | Using index | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ 2 rows in set, 1 warning (0.02 sec) 子查询可能会被 mysql 转换为连接查询, 导致 id 相同 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = \u0026#39;a\u0026#39;); +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+ | 1 | SIMPLE | s2 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9954 | 10.00 | Using where; Start temporary | | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | xiaohaizi.s2.key3 | 1 | 100.00 | End temporary | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+ 2 rows in set, 1 warning (0.00 sec) union 查询合并两个表的结果并去重 id 为 null 表示创建了用于合并的临时表 table 为 \u0026lt;union1,2\u0026gt; 表示临时表的名称 1 2 3 4 5 6 7 8 9 mysql\u0026gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2; +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 2 | UNION | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | NULL | | NULL | UNION RESULT | \u0026lt;union1,2\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ 3 rows in set, 1 warning (0.00 sec) union all 查询合并两个表, 但不去重 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 2 | UNION | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ 2 rows in set, 1 warning (0.01 sec) select_type 有多种值\n名称 描述 SIMPLE Simple SELECT (not using UNION or subqueries) PRIMARY Outermost SELECT UNION Second or later SELECT statement in a UNION UNION RESULT Result of a UNION SUBQUERY First SELECT in subquery DEPENDENT SUBQUERY First SELECT in subquery, dependent on outer query DEPENDENT UNION Second or later SELECT statement in a UNION, dependent on outer query DERIVED Derived table MATERIALIZED Materialized subquery UNCACHEABLE SUBQUERY A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query UNCACHEABLE UNION The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY) SIMPLE 查询语句中不包含 union 或子查询\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) PRIMARY 包含 union, union all, 子查询的语句, 最左边的小查询的 select_type 是 primary\n1 2 3 4 5 6 7 8 9 mysql\u0026gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2; +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 2 | UNION | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | NULL | | NULL | UNION RESULT | \u0026lt;union1,2\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ 3 rows in set, 1 warning (0.00 sec) UNION 包含 union 或 union all 的查询语句, 除了最左边的是 primary, 其余是 union\n1 2 3 4 5 6 7 8 9 mysql\u0026gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2; +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 2 | UNION | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | NULL | | NULL | UNION RESULT | \u0026lt;union1,2\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ 3 rows in set, 1 warning (0.00 sec) SUBQUERY 如果包含子查询的查询语句不能够转为对应的 semi-join 的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案 来执行该子查询时，该子查询的第一个 select 关键字代表的那个查询的 select_type 就是 subquery\n由于 select_type 为 subquery 的子查询会被物化，所以只需要执行一遍 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | SUBQUERY | s2 | NULL | index | idx_key1 | idx_key1 | 303 | NULL | 9954 | 100.00 | Using index | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ 2 rows in set, 1 warning (0.00 sec) DEPENDENT SUBQUERY 如果包含子查询的查询语句不能够转为对应的 semi-join 的形式，并且该子查询是相关子查询，则该子查询的第一个 select 关键字代表的那个 查询的 select_type 就是 dependent subquery\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = \u0026#39;a\u0026#39;; +----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | DEPENDENT SUBQUERY | s2 | NULL | ref | idx_key2,idx_key1 | idx_key2 | 5 | xiaohaizi.s1.key2 | 1 | 10.00 | Using where | +----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+ 2 rows in set, 2 warnings (0.00 sec) DEPENDENT UNION 在包含 union 或者 union all 的大查询中，如果各个小查询都依赖于外层查询的话，除了最左边的那个小查询之外，其余的小查询的 select_type 的值 就是 dependent union\n1 2 3 4 5 6 7 8 9 10 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = \u0026#39;a\u0026#39; UNION SELECT key1 FROM s1 WHERE key1 = \u0026#39;b\u0026#39;); +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | DEPENDENT SUBQUERY | s2 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 12 | 100.00 | Using where; Using index | | 3 | DEPENDENT UNION | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | Using where; Using index | | NULL | UNION RESULT | \u0026lt;union2,3\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+ 4 rows in set, 1 warning (0.03 sec) 这个例子给的不太清晰\nDERIVED 对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的 select_type 就是 derived\n派生表 物化 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c \u0026gt; 1; +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | 1 | PRIMARY | \u0026lt;derived2\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 33.33 | Using where | | 2 | DERIVED | s1 | NULL | index | idx_key1 | idx_key1 | 303 | NULL | 9688 | 100.00 | Using index | +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ 2 rows in set, 1 warning (0.00 sec) MATERIALIZED 当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 select_type 属性就是 materialized\nid 为2的记录是单表查询, 并被物化 id 为1的两条记录是连接查询 table 为 的记录表示其是 id 为2的记录对应的查询结果 1 2 3 4 5 6 7 8 9 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2); +----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ALL | idx_key1 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 1 | SIMPLE | \u0026lt;subquery2\u0026gt; | NULL | eq_ref | \u0026lt;auto_key\u0026gt; | \u0026lt;auto_key\u0026gt; | 303 | xiaohaizi.s1.key1 | 1 | 100.00 | NULL | | 2 | MATERIALIZED | s2 | NULL | index | idx_key1 | idx_key1 | 303 | NULL | 9954 | 100.00 | Using index | +----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+ 3 rows in set, 1 warning (0.01 sec) UNCACHEABLE SUBQUERY 不常用\nUNCACHEABLE UNION 不常用\npartitions 没讲\ntype 单表访问方法\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.04 sec) system 表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如 MyISAM、Memory，那么对该表的访问方法就是 system\n1 2 3 4 5 6 7 8 9 10 11 12 13 mysql\u0026gt; CREATE TABLE t(i int) Engine=MyISAM; Query OK, 0 rows affected (0.05 sec) mysql\u0026gt; INSERT INTO t VALUES(1); Query OK, 1 row affected (0.01 sec) mysql\u0026gt; EXPLAIN SELECT * FROM t; +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+ | 1 | SIMPLE | t | NULL | system | NULL | NULL | NULL | NULL | 1 | 100.00 | NULL | +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) const 根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是 const\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE id = 5; +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | NULL | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.01 sec) eq_ref 在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须 进行等值比较），则对该被驱动表的访问方法就是 eq_ref\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id; +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | PRIMARY | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | eq_ref | PRIMARY | PRIMARY | 4 | xiaohaizi.s1.id | 1 | 100.00 | NULL | +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ 2 rows in set, 1 warning (0.01 sec) ref 当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是 ref\nfulltext 没讲\nref_or_null 对普通二级索引进行等值匹配查询，该索引列的值也可以是 NULL 值时，那么对该表的访问方法就可能是 ref_or_null\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39; OR key1 IS NULL; +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | ref_or_null | idx_key1 | idx_key1 | 303 | const | 9 | 100.00 | Using index condition | +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+ 1 row in set, 1 warning (0.01 sec) index_merge 1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39; OR key3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+ | 1 | SIMPLE | s1 | NULL | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL | 14 | 100.00 | Using union(idx_key1,idx_key3); Using where | +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+ 1 row in set, 1 warning (0.01 sec) unique_subquery 针对在一些包含 IN 子查询的查询语句中，如果查询优化器决定将 IN 子查询转换为 EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该 子查询执行计划的 type 列的值就是 unique_subquery\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = \u0026#39;a\u0026#39;; +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | DEPENDENT SUBQUERY | s2 | NULL | unique_subquery | PRIMARY,idx_key1 | PRIMARY | 4 | func | 1 | 10.00 | Using where | +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+ 2 rows in set, 2 warnings (0.00 sec) index_subquery index_subquery 与unique_subquery 类似，只不过访问子查询中的表时使用的是普通的索引\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 = s2.key1) OR key3 = \u0026#39;a\u0026#39;; +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | DEPENDENT SUBQUERY | s2 | NULL | index_subquery | idx_key1,idx_key3 | idx_key3 | 303 | func | 1 | 10.00 | Using where | +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+ 2 rows in set, 2 warnings (0.01 sec) 例子不清楚\nrange 使用索引获取某些范围区间的记录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;); +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 27 | 100.00 | Using index condition | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.01 sec) mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;a\u0026#39; AND key1 \u0026lt; \u0026#39;b\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 294 | 100.00 | Using index condition | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.00 sec) index 当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ | 1 | SIMPLE | s1 | NULL | index | NULL | idx_key_part | 909 | NULL | 9688 | 10.00 | Using where; Using index | +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ 1 row in set, 1 warning (0.00 sec) ALL 全表扫描\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) possible_keys 和 key possible_keys 列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，key 列表示实际用到的索引有哪些\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39; AND key3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1,idx_key3 | idx_key3 | 303 | const | 6 | 2.75 | Using where | +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+ 1 row in set, 1 warning (0.01 sec) 使用 index 访问方法来查询某个表时，possible_keys 列是空的，而 key 列展示的是实际使用到的索引\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ | 1 | SIMPLE | s1 | NULL | index | NULL | idx_key_part | 909 | NULL | 9688 | 10.00 | Using where; Using index | +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ 1 row in set, 1 warning (0.00 sec) possible_keys 列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的 索引。\nkey_len 索引记录的长度, 由三部分组成\n对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是 VARCHAR(100)，使用的字符集是utf8，那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。 如果该索引列可以存储 NULL 值，则 key_len 比不可以存储 NULL 值时多1个字节。 对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。 由于 id 列的类型是 INT，并且不可以存储 NULL 值，所以在使用该列的索引时 key_len 大小就是4。\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE id = 5; +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | NULL | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.01 sec) 当索引列可以存储 NULL 值时\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key2 = 5; +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | const | idx_key2 | idx_key2 | 5 | const | 1 | 100.00 | NULL | +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) 对于可变长度的索引列来说\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) 在执行计划中输出 key_len 列主要是为了让我们区分某个使用联合索引的查询具体用了几个索引列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key_part | idx_key_part | 303 | const | 12 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = \u0026#39;a\u0026#39; AND key_part2 = \u0026#39;b\u0026#39;; +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key_part | idx_key_part | 606 | const,const | 1 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+ 1 row in set, 1 warning (0.01 sec) ref 当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是 const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery 其中之 一时，ref 列展示的就是与索引列作等值匹配的数据是什么, 常见的有常数或者某个列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.01 sec) mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id; +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | PRIMARY | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | eq_ref | PRIMARY | PRIMARY | 4 | xiaohaizi.s1.id | 1 | 100.00 | NULL | +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ 2 rows in set, 1 warning (0.00 sec) 与索引列进行等值匹配的值是个函数\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1); +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | ref | idx_key1 | idx_key1 | 303 | func | 1 | 100.00 | Using index condition | +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+ 2 rows in set, 1 warning (0.00 sec) rows 如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的 rows 列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的 rows 列就代表预计扫描的索引记录行数。\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 266 | 100.00 | Using index condition | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.00 sec) filtered MySQL 在计算驱动表扇出时采用的一个策略：\n如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。 该查询使用 idx_key1 索引来执行查询，从 rows 列可以看出满足 key1 \u0026gt; \u0026lsquo;z\u0026rsquo; 的记录有266条。执行计划的 filtered 列就代表查询优化器预测在这 266条记录中，有多少条记录满足其余的搜索条件，也就是 common_field = \u0026lsquo;a\u0026rsquo; 这个条件的百分比。此处 filtered 列的值是10.00，说明查询优 化器预测在266条记录中有10.00%的记录满足 common_field = \u0026lsquo;a\u0026rsquo; 这个条件。\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39; AND common_field = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 266 | 10.00 | Using index condition; Using where | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+ 1 row in set, 1 warning (0.00 sec) 对于单表查询来说，这个 filtered 列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的 filtered 值\n从执行计划中可以看出来，查询优化器打算把 s1 当作驱动表，s2 当作被驱动表。 我们可以看到驱动表 s1 表的执行计划的 rows 列为9688，filtered 列为10.00，这意味着驱动表 s1 的扇出值就是9688 × 10.00% = 968.8，这说 明还要对被驱动表执行大约968次查询。 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ALL | idx_key1 | NULL | NULL | NULL | 9688 | 10.00 | Using where | | 1 | SIMPLE | s2 | NULL | ref | idx_key1 | idx_key1 | 303 | xiaohaizi.s1.key1 | 1 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+ 2 rows in set, 1 warning (0.00 sec) ","permalink":"https://jdxj.github.io/posts/books/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84-%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3mysql/16-explain%E8%AF%A6%E8%A7%A3%E4%B8%8A/","summary":"示例表 使用例子 1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT 1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | No tables","title":"16 Explain详解(上)"},{"content":"技术分析 所有的技术分析都是建立在三大假设之上的。\n第一，市场行为包含一切。这句话的含义是所有的基础事件——经济事件、社会事件、战争、自然灾害等作用于市场都会反映到价格和交易量的变化中，特别是 与一家公司收入、利润和未来业绩有关的所有信息都已自动反映在公司股票的价格和交易量上。 第二，价格以趋势方式演变：价格会沿着原有的趋势继续运行，也就是说，价格正在上涨的股票会继续上涨，价格正在下跌的股票会继续下跌，而横盘整理的 股票会继续盘整，直到趋势改变。 第三，历史会重演：人们可以借助市场的历史信息和历史规律，对今后市场的变化进行推断预测。 技术分析的三大假设并没有被主流学术界所接受 在实践当中，单纯的技术分析在预测股价的实用性方面是存疑的 量化投资在中国兴起的时候，一群从海外回来的基金经理，用电脑技术打败国内投资者，赚钱很轻松。但随着越来越多的高智商、精通电脑技术的人加入量化投 资的行列，这几年量化投资赚钱也越来越难。\n未来技术分析的发展方向，可能向“行为金融学”寻求理论支持，并和基本面分析做结合 股票该持有还是该卖出，只和股价的未来走势有关，而股价的未来走势和投资者成本没有任何关系，所以理性的投资者不应该根据自己的持仓成本和盈亏来做买 卖决策。但行为金融学告诉我们，人是不理性的，人一定会根据自己的持仓成本和盈亏来做买卖决策。这时候，密集成交区的股价就构成了技术分析中的压力线 和支撑线。\n技术分析发现交易信号，基本面分析剔除高危垃圾股\n基本面投资 基本面投资的流派\n价值投资 成长股投资 价值投资就是买入被低估的股票，等待价值回归 买入价格低于价值的股票，等待价值回归\n核心问题\n什么是低估 被低估的股票会不会回归价值 低估的多种含义\n相对低估是它的估值相对同类公司便宜 绝对低估又可以分为两种情形 一种是低于净资产或者重置成本 另一种是低于内在价值 推荐大家读一读《投资最重要的事》\n成长股投资就是寻找能持续高成长的公司，享受业绩和估值双重提升带来的获利机会 市盈率=股价 / 每股盈利 股价=每股盈利×市盈率 成长股投资的核心理念是，从静态估值看，股价已经不便宜，但如果其业绩有持续高增长的潜力，静态估值贵一点儿，也值得投资。\n成长股投资最大的风险是，当高成长性逆转后，股价可能会跌得非常厉害。\n股价=每股盈利×市盈率，每股盈利和市盈率都上涨，股价自然会快速上涨。但是，成长股的成长性一旦逆转，就会遭遇“戴维斯双杀”。每股盈利下跌，估值也下 跌，这时候股价就会跌得很厉害。\n价值投资和成长股投资进行比较得知，价值投资更看重现在，成长股投资更看重未来。所\n“买卖逻辑自洽”，就是你买和卖的理由要逻辑一致。\n那么对价值投资来说，买入的理由是什么？低估。对成长股投资来说，买入的理由是什么？高成长。 那什么时候卖出股票呢？对价值投资来说，是不再低估。对成长股投资来说是不再高成长。 价值投资最大的问题是，很多股票被低估是有合理原因的。\n行业可能在下坡路了 投资者只有将公司的成长性、竞争力和公司的合理估值相结合，才是价值投资。\n在用估值指标的时候，投资者需要注意3点。\n第一，估值必须和未来可持续的复合增长率匹配，也就是说，投资者要找到估值和成长性合理匹配的公司。 第二，投资者计算估值时要剔除非经常性损益的影响。很多公司的盈利里有一些非经常性损益，比如一次性出售房地产的收益，这类收益要剔除掉，特别是在 用市盈率估值的时候。 第三，投资者要注意财务造假的可能性。如果盈利都是假的，那估值就完全没有意义了。 表3-1 价值投资和成长股投资的区别 基本面投资为什么能够战胜市场，为什么能够取得超额收益。\n第一，基本面投资讲究安全边际。什么叫安全边际？通俗一点儿说，你买的股票的价格便宜、合理，就有安全边际。 第二，基本面投资讲究投资逻辑，买卖逻辑要自洽。逻辑自洽是买一只股票和卖这只股票的逻辑要一致。 第三，基本面投资能够让投资者避免追涨杀跌，避免过度交易。 第四，在中国做基本面投资的人不多，所以更有机会成功。 基本面博弈 为什么叫“基本面博弈”？因为如果将它归类于技术分析，它关注的东西、用的语言都和基本面相关，比如它会关心经济形势、政府政策、公司盈利等基本面因素； 如果将它归类于基本面投资，它的持股周期并不长，往往只有几个月，很少超过1年，和基本面投资的“买入持有”策略有很大差异。“基本面博弈”这一称呼，表 明它用的是基本面的语言，但本质上是一种博弈。\n在基本面博弈中，最常见的是主题投资策略和轮动策略。\n主题投资策略 主题有点儿类似大家常说的“题材”，主题投资是通过挖掘对股票市场有较大影响的因素，对潜在受益的行业和公司进行投资的一种策略。但和纯粹的题材炒作或 者概念炒作不一样，主题投资依赖于对基本面的判断，寻找有较大概率能兑现业绩高增长的投资机会，延续的时间周期可能较长，而题材炒作或者概念炒作则完 全是资金推动的短期炒作，基本上是“昙花一现”。\n主题投资的特点在于它并不按照一般的行业划分来区分股票，而是将驱动经济发展的某个因素作为“主题”，以此来选择地域、行业、板块或个股。\n表3-2 2011-2016年主题投资类型 一般来说，主题投资更适合早期的产业。正因为早期，所以想象空间大、无法在短时间内证伪，投资者对收入和利润的要求相对没那么高，或者产业内竞争不那 么激烈，率先进入这个产业的公司能取得不错的利润。随着产业演进，产业内公司充分竞争，公司盈利能力经常会出现一个阶段性低点，兼并重组开始出现，部 分经营不善的公司甚至退出产业，集中度开始提升，龙头公司盈利能力也逐步回升，出现所谓的成长股投资阶段。\n图3-1 产业演进曲线 表3-3 主题投资和成长股投资的区别 在A股市场投资，主流机构一般会选择哪些主题进行重点投资？什么样的主题是优质的主题？\n第一，主题选择要高大上，具备想象空间。选择的主题想象空间越大，越能引起市场的参与热情。比如2015年的互联网+主题，想象空间就足够大。反过来共 享单车这样的主题，想象空间就小很多。 第二，主题容量要足够大。主题相关的标的股票要能容纳足够多的资金，如果太小，就不能吸引主流机构资金大规模参与。 第三，主题要能被普通投资者理解并关注和传播。一个能被普通投资者理解和传播的主题，较容易形成市场热点并扩散，太专业的主题只能由少数专业机构参 与，很难形成大行情。 第四，主题持续的时间要足够长，特别是较长时间内难以被证伪。 轮动策略 根据宏观经济景气周期、行业盈利周期、股票市场变动趋势等因素，轮流选择不同板块、不同行业、不同风格股票进行投资的策略。\n“美林时钟”理论按照经济增长与通胀的不同搭配，将经济周期划分为4个阶段。\n（1）“经济上行，通胀下行”构成复苏阶段，此阶段由于股票对经济的弹性更大，其相对债券和现金具备明显的超额收益。 （2）“经济上行，通胀上行”构成过热阶段，此阶段由于通胀上升，增加了持有现金的机会成本，可能出台的加息政策降低了债券的吸引力，股票的配置价值 相对较强。 （3）“经济下行，通胀上行”构成滞胀阶段，此阶段现金收益率提高，持有现金最明智，经济下行对企业盈利的冲击将对股票构成负面影响，债券相对股票的 收益率提高。 （4）“经济下行，通胀下行”构成衰退阶段，此阶段通胀压力下降，货币政策趋松，债券表现最突出，随着经济即将见底的预期逐步形成，股票的吸引力逐步 增强。 图3-2 “美林时钟”的经济周期和投资策略 在股票市场中，轮动策略可以进一步分为以下方法。\n板块轮动：根据大的经济周期，在成长、消费、周期、金融地产等大板块之间进行择时投资。 行业轮动：根据不同行业的不同景气周期，在行业之间进行择时投资。 风格轮动：根据股票市场的变化趋势，在不同风格之间进行择时投资，比如大小盘风格轮动、成长价值风格轮动等。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/","summary":"技术分析 所有的技术分析都是建立在三大假设之上的。 第一，市场行为包含一切。这句话的含义是所有的基础事件——经济事件、社会事件、战争、自然灾害等","title":"第三章 股票投资常见的盈利体系"},{"content":"盈利体系的基石：正确认知 对股票的认知: 投资股票靠什么赚钱 对风险的认知: 如何应对投资亏损 对股票的认知 一种认知是：股票就是博弈的筹码。 零和游戏 另一种认知是：股票是投资上市公司的载体。 你赚的钱是上市公司的成长带给你的利润增长 股票是一个财富转移的工具。 对风险的认知 现代金融学理论用股价的波动率来衡量风险，股价的波动程度代表着风险的高低。股价波动性越大，意味着股票的风险越大。 巴菲特认为投资的风险并不来源于波动，波动反而是机会，因为股价波动的幅度越大，好公司越会出现被低估的机会。 巴菲特认为本金的永久性损失才是真正的风险。什么是本金的永久性损失？是你所买入股票的公司基本面恶化，股价永远回不到你买入的价格，这才是真正的风 险。所以，真正的风险并非股价的波动，而是来自公司的“内在价值风险”。所以，选择安全边际高的股票，才是避免风险的最好投资方法。\n盈利体系的基本内容：“选股—验证—决策—跟踪”四大环节 第一步：选股，就是发现潜在的好股票 最常见的就是从财务指标中进行初选。\n净资产收益率 (ROE) A股市场3000多家上市公司，平均净资产收益率在7%至8%之间。 我们设定一个简单指标，选出净资产收益率连续3年大于20%的股票，就能剔除掉90%的股票，只剩下大约300只，这就能大大降低我们选择的难度。 从新闻中发现好股票的线索，从生活中发现好股票的线索，从券商研报中发现好股票的线索。 第二步：验证，当你初选出好股票之后，需要验证它是不是真的好股票 首先，我们要看这个行业的空间大不大，行业空间决定公司的发展空间。\n技术发展趋势 智能手机 -\u0026gt; 改变手机产业 -\u0026gt; 移动社交/支付/手机游戏 人工智能, 大数据, 物联网 供求关系. 是变化的, 需要不断跟踪 政策扶持 其次，我们要验证公司的核心竞争力。\n足够深的护城河. 企业相当长一段时间内无法被模仿和替代的竞争优势，如品牌、专利、垄断性牌照、规模优势等 优秀的管理团队. 需要考察管理层的眼光、能力和管理思路，还要考察管理层是否有把企业做大做强的决心 再次，我们要重视财务分析，因为财务分析是验证公司是否有竞争力的重要手段。\n最后，我们还要看估值。\n投资者做基本面投资就必须要研究估值，不管是价值股投资还是成长股投资，都必须研究估值，因为好股票=好公司+合理估值。 我们只有了解了公司的合理估值，才能通过与现有股价进行对比，判断目前股价是被高估、合理还是被低估。 如果股价被高估，即使基本面再好，也不是买入的机会。 第三步：决策，就是做出是否买、如何买的判断 在买入之前，你要想清楚以下问题。\n第一，我准备在什么价格区间买入？或者我在哪些条件具备的情况下买入这只股票？ 第二，我准备用多少资金买入这只股票？这只股票占我整个组合的比例是多少？ 第三，我准备持有这只股票多长时间？到什么价格或发生什么情况，我会准备卖出这只股票？ 第四，买入之后可能会出现什么样的意外？如果出现了意外，我应该怎样应对？ 第四步：跟踪，持续关注和研究公司的基本面变化 如何止盈和止损\n重点\n股票的价格与其曾经的价格无关, 只和估值有关 忘掉成本, 唯一决定这只股票涨跌的是它的基本面未来会怎么样，跟你被套牢还是盈利没有任何关系 要学会利用各种资源，尤其是券商分析师的报告 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%9E%84%E5%BB%BA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/","summary":"盈利体系的基石：正确认知 对股票的认知: 投资股票靠什么赚钱 对风险的认知: 如何应对投资亏损 对股票的认知 一种认知是：股票就是博弈的筹码。 零和游戏 另","title":"第二章 我们需要构建什么样的盈利体系"},{"content":"股票投资看似简单却很复杂 股票投资难，在于股票投资是一个概率游戏，正确决策（过程）未必带来好的结果，错误决策（过程）有时候会让你赚钱。也就是说，决策（过程）正误和投资 结果好坏没有必然联系，这就会导致以下3种情况。\n一是赚了钱，却很难归因或者错误归因 比如“十送十”买入股票，股价上涨后投资者很开心，觉得自己决策正确。但股价真正上涨的原因可能是业绩超预期，或者政策变化，但投资者却把上涨原因归结 为“十送十”。下次投资，投资者就会去找“十送十”的股票，而不是业绩超预期的股票。\n二是赚了钱，却不可重复，运气成分大于能力成分 投资是一个概率游戏\n三是因为运气，错误决策（过程）产生了好结果，强化了错误决策 长期按照这个思路操作下去，投资者一定会亏损累累，因为很可能有这样的结果：多次“成功操作”赚来的钱被一次连本带利地亏完。\n投资最重要的事：建立可重复、大概率能赚钱的盈利体系 大数定律\n表1-1 单次博弈和重复博弈 DFH盈利体系的内容，概括起来有以下几点。\n选股：幸运的行业+能干的公司 投资者要看公司所处的行业特征如何，是否有较大的发展空间； 公司的商业模式如何，是否具有可持续的发展能力，是否经得起未来的考验； 管理层是否足够优秀，是否拥有与自己行业特征相匹配的能力。 投资者要尽量不买上市不到两年的新股，不追逐主题、热点，不买市盈率特别高的股票。 策略：长期投资，陪伴好公司成长 投资者坚持“自下而上”地选择优秀公司，深入研究公司的基本面，关注公司的本身，关注公司的核心竞争力的提升和行业地位的稳固； 坚信有核心竞争力的优质上市公司的回报率会远高于社会平均回报率； 避免高换手率，不频繁交易，坚持长期投资，陪伴好公司成长，赚取上市公司长期盈利增长的钱，赚取上市公司分红的钱。 风控：专注于择股，大部分时间不择时 时间是优质公司的朋友 眼于长期的投资机会而不过多考虑股价的短期波动 敢于逆向思维、逆向投资 时间是好体系的朋友，是差体系的敌人 任何投资，脱离时间维度，都是没有意义的:\n对于价值投资来说，至少要有2～3年的持股周期。 对于技术分析来说，时间长则要数月，短则要数天。 而对于量化高频交易来说，考虑的时间可能是几秒，甚至是零点几秒。 从长期来看，股价是由价值决定的，股价永远围绕着公司价值波动。什么是公司价值？它是公司基本面决定的合理估值。但在短期内，股价往往会和公司价值发 生偏离，甚至是很大的偏离。对优秀公司来说，随着时间的推移，它的盈利会不断增长，价值会不断提升。\n投资者亏钱的最大问题：没有盈利体系或者拥有错误的盈利体系 正确的盈利体系应该符合3个标准\n适合自己的能力圈. 个人投资者在构建自己的盈利体系的过程中，要综合考虑自己的职业、财务状况、风险承受能力，以及自己的性格特点。 逻辑自洽 买股票的逻辑和卖股票的逻辑要一致。 我经常会碰到一些个人投资者跟我说他买了哪只股票，我问他为什么买这只股票，他说看好这个行业，公司业绩也很好，讲了一堆理由，都是基本面的逻辑。 过了3天，他又跟我说他把那只股票卖了，因为股价跌穿5日线、“死叉”出来了，这又是技术分析的逻辑。这样的买卖逻辑自洽吗？买卖逻辑不自洽的人， 99%的概率是做不好投资的，能做好投资的一定是买卖逻辑自洽的人。 符合市场规律和趋势 可持续、可复制. 一个正确的盈利体系，一定是在相当长一段时间内可持续、可复制的。有些策略或者方法，虽然也能赚钱，但不能持续。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E8%A6%81/","summary":"股票投资看似简单却很复杂 股票投资难，在于股票投资是一个概率游戏，正确决策（过程）未必带来好的结果，错误决策（过程）有时候会让你赚钱。也就是说","title":"第一章 盈利体系为什么重要"},{"content":"15.1 Introduction to InnoDB 15.1.2 Best Practices for InnoDB Tables 使用索引 关闭自动提交 (写速度限制) 15.1.3 Verifying that InnoDB is the Default Storage Engine DEFAULT 字样\n1 2 SHOW ENGINES; SELECT * FROM INFORMATION_SCHEMA.ENGINES; 15.2 InnoDB and the ACID Model A: atomicity. C: consistency. I: isolation. D: durability. 15.3 InnoDB Multi-Versioning InnoDB 在每行记录上添加三个字段\nDB_TRX_ID: 最新进行操作(insert, update, delete)的事务 id DB_ROLL_PTR: 指向 undo log 的指针 DB_ROW_ID: row id, InnoDB 自动生成的聚集索引才有 insert undo log 在事务提交后删除, update undo log 在没有依赖后删除.\n15.7 InnoDB Locking and Transaction Model 15.7.1 InnoDB Locking Shared and Exclusive Locks 就是读写锁\nIntention Locks 表级锁, 表明一个事务稍后要对该表某行请求的锁\nintention shared lock (IS) intention exclusive lock (IX) SELECT ... FOR SHARE sets an IS lock, and SELECT ... FOR UPDATE sets an IX lock.\nRecord Locks SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE, 阻止其他事务 insert, update, delete t.c1 = 10 的行\nGap Locks 锁定索引记录间的间隙, 或者第一条记录之前的间隙, 或者最后一条记录后的间隙\nSELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE, t.c1 = 15 不能被插入\nNext-Key Locks record lock 和索引记录之前的 gap lock 组合\nInsert Intention Locks AUTO-INC Locks AUTO_INCREMENT 列\nPredicate Locks for Spatial Indexes 15.7.5 Deadlocks in InnoDB 隔离级别不影响死锁的可能性, 因为隔离级别负责读操作, 然而死锁发生在写操作\n","permalink":"https://jdxj.github.io/posts/docs/mysql/chapter15-the-innodb-storage-engine/","summary":"15.1 Introduction to InnoDB 15.1.2 Best Practices for InnoDB Tables 使用索引 关闭自动提交 (写速度限制) 15.1.3 Verifying that InnoDB is the Default Storage Engine DEFAULT 字样 1 2 SHOW ENGINES; SELECT * FROM INFORMATION_SCHEMA.ENGINES; 15.2 InnoDB and the ACID Model A: atomicity. C: consistency. I: isolation. D: durability. 15.3 InnoDB Multi-Versioning InnoDB 在每行记录","title":"Chapter15 The InnoDB Storage Engine"},{"content":"原文\nOptions -K, --config \u0026lt;file\u0026gt; 在文件中指定 curl 的参数\n选项和其参数可以用 空格, :, = 分隔 如果选项前有 - 或 --, 则可以省略 :, = 长选项可省略 -- 参数中包含空格 (或者以 :, = 开头), 则需要用引号包围 -x, --proxy [protocol://]host[:port] -A, --user-agent \u0026lt;name\u0026gt; -A \u0026quot;\u0026quot;, 请求中将不会有该 header -A \u0026quot; \u0026quot;, 有该 header, 但是值为空白 -H, --header \u0026lt;header/@file\u0026gt; 清除某个 header\n-H \u0026#34;Host:\u0026#34; 发送不带值的自定义 header, 必须以 ; 结尾\n-H \u0026#34;X-Custom-Header;\u0026#34; 使用 @filename 可以在文件中读取 header\n// todo 例子 -b, --cookie \u0026lt;data|filename\u0026gt; 在命令行中所指定的 cookie 的格式\n\u0026#34;NAME1=VALUE1; NAME2=VALUE2\u0026#34; 从文件中读取\n文件的 cookie 格式应该是 Netscape/Mozilla cookie file format 1 curl -b cookiefile https://example.com 从文件中读取 cookie 并写回\n1 curl -b cookiefile -c cookiefile https://example.com -c, --cookie-jar \u0026lt;filename\u0026gt; 存储 cookie\n-L, --location 跟随重定向\n-d, --data \u0026lt;data\u0026gt; 发送 application/x-www-form-urlencoded 数据\n1 2 curl -d \u0026#34;name=curl\u0026#34; -d \u0026#34;tool=cmdline\u0026#34; https://example.com curl -d @filename https://example.com --data-binary \u0026lt;data\u0026gt; 发送 application/x-www-form-urlencoded 数据\n-F, --form \u0026lt;name=content\u0026gt; 发送 multipart/form-data 数据\n@, 作为文件上传\n1 2 3 curl -F profile=@portrait.jpg https://example.com/upload.cgi # Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;nameinpost\u0026#34; curl -F \u0026#34;file=@localfile;filename=nameinpost\u0026#34; example.com 发送 form\n1 curl -F name=John -F shoesize=11 https://example.com/ \u0026lt;, 从文件中读 form\n1 curl -F \u0026#34;story=\u0026lt;hugefile.txt\u0026#34; https://example.com/ -e, --referer \u0026lt;URL\u0026gt; 添加 referer header\n1 curl --referer \u0026#34;https://fake.example;auto\u0026#34; -L https://example.com -G, --get 更改 HTTP 方法为 GET\n-i, --include 输出包括响应 header\n注意, 如果使用 -o 选项, 那么会把 header 也输出到文件中\n-v, --verbose 更多传输信息\n-k, --insecure 跳过证书检查\n-w, --write-out \u0026lt;format\u0026gt; -D, --dump-header \u0026lt;filename\u0026gt; 保存 header 到文件\n1 2 curl --json \u0026#39;{ \u0026#34;drink\u0026#34;:\u0026#39; --json \u0026#39; \u0026#34;coffe\u0026#34; }\u0026#39; https://example.com curl --json @prepared https://example.com --json \u0026lt;data\u0026gt; Files ~/.curlrc Environment Proxy protocol prefixes ","permalink":"https://jdxj.github.io/posts/cmd/curl/","summary":"原文 Options -K, --config \u0026lt;file\u0026gt; 在文件中指定 curl 的参数 选项和其参数可以用 空格, :, = 分隔 如果选项前有 - 或 --, 则可以省略 :, = 长选项可省略 -- 参数中包含空格 (或者以 :, = 开头","title":"curl"}]
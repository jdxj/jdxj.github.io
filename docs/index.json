[{"content":"Channel 的应用场景 数据交流：当作并发的 buffer 或者 queue，解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者（Producer）和消费者（Consumer）。 数据传递：一个 goroutine 将数据交给另一个 goroutine，相当于把数据的拥有权 (引用) 托付出去。 信号通知：一个 goroutine 可以将信号 (closing、closed、data ready 等) 传递给另一个或者另一组 goroutine 。 任务编排：可以让一组 goroutine 按照一定的顺序并发或者串行的执行，这就是编排的功能。 锁：利用 Channel 也可以实现互斥锁的机制。 Channel 的实现原理 ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/channel/","summary":"Channel 的应用场景 数据交流：当作并发的 buffer 或者 queue，解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者（Producer）和消费者（Consum","title":"Channel"},{"content":"对于无符号的整数和 uinptr 类型来说，怎么实现减去一个值呢？\n1 AddUint32(\u0026amp;x, ^uint32(c-1)). CAS (CompareAndSwap) 1 func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) Lock-Free queue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 package queue import ( \u0026#34;sync/atomic\u0026#34; \u0026#34;unsafe\u0026#34; ) // lock-free的queue type LKQueue struct { head unsafe.Pointer tail unsafe.Pointer } // 通过链表实现，这个数据结构代表链表中的节点 type node struct { value interface{} next unsafe.Pointer } func NewLKQueue() *LKQueue { n := unsafe.Pointer(\u0026amp;node{}) return \u0026amp;LKQueue{head: n, tail: n} } // 入队 func (q *LKQueue) Enqueue(v interface{}) { n := \u0026amp;node{value: v} for { tail := load(\u0026amp;q.tail) next := load(\u0026amp;tail.next) if tail == load(\u0026amp;q.tail) { // 尾还是尾 if next == nil { // 还没有新数据入队 if cas(\u0026amp;tail.next, next, n) { //增加到队尾 cas(\u0026amp;q.tail, tail, n) //入队成功，移动尾巴指针 return } } else { // 已有新数据加到队列后面，需要移动尾指针 cas(\u0026amp;q.tail, tail, next) } } } } // 出队，没有元素则返回nil func (q *LKQueue) Dequeue() interface{} { for { head := load(\u0026amp;q.head) tail := load(\u0026amp;q.tail) next := load(\u0026amp;head.next) if head == load(\u0026amp;q.head) { // head还是那个head if head == tail { // head和tail一样 if next == nil { // 说明是空队列 return nil } // 只是尾指针还没有调整，尝试调整它指向下一个 cas(\u0026amp;q.tail, tail, next) } else { // 读取出队的数据 v := next.value // 既然要出队了，头指针移动到下一个 if cas(\u0026amp;q.head, head, next) { return v // Dequeue is done. return } } } } } // 将unsafe.Pointer原子加载转换成node func load(p *unsafe.Pointer) (n *node) { return (*node)(atomic.LoadPointer(p)) } // 封装CAS,避免直接将*node转换成unsafe.Pointer func cas(p *unsafe.Pointer, old, new *node) (ok bool) { return atomic.CompareAndSwapPointer( p, unsafe.Pointer(old), unsafe.Pointer(new)) } ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/atomic/","summary":"对于无符号的整数和 uinptr 类型来说，怎么实现减去一个值呢？ 1 AddUint32(\u0026amp;x, ^uint32(c-1)). CAS (CompareAndSwap) 1 func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) Lock-Free queue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28","title":"Atomic"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/oschina/%E7%86%94%E6%96%AD/","summary":"原文","title":"熔断"},{"content":"在使用 Context 的时候，有一些约定俗成的规则。\n一般函数使用 Context 的时候，会把这个参数放在第一个参数的位置。 从来不把 nil 当做 Context 类型的参数值，可以使用 context.Background() 创建一个空的上下文对象，也不要使用 nil。 Context 只用来临时做函数之间的上下文透传，不能持久化 Context 或者把 Context 长久保存。把 Context 持久化到数据库、本地文件或者全局变量、 缓存中都是错误的用法。 key 的类型不应该是字符串类型或者其它内建类型，否则容易在包之间使用 Context 时候产生冲突。使用 WithValue 时，key 的类型应该是自己定义的类型。 常常使用 struct{}作为底层类型定义 key 的类型。对于 exported key 的静态类型，常常是接口或者指针。这样可以尽量减少内存分配。 WithValue 1 2 3 4 type valueCtx struct { Context key, val interface{} } WithCancel 不是只有你想中途放弃，才去调用 cancel，只要你的任务正常完成了，就需要调用 cancel\n1 2 3 4 5 6 7 8 9 10 func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { c := newCancelCtx(parent) propagateCancel(parent, \u0026amp;c)// 把c朝上传播 return \u0026amp;c, func() { c.cancel(true, Canceled) } } // newCancelCtx returns an initialized cancelCtx. func newCancelCtx(parent Context) cancelCtx { return cancelCtx{Context: parent} } propagateCancel 方法会顺着 parent 路径往上找，直到找到一个 cancelCtx，或者为 nil。如果不为空，就把自己加入到这个 cancelCtx 的 child， 以便这个 cancelCtx 被取消的时候通知自己。如果为空，会新起一个 goroutine，由它来监听 parent 的 Done 是否已关闭。\ncancel 是向下传递的，如果一个 WithCancel 生成的 Context 被 cancel 时，如果它的子 Context（也有可能是孙，或者更低，依赖子的类型）也是 cancelCtx 类型的，就会被 cancel，但是不会向上传递。parent Context 不会因为子 Context 被 cancel 而 cancel。\nWithTimeout WithTimeout 其实是和 WithDeadline 一样，只不过一个参数是超时时间，一个参数是截止时间。超时时间加上当前时间，其实就是截止时间，因此， WithTimeout 的实现是：\n1 2 3 4 func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { // 当前时间+timeout就是deadline return WithDeadline(parent, time.Now().Add(timeout)) } WithDeadline 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { // 如果parent的截止时间更早，直接返回一个cancelCtx即可 if cur, ok := parent.Deadline(); ok \u0026amp;\u0026amp; cur.Before(d) { return WithCancel(parent) } c := \u0026amp;timerCtx{ cancelCtx: newCancelCtx(parent), deadline: d, } propagateCancel(parent, c) // 同cancelCtx的处理逻辑 dur := time.Until(d) if dur \u0026lt;= 0 { //当前时间已经超过了截止时间，直接cancel c.cancel(true, DeadlineExceeded) return c, func() { c.cancel(false, Canceled) } } c.mu.Lock() defer c.mu.Unlock() if c.err == nil { // 设置一个定时器，到截止时间后取消 c.timer = time.AfterFunc(dur, func() { c.cancel(true, DeadlineExceeded) }) } return c, func() { c.cancel(true, Canceled) } } ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/context/","summary":"在使用 Context 的时候，有一些约定俗成的规则。 一般函数使用 Context 的时候，会把这个参数放在第一个参数的位置。 从来不把 nil 当做 Context 类型的参数值，可以使用 context.Background() 创建一","title":"Context"},{"content":"中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。\n参考 中介模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/","summary":"Mediator Pattern","title":"中介模式"},{"content":"它用来描述如何构建一个简单的“语言”解释器。比起命令模式，解释器模式更加小众，只在一些特定的领域会被用到，比如编译器、规则引擎、正则表达式。\n解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。\n参考 解释器模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"Interpreter Pattern","title":"解释器模式"},{"content":"设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，它类似我们之前讲过的回调。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public interface Command { void execute(); } public class GotDiamondCommand implements Command { // 省略成员变量 public GotDiamondCommand(/*数据*/) { //... } @Override public void execute() { // 执行相应的逻辑 } } //GotStartCommand/HitObstacleCommand/ArchiveCommand类省略 public class GameApplication { private static final int MAX_HANDLED_REQ_COUNT_PER_LOOP = 100; private Queue\u0026lt;Command\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); public void mainloop() { while (true) { List\u0026lt;Request\u0026gt; requests = new ArrayList\u0026lt;\u0026gt;(); //省略从epoll或者select中获取数据，并封装成Request的逻辑， //注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。 for (Request request : requests) { Event event = request.getEvent(); Command command = null; if (event.equals(Event.GOT_DIAMOND)) { command = new GotDiamondCommand(/*数据*/); } else if (event.equals(Event.GOT_STAR)) { command = new GotStartCommand(/*数据*/); } else if (event.equals(Event.HIT_OBSTACLE)) { command = new HitObstacleCommand(/*数据*/); } else if (event.equals(Event.ARCHIVE)) { command = new ArchiveCommand(/*数据*/); } // ...一堆else if... queue.add(command); } int handledCount = 0; while (handledCount \u0026lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) { if (queue.isEmpty()) { break; } Command command = queue.poll(); command.execute(); } } } } 参考 命令模式 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","summary":"Command Pattern","title":"命令模式"},{"content":"也叫快照（Snapshot）模式, 主要是用来防丢失、撤销、恢复等。\n在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 public class InputText { private StringBuilder text = new StringBuilder(); public String getText() { return text.toString(); } public void append(String input) { text.append(input); } public Snapshot createSnapshot() { return new Snapshot(text.toString()); } public void restoreSnapshot(Snapshot snapshot) { this.text.replace(0, this.text.length(), snapshot.getText()); } } public class Snapshot { private String text; public Snapshot(String text) { this.text = text; } public String getText() { return this.text; } } public class SnapshotHolder { private Stack\u0026lt;Snapshot\u0026gt; snapshots = new Stack\u0026lt;\u0026gt;(); public Snapshot popSnapshot() { return snapshots.pop(); } public void pushSnapshot(Snapshot snapshot) { snapshots.push(snapshot); } } public class ApplicationMain { public static void main(String[] args) { InputText inputText = new InputText(); SnapshotHolder snapshotsHolder = new SnapshotHolder(); Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String input = scanner.next(); if (input.equals(\u0026#34;:list\u0026#34;)) { System.out.println(inputText.toString()); } else if (input.equals(\u0026#34;:undo\u0026#34;)) { Snapshot snapshot = snapshotsHolder.popSnapshot(); inputText.restoreSnapshot(snapshot); } else { snapshotsHolder.pushSnapshot(inputText.createSnapshot()); inputText.append(input); } } } } 参考 备忘录模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","summary":"Memento Pattern","title":"备忘录模式"},{"content":"建议你不要使用访问者模式。\n允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 public abstract class ResourceFile { protected String filePath; public ResourceFile(String filePath) { this.filePath = filePath; } abstract public void accept(Visitor vistor); } public class PdfFile extends ResourceFile { public PdfFile(String filePath) { super(filePath); } @Override public void accept(Visitor visitor) { visitor.visit(this); } //... } //...PPTFile、WordFile跟PdfFile类似，这里就省略了... public interface Visitor { void visit(PdfFile pdfFile); void visit(PPTFile pdfFile); void visit(WordFile pdfFile); } public class Extractor implements Visitor { @Override public void visit(PPTFile pptFile) { //... System.out.println(\u0026#34;Extract PPT.\u0026#34;); } @Override public void visit(PdfFile pdfFile) { //... System.out.println(\u0026#34;Extract PDF.\u0026#34;); } @Override public void visit(WordFile wordFile) { //... System.out.println(\u0026#34;Extract WORD.\u0026#34;); } } public class Compressor implements Visitor { @Override public void visit(PPTFile pptFile) { //... System.out.println(\u0026#34;Compress PPT.\u0026#34;); } @Override public void visit(PdfFile pdfFile) { //... System.out.println(\u0026#34;Compress PDF.\u0026#34;); } @Override public void visit(WordFile wordFile) { //... System.out.println(\u0026#34;Compress WORD.\u0026#34;); } } public class ToolApplication { public static void main(String[] args) { Extractor extractor = new Extractor(); List\u0026lt;ResourceFile\u0026gt; resourceFiles = listAllResourceFiles(args[0]); for (ResourceFile resourceFile : resourceFiles) { resourceFile.accept(extractor); } Compressor compressor = new Compressor(); for(ResourceFile resourceFile : resourceFiles) { resourceFile.accept(compressor); } } private static List\u0026lt;ResourceFile\u0026gt; listAllResourceFiles(String resourceDirectory) { List\u0026lt;ResourceFile\u0026gt; resourceFiles = new ArrayList\u0026lt;\u0026gt;(); //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile) resourceFiles.add(new PdfFile(\u0026#34;a.pdf\u0026#34;)); resourceFiles.add(new WordFile(\u0026#34;b.word\u0026#34;)); resourceFiles.add(new PPTFile(\u0026#34;c.ppt\u0026#34;)); return resourceFiles; } } 参考 访问者模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"Visitor Pattern","title":"访问者模式"},{"content":"也叫作游标模式（Cursor Design Pattern）。\n1 2 3 4 5 6 7 8 9 10 11 12 // 接口定义方式一 public interface Iterator\u0026lt;E\u0026gt; { boolean hasNext(); void next(); E currentItem(); } // 接口定义方式二 public interface Iterator\u0026lt;E\u0026gt; { boolean hasNext(); E next(); } 迭代器实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class ArrayIterator\u0026lt;E\u0026gt; implements Iterator\u0026lt;E\u0026gt; { private int cursor; private ArrayList\u0026lt;E\u0026gt; arrayList; public ArrayIterator(ArrayList\u0026lt;E\u0026gt; arrayList) { this.cursor = 0; this.arrayList = arrayList; } @Override public boolean hasNext() { return cursor != arrayList.size(); //注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。 } @Override public void next() { cursor++; } @Override public E currentItem() { if (cursor \u0026gt;= arrayList.size()) { throw new NoSuchElementException(); } return arrayList.get(cursor); } } public class Demo { public static void main(String[] args) { ArrayList\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); names.add(\u0026#34;xzg\u0026#34;); names.add(\u0026#34;wang\u0026#34;); names.add(\u0026#34;zheng\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = new ArrayIterator(names); while (iterator.hasNext()) { System.out.println(iterator.currentItem()); iterator.next(); } } } 将创建迭代器的逻辑放到容器中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public interface List\u0026lt;E\u0026gt; { Iterator iterator(); //...省略其他接口函数... } public class ArrayList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt; { //... public Iterator iterator() { return new ArrayIterator(this); } //...省略其他代码 } public class Demo { public static void main(String[] args) { List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); names.add(\u0026#34;xzg\u0026#34;); names.add(\u0026#34;wang\u0026#34;); names.add(\u0026#34;zheng\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = names.iterator(); while (iterator.hasNext()) { System.out.println(iterator.currentItem()); iterator.next(); } } } 参考 迭代器模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"Iterator Pattern","title":"迭代器模式"},{"content":"什么是有限状态机？ 有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。 其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。\n状态机实现方式 分支逻辑法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 public class MarioStateMachine { private int score; private State currentState; public MarioStateMachine() { this.score = 0; this.currentState = State.SMALL; } public void obtainMushRoom() { if (currentState.equals(State.SMALL)) { this.currentState = State.SUPER; this.score += 100; } } public void obtainCape() { if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) { this.currentState = State.CAPE; this.score += 200; } } public void obtainFireFlower() { if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) { this.currentState = State.FIRE; this.score += 300; } } public void meetMonster() { if (currentState.equals(State.SUPER)) { this.currentState = State.SMALL; this.score -= 100; return; } if (currentState.equals(State.CAPE)) { this.currentState = State.SMALL; this.score -= 200; return; } if (currentState.equals(State.FIRE)) { this.currentState = State.SMALL; this.score -= 300; return; } } public int getScore() { return this.score; } public State getCurrentState() { return this.currentState; } } 查表法 在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 public enum Event { GOT_MUSHROOM(0), GOT_CAPE(1), GOT_FIRE(2), MET_MONSTER(3); private int value; private Event(int value) { this.value = value; } public int getValue() { return this.value; } } public class MarioStateMachine { private int score; private State currentState; private static final State[][] transitionTable = { {SUPER, CAPE, FIRE, SMALL}, {SUPER, CAPE, FIRE, SMALL}, {CAPE, CAPE, CAPE, SMALL}, {FIRE, FIRE, FIRE, SMALL} }; private static final int[][] actionTable = { {+100, +200, +300, +0}, {+0, +200, +300, -100}, {+0, +0, +0, -200}, {+0, +0, +0, -300} }; public MarioStateMachine() { this.score = 0; this.currentState = State.SMALL; } public void obtainMushRoom() { executeEvent(Event.GOT_MUSHROOM); } public void obtainCape() { executeEvent(Event.GOT_CAPE); } public void obtainFireFlower() { executeEvent(Event.GOT_FIRE); } public void meetMonster() { executeEvent(Event.MET_MONSTER); } private void executeEvent(Event event) { int stateValue = currentState.getValue(); int eventValue = event.getValue(); this.currentState = transitionTable[stateValue][eventValue]; this.score += actionTable[stateValue][eventValue]; } public int getScore() { return this.score; } public State getCurrentState() { return this.currentState; } } 状态模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 public interface IMario { State getName(); void obtainMushRoom(MarioStateMachine stateMachine); void obtainCape(MarioStateMachine stateMachine); void obtainFireFlower(MarioStateMachine stateMachine); void meetMonster(MarioStateMachine stateMachine); } public class SmallMario implements IMario { private static final SmallMario instance = new SmallMario(); private SmallMario() {} public static SmallMario getInstance() { return instance; } @Override public State getName() { return State.SMALL; } @Override public void obtainMushRoom(MarioStateMachine stateMachine) { stateMachine.setCurrentState(SuperMario.getInstance()); stateMachine.setScore(stateMachine.getScore() + 100); } @Override public void obtainCape(MarioStateMachine stateMachine) { stateMachine.setCurrentState(CapeMario.getInstance()); stateMachine.setScore(stateMachine.getScore() + 200); } @Override public void obtainFireFlower(MarioStateMachine stateMachine) { stateMachine.setCurrentState(FireMario.getInstance()); stateMachine.setScore(stateMachine.getScore() + 300); } @Override public void meetMonster(MarioStateMachine stateMachine) { // do nothing... } } // 省略SuperMario、CapeMario、FireMario类... public class MarioStateMachine { private int score; private IMario currentState; public MarioStateMachine() { this.score = 0; this.currentState = SmallMario.getInstance(); } public void obtainMushRoom() { this.currentState.obtainMushRoom(this); } public void obtainCape() { this.currentState.obtainCape(this); } public void obtainFireFlower() { this.currentState.obtainFireFlower(this); } public void meetMonster() { this.currentState.meetMonster(this); } public int getScore() { return this.score; } public State getCurrentState() { return this.currentState.getName(); } public void setScore(int score) { this.score = score; } public void setCurrentState(IMario currentState) { this.currentState = currentState; } } 像游戏这种比较复杂的状态机，包含的状态比较多，我优先推荐使用查表法，而状态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下 单这种类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。\n参考 状态模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","summary":"Stat Pattern","title":"状态模式"},{"content":"在职责链模式中，多个处理器依次处理同一个请求。\n链表实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public abstract class Handler { protected Handler successor = null; public void setSuccessor(Handler successor) { this.successor = successor; } public final void handle() { boolean handled = doHandle(); if (successor != null \u0026amp;\u0026amp; !handled) { successor.handle(); } } protected abstract boolean doHandle(); } public class HandlerA extends Handler { @Override protected boolean doHandle() { boolean handled = false; //... return handled; } } public class HandlerB extends Handler { @Override protected boolean doHandle() { boolean handled = false; //... return handled; } } public class HandlerChain { private Handler head = null; private Handler tail = null; public void addHandler(Handler handler) { handler.setSuccessor(null); if (head == null) { head = handler; tail = handler; return; } tail.setSuccessor(handler); tail = handler; } public void handle() { if (head != null) { head.handle(); } } } // 使用举例 public class Application { public static void main(String[] args) { HandlerChain chain = new HandlerChain(); chain.addHandler(new HandlerA()); chain.addHandler(new HandlerB()); chain.handle(); } } 数组实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public interface IHandler { boolean handle(); } public class HandlerA implements IHandler { @Override public boolean handle() { boolean handled = false; //... return handled; } } public class HandlerB implements IHandler { @Override public boolean handle() { boolean handled = false; //... return handled; } } public class HandlerChain { private List\u0026lt;IHandler\u0026gt; handlers = new ArrayList\u0026lt;\u0026gt;(); public void addHandler(IHandler handler) { this.handlers.add(handler); } public void handle() { for (IHandler handler : handlers) { boolean handled = handler.handle(); if (handled) { break; } } } } // 使用举例 public class Application { public static void main(String[] args) { HandlerChain chain = new HandlerChain(); chain.addHandler(new HandlerA()); chain.addHandler(new HandlerB()); chain.handle(); } } 职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。\n参考 职责链模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/","summary":"Chain of Responsibility Pattern","title":"职责链模式"},{"content":"最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。\n定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 // 定义策略 public interface Strategy { void algorithmInterface(); } public class ConcreteStrategyA implements Strategy { @Override public void algorithmInterface() { //具体的算法... } } public class ConcreteStrategyB implements Strategy { @Override public void algorithmInterface() { //具体的算法... } } // 创建策略-可重用的策略 public class StrategyFactory { private static final Map\u0026lt;String, Strategy\u0026gt; strategies = new HashMap\u0026lt;\u0026gt;(); static { strategies.put(\u0026#34;A\u0026#34;, new ConcreteStrategyA()); strategies.put(\u0026#34;B\u0026#34;, new ConcreteStrategyB()); } public static Strategy getStrategy(String type) { if (type == null || type.isEmpty()) { throw new IllegalArgumentException(\u0026#34;type should not be empty.\u0026#34;); } return strategies.get(type); } } // 创建策略-每次新创建策略对象 public class StrategyFactory { public static Strategy getStrategy(String type) { if (type == null || type.isEmpty()) { throw new IllegalArgumentException(\u0026#34;type should not be empty.\u0026#34;); } if (type.equals(\u0026#34;A\u0026#34;)) { return new ConcreteStrategyA(); } else if (type.equals(\u0026#34;B\u0026#34;)) { return new ConcreteStrategyB(); } return null; } } // 使用策略 // 策略接口：EvictionStrategy // 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy... // 策略工厂：EvictionStrategyFactory public class UserCache { private Map\u0026lt;String, User\u0026gt; cacheData = new HashMap\u0026lt;\u0026gt;(); private EvictionStrategy eviction; public UserCache(EvictionStrategy eviction) { this.eviction = eviction; } //... } // 运行时动态确定，根据配置文件的配置决定使用哪种策略 public class Application { public static void main(String[] args) throws Exception { EvictionStrategy evictionStrategy = null; Properties props = new Properties(); props.load(new FileInputStream(\u0026#34;./config.properties\u0026#34;)); String type = props.getProperty(\u0026#34;eviction_type\u0026#34;); evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type); UserCache userCache = new UserCache(evictionStrategy); //... } } // 非运行时动态确定，在代码中指定使用哪种策略 public class Application { public static void main(String[] args) { //... EvictionStrategy evictionStrategy = new LruEvictionStrategy(); UserCache userCache = new UserCache(evictionStrategy); //... } } 利用策略模式避免分支判断 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 策略的定义 public interface DiscountStrategy { double calDiscount(Order order); } // 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码... // 策略的创建 public class DiscountStrategyFactory { private static final Map\u0026lt;OrderType, DiscountStrategy\u0026gt; strategies = new HashMap\u0026lt;\u0026gt;(); static { strategies.put(OrderType.NORMAL, new NormalDiscountStrategy()); strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy()); strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy()); } public static DiscountStrategy getDiscountStrategy(OrderType type) { return strategies.get(type); } } // 策略的使用 public class OrderService { public double discount(Order order) { OrderType type = order.getType(); DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type); return discountStrategy.calDiscount(order); } } 实际上使用map来消除的\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","summary":"Strategy Pattern","title":"策略模式"},{"content":"用来解决复用和扩展两个问题\n模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步 骤。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public abstract class AbstractClass { public final void templateMethod() { //... method1(); //... method2(); //... } protected abstract void method1(); protected abstract void method2(); } public class ConcreteClass1 extends AbstractClass { @Override protected void method1() { //... } @Override protected void method2() { //... } } public class ConcreteClass2 extends AbstractClass { @Override protected void method1() { //... } @Override protected void method2() { //... } } AbstractClass demo = ConcreteClass1(); demo.templateMethod(); 参考 模板方法-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/","summary":"Template Method","title":"模板模式"},{"content":"sync.Pool 数据类型用来保存一组可独立访问的临时对象。\nsync.Pool 本身就是线程安全的 sync.Pool 不可在使用之后再复制使用 Get 方法的返回值还可能会是一个 nil（Pool.New 字段没有设置，又没有空闲元素可以返回），所以你在使用的时候，可能需要判断 如果 Put 一个 nil 值，Pool 就会忽略这个值 实现原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func poolCleanup() { // 丢弃当前victim, STW所以不用加锁 for _, p := range oldPools { p.victim = nil p.victimSize = 0 } // 将local复制给victim, 并将原local置为nil for _, p := range allPools { p.victim = p.local p.victimSize = p.localSize p.local = nil p.localSize = 0 } oldPools, allPools = allPools, nil } 请求元素时也是优先从 local 字段中查找可用的元素\n而 poolLocalInternal 也包含两个字段：private 和 shared。\nprivate，代表一个缓存的元素，而且只能由相应的一个 P 存取。因为一个 P 同时只能执行一个 goroutine，所以不会有并发的问题。 shared，可以由任意的 P 访问，但是只有本地的 P 才能 pushHead/popHead，其它 P 可以 popTail，相当于只有一个本地的 P 作为生产者（Producer），多个 P 作为消费者（Consumer），它是使用一个 local-free 的 queue 列表实现的。 Get 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func (p *Pool) Get() interface{} { // 把当前goroutine固定在当前的P上 l, pid := p.pin() x := l.private // 优先从local的private字段取，快速 l.private = nil if x == nil { // 从当前的local.shared弹出一个，注意是从head读取并移除 x, _ = l.shared.popHead() if x == nil { // 如果没有，则去偷一个 x = p.getSlow(pid) } } runtime_procUnpin() // 如果没有获取到，尝试使用New函数生成一个新的 if x == nil \u0026amp;\u0026amp; p.New != nil { x = p.New() } return x } 重点是 getSlow 方法，我们来分析下。看名字也就知道了，它的耗时可能比较长。它首先要遍历所有的 local，尝试从它们的 shared 弹出一个元素。如果还没 找到一个，那么，就开始对 victim 下手了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func (p *Pool) getSlow(pid int) interface{} { size := atomic.LoadUintptr(\u0026amp;p.localSize) locals := p.local // 从其它proc中尝试偷取一个元素 for i := 0; i \u0026lt; int(size); i++ { l := indexLocal(locals, (pid+i+1)%int(size)) if x, _ := l.shared.popTail(); x != nil { return x } } // 如果其它proc也没有可用元素，那么尝试从vintim中获取 size = atomic.LoadUintptr(\u0026amp;p.victimSize) if uintptr(pid) \u0026gt;= size { return nil } locals = p.victim l := indexLocal(locals, pid) if x := l.private; x != nil { // 同样的逻辑，先从vintim中的local private获取 l.private = nil return x } for i := 0; i \u0026lt; int(size); i++ { // 从vintim其它proc尝试偷取 l := indexLocal(locals, (pid+i)%int(size)) if x, _ := l.shared.popTail(); x != nil { return x } } // 如果victim中都没有，则把这个victim标记为空，以后的查找可以快速跳过了 atomic.StoreUintptr(\u0026amp;p.victimSize, 0) return nil } Put 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func (p *Pool) Put(x interface{}) { if x == nil { // nil值直接丢弃 return } l, _ := p.pin() if l.private == nil { // 如果本地private没有值，直接设置这个值即可 l.private = x x = nil } if x != nil { // 否则加入到本地队列中 l.shared.pushHead(x) } runtime_procUnpin() } sync.Pool 的坑 内存泄漏 将容量已经变得很大的 Buffer 再放回 Pool 中，导致内存泄漏。\n在使用 sync.Pool 回收 buffer 的时候，一定要检查回收的对象的大小。如果 buffer 太大，就不要回收了，否则就太浪费了。\n内存浪费 可以将 buffer 池分成几层。\n首先，小于 512 byte 的元素的 buffer 占一个池子； 其次，小于 1K byte 大小的元素占一个池子； 再次，小于 4K byte 大小的元素占一个池子。 这样分成几个池子以后，就可以根据需要，到所需大小的池子中获取 buffer 了。\n连接池 http.Client 实现连接池的代码是在 Transport 类型中 tcp连接池fatih/pool 标准库 sql.DB 还提供了一个通用的数据库的连接池，通过 MaxOpenConns 和 MaxIdleConns 控制最大的连接数和最大的 idle 的连接数。 Memcached Client 连接池采用 Mutex+Slice 实现 Pool Worker Pool fasthttp workerpool workerpool 参考 更加通用的多层buffer池bucketpool bytebufferpool bpool ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/pool/","summary":"sync.Pool 数据类型用来保存一组可独立访问的临时对象。 sync.Pool 本身就是线程安全的 sync.Pool 不可在使用之后再复制使用 Get 方法的返回值还可能会是一个 nil（Pool.Ne","title":"Pool"},{"content":"也被称为发布订阅模式（Publish-Subscribe Design Pattern）\n在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。\n一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。 常见的实现方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public interface Subject { void registerObserver(Observer observer); void removeObserver(Observer observer); void notifyObservers(Message message); } public interface Observer { void update(Message message); } public class ConcreteSubject implements Subject { private List\u0026lt;Observer\u0026gt; observers = new ArrayList\u0026lt;Observer\u0026gt;(); @Override public void registerObserver(Observer observer) { observers.add(observer); } @Override public void removeObserver(Observer observer) { observers.remove(observer); } @Override public void notifyObservers(Message message) { for (Observer observer : observers) { observer.update(message); } } } public class ConcreteObserverOne implements Observer { @Override public void update(Message message) { //TODO: 获取消息通知，执行自己的逻辑... System.out.println(\u0026#34;ConcreteObserverOne is notified.\u0026#34;); } } public class ConcreteObserverTwo implements Observer { @Override public void update(Message message) { //TODO: 获取消息通知，执行自己的逻辑... System.out.println(\u0026#34;ConcreteObserverTwo is notified.\u0026#34;); } } public class Demo { public static void main(String[] args) { ConcreteSubject subject = new ConcreteSubject(); subject.registerObserver(new ConcreteObserverOne()); subject.registerObserver(new ConcreteObserverTwo()); subject.notifyObservers(new Message()); } } 参考 观察者模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"Observer Pattern","title":"观察者模式"},{"content":"享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。\n池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并 不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中， 都是被所有使用者共享的，主要目的是节省空间。\n参考 享元模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","summary":"Flyweight Pattern","title":"享元模式"},{"content":"不常用, 主要是用来处理树形结构数据。\n参考 组合模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","summary":"Composite Pattern","title":"组合模式"},{"content":"外观模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。\n应用场景 解决易用性问题 解决性能问题 将多个接口调用替换为一个门面接口调用，减少网络通信成本 解决分布式事务问题 计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。 该如何组织门面接口和非门面接口？ 如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。 如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。 如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。 参考 门面模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/","summary":"Facade Pattern","title":"外观/门面模式"},{"content":"将不兼容的接口转换为可兼容的接口, 适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。\n类适配器使用继承关系来实现 对象适配器使用组合关系来实现 ITarget 表示要转化成的接口定义 Adaptee 是一组不兼容 ITarget 接口定义的接口 Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // 类适配器: 基于继承 public interface ITarget { void f1(); void f2(); void fc(); } public class Adaptee { public void fa() { //... } public void fb() { //... } public void fc() { //... } } public class Adaptor extends Adaptee implements ITarget { public void f1() { super.fa(); } public void f2() { //...重新实现f2()... } // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点 } // 对象适配器：基于组合 public interface ITarget { void f1(); void f2(); void fc(); } public class Adaptee { public void fa() { //... } public void fb() { //... } public void fc() { //... } } public class Adaptor implements ITarget { private Adaptee adaptee; public Adaptor(Adaptee adaptee) { this.adaptee = adaptee; } public void f1() { adaptee.fa(); //委托给Adaptee } public void f2() { //...重新实现f2()... } public void fc() { adaptee.fc(); } } 使用类适配器还是对象适配器?\n如果 Adaptee 接口并不多，那两种实现方式都可以。 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比 起对象适配器的实现方式，Adaptor 的代码量要少一些。(直接拿来用, 选择类适配器) 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。 (要重写, 选择对象适配器) 应用场景 封装有缺陷的接口设计 统一多个类的接口设计 替换依赖的外部系统 兼容老版本接口 适配不同格式的数据 参考 适配器模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"Adapter Pattern","title":"适配器模式"},{"content":"装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。\n组合由于继承, 避免复杂的继承关系\n装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类 1 2 3 4 InputStream in = new FileInputStream(\u0026#34;/user/wangzheng/test.txt\u0026#34;); InputStream bin = new BufferedInputStream(in); DataInputStream din = new DataInputStream(bin); int data = din.readInt(); 装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。 代理模式中，代理类附加的是跟原始类无关的功能 参考 装饰器模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"Decorator Pattern","title":"装饰器模式"},{"content":"桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public interface MsgSender { void send(String message); } public class TelephoneMsgSender implements MsgSender { private List\u0026lt;String\u0026gt; telephones; public TelephoneMsgSender(List\u0026lt;String\u0026gt; telephones) { this.telephones = telephones; } @Override public void send(String message) { //... } } public class EmailMsgSender implements MsgSender { // 与TelephoneMsgSender代码结构类似，所以省略... } public class WechatMsgSender implements MsgSender { // 与TelephoneMsgSender代码结构类似，所以省略... } public abstract class Notification { protected MsgSender msgSender; public Notification(MsgSender msgSender) { this.msgSender = msgSender; } public abstract void notify(String message); } public class SevereNotification extends Notification { public SevereNotification(MsgSender msgSender) { super(msgSender); } @Override public void notify(String message) { msgSender.send(message); } } public class UrgencyNotification extends Notification { // 与SevereNotification代码结构类似，所以省略... } public class NormalNotification extends Notification { // 与SevereNotification代码结构类似，所以省略... } public class TrivialNotification extends Notification { // 与SevereNotification代码结构类似，所以省略... } 参考 桥接模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","summary":"Bridge Pattern","title":"桥接模式"},{"content":"代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。\n代理类和业务类实现相同接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 public interface IUserController { UserVo login(String telephone, String password); UserVo register(String telephone, String password); } public class UserController implements IUserController { //...省略其他属性和方法... @Override public UserVo login(String telephone, String password) { //...省略login逻辑... //...返回UserVo数据... } @Override public UserVo register(String telephone, String password) { //...省略register逻辑... //...返回UserVo数据... } } public class UserControllerProxy implements IUserController { private MetricsCollector metricsCollector; private UserController userController; public UserControllerProxy(UserController userController) { this.userController = userController; this.metricsCollector = new MetricsCollector(); } @Override public UserVo login(String telephone, String password) { long startTimestamp = System.currentTimeMillis(); // 委托 UserVo userVo = userController.login(telephone, password); long endTimeStamp = System.currentTimeMillis(); long responseTime = endTimeStamp - startTimestamp; RequestInfo requestInfo = new RequestInfo(\u0026#34;login\u0026#34;, responseTime, startTimestamp); metricsCollector.recordRequest(requestInfo); return userVo; } @Override public UserVo register(String telephone, String password) { long startTimestamp = System.currentTimeMillis(); UserVo userVo = userController.register(telephone, password); long endTimeStamp = System.currentTimeMillis(); long responseTime = endTimeStamp - startTimestamp; RequestInfo requestInfo = new RequestInfo(\u0026#34;register\u0026#34;, responseTime, startTimestamp); metricsCollector.recordRequest(requestInfo); return userVo; } } //UserControllerProxy使用举例 //因为原始类和代理类实现相同的接口，是基于接口而非实现编程 //将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码 IUserController userController = new UserControllerProxy(new UserController()); 对于外部代码, 可以使用继承\n动态代理 Dynamic Proxy 在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class MetricsCollectorProxy { private MetricsCollector metricsCollector; public MetricsCollectorProxy() { this.metricsCollector = new MetricsCollector(); } public Object createProxy(Object proxiedObject) { Class\u0026lt;?\u0026gt;[] interfaces = proxiedObject.getClass().getInterfaces(); DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject); return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler); } private class DynamicProxyHandler implements InvocationHandler { private Object proxiedObject; public DynamicProxyHandler(Object proxiedObject) { this.proxiedObject = proxiedObject; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { long startTimestamp = System.currentTimeMillis(); Object result = method.invoke(proxiedObject, args); long endTimeStamp = System.currentTimeMillis(); long responseTime = endTimeStamp - startTimestamp; String apiName = proxiedObject.getClass().getName() + \u0026#34;:\u0026#34; + method.getName(); RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp); metricsCollector.recordRequest(requestInfo); return result; } } } //MetricsCollectorProxy使用举例 MetricsCollectorProxy proxy = new MetricsCollectorProxy(); IUserController userController = (IUserController) proxy.createProxy(new UserController()); 参考 代理模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","summary":"Proxy Pattern","title":"代理模式"},{"content":"聚合统计 集合的交, 差, 并集\nSUNIONSTORE SDIFFSTORE SINTERSTORE 这些命令复杂度较高\n排序统计 可以使用sorted set保证分页时, 元素不会串\nZRANGEBYSCORE 二值状态统计 bitmap\nSETBIT BITOP BITCOUNT 基数统计 指统计一个集合中不重复的元素个数\nset\nSADD SCARD hash\nHSET HLEN hyperLogLog\n用于统计基数的数据集合类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小。 有一定误差 PFADD PFCOUNT ","permalink":"https://jdxj.github.io/posts/articles/jdxj/redis/redis%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%BC%8F/","summary":"聚合统计 集合的交, 差, 并集 SUNIONSTORE SDIFFSTORE SINTERSTORE 这些命令复杂度较高 排序统计 可以使用sorted set保证分页时, 元素不会串 ZRANGEBYSCORE 二值状态统计 bitmap SETBIT BITOP BITCOUNT 基数统计 指统","title":"Redis中常见的四种统计模式"},{"content":"占用内存的元数据过多\n全局hash表一个项是dictEntry 封装底层编码的RedisObject 如果想节约内存, 可以考虑使用底层编码为ziplist的集合\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/redis/%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E4%BD%BF%E7%94%A8string/","summary":"占用内存的元数据过多 全局hash表一个项是dictEntry 封装底层编码的RedisObject 如果想节约内存, 可以考虑使用底层编码为zip","title":"过多的使用String键会造成内存浪费"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/segmentfault/go-generics/","summary":"原文","title":"Go 1.18 泛型全面讲解：一篇讲清泛型的全部"},{"content":"key必须是可比较的\n不可比较的类型 如果 struct 的某个字段值修改了，查询 map 时无法获取它 add 进去的值 有序的map orderedmap\n不能并发读写\n实现线程安全map 加读写锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package test import \u0026#34;sync\u0026#34; type RWMap[K comparable, V any] struct { sync.RWMutex m map[K]V } func NewRWMap[K comparable, V any](n int) *RWMap[K, V] { return \u0026amp;RWMap[K, V]{ m: make(map[K]V), } } func (m *RWMap[K, V]) Get(k K) (V, bool) { m.RLock() defer m.RUnlock() v, existed := m.m[k] return v, existed } func (m *RWMap[K, V]) Set(k K, v V) { m.Lock() defer m.Unlock() m.m[k] = v } func (m *RWMap[K, V]) Delete(k K) { m.Lock() defer m.Unlock() delete(m.m, k) } func (m *RWMap[K, V]) Len() int { m.RLock() defer m.RUnlock() return len(m.m) } func (m *RWMap[K, V]) Each(f func(k K, v V) bool) { m.RLock() defer m.RUnlock() for k, v := range m.m { if !f(k, v) { return } } } 分片加锁concurrent-map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 var SHARD_COUNT = 32 // 分成SHARD_COUNT个分片的map type ConcurrentMap []*ConcurrentMapShared // 通过RWMutex保护的线程安全的分片，包含一个map type ConcurrentMapShared struct { items map[string]interface{} sync.RWMutex // Read Write mutex, guards access to internal map. } // 创建并发map func New() ConcurrentMap { m := make(ConcurrentMap, SHARD_COUNT) for i := 0; i \u0026lt; SHARD_COUNT; i++ { m[i] = \u0026amp;ConcurrentMapShared{items: make(map[string]interface{})} } return m } // 根据key计算分片索引 func (m ConcurrentMap) GetShard(key string) *ConcurrentMapShared { return m[uint(fnv32(key))%uint(SHARD_COUNT)] } func (m ConcurrentMap) Set(key string, value interface{}) { // 根据key计算出对应的分片 shard := m.GetShard(key) shard.Lock() //对这个分片加锁，执行业务操作 shard.items[key] = value shard.Unlock() } func (m ConcurrentMap) Get(key string) (interface{}, bool) { // 根据key计算出对应的分片 shard := m.GetShard(key) shard.RLock() // 从这个分片读取key的值 val, ok := shard.items[key] shard.RUnlock() return val, ok } sync.Map sync.Map 并不是用来替换内建的 map 类型的，它只能被应用在一些特殊的场景里。\n官方的文档中指出，在以下两个场景中使用 sync.Map，会比使用 map+RWMutex 的方式，性能要好得多：\n只会增长的缓存系统中，一个 key 只写入一次而被读很多次； 多个 goroutine 为不相交的键集读、写和重写键值对。 这两个场景说得都比较笼统，而且，这些场景中还包含了一些特殊的情况。所以，官方建议你针对自己的场景做性能评测，如果确实能够显著提高性能，再使用 sync.Map。\n","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/map/","summary":"key必须是可比较的 不可比较的类型 如果 struct 的某个字段值修改了，查询 map 时无法获取它 add 进去的值 有序的map orderedmap 不能并发读写 实现线程安全map 加读写锁","title":"map"},{"content":"选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。\n原地排序 不稳定 最好O(n^2) 最坏O(n^2) 平均O(n^2) 参考 选择排序-go ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","summary":"Selection Sort","title":"选择排序"},{"content":"插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 插入排序，a表示数组，n表示数组大小 public void insertionSort(int[] a, int n) { if (n \u0026lt;= 1) return; for (int i = 1; i \u0026lt; n; ++i) { int value = a[i]; int j = i - 1; // 查找插入的位置 for (; j \u0026gt;= 0; --j) { if (a[j] \u0026gt; value) { a[j+1] = a[j]; // 数据移动 } else { break; } } a[j+1] = value; // 插入数据 } } 原地排序 稳定 最好O(n) 最坏O(n^2) 平均O(n^2) 参考 插入排序-go ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","summary":"Insertion Sort","title":"插入排序"},{"content":"一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。\n第一次 后续 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 冒泡排序，a表示数组，n表示数组大小 public void bubbleSort(int[] a, int n) { if (n \u0026lt;= 1) return; for (int i = 0; i \u0026lt; n; ++i) { // 提前退出冒泡循环的标志位 boolean flag = false; for (int j = 0; j \u0026lt; n - i - 1; ++j) { if (a[j] \u0026gt; a[j+1]) { // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true; // 表示有数据交换 } } if (!flag) break; // 没有数据交换，提前退出 } } 原地排序 稳定 最好O(n) 最坏O(n^2) 平均O(n^2) 参考 冒泡排序-go ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","summary":"Bubble Sort","title":"冒泡排序"},{"content":"排序算法的执行效率 最好情况、最坏情况、平均情况时间复杂度 时间复杂度的系数、常数 、低阶 比较次数和交换（或移动）次数 排序算法的内存消耗 原地排序 排序算法的稳定性 ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","summary":"排序算法的执行效率 最好情况、最坏情况、平均情况时间复杂度 时间复杂度的系数、常数 、低阶 比较次数和交换（或移动）次数 排序算法的内存消耗 原地排序 排","title":"如何分析排序算法"},{"content":"如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝） 的方式来创建新对象，以达到节省创建时间的目的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class Demo { private HashMap\u0026lt;String, SearchWord\u0026gt; currentKeywords=new HashMap\u0026lt;\u0026gt;(); private long lastUpdateTime = -1; public void refresh() { // 原型模式就这么简单，拷贝已有对象的数据，更新少量差值 HashMap\u0026lt;String, SearchWord\u0026gt; newKeywords = (HashMap\u0026lt;String, SearchWord\u0026gt;) currentKeywords.clone(); // 浅拷贝 // 从数据库中取出更新时间\u0026gt;lastUpdateTime的数据，放入到newKeywords中 List\u0026lt;SearchWord\u0026gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime); long maxNewUpdatedTime = lastUpdateTime; for (SearchWord searchWord : toBeUpdatedSearchWords) { if (searchWord.getLastUpdateTime() \u0026gt; maxNewUpdatedTime) { maxNewUpdatedTime = searchWord.getLastUpdateTime(); } if (newKeywords.containsKey(searchWord.getKeyword())) { SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword()); oldSearchWord.setCount(searchWord.getCount()); oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime()); } else { newKeywords.put(searchWord.getKeyword(), searchWord); } } lastUpdateTime = maxNewUpdatedTime; currentKeywords = newKeywords; } private List\u0026lt;SearchWord\u0026gt; getSearchWords(long lastUpdateTime) { // TODO: 从数据库中取出更新时间\u0026gt;lastUpdateTime的数据 return null; } } 深拷贝和浅拷贝 浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。\n深拷贝\n方法一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class Demo { private HashMap\u0026lt;String, SearchWord\u0026gt; currentKeywords=new HashMap\u0026lt;\u0026gt;(); private long lastUpdateTime = -1; public void refresh() { // Deep copy HashMap\u0026lt;String, SearchWord\u0026gt; newKeywords = new HashMap\u0026lt;\u0026gt;(); for (HashMap.Entry\u0026lt;String, SearchWord\u0026gt; e : currentKeywords.entrySet()) { SearchWord searchWord = e.getValue(); SearchWord newSearchWord = new SearchWord( searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime()); newKeywords.put(e.getKey(), newSearchWord); } // 从数据库中取出更新时间\u0026gt;lastUpdateTime的数据，放入到newKeywords中 List\u0026lt;SearchWord\u0026gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime); long maxNewUpdatedTime = lastUpdateTime; for (SearchWord searchWord : toBeUpdatedSearchWords) { if (searchWord.getLastUpdateTime() \u0026gt; maxNewUpdatedTime) { maxNewUpdatedTime = searchWord.getLastUpdateTime(); } if (newKeywords.containsKey(searchWord.getKeyword())) { SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword()); oldSearchWord.setCount(searchWord.getCount()); oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime()); } else { newKeywords.put(searchWord.getKeyword(), searchWord); } } lastUpdateTime = maxNewUpdatedTime; currentKeywords = newKeywords; } private List\u0026lt;SearchWord\u0026gt; getSearchWords(long lastUpdateTime) { // TODO: 从数据库中取出更新时间\u0026gt;lastUpdateTime的数据 return null; } } 方法二 1 2 3 4 5 6 7 8 9 10 public Object deepCopy(Object object) { ByteArrayOutputStream bo = new ByteArrayOutputStream(); ObjectOutputStream oo = new ObjectOutputStream(bo); oo.writeObject(object); ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray()); ObjectInputStream oi = new ObjectInputStream(bi); return oi.readObject(); } 深浅结合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Demo { private HashMap\u0026lt;String, SearchWord\u0026gt; currentKeywords=new HashMap\u0026lt;\u0026gt;(); private long lastUpdateTime = -1; public void refresh() { // Shallow copy HashMap\u0026lt;String, SearchWord\u0026gt; newKeywords = (HashMap\u0026lt;String, SearchWord\u0026gt;) currentKeywords.clone(); // 从数据库中取出更新时间\u0026gt;lastUpdateTime的数据，放入到newKeywords中 List\u0026lt;SearchWord\u0026gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime); long maxNewUpdatedTime = lastUpdateTime; for (SearchWord searchWord : toBeUpdatedSearchWords) { if (searchWord.getLastUpdateTime() \u0026gt; maxNewUpdatedTime) { maxNewUpdatedTime = searchWord.getLastUpdateTime(); } if (newKeywords.containsKey(searchWord.getKeyword())) { newKeywords.remove(searchWord.getKeyword()); } newKeywords.put(searchWord.getKeyword(), searchWord); } lastUpdateTime = maxNewUpdatedTime; currentKeywords = newKeywords; } private List\u0026lt;SearchWord\u0026gt; getSearchWords(long lastUpdateTime) { // TODO: 从数据库中取出更新时间\u0026gt;lastUpdateTime的数据 return null; } } 参考 原型模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","summary":"Prototype Pattern","title":"原型模式"},{"content":"把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校 验通过之后才会创建对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 public class ResourcePoolConfig { private String name; private int maxTotal; private int maxIdle; private int minIdle; private ResourcePoolConfig(Builder builder) { this.name = builder.name; this.maxTotal = builder.maxTotal; this.maxIdle = builder.maxIdle; this.minIdle = builder.minIdle; } //...省略getter方法... //我们将Builder类设计成了ResourcePoolConfig的内部类。 //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。 public static class Builder { private static final int DEFAULT_MAX_TOTAL = 8; private static final int DEFAULT_MAX_IDLE = 8; private static final int DEFAULT_MIN_IDLE = 0; private String name; private int maxTotal = DEFAULT_MAX_TOTAL; private int maxIdle = DEFAULT_MAX_IDLE; private int minIdle = DEFAULT_MIN_IDLE; public ResourcePoolConfig build() { // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等 if (StringUtils.isBlank(name)) { throw new IllegalArgumentException(\u0026#34;...\u0026#34;); } if (maxIdle \u0026gt; maxTotal) { throw new IllegalArgumentException(\u0026#34;...\u0026#34;); } if (minIdle \u0026gt; maxTotal || minIdle \u0026gt; maxIdle) { throw new IllegalArgumentException(\u0026#34;...\u0026#34;); } return new ResourcePoolConfig(this); } public Builder setName(String name) { if (StringUtils.isBlank(name)) { throw new IllegalArgumentException(\u0026#34;...\u0026#34;); } this.name = name; return this; } public Builder setMaxTotal(int maxTotal) { if (maxTotal \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;...\u0026#34;); } this.maxTotal = maxTotal; return this; } public Builder setMaxIdle(int maxIdle) { if (maxIdle \u0026lt; 0) { throw new IllegalArgumentException(\u0026#34;...\u0026#34;); } this.maxIdle = maxIdle; return this; } public Builder setMinIdle(int minIdle) { if (minIdle \u0026lt; 0) { throw new IllegalArgumentException(\u0026#34;...\u0026#34;); } this.minIdle = minIdle; return this; } } } // 这段代码会抛出IllegalArgumentException，因为minIdle\u0026gt;maxIdle ResourcePoolConfig config = new ResourcePoolConfig.Builder() .setName(\u0026#34;dbconnectionpool\u0026#34;) .setMaxTotal(16) .setMaxIdle(10) .setMinIdle(12) .build(); 与工厂模式有何区别？ 工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复 杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。\n参考 建造者模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"Builder Pattern","title":"建造者模式"},{"content":"简单工厂 Simple Factory 根据key返回符合某一接口的实现\n方式一\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class RuleConfigSource { public RuleConfig load(String ruleConfigFilePath) { String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension); if (parser == null) { throw new InvalidRuleConfigException( \u0026#34;Rule config file format is not supported: \u0026#34; + ruleConfigFilePath); } String configText = \u0026#34;\u0026#34;; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; } private String getFileExtension(String filePath) { //...解析文件名获取扩展名，比如rule.json，返回json return \u0026#34;json\u0026#34;; } } public class RuleConfigParserFactory { public static IRuleConfigParser createParser(String configFormat) { IRuleConfigParser parser = null; if (\u0026#34;json\u0026#34;.equalsIgnoreCase(configFormat)) { parser = new JsonRuleConfigParser(); } else if (\u0026#34;xml\u0026#34;.equalsIgnoreCase(configFormat)) { parser = new XmlRuleConfigParser(); } else if (\u0026#34;yaml\u0026#34;.equalsIgnoreCase(configFormat)) { parser = new YamlRuleConfigParser(); } else if (\u0026#34;properties\u0026#34;.equalsIgnoreCase(configFormat)) { parser = new PropertiesRuleConfigParser(); } return parser; } } 方式二\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class RuleConfigParserFactory { private static final Map\u0026lt;String, RuleConfigParser\u0026gt; cachedParsers = new HashMap\u0026lt;\u0026gt;(); static { cachedParsers.put(\u0026#34;json\u0026#34;, new JsonRuleConfigParser()); cachedParsers.put(\u0026#34;xml\u0026#34;, new XmlRuleConfigParser()); cachedParsers.put(\u0026#34;yaml\u0026#34;, new YamlRuleConfigParser()); cachedParsers.put(\u0026#34;properties\u0026#34;, new PropertiesRuleConfigParser()); } public static IRuleConfigParser createParser(String configFormat) { if (configFormat == null || configFormat.isEmpty()) { return null;//返回null还是IllegalArgumentException全凭你自己说了算 } IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase()); return parser; } } 尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加 parser，也没有太多的 parser）是没有问题的。\n工厂方法 Factory Method 为了把创建对象的函数放到map\u0026lt;string, Factory\u0026gt;中, 所以又把工厂给抽象成接口了.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public interface IRuleConfigParserFactory { IRuleConfigParser createParser(); } public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new JsonRuleConfigParser(); } } public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new XmlRuleConfigParser(); } } public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new YamlRuleConfigParser(); } } public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new PropertiesRuleConfigParser(); } } public class RuleConfigSource { public RuleConfig load(String ruleConfigFilePath) { String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension); if (parserFactory == null) { throw new InvalidRuleConfigException(\u0026#34;Rule config file format is not supported: \u0026#34; + ruleConfigFilePath); } IRuleConfigParser parser = parserFactory.createParser(); String configText = \u0026#34;\u0026#34;; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; } private String getFileExtension(String filePath) { //...解析文件名获取扩展名，比如rule.json，返回json return \u0026#34;json\u0026#34;; } } //因为工厂类只包含方法，不包含成员变量，完全可以复用， //不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。 public class RuleConfigParserFactoryMap { //工厂的工厂 private static final Map\u0026lt;String, IRuleConfigParserFactory\u0026gt; cachedFactories = new HashMap\u0026lt;\u0026gt;(); static { cachedFactories.put(\u0026#34;json\u0026#34;, new JsonRuleConfigParserFactory()); cachedFactories.put(\u0026#34;xml\u0026#34;, new XmlRuleConfigParserFactory()); cachedFactories.put(\u0026#34;yaml\u0026#34;, new YamlRuleConfigParserFactory()); cachedFactories.put(\u0026#34;properties\u0026#34;, new PropertiesRuleConfigParserFactory()); } public static IRuleConfigParserFactory getParserFactory(String type) { if (type == null || type.isEmpty()) { return null; } IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase()); return parserFactory; } } 基本上符合开闭原则\n抽象工厂 Abstract Factory 应用场景比较特殊，没有前两种常用\nFactory接口中包含更多种类的create()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public interface IConfigParserFactory { IRuleConfigParser createRuleParser(); ISystemConfigParser createSystemParser(); //此处可以扩展新的parser类型，比如IBizConfigParser } public class JsonConfigParserFactory implements IConfigParserFactory { @Override public IRuleConfigParser createRuleParser() { return new JsonRuleConfigParser(); } @Override public ISystemConfigParser createSystemParser() { return new JsonSystemConfigParser(); } } public class XmlConfigParserFactory implements IConfigParserFactory { @Override public IRuleConfigParser createRuleParser() { return new XmlRuleConfigParser(); } @Override public ISystemConfigParser createSystemParser() { return new XmlSystemConfigParser(); } } // 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码 参考 简单工厂-go 工厂方法-go 抽象工厂-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","summary":"Factory Pattern","title":"工厂模式"},{"content":"Once 的使用场景 1 func (o *Once) Do(f func()) Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源。\n如何实现一个 Once？ 很多人认为实现一个 Once 一样的并发原语很简单\n1 2 3 4 5 6 7 8 9 10 type Once struct { done uint32 } func (o *Once) Do(f func()) { if !atomic.CompareAndSwapUint32(\u0026amp;o.done, 0, 1) { return } f() } 就是如果参数 f 执行很慢的话，后续调用 Do 方法的 goroutine 虽然看到 done 已经设置为执行过了，但是获取某些初始化资源的时候可能会得到空的资源\n一个正确的 Once 实现要\n使用一个互斥锁保证只有一个 goroutine 进行初始化 利用双检查的机制（double-checking），再次判断 o.done 是否为 0，如果为 0，则是第一次执行，执行完毕后，就将 o.done 设置为 1，然后释放锁。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type Once struct { done uint32 m Mutex } func (o *Once) Do(f func()) { if atomic.LoadUint32(\u0026amp;o.done) == 0 { o.doSlow(f) } } func (o *Once) doSlow(f func()) { o.m.Lock() defer o.m.Unlock() // 双检查 if o.done == 0 { defer atomic.StoreUint32(\u0026amp;o.done, 1) f() } } ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/once/","summary":"Once 的使用场景 1 func (o *Once) Do(f func()) Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源。 如何实现一个 On","title":"Once"},{"content":"Go 标准库提供 Cond 原语的目的是，为等待/通知场景下的并发问题提供支持。\nCond 的基本用法 1 2 3 4 5 type Cond func NeWCond(l Locker) *Cond func (c *Cond) Broadcast() func (c *Cond) Signal() func (c *Cond) Wait() Cond 关联的 Locker 实例可以通过 c.L 访问，它内部维护着一个先入先出的等待队列。 Signal 方法，允许调用者 Caller 唤醒一个等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等待队 列中有一个或者多个等待的 goroutine，则需要从等待队列中移除第一个 goroutine 并把它唤醒。 调用 Signal 方法时，不强求你一定要持有 c.L 的锁。 Broadcast 方法，允许调用者 Caller 唤醒所有等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等 待队列中有一个或者多个等待的 goroutine，则清空所有等待的 goroutine，并全部唤醒。 调用 Broadcast 方法时，也不强求你一定持有 c.L 的锁。 Wait 方法，会把调用者 Caller 放入 Cond 的等待队列中并阻塞，直到被 Signal 或者 Broadcast 的方法从等待队列中移除并唤醒。 调用 Wait 方法时必须要持有 c.L 的锁。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func main() { c := sync.NewCond(\u0026amp;sync.Mutex{}) var ready int for i := 0; i \u0026lt; 10; i++ { go func(i int) { time.Sleep(time.Duration(rand.Int63n(10)) * time.Second) // 加锁更改等待条件 c.L.Lock() ready++ c.L.Unlock() log.Printf(\u0026#34;运动员#%d 已准备就绪\\n\u0026#34;, i) // 广播唤醒所有的等待者 c.Broadcast() }(i) } c.L.Lock() for ready != 10 { c.Wait() log.Println(\u0026#34;裁判员被唤醒一次\u0026#34;) } c.L.Unlock() //所有的运动员是否就绪 log.Println(\u0026#34;所有运动员都准备就绪。比赛开始，3，2，1, ......\u0026#34;) } Cond 的使用其实没那么简单。它的复杂在于：\n这段代码有时候需要加锁，有时候可以不加； Wait 唤醒后需要检查条件； 条件变量的更改，其实是需要原子操作或者互斥锁保护的。 Cond 的实现原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 type Cond struct { noCopy noCopy // 当观察或者修改等待条件的时候需要加锁 L Locker // 等待队列 notify notifyList checker copyChecker } func NewCond(l Locker) *Cond { return \u0026amp;Cond{L: l} } func (c *Cond) Wait() { c.checker.check() // 增加到等待队列中 t := runtime_notifyListAdd(\u0026amp;c.notify) c.L.Unlock() // 阻塞休眠直到被唤醒 runtime_notifyListWait(\u0026amp;c.notify, t) c.L.Lock() } func (c *Cond) Signal() { c.checker.check() runtime_notifyListNotifyOne(\u0026amp;c.notify) } func (c *Cond) Broadcast() { c.checker.check() runtime_notifyListNotifyAll(\u0026amp;c.notify) } runtime_notifyListXXX 是运行时实现的方法，实现了一个等待 / 通知的队列。 copyChecker 是一个辅助结构，可以在运行时检查 Cond 是否被复制使用。 Signal 和 Broadcast 只涉及到 notifyList 数据结构，不涉及到锁。 Wait 把调用者加入到等待队列时会释放锁，在被唤醒之后还会请求锁。在阻塞休眠期间，调用者是不持有锁的，这样能让其他 goroutine 有机会检查或者更新 等待变量。 Cond为什么不能被Channel替代 Cond 和一个 Locker 关联，可以利用这个 Locker 对相关的依赖条件更改提供保护。 Cond 可以同时支持 Signal 和 Broadcast 方法，而 Channel 只能同时支持其中一种。 Cond 的 Broadcast 方法可以被重复调用。等待条件再次变成不满足的状态后，我们又可以调用 Broadcast 再次唤醒等待的 goroutine。这也是 Channel 不能支持的，Channel 被 close 掉了之后不支持再 open。 有限容量队列实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;sync\u0026#34; ) type Queue struct { cond *sync.Cond data []interface{} capc int logs []string } func NewQueue(capacity int) *Queue { return \u0026amp;Queue{cond: \u0026amp;sync.Cond{L: \u0026amp;sync.Mutex{}}, data: make([]interface{}, 0), capc: capacity, logs: make([]string, 0)} } func (q *Queue) Enqueue(d interface{}) { q.cond.L.Lock() defer q.cond.L.Unlock() for len(q.data) == q.capc { q.cond.Wait() } // FIFO入队 q.data = append(q.data, d) // 记录操作日志 q.logs = append(q.logs, fmt.Sprintf(\u0026#34;En %v\\n\u0026#34;, d)) // 通知其他waiter进行Dequeue或Enqueue操作 q.cond.Broadcast() } func (q *Queue) Dequeue() (d interface{}) { q.cond.L.Lock() defer q.cond.L.Unlock() for len(q.data) == 0 { q.cond.Wait() } // FIFO出队 d = q.data[0] q.data = q.data[1:] // 记录操作日志 q.logs = append(q.logs, fmt.Sprintf(\u0026#34;De %v\\n\u0026#34;, d)) // 通知其他waiter进行Dequeue或Enqueue操作 q.cond.Broadcast() return } func (q *Queue) Len() int { q.cond.L.Lock() defer q.cond.L.Unlock() return len(q.data) } func (q *Queue) String() string { var b strings.Builder for _, log := range q.logs { // fmt.Fprint(\u0026amp;b, log) b.WriteString(log) } return b.String() } ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/cond/","summary":"Go 标准库提供 Cond 原语的目的是，为等待/通知场景下的并发问题提供支持。 Cond 的基本用法 1 2 3 4 5 type Cond func NeWCond(l Locker) *Cond func (c *Cond) Broadcast() func (c *Cond) Signal() func (c *Cond) Wait() Cond 关联的 Locker 实例可","title":"Cond 条件变量"},{"content":"递归需要满足的三个条件 一个问题的解可以分解为几个子问题的解 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 注意 递归代码要警惕堆栈溢出 递归代码要警惕重复计算 在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。 在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销 ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%80%92%E5%BD%92/","summary":"递归需要满足的三个条件 一个问题的解可以分解为几个子问题的解 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 注意","title":"递归"},{"content":"一个类只允许创建一个对象（或者实例）\n为什么要使用单例？ 处理资源访问冲突 表示全局唯一类 实现一个单例 私有构造方法 线程安全的创建实例 是否延迟加载 getInstance()性能是否高 饿汉式 立即初始化 如果有外部依赖时, 可能会初始化失败 1 2 3 4 5 6 7 8 9 10 11 public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static final IdGenerator instance = new IdGenerator(); private IdGenerator() {} public static IdGenerator getInstance() { return instance; } public long getId() { return id.incrementAndGet(); } } 懒汉式 延迟加载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static IdGenerator instance; private IdGenerator() {} public static synchronized IdGenerator getInstance() { if (instance == null) { instance = new IdGenerator(); } return instance; } public long getId() { return id.incrementAndGet(); } } 双重检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static IdGenerator instance; private IdGenerator() {} public static IdGenerator getInstance() { if (instance == null) { synchronized(IdGenerator.class) { // 此处为类级别的锁 if (instance == null) { instance = new IdGenerator(); } } } return instance; } public long getId() { return id.incrementAndGet(); } } 实际上，上述实现方式存在问题：CPU 指令重排序可能导致在 IdGenerator 类的对象被关键字 new 创建并赋值给 instance 之后，还没来得及初始化（执行 构造函数中的代码逻辑），就被另一个线程使用了。这样，另一个线程就使用了一个没有完整初始化的 IdGenerator 类的对象。要解决这个问题，我们只需要给 instance 成员变量添加 volatile 关键字来禁止指令重排序即可。\n静态内部类 一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。 instance 的唯一性、创建过程的线程安全 性，都由 JVM 来保证。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class IdGenerator { private AtomicLong id = new AtomicLong(0); private IdGenerator() {} private static class SingletonHolder{ private static final IdGenerator instance = new IdGenerator(); } public static IdGenerator getInstance() { return SingletonHolder.instance; } public long getId() { return id.incrementAndGet(); } } 枚举 这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。\n1 2 3 4 5 6 7 8 public enum IdGenerator { INSTANCE; private AtomicLong id = new AtomicLong(0); public long getId() { return id.incrementAndGet(); } } 参考 单例模式-go ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","summary":"Singleton Pattern","title":"单例模式"},{"content":"WaitGroup 的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type WaitGroup struct { // 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则 noCopy noCopy // 64bit(8bytes)的值分成两段，高32bit是计数值，低32bit是waiter的计数 // 另外32bit是用作信号量的 // 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样，具体处理看下面的方法 // 总之，会找到对齐的那64bit作为state，其余的32bit做信号量 state1 [3]uint32 } // 得到state的地址和信号量的地址 func (wg *WaitGroup) state() (statep *uint64, semap *uint32) { if uintptr(unsafe.Pointer(\u0026amp;wg.state1))%8 == 0 { // 如果地址是64bit对齐的，数组前两个元素做state，后一个元素做信号量 return (*uint64)(unsafe.Pointer(\u0026amp;wg.state1)), \u0026amp;wg.state1[2] } else { // 如果地址是32bit对齐的，数组后两个元素用来做state，它可以用来做64bit的原子操作，第一个元素32bit用来做信号量 return (*uint64)(unsafe.Pointer(\u0026amp;wg.state1[1])), \u0026amp;wg.state1[0] } } 在 64 位环境下，state1 的第一个元素是 waiter 数，第二个元素是 WaitGroup 的计数值，第三个元素是信号量。\n在 32 位环境下，如果 state1 不是 64 位对齐的地址，那么 state1 的第一个元素是信号量，后两个元素分别是 waiter 数和计数值。\nAdd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func (wg *WaitGroup) Add(delta int) { statep, semap := wg.state() // 高32bit是计数值v，所以把delta左移32，增加到计数上 state := atomic.AddUint64(statep, uint64(delta)\u0026lt;\u0026lt;32) v := int32(state \u0026gt;\u0026gt; 32) // 当前计数值 w := uint32(state) // waiter count if v \u0026gt; 0 || w == 0 { return } // 如果计数值v为0并且waiter的数量w不为0，那么state的值就是waiter的数量 // 将waiter的数量设置为0，因为计数值v也是0,所以它们俩的组合*statep直接设置为0即可。此时需要并唤醒所有的waiter *statep = 0 for ; w != 0; w-- { runtime_Semrelease(semap, false, 0) } } // Done方法实际就是计数器减1 func (wg *WaitGroup) Done() { wg.Add(-1) } Wait Wait 方法的实现逻辑是：不断检查 state 的值。如果其中的计数值变为了 0，那么说明所有的任务已完成，调用者不必再等待，直接返回。如果计数值大于 0， 说明此时还有任务没完成，那么调用者就变成了等待者，需要加入 waiter 队列，并且阻塞住自己。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func (wg *WaitGroup) Wait() { statep, semap := wg.state() for { state := atomic.LoadUint64(statep) v := int32(state \u0026gt;\u0026gt; 32) // 当前计数值 w := uint32(state) // waiter的数量 if v == 0 { // 如果计数值为0, 调用这个方法的goroutine不必再等待，继续执行它后面的逻辑即可 return } // 否则把waiter数量加1。期间可能有并发调用Wait的情况，所以最外层使用了一个for循环 if atomic.CompareAndSwapUint64(statep, state, state+1) { // 阻塞休眠等待 runtime_Semacquire(semap) // 被唤醒，不再阻塞，返回 return } } } 使用 WaitGroup 的正确姿势是，预先确定好 WaitGroup 的计数值，然后调用相同次数的 Done 完成相应的任务。\n总结 ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/waitgroup/","summary":"WaitGroup 的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type WaitGroup struct { // 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则 noCopy noCopy // 64bit(8","title":"WaitGroup"},{"content":"先进者先出，这就是典型的“队列”。\n循环队列 要想写出没有 bug 的循环队列的实现代码最关键的是，确定好队空和队满的判定条件。\n队空 head == tail 队满 head == (tail+1)%n 阻塞队列 就是在队列为空的时候，从队头取数据会被阻塞 果队列已经满了，那么插入数据的操作就会被阻塞 并发队列 线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存 或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。\n","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%98%9F%E5%88%97/","summary":"先进者先出，这就是典型的“队列”。 循环队列 要想写出没有 bug 的循环队列的实现代码最关键的是，确定好队空和队满的判定条件。 队空 head == tail 队满 head == (tail+1)%n 阻塞","title":"队列"},{"content":"栈是一种“操作受限”的线性表\n","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%A0%88/","summary":"栈是一种“操作受限”的线性表","title":"栈"},{"content":"命名 命名长度 作用域大的长点 作用域小的短点 利用上下文简化命令 属性名可以不加user 1 2 3 4 5 6 public class User { private String userName; private String userPassword; private String userAvatarUrl; //... } 函数参数 1 2 3 public void uploadUserAvatarImageToAliyun(String userAvatarImageUri); //利用上下文简化为： public void uploadUserAvatarImageToAliyun(String imageUri); 命名要可读、可搜索 大概能读出个音就行 大家都用“selectXXX”表示查询，你就不要用“queryXXX”；大家都用“insertXXX”表示插入一条数据，你就要不用“addXXX” 命名接口和抽象类 接口 实现 IUserService UserService UserService UserServiceImpl 对于抽象类, 比如AbstractConfiguration可以不加Abstract\n注释 写什么 做什么 为什么 怎么做 注释是不是越多越好？ 类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的 可读性。 代码风格 类、函数多大才合适？ 对于函数代码行数的最大限制，网上有一种说法，那就是不要超过一个显示屏的垂直高度。 对于类的代码行数的最大限制, 当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功 能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数过多了。 一行代码多长最合适？ 一行代码最长不能超过 IDE 显示的宽度。需要滚动鼠标才能查看一行的全部代码，显然不利于代码的阅读。 善用空行分割单元块 四格缩进还是两格缩进？ go中没有这个问题 不要用tab 大括号是否要另起一行？ go中没有这个问题 类中成员的排列顺序 go中字段顺序影响内存占用(内存对齐) 技巧 把大块代码分割成更小的单元块 避免函数参数过多 勿用函数参数来控制逻辑 不要使用bool参数 不要使用参数是否为null 函数设计要职责单一 移除过深的嵌套层次 学会使用解释性变量 常量取代魔法数字 1 2 3 4 5 6 7 8 9 public double CalculateCircularArea(double radius) { return (3.1415) * radius * radius; } // 常量替代魔法数字 public static final Double PI = 3.1415; public double CalculateCircularArea(double radius) { return PI * radius * radius; } 使用解释性变量来解释复杂表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 if (date.after(SUMMER_START) \u0026amp;\u0026amp; date.before(SUMMER_END)) { // ... } else { // ... } // 引入解释性变量后逻辑更加清晰 boolean isSummer = date.after(SUMMER_START)\u0026amp;\u0026amp;date.before(SUMMER_END); if (isSummer) { // ... } else { // ... } 代码质量checklist 常规checklist\n目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？ 是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？ 设计模式是否应用得当？是否有过度设计？ 代码是否容易扩展？如果要添加新功能，是否容易实现？ 代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？ 代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？ 代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？ 业务需求checklist\n代码是否实现了预期的业务需求？ 逻辑是否正确？是否处理了各种异常情况？ 日志打印是否得当？是否方便 debug 排查问题？ 接口是否易用？是否支持幂等、事务等？ 代码是否存在并发问题？是否线程安全？ 性能是否有优化空间，比如，SQL、算法是否可以优化？ 是否有安全漏洞？比如输入输出校验是否全面？ ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%A7%84%E8%8C%83/","summary":"命名 命名长度 作用域大的长点 作用域小的短点 利用上下文简化命令 属性名可以不加user 1 2 3 4 5 6 public class User { private String userName; private String userPassword; private String userAvatarUrl; //... } 函数参数 1 2 3 public void","title":"规范"},{"content":"为什么要重构（why）？ 保证代码质量 对工程师本身技术成长有意义 到底重构什么（what）？ 大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这 类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入 bug 的风 险也会相对比较大。\n小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。小型重构更多 的是利用我们能后面要讲到的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入 bug 的风险相对来说也会比较小。\n什么时候重构（when）？ 持续重构\n平时没有事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合 编码规范、不好的设计重构一下。总之，就像把单元测试、Code Review 作为开发的一部分\n如何重构（how）？ 在进行大型重构的时候，我们要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后， 再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，我们都要控制好重构影响到的代码范围，考虑好如何兼容老的代码 逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，我们才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新的功能开发相冲突。\n大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。而小规模低层次的重构，因为影响范围小，改动耗时短，所 以，只要你愿意并且有时间，随时都可以去做。实际上，除了人工去发现低层次的质量问题，我们还可以借助很多成熟的静态代码分析工具（比如 CheckStyle、 FindBugs、PMD），来自动发现代码中的问题，然后针对性地进行重构优化。\n对于重构这件事情，资深的工程师、项目 leader 要负起责任来，没事就重构一下代码，时刻保证代码质量处在一个良好的状态。否则，一旦出现“破窗效应”，一个 人往里堆了一些烂代码，之后就会有更多的人往里堆更烂的代码。毕竟往项目里堆砌烂代码的成本太低了。不过，保持代码质量最好的方法还是打造一种好的技术氛围， 以此来驱动大家主动去关注代码质量，持续重构代码。\n保证重构不出错的手段 单元测试 mock 重构手段 解耦 封装与抽象 中间层 模块化 单一职责原则 基于接口而非实现编程 依赖注入 多用组合少用继承 迪米特法则 观察者模式 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%87%8D%E6%9E%84/","summary":"为什么要重构（why）？ 保证代码质量 对工程师本身技术成长有意义 到底重构什么（what）？ 大型重构指的是对顶层代码设计的重构，包括：系统、模块","title":"重构"},{"content":"Law of Demeter, 迪米特法则\n另外一个更加达意的名字: 最小知识原则, The Least Knowledge Principle\n每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。 或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。 用接口隔离\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/lod/","summary":"Law of Demeter, 迪米特法则 另外一个更加达意的名字: 最小知识原则, The Least Knowledge Principle 每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “clo","title":"LOD"},{"content":"Don’t Repeat Yourself。\n考虑几方面\n实现逻辑重复 功能语义重复 代码执行重复 怎么提高代码复用性？\n减少代码耦合 满足单一职责原则 模块化 业务与非业务逻辑分离 通用代码下沉 继承、多态、抽象、封装 应用模板等设计模式 泛型 复用意识 Rule of Three 第一次编写代码的时候，我们不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/dry/","summary":"Don’t Repeat Yourself。 考虑几方面 实现逻辑重复 功能语义重复 代码执行重复 怎么提高代码复用性？ 减少代码耦合 满足单一职责原则 模块化 业务与非业","title":"DRY"},{"content":"You Ain’t Gonna Need It。你不会需要它.\n不要做过度设计。 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/yagni/","summary":"You Ain’t Gonna Need It。你不会需要它. 不要做过度设计。","title":"YAGNI"},{"content":" Keep It Simple and Stupid. Keep It Short and Simple. Keep It Simple and Straightforward. 如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/kiss/","summary":"Keep It Simple and Stupid. Keep It Short and Simple. Keep It Simple and Straightforward. 如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”","title":"KISS"},{"content":"Single Responsibility Principle, 单一职责原则\n一个类或者模块只负责完成一个职责（或者功能）。\n如何判断类的职责是否足够单一？\n并没有一个非常明确的、可以量化的标准 下面这几条判断原则，比起很主观地去思考类是否职责单一，要更有指导意义、更具有可执行性：\n类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分； 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分； 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性； 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰； 类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应 的方法拆分出来。 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/solid/srp/","summary":"Single Responsibility Principle 单一职责原则","title":"SRP"},{"content":"Open Closed Principle, 开闭原则\n软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。\n在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、 职责链、状态等）。\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/solid/ocp/","summary":"Open Closed Principle 开闭原则","title":"OCP"},{"content":"Liskov Substitution Principle, 里式替换原则\n子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证 原来程序的逻辑行为（behavior）不变及正确性不被破坏。\nLSP与多态的区别\n里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。 替换前后的行为一模一样\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/solid/lsp/","summary":"Liskov Substitution Principle 里式替换原则","title":"LSP"},{"content":"Interface Segregation Principle, 接口隔离原则\n客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/solid/isp/","summary":"Interface Segregation Principle 接口隔离原则","title":"ISP"},{"content":"IOC Inversion Of Control, 控制反转\n流程的控制权从程序员“反转”到了框架。 控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。 DI Dependency Injection, 依赖注入\n一种具体的编码技巧 不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。 优点\n提高了代码的扩展性，我们可以灵活地替换依赖的类。 DIP Dependency Inversion Principle, 依赖反转原则/依赖倒置原则\n高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象 （abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。\n调用者属于高层，被调用者属于低层 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/solid/dip/","summary":"Dependency Inversion Principle 依赖反转原则/依赖倒置原则","title":"DIP"},{"content":"贫血模型(Anemic Domain Model)将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。\n充血模型(Rich Domain Model)，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。\n基于贫血模型的开发模式, 不夸张地讲，我们平时的开发，大部分都是 SQL 驱动（SQL-Driven）的开发模式。我们接到一个后端接口的开发需求的时候，就去 看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写 SQL 语句来获取数据。之后就是定义 Entity、BO、VO，然后模板式地往对应 的 Repository、Service、Controller 类中添加代码。业务逻辑包裹在一个大的 SQL 语句中，而 Service 层可以做的事情很少。SQL 都是针对特定的 业务功能编写的，复用性差。当我要开发另一个业务功能的时候，只能重新写个满足新需求的 SQL 语句，这就可能导致各种长得差不多、区别很小的 SQL 语句满 天飞。所以，在这个过程中，很少有人会应用领域模型、OOP 的概念，也很少有代码复用意识。 基于充血模型的 DDD 的开发模式，需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都 基于之前定义好的这些领域模型来完成。 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B/","summary":"贫血模型(Anemic Domain Model)将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。 充血模型(Rich Domain Mode","title":"贫血模型与充血模型"},{"content":"抽象类的特性 (代码复用, 多态特性)\n不允许实例化, 只能被继承 可以包含属性和方法 子类继承抽象类, 必须实现抽象方法 接口的特性 (代码复用, 解耦)\n不能包含属性 只能声明方法 类必须实现接口所有方法 如何决定该用抽象类还是接口？\n从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。 而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"抽象类的特性 (代码复用, 多态特性) 不允许实例化, 只能被继承 可以包含属性和方法 子类继承抽象类, 必须实现抽象方法 接口的特性 (代码复用, 解耦) 不能","title":"接口与抽象类的区别"},{"content":" 滥用getter, setter违反封装特性 是否公开了不应该公开的 滥用全局变量和全局方法违反封装特性 是否有必要放到全局 定义数据和方法分离的类 MVC ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81%E7%9C%8B%E4%BC%BC%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%AE%9E%E9%99%85%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/","summary":"滥用getter, setter违反封装特性 是否公开了不应该公开的 滥用全局变量和全局方法违反封装特性 是否有必要放到全局 定义数据和方法分离的类 MVC","title":"哪些代码看似是面向对象 实际是面向过程"},{"content":"一、股票组合搭建步骤 每个月或每个季度定期调整组合，在选股时要综合考虑几点因素 宏观环境和经济周期导向，如货币政策宽松时可适当多配成长风格类个股，通货膨胀严重时重点精选周期类个股（但同样要避免行业过度集中的问题）； 个股业绩导向，即近期财报表现不佳的个股少配或不配，多选择业绩较好或有向好预期的个股； 消息面导向，当股票池中某行业有政策催化因素（如2020年中新能源政策利好不断），或个股有“消息引火索”（如新冠疫情利好智飞生物、英科医疗等抗疫题 材股）时，都可以在当月或当季组合中做一定配置。 在“海选”出个股后，每只股票视估值情况赋予8%～15%的仓位占比，原则上估值偏高的低配，估值偏低的高配。再看好的股票，仓位占比也不建议超过资金的 20%。 分析每只股票的行业特性。分清楚目标个股是属于强周期行业（如能源、钢铁），还是抗周期行业（如消费、医药）甚至逆周期行业（低端消费行业、部分科技企 业）。同一级行业个股持仓占比不建议超过30%，尽量做到行业分散周期对冲，避免出现组合由于行业过分集中暴涨暴跌的情况，而且充分分散行业能够获得更稳 健的收益。 二、组合成份股的调整 如个股出现重大风险事件股价暴跌时，要果断移出。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E7%B2%BE%E9%80%89%E4%B8%AA%E8%82%A1%E5%81%9A%E7%BB%84%E5%90%88/","summary":"一、股票组合搭建步骤 每个月或每个季度定期调整组合，在选股时要综合考虑几点因素 宏观环境和经济周期导向，如货币政策宽松时可适当多配成长风格类个股","title":"第二节 精选个股做组合"},{"content":"一、构建股票池的意义 A股近4000只股票，多数股票仅适合短线投机，只有少部分好股才有长期持有价值。经过层层筛选的股票基本面可靠程度较高，踩雷的概率会降低许多。\n在框定股票池后，就不会被海量的个股乱花渐欲迷人眼。只需要和自己最熟悉的股票打交道，跟踪公司的业绩表现和新闻动态，当基本面、技术面或消息面出现交易信 号时，能迅速做出反应。买卖动作都有逻辑，就不会在机会来临时行动滞后，风险加大时还浑然不觉。\n二、如何打造股票池 股票池应由小扩大，研究明白一个纳入一个\n造股票池的建议如下\n股票数量：不宜过多，以30～100只为宜。道理很简单，机构有强大的研究资源支持，可以同时覆盖三五百只股票。而个人能力和精力都有限，贪多求全反而适得其 反。 覆盖行业：要足够分散。市场风格是轮动的，除个别能够保持长期强势的行业外，多数行业容易在各领风骚数个月后归入沉寂。股票池中涵盖多个行业和题材，会方 便我们在政策性、趋势性投资机会出现时选配个股。 选股因子, 营收增速、净利润增速、自由现金流、净资产收益率、毛利率和分红率，这类指标对选股非常重要。 表9-1　2021年版“潴100股票池”\n新人基本面分析功底弱？没关系，还有一种偷懒的方法——抄机构作业。\n天天基金网、私募排排网 三、股票池的管理 成分股出现由盈转亏、涉及诉讼或被他国制裁一类的坏消息不打紧，只要不是会导致基本面重大变化的利空都可以不急于移出股票池。但如果有财务造假、实控人或管 理团队道德品质败坏等原则性问题，应该第一时间进行调整。\n股价走势和估值变动也需要定期跟踪，但其变化并不是调入或调出股票池的主要原因。\n打造股票池的核心目标在于缩小研究范围，在去粗取精精耕细作精益求精后，最终将为选定投资组合保驾护航。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E8%82%A1%E7%A5%A8%E6%B1%A0/","summary":"一、构建股票池的意义 A股近4000只股票，多数股票仅适合短线投机，只有少部分好股才有长期持有价值。经过层层筛选的股票基本面可靠程度较高，踩雷","title":"第一节 打造个人专属股票池"},{"content":"再融资是指上市公司通过配股、增发和发债等方式，在证券市场上进行直接融资。\n一、公开增发／定向增发 IPO是上市公司首次公开发行股票向市场募资，增发则是已上市企业出于某种目的再融资而再次发行股票的行为，主要分为公开增发和定向增发两种。无论哪种形式均 需满足组织机构健全、管理层勤勉尽职、财务状况和盈利能力不存在明显瑕疵等条件，故能获准增发的企业基本面一般不会太糟糕。\n公开增发因条件苛刻近年少见, 原股东持有的股票并不增加，但总股本增加后一般会导致同期每股账面权益（净资产值）增加，同期每股收益会被摊薄，因此公开增 发通常被视为利空。 定向增发较为常见. 公开增发稀释原股东权益的影响同样存在，且为顺利完成再融资，发行价一般会在当前股价基础上有一定比例折让，锁定期满后解禁还存在抛售 隐忧（公开增发无锁定期），即便参与方不减持，也可能因避险情绪引发股价短线下挫。 二、配股 配股原理与增发类似，区别在于未引进新股东，而是向原股东们按持股比例配售一定数量的新发行股票。配股价会较市价有所折让，总股本增加同样存在稀释每股权益 的问题，因此一般被视为利空。\n持股者如无意参与配股，一定要在缴款起始日前卖出（一般上市公司会在这天开始停牌），否则会因除权承受亏损。\n三、发债／发可转债 普通债券发行属于中性消息，当然如果负债成本过高，发债后负债率过高，或融资用途仅仅是借新还旧，也会引起市场对其基本面的质疑。\n可转债是持有人既可以持有到期获取本息，又可以在满足一定条件的情况下将债券转换为股票的，兼具债性和股性的特殊债券。对上市公司而言，可转债融资成本 （利率）比普通公司债低，如果可转债持有人最终选择转股更几乎是没有成本。但对原股东而言，若转股在理论上存在类似增发或配股稀释权益的负面影响。因此，可转债发行时也会给原股东优选认购权。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%B6%88%E6%81%AF/%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%86%8D%E8%9E%8D%E8%B5%84%E5%AF%B9%E4%B8%AA%E8%82%A1%E7%9A%84%E5%BD%B1%E5%93%8D/","summary":"再融资是指上市公司通过配股、增发和发债等方式，在证券市场上进行直接融资。 一、公开增发／定向增发 IPO是上市公司首次公开发行股票向市场募资，增","title":"第三节 再融资对个股的影响"},{"content":"一、业绩报告 季报、半年报和年报等定期财报公开披露，是对短线股价影响最明显的一大消息类型。一季报的集中披露期在4月，半年报在7—8月，三季报在10月，年报则必须在次 年的4月前完成对外披露。财报披露前后股价容易鸡飞狗跳，这也是4、7、10月等财报月个股分化程度和市场波动一般较其他月份大的原因。\n判断业绩好坏不能只单纯看营业收入和净利润等数字大小，除了要比较扣除非经常性损益后的净利润情况，并考虑同／环比增速、对照期基数是否正常和股价相对位置 高低外, 还有一个极重要的参考因素——业绩是否“超预期”，“业绩超预期”或“不及预期”才是很多老手和机构买入或卖出股票的经典策略。\n二、业绩预告和快报 业绩预告和快报同样有预期引领功能。\n按规定，深交所主板上市公司年报、半年报和三季报如出现净利润为负或扭亏为盈，或与上年同期相比上升或下降50%以上等情况须进行业绩预告，一季报预告不做强 制披露要求。 上交所主板、科创板和深交所创业板，仅对符合上述条件（创业板还多一条：期末净资产为负）的企业有年报预告要求，一季报、半年报和三季报均无要求。 业绩快报现在也属于企业自愿披露事项，盈利情况较好、有市值管理需求的企业可能会用这种方式“剧透”业绩。 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%B6%88%E6%81%AF/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E4%B8%9A%E7%BB%A9%E6%8A%AB%E9%9C%B2%E5%AF%B9%E4%B8%AA%E8%82%A1%E7%9A%84%E5%BD%B1%E5%93%8D/","summary":"一、业绩报告 季报、半年报和年报等定期财报公开披露，是对短线股价影响最明显的一大消息类型。一季报的集中披露期在4月，半年报在7—8月，三季报在","title":"第二节 业绩披露对个股的影响"},{"content":"一、真消息与假消息 对消息真假的判断要结合来源是否权威、内容是否符合逻辑、市场有无异动等因素综合考虑。\n一般真消息曝出前后综合指数、行业指数或个股多少会有异动，市场波澜不惊则多半属于假消息。如若市场因假消息异动，在利好证伪后要迅速撤离避免损失扩大，利 空证伪后可考虑补回被谣言制造者骗取的筹码。\n二、公开消息与内幕消息 等你自以为拿到绝密消息如获至宝地追高买入，多半就是去接盘啦！\n证券市场有严格的信息披露制度，投资者完全可以通过合法合规的手段收集关于目标企业的相关信息（本章第三节会展开介绍）。多看正规媒体新闻报道，多读财报研 报跟踪企业基本面消息面变化，少听信微博大V、亲朋好友或张三李四的“八手消息”，才是一个成熟投资者应有的“消息观”。\n三、有实质影响的消息和无效消息 需要思考的是，这种消息对企业的业绩改善有任何实质性作用吗？\n四、宏观消息、行业消息与个股消息 宏观经济和行业、个股基本面的变化，及各类突发事件，共同组成了消息面。\n宏观面的消息包括GDP、PMI、社融等经济数据公布，存款准备金、存贷款利率和印花税等货币财政政策调整，长远经济规划（如“一带一路”“十四五”），重大会议 （如“两会”、中央经济工作会议）和区域建设规划（如雄安新区、海南自贸区建设）以及国际地缘政治经济事件等，其影响往往较全面、重大和深远。\n行业性消息影响不了全局，但足够让某个板块内的一众个股鸡飞狗跳。行业性利好自然是你好我好大家好，行业性黑天鹅的影响则需要辩证看待。\n一般而言，对行业进行整改整顿或提出某些约束性措施的监管政策，从长远看对行业龙头较有利。 要擅于捕捉行业黑天鹅带来的逆势抄底机会，而不是一见所谓利空就躲得老远，不敢再碰。 个股的消息更多更杂，既包括引发基本面（估值）变化的事项，如业绩提升或下降、并购重组、定向增发、回购（注销）、分红、高送转、签订重大合同等，又包括会 激起股价巨震的突发事件，如实控人死亡或犯罪、管理团队变动、企业违规或犯罪被罚、财务造假被曝光、安全生产事故等。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%B6%88%E6%81%AF/%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%B6%88%E6%81%AF%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E5%BD%B1%E5%93%8D/","summary":"一、真消息与假消息 对消息真假的判断要结合来源是否权威、内容是否符合逻辑、市场有无异动等因素综合考虑。 一般真消息曝出前后综合指数、行业指数或个","title":"第一节 消息的分类及其对市场的影响"},{"content":"一、K线的基本原理 图7-8　标准K线的结构\n以日K线为例讲解K线基本原理\n当日收盘价高于开盘价时收阳线，低于开盘价时收阴线。\n对阳线而言，最高价高于收盘价的差值部分用上影线体现，最低价低于开盘价的差值部分用下影线体现。\n对阴线来说，最高价高于开盘价的差值部分用上影线体现，最低价低于收盘价的差值部分用下影线体现\n如果当日开盘价较前一交易日高开较多，即便收盘价低于开盘价收阴线，但还是高于前一日收盘价。这样的阴线其实还是收涨的，所以被称为“假阴线”。\n反之，如果当日开盘价较前一交易日低开较多，即便收盘价高于开盘价收阳线，但还是低于前一日收盘价，这样的阳线被称为“假阳线”。\n假阳线和假阴线在震荡行情中意义不大，但如果在趋势性上涨或下跌一段时间后出现，则有可能是行情扭转的信号。\n二、12种K线形状 图7-9　12种基本K线形状\n2^3 * 2 - 4 = 12\n表7-1　各K线名称及意义\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8A%80%E6%9C%AF/%E7%AC%AC%E5%9B%9B%E8%8A%82-k%E7%BA%BF%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%A4%BA%E4%BE%8B/","summary":"一、K线的基本原理 图7-8 标准K线的结构 以日K线为例讲解K线基本原理 当日收盘价高于开盘价时收阳线，低于开盘价时收阴线。 对阳线而言，最高价高于","title":"第四节 K线技术简介及示例(上)"},{"content":"看懂分时图的含义是解读市场和个股行情，展开各类技术分析的必经之路。很多超短线高手仅靠盘口数据和分时图形就能观察多空交战情况，判断主力动向，进而对后 市走向做出预判。分时图分为指数分时图和个股分时图，二者基本要素类似，只是细节上略有差别。\n一、大盘分时图示例 图7-4　上证指数分时图\n图形的左边是指数点位，右侧是涨跌幅度。横轴以每分钟为单位向前推进，成交量在图形底部以红绿白色等柱子的形式展示。正常交易日全天共4个小时，一共会出 240(4*60)根柱子。 当某一分钟收涨时买方占优显示红柱，反之出绿柱。 全天开盘和收盘两个时间段因为集合竞价前后成交都会更密集，成交量柱都会较其他时间更长。 零轴附近的柱子则是反映即时所有股票的买盘与卖盘在数量上的比率，红柱线的增长减短表示上涨买盘力量的增减，绿柱线的增长缩短表示下跌卖盘力度的强弱。 关注度更高的是粗的那根白线，它体现的是加权平均法下的上证指数。即既考虑个股股价，也考虑个股的股本，大盘股股本越大所占权重越大，故而对指数影响力也 就越大。而黄线代表的“领先指标”，则是运用算术平均法，不考虑股本差别，通过将所有股票的价格简单相加后平均计算得出。 二、个股分时图示例 图7-5　山西汾酒分时图\n多了一根分时均价线 以盘口总成交额除以总成交量的运算方式计算每一股即时的平均成交价，能精确统计当前所有参与者的持仓成本。 靠股价走势线和分时均价线关系分辨当日个股强弱的规律：\n当股价持续在均价线上方运行时，表明市场预期较好，买盘踊跃，当天介入的大部分资金都能赚钱，这是盘口强势特征； 当股价持续在均价线下方运行时，表明市场预期较差，卖盘踊跃，当天介入的大部分资金都亏钱，属弱势特征； 当均价线从低位持续上扬时，表明市场预期提高，投资者纷纷入场推动股价上涨，综合持仓成本不断抬高，对股价形成支撑； 当均价线从高位持续下挫时，表明市场预期较差，投资者纷纷离场迫使股价下跌，综合持仓成本不断下降，对股价形成压制。 三、其他分时技术分析术语 图7-7　陕西煤业分时盘口信息\n买卖五档 在每天买卖的委托单中，这是多空各方交易意图的直接体现。\n委比和委差 相比看买卖五档，委比是以数值比例的方式，更直观体现某一时段买卖盘相对强度的指标。\n其计算公式是委比=（委买手数－委卖手数）/（委买手数+委卖手数）×100%，取值范围为±100%。 当委比为正值时说明买方占优，数值越大买方实力越强，委比为负值说明卖方占优。 当委比值为+100%时个股涨停，反之个股则惨遭跌停。 委差是用大盘或个股的买单总量减去卖单总量，反映买卖双方力道对比。正数为买方占优，负数为卖方更强。\n换手率 换手率是指在单位时间内，某只个股的累计成交量与其流通股本之间的比率，反映的是单个股票的筹码流通情况，一般讨论较多的是每日换手率。\n量比 量比是衡量相对成交量的指标，是指股市开市后平均每分钟的成交量与过去5个交易日平均每分钟成交量之比。通常认为量比为0.8～1.5属于正常状态，而如果低于或 高于这一阈值则是出现了缩量或放量，特别是量比数值低于0.5倍或高于2.5倍时要重点留意股价走势。\n内盘和外盘 所谓内盘，是指按照买方已经挂好的价格成交的主动性卖盘，越大表示主动性抛盘越多。而外盘则刚好相反，是指按卖方已经挂好的价格成交的主动性买盘，越大表示 主动买入的资金越多。二者加起来就是总成交量。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%88%86%E6%97%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%A4%BA%E4%BE%8B/","summary":"看懂分时图的含义是解读市场和个股行情，展开各类技术分析的必经之路。很多超短线高手仅靠盘口数据和分时图形就能观察多空交战情况，判断主力动向，进","title":"第三节 分时技术简介及示例"},{"content":"一、K线流 K线流旨在用图形的方式记录指数和个股价格在每个时间段的变化，注重研究K线及其组合形态的规律，借以判断市场中多空力量的对比，并凭此预测后市运行态势。\n图7-2　K线图灵感来源于蜡烛\n二、切线流 切线流的逻辑基础是前文讲述的技术分析三大假设中的“价格以趋势方式演变”，其核心玩法是按一定原则和方法在价格图中画出直线，并据此预判指数或个股价格的未 来趋势。这些直线或平或斜，对价格起着支撑或压力的作用，被统称为“切线”。\n寻找和绘制对后市价格走向有影响的切线的方法有很多，典型的包括趋势线法、通道线法、黄金分割线法、百分比线法、扇形线法、甘氏线法等。如今专业一点的炒股 软件都会自带绘制各类切线的功能，使用比较简单\n严格意义上的切线特指直线，因此均线、布林线等同样旨在寻找支撑和压力的技术理论不能归为其中，这是很多人容易混淆的地方。但这类“找线”或“找点”的方法本质 原理是相近的，配合起来使用，效果会更好。\n三、形态流 形态流信徒们立足点更为宏大，注重观察较长一段时间价格走势的变化。他们笃信“历史会重演”：当指数或股价以某种典型波动轨迹出现时，复现其历史上有过的走势 的概率较大。\n从大的类型上看，形态可以分为持续整理和反转突破两种。持续整理形态是价格尽管有或上或下的变化，但总体是沿原来的运行趋势行进。反转突破形态则是多空双方 打破了原有的“默契”，运行趋势出现根本性变化，出现这类形态的苗头时，要提防变盘。\n四、指标流 指标流中理科生云集，尤其受到有数学或计算机背景的股民追捧。和偏直观感受的K线、切线和形态流不同，他们专注于研究各类记录股市运行特征的参数和技术指标， 通过数据强弱的变化判断价格趋势的涨跌，并运用于指导买入卖出实战。这种方法相对更重视数据的客观性，尽量少掺杂个人的主观判断。因此有相当多的指标流技术 派在计算机编程技术的帮助下，完成了向量化派的转变。\n技术指标如弱水三千，可只取三瓢饮。选定学习和熟悉三个技术指标足以应对市场上的各类变化，个人建议必须掌握的是MA和MACD两个趋势指标，并辅之以另一个震 荡指标即可。\nMA（移动平均线）、MACD（指数平滑异同移动平均线） 五、波浪流 波浪理论的开创者是美国人拉尔夫·纳尔逊·艾略特，他认为股票价格的运动遵循自然界波浪起伏的规律，将股价上升期分为五浪，其中又可以细分1/3/5三个奇数上升浪和2/4两个偶数调整浪；股价下跌期分为A/B/C三浪，其中A和C是下跌浪，B是反弹浪\n大浪套中浪，中浪套小浪，一浪之后还有一浪。千人千浪，每一个数浪大师都能把浪花拨弄得天花乱坠。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E7%9A%84%E4%BA%94%E5%A4%A7%E6%B5%81%E6%B4%BE/","summary":"一、K线流 K线流旨在用图形的方式记录指数和个股价格在每个时间段的变化，注重研究K线及其组合形态的规律，借以判断市场中多空力量的对比，并凭此预","title":"第二节 技术分析方法的五大流派"},{"content":"如果因为个人能力问题无法驾驭好一匹马，怎么能对马破口大骂，而不反躬自省？\n一、技术分析及量价时空 技术分析是以K线、均线、切线和波浪等图形为主要工具，判断股票、债券和期货等金融交易品种在量、价、时、空等四方面的变化趋势，并以结论指导下一步交易动 作的研究方法。\n量即成交量，价即价格。\n分析大盘指数时用到的是全市场的成交量和指数点位 具体到个股时是单只股票的成交量和成交价格。 市场参与主体有机构、游资、散户等等，但最终落实到交易本身只分买方和卖方，成交量就是买卖双方就指数或个股价格达成共识时产生的交易额。\n在各级别技术走势图中，时间表现为横轴，表征空间的纵轴体现的则是价格波动的幅度\n图7-1　量价时空示意\n当你熟悉技术分析后，会发现所有的方法都只是在努力解释和辨清量价时空四要素之间的关系，只是不同技术流派侧重点各有不同。如K线和均线分析法重点研究价格 趋势，布林线分析法研究价格和空间，波浪理论则重在研究时空关系。而那些所谓的技术分析高手，不过是比一般人对这四个字的理解程度更深一些，对各门学问间的 融会贯通做得较好些罢了。\n二、技术分析的三大假设 第一条：市场行为包容消化一切。在纯粹的技术派看来，任何影响市场的政治、经济、心理因素，以及它们的一切变化，都将完全被指数或股价的波动所反映。 第二条：价格以趋势方式演变。技术派相信趋势一旦形成，价格会朝阻力最小的方向运动，如果没有外力干预，将按惯性继续沿已形成的趋势前进。只有当某种外力 打破现有平衡时，才会出现具有操作指导意义的拐点信号。 第三条：历史会重演, 但绝不是细节上简单复现。 三、如何正确理解技术分析的价值 技术分析能较好地帮助散户抓住盈利机会，并避免深陷雷区 技术分析水平到一定程度后，能通过对量价时空的判断把握大盘整体走向和个股的买入、卖出机会。\n技术分析只是交易方法体系中的一环而远非全部 不同方法应对不同风格的市场也各有长短\n技术分析的结果必须用“概率思维”对待 分析结论只是提供预判，最后结果正确与否必须交给市场印证。而一旦出错，必须采取措施果断纠偏。\n技术分析应用于预判指数比预测个股准确率更高。技术分析某种程度上可视为集体心理的自我实现\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8A%80%E6%9C%AF/%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E5%AF%B9%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E7%9A%84%E6%84%8F%E4%B9%89/","summary":"如果因为个人能力问题无法驾驭好一匹马，怎么能对马破口大骂，而不反躬自省？ 一、技术分析及量价时空 技术分析是以K线、均线、切线和波浪等图形为主要","title":"第一节 技术分析对股票投资的意义"},{"content":"一、绝对估值法的逻辑基础 上市公司的内在价值，是将预期未来现金流，按照反映其风险的折现率，进行折现后的现值加总。\n对估值法的分支有很多，其中使用率较高且便于初学者掌握的，主要是现金股利折现模型（Dividend Discount Model，简称DDM）和自由现金流折现模型 （Free Cash Flow for the Firm，简称FCFF）两种。它们都属于广义的现金流折现法（Discounted Cash Flow，简称DCF），分别通过测算上市公司未来 的现金股利或自由现金流，实现估算公司股票内在价值的目的。但无论何种方法，理解什么是“折现”都是展开学习的前提。\n二、折现与折现率 折现，也叫贴现，是指将未来现金流折算成等价现值的过程。\n折现率，本质是资产未来预计取得的收益率水平，未来可以是一年、三年或者更长。\n根据公式定义，未来收益的现值=未来收益绝对值/（1+折现率）^n，n为与折现率匹配的折现期数（如以年收益率作为折现率，则n=需要折现的年数）； 如未来有多笔收益，则现值为每一笔收益折现到当前时点的数值之和。 三、折现率的应用 不同现金流的选择 现在有A、B两笔现金流，哪一笔更好呢？\nA：一年后得到10 000元，两年后再得到10 000元； B：一年后无所得，两年后一次性得到20 500元。 假设预期收益率是4%，即以4%作为折现率。\nA现金流：一年后得到10 000元，两年后再得到10 000元，相当于当前时点马上得到约18 861元\n图6-7　A现金流计算步骤\nB现金流：一年后无收入，两年后得到2.05万元，相当于当前时点马上得到约18 953元\n图6-8　B现金流计算步骤\n由于B现金流的18 953元现值大于A现金流的18 861元现值，因此B现金流要优于A现金流。\n此处的18 861元和18 953元有一个专门的名称——净现值（Net Present Value，NPV），是指未来资金流入的现值与未来资金流出的现值之间的差额。\n不同投资项目的选择 C：初始投入2万元，一年后追加投入8万元，两年后退出项目获得11万元，项目结束； D：初始一次性投入10万元，一年后部分退出获得5万元，两年后全部退出获得6万元，项目结束。 以4%的折现率为例\nC项目的净现值为0.48万元 图6-9　C项目净现值计算步骤\n同理可计算出D项目的净现值约为0.36万元，因此在4%折现率之下，项目C优于项目D。 影响净现值的核心因素主要包括以下三点：\n未来现金流的大小。未来现金流净流入越大，折现到当前的NPV就越高。 折现率的高低。折现率越低，折现到当前的NPV就越高。 折现周期的长短。折现期数越短，现金流折现到当前的NPV就越高。 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BC%B0%E5%80%BC/%E7%AC%AC%E4%B8%83%E8%8A%82-%E7%BB%9D%E5%AF%B9%E4%BC%B0%E5%80%BC%E6%B3%95%E4%BB%8B%E7%BB%8D/","summary":"一、绝对估值法的逻辑基础 上市公司的内在价值，是将预期未来现金流，按照反映其风险的折现率，进行折现后的现值加总。 对估值法的分支有很多，其中使用","title":"第七节 绝对估值法介绍"},{"content":"很多人喜欢用指数点位来判断当前时点是否存在泡沫、是否值得出手投资。客观讲，这种思路可能并不适用于所有个股的买卖择时。\n将指数分位值理解为对某一市场或某一行业所有成份股的“集体估值”并知道如何使用即可。\n一、指数分位怎么用 指数估值\n根据当前估值处于历史估值的位置来判断性价比 二、指数分位估值法使用要点 理论上分位值越小，风险越低。但分位值体现的只是历史，并不能用于预测未来。 不要把指数点位与个股时机的判断混为一谈。指数分位值高，可能也有性价比很高的个股机会；指数分位值再低，也不能代表所有的个股都有投资价值。 部分指数成立时间晚，历史年限短，分位值参考价值较低 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BC%B0%E5%80%BC/%E7%AC%AC%E5%85%AD%E8%8A%82-%E6%8C%87%E6%95%B0%E5%88%86%E4%BD%8D%E4%BC%B0%E5%80%BC%E6%B3%95%E4%BB%8B%E7%BB%8D/","summary":"很多人喜欢用指数点位来判断当前时点是否存在泡沫、是否值得出手投资。客观讲，这种思路可能并不适用于所有个股的买卖择时。 将指数分位值理解为对某一","title":"第六节 指数分位估值法介绍"},{"content":"一、市销率是什么 公司总市值=每股股价×公司总股本 公司营业收入=每股营业收入×公司总股本 市销率=公司总市值／公司营业收入 市销率=公司总市值／公司营业收入=每股股价／每股营业收入\n二、市销率用在哪儿 亏损的企业\n三、市销率估值法使用要点 企业收入的构成中也存在着与主业相关性较低的收入成分。因此在计算市销率过程中，营业收入通常选用“主营业务收入”。\n市销率以收入作为评价的主要依据，因此收入的质量就尤为关键。\n当企业存在应收账款账期较长、坏账率较高、应收票据占比较大等情况时，会对市销率的使用效果起到负面影响。 在使用市销率的时候，务必要关注企业利润表各项的结构及其合理性，客观分析企业尚未盈利的真实原因。\n表6-9　三种估值方法对比\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BC%B0%E5%80%BC/%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%B8%82%E9%94%80%E7%8E%87%E4%BC%B0%E5%80%BC%E6%B3%95%E4%BB%8B%E7%BB%8D/","summary":"处于亏损阶段的企业，市盈率基本不适用, 应使用市销率","title":"第五节 市销率估值法介绍"},{"content":" 公司总市值=每股股价×公司总股本 公司净利润=每股净利润×公司总股本 市盈率=公司总市值/公司净利润 市盈率=公司总市值/公司净利润=每股股价/每股净利润\n市盈率的本质就是静态投资回报周期\n前提，公司的现金分红率必须为100%（现金分红率=现金分红额／可分配净利润总额） 一、常见的几种市盈率 静态市盈率：公司当前总市值／公司前一会计年度净利润（上市公司须以年报公告为准）\n静态市盈率的主要缺点在于，上市公司T年的年报一般会在T+1年的3—4月才会公告 动态市盈率：公司当前总市值／公司未来会计年度净利润，比如现在是2021年上半年，动态市盈率一般表达为PE（21E）、PE（22E），分别代表公司当前总市值与 2021年预测全年净利润、2022年预测全年净利润的比率。\n动态市盈率的主要缺点在于，未来年度净利润全部为预测值。如果预测结果过于乐观，会造成分母过大，有动态市盈率计算结果被低估的风险。 滚动市盈率：公司当前总市值／公司最近四个季度的净利润之和（上市公司须以公告为准）. 一般以PE（TTM）表示\n滚动市盈率较前两者都更加精确，也是最为广泛使用的市盈率口径。 假设A公司的总市值是50亿，目前2020年年报尚未公布\n表6-7　A公司净利润假设\n静态市盈率\nPE=50/3.67=13.64（等到2020年年报公告后，分母换成2020年全年净利润） 动态市盈率\nPE（21E）=50/5.28=9.47 PE（22E）=50/6.34=7.89 滚动市盈率\nPE（TTM）=50/（1+0.8+1.5+0.9）=11.9 40倍市盈率（无特别说明的情况下，均指滚动市盈率）的股票，和4%收益率（相当于25倍市盈率）的理财，选择前者的原因主要有两个：\n判断公司未来净利润会保持增长，将市盈率逐步摊薄至25倍以下； 或判断理财未来收益率会下降，理财产品对应的市盈率逐步提高至40倍以上（第一点的影响一般会更大）。 二、市盈率相对盈利增长比率（PEG） PEG指标中的PE即PE（TTM），G指的是未来（一般不少于3年）净利润平均增速（Growth），PEG=PE/（G×100）。\n假设B公司2020年PE（TTM）为25倍\n表6-8　B公司净利润及增速假设\n粗略计算未来三年业绩的平均增速约为20%，根据公式可得出，PEG=25/（20%×100）=1.25。\n对于PEG指标，通常认为当PEG\u0026gt;1时的价格偏高，PEG\u0026lt;1时的价格偏低。当然不同行业的参照值也存在差异\n夕阳行业可以将PEG与0.8对比，朝阳行业可以将PEG与1.2对比 大多数情况下，同一行业内PEG低的企业相对安全一些；同一企业的不同时点，PEG低的时候相对安全一些 三、市盈率估值法使用要点 在某些情况下，净利润的增长并不能带来每股净利润的提高。比如上市公司定向增发 建议使用“扣除非经常性损益后的净利润”作为分母另行计算，更能体现出企业主营业务真实利润情况对应的估值水平。 在大多数软件中，无论何种口径的市盈率，基本都是选用全口径净利润作为分母。 全口径包含投资收益、资产处置、政府补贴等不规律因素的影响（一般统称为“非经常性损益”）。 谨防估值陷阱, 市净率看资产质量，市盈率看业绩成长。 只有一种情况下市盈率为负，那就是标的公司处于亏损状态（市值或股价最低为零，不会为负）。 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BC%B0%E5%80%BC/%E7%AC%AC%E5%9B%9B%E8%8A%82-%E5%B8%82%E7%9B%88%E7%8E%87%E4%BC%B0%E5%80%BC%E6%B3%95%E4%BB%8B%E7%BB%8D/","summary":"公司总市值=每股股价×公司总股本 公司净利润=每股净利润×公司总股本 市盈率=公司总市值/公司净利润 市盈率=公司总市值/公司净利润=每股股价/每","title":"第四节 市盈率估值法介绍"},{"content":"一、市净率是什么 公司总市值=每股股价×公司总股本 公司净资产=每股净资产×公司总股本 市净率=公司总市值/公司净资产 市净率=公司总市值/公司净资产=每股股价/每股净资产\n二、市净率运用要点 市净率估值方法对于标的公司资产质量的敏感度较高, 资产越重的企业，资产质量就越为关键\n市净率估值法多用于如钢铁、煤炭等资产规模较大的重资产行业，以及如银行、地产等净资产规模较大的资金密集型行业。 使用市净率估值方法，以下几个问题尤为重要。\n如何判断重资产公司的资产质量？ 市净率越低代表风险越小吗？ 在市净率维度下，如何设定安全边际？ 三、康美药业案例：关于企业资产质量的判断 有钱也不还 公司每年宁可支付越来越高的财务费用，也不肯用几百亿元的货币资金去偿还几十亿元的短期借款（短期借款一般为一年期借款，不存在无法提前偿还的问题）。\n表6-1　康美药业历年货币资金、短期借款和财务费用统计\n不用也不还 长年均未出现大额资金缺口，且没有过高的投资需求，为什么不肯偿还几十亿元的有息负债？\n表6-2　康美药业历年经营活动和投资活动现金流净额统计\n还了继续借 一家公司资金充足，却每年都要玩筹资活动的现金流游戏\n表6-3　康美药业历年债务相关现金收付情况统计\n四、模拟案例：市净率低并不等于风险小（同行业横向对比） 表6-4　A、B公司简化资产负债表\n假设目前市场给予两家公司的估值均为1亿元，通过计算可以得出，A公司对应的市净率约为4.35倍（1亿元/0.23亿元），B公司对应的市净率约为1.82倍 （1亿元/0.55亿元）。如果仅从市净率的角度看，能否直接得出结论：B公司比A公司便宜呢？\n答案是不能。两家公司的资产质量不同，直接以市净率的比较判断贵或便宜，也是不科学的。\nB公司仍然存在以下问题：\n应收票据如为商业承兑汇票，存在无法足额兑付的风险； 应收账款虽已计提坏账准备，但由于余额较大，存在计提坏账准备金仍不足额的风险； 存货同样可能存在虽然计提了跌价准备金但仍不足额的风险，尤其对于周期类原材料存货，价格剧烈波动是经常发生的； 目前的会计准则下，商誉不涉及摊销，如果商誉是由于收购其他标的形成，且收购标的实际业绩明显未达收购时点的业绩预期，就有可能存在大额减值风险，将直接 削减净资产余额； 短期借款余额较大，货币资金余额无法偿还到期本息的风险。 假设通过对B公司的深度研究，确实发现存在上述风险。为了留出足够的安全边际，对B公司的资产负债表进行调整\n表6-5　A、B公司简化资产负债表（调整后）\n调整后，B公司对应1亿元估值的市净率约为7.14倍。相较于A公司，B公司在市净率维度已不存在价格优势。\n当然，如果通过深度研究排除上述潜在风险，那么B公司仍然具备价格优势。但不论最终的结论如何，都是以对公司的深度研究为基础和前提。 五、招商银行与民生银行对比案例：市净率低并不等于风险小 对于银行来说，影响净资产质量众多因素中，有两个极为关键：不良贷款率和拨备覆盖率。前者是金融机构不良贷款占总贷款余额的比重，越低越好；后者是实际上银 行贷款可能发生的呆、坏账准备金的使用比率，用来衡量银行贷款损失准备金计提是否充足，越高越好。\n表6-6　招商、民生银行历年不良贷款率和拨备覆盖率对比\n图6-1　招商、民生银行PB估值中枢对比\nPB绝对值的高低未必代表股票真正“贵”或“便宜”。请牢记，资产质量才是PB角度下最关键的因素。\n六、招商银行案例：通过自身历史维度（纵向）分析市净率 图6-3　招商银行市净率估值中枢\n在纵向维度上，也要先对上市公司做好充分的研究。如果公司的资产质量在历史长期保持健康稳定并且在未来也无明显恶化风险，PB低等于风险小；如果公司的资产质 量稳定性较差，或者在未来存在恶化风险，则PB低不等于风险小。\n同行业不同公司之间的选择：\n资产质量接近的，选市净率低的； 市净率接近的，选资产质量好的 同一公司不同时点的选择\n资产质量健康稳定以及呈现向好趋势的，在市净率接近历史底部附近时出手买入或加仓 资产质量不稳定甚至有恶化风险的，市净率处于底部也不能盲目操作 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BC%B0%E5%80%BC/%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%B8%82%E5%87%80%E7%8E%87%E4%BC%B0%E5%80%BC%E6%B3%95%E4%BB%8B%E7%BB%8D/","summary":"一、市净率是什么 公司总市值=每股股价×公司总股本 公司净资产=每股净资产×公司总股本 市净率=公司总市值/公司净资产 市净率=公司总市值/公司净资","title":"第三节 市净率估值法介绍"},{"content":"没有任何一种估值工具是完美的、能在所有环境下都完全生效的。\n灵活运用多种估值方法，不要固守某一种方法。 绝对估值法是指，在上市公司基本面分析，以及上市公司未来业绩、财务等因素预测的基础上对其价值进行判断，常见的方法包括现金股利折现和自由现金流折现模型 等。\n相对估值法是在上市公司核心比率、价值指标等基础上，通过寻找同行业、同类型、同周期等各方面最接近的对标企业及相似交易案例，并与其对比分析，从而对上市 公司的价值进行判断，常见的方法包括PE（市盈率）、PB（市净率）和PS（市销率）等。\n需要注意的是，现实投资中两种估值方法的结论并不始终一致，很多情况下二者结论差异极大，甚至会出现结论完全相反的情况。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BC%B0%E5%80%BC/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E4%BC%B0%E5%80%BC%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB/","summary":"没有任何一种估值工具是完美的、能在所有环境下都完全生效的。 灵活运用多种估值方法，不要固守某一种方法。 绝对估值法是指，在上市公司基本面分析，以","title":"第二节 估值方法的分类"},{"content":"脱离价值谈论价格是没有意义的。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BC%B0%E5%80%BC/%E7%AC%AC%E4%B8%80%E8%8A%82-%E4%BC%B0%E5%80%BC%E5%AF%B9%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E7%9A%84%E6%84%8F%E4%B9%89/","summary":"脱离价值谈论价格是没有意义的。","title":"第一节 估值对股票投资的意义"},{"content":"一、三张表之间的关系 总的来说，这三张报表是站在两个不同的视角来看待企业：一是风险视角，通过现金流量表可审视企业能否继续存活；二是收益视角，资产负债表和利润表勾勒出企业 持续经营的模样——有多少家底，经营成绩又究竟如何。\n资产负债表是一个时点报表，其中各科目期初和期末数值的变化，都能通过利润表和现金流量表这两张期间报表反映出来。\n图5-3　三张表勾稽关系示意图\n期末资产=期末负债+期初所有者权益+本期净利润－本年度实际分红\n二、财务指标综合分析 盈利能力指标 盈利能力可分两个维度：一是从销售角度看收入盈利能力，二是从投入角度看资产盈利能力。\n收入盈利能力指标常见的有毛利率、营业利润率、净利率等\n毛利率=（营业收入－营业成本）÷营业收入 营业利润率=（营业收入－营业成本－三大费用）÷营业收入 净利率=净利润÷营业收入 常见的资产盈利能力指标有净资产收益率（ROE）和总资产收益率（ROA）。ROE和ROA是更能够体现企业盈利能力的指标，它不仅考虑了收益的大小，还考虑了收益的 效率问题。其中ROA代表了企业全部资产的获利能力，ROE代表了企业股东的获利能力。\n净资产收益率=净利润÷平均净资产 总资产收益率=净利润÷平均总资产 其中平均净资产和平均总资产可以简单用期初值加上期末值除以2得到。\n偿债能力指标 偿债能力同样分两部分，分别是短期偿债能力和长期偿债能力。\n短期偿债能力的核心思路是流动资产越多，短期偿债能力越强，主要指标是流动比率和速动比率。速动的意思是能够快速变现的流动资产，而存货有时是很难快速变现 的\n动比率=流动资产÷流动负债 速动比率=（流动资产－存货）÷流动负债 对于非重资产企业，流动比率通常在2左右，速动比率通常在1左右，这两个比率不需要过高。\n长期偿债能力是指企业偿还一年以上债务的能力，通常用资产负债率来计算，不过只要企业能够长期盈利，长期偿债能力一般都不存在太大问题。\n资产负债率=负债总额÷资产总额 对企业而言，适当的负债有助于发展，所以这个比率并不是越低越好，通常45%～60%是比较合适的区间。\n判断企业的偿债能力还有一个快速方法，就是看现金及现金等价物能否覆盖所有的有息负债，如果能够覆盖或者相差不大，偿债能力就较强。\n现金流指标 收现率 = 销售商品、提供劳务收到的现金/主营业务收入 现比 = 经营活动现金流量净额/净利润 对于收现率约等于“1+增值税税率”的企业，通常认为其收入的大部分都作为现金收回。而净现比主要体现净利润的质量，大于1时，说明企业每实现1元净利润，实际 可以收到大于1元的现金。需要注意的是，发展期企业净现比通常较小，另外行业差异也会带来较大的净现比差异。\n增长率指标 营业收入增长率=（本期营业收入－上期营业收入）÷上期营业收入 营业利润增长率=（本期营业利润－上期营业利润）÷上期营业利润 净资产增长率=（本期净资产－上期净资产）÷上期净资产 总资产增长率=（本期总资产－上期总资产）÷上期总资产 营运能力指标 企业的回报取决于效益和效率，效益可以用利润率、毛利率表示，效率则可以用各种资产的周转率表示，其公式为\n某类资产周转率=营业收入÷某类资产平均余额 资产的平均余额可以简单地用期初和期末余额之和除以2来计算，不同的资产对应不同的周转率。如存货就是存货周转率，固定资产就是固定资产周转率，应收账款就 是应收账款周转率，总资产就是总资产周转率\n应收账款周转率越高，代表应收账款在本会计年度内转化为现金的次数越多，每次应收账款的回款速度越快。 存货周转率反映公司的存货利用情况。一般来说，存货周转率越高，存货占用的资金越少。但存货周转率太高，会让企业出现供不应求的状态，从而影响企业的收入。 固定资产周转率是衡量厂房和机器设备等固定资产使用效率的比率。这个周转率越大越好，越大就证明固定资产很好，可以带来较多收入。需要注意的是，重资产和 轻资产经营的公司，该项周转率的差异会比较大。 总资产周转率是综合评价企业全部资产经营质量和利用效率的重要指标。总资产周转率越大，证明同样数量的资产产生更多的销售收入，或者同样的销售收入占用更 少的资源。其他各项指标接近的情况下，总资产周转率越大，还可反映企业管理层的资产运用能力越强。 三、最关键的财务指标——ROE ROE是代表企业股东权益的投资报酬率，是评价股东权益财务状况的重要指标。\n净资产收益率=净利润÷净资产=（净利润÷营业收入）×（营业收入÷平均总资产）×（平均总资产÷净资产）=净利润率×总资产周转率×杠杆系数\n高净利润率模式的代表就是贵州茅台 高资产周转率模式的在商超等零售行业中比较普遍 高杠杆模式的典型行业就是金融业 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%A2%E6%8A%A5/%E7%AC%AC%E4%B8%83%E8%8A%82-%E8%B4%A2%E5%8A%A1%E6%8C%87%E6%A0%87%E7%9A%84%E7%BB%BC%E5%90%88%E5%88%86%E6%9E%90/","summary":"一、三张表之间的关系 总的来说，这三张报表是站在两个不同的视角来看待企业：一是风险视角，通过现金流量表可审视企业能否继续存活；二是收益视角，资","title":"第七节 财务指标的综合分析"},{"content":"现金流量表是反映在一定时间内企业经营、投资和筹资活动对其现金及现金等价物流入和流出所产生影响的财务报表。它区别于利润表和资产负债表的一个重要特征， 就是现金流量表采用的是收付实现制，而另两张表都是权责发生制。\n资产负债表和利润表在权责发生制下的很多信息都会被美化，资产可能会被提前确认，利润也会被提前装进去。而现金流量表会更真实地反映当期的现金流动情况，可 以让你看清楚企业的经营情况究竟如何。\n现金和现金等价物与资产负债表中货币资金科目的区别。\n现金和现金等价物有一个非常鲜明的特征，就是在三个月内随时能够为企业所调用。 货币资金科目下的其他货币资金（受限制的钱）和定期存款，前者显然不可能随时被调用；后者存期通常都在一年以上，两者属于货币资金，但不能归为现金等价物。 银行承兑商业汇票能无条件地把现金给持有人，对企业来说基本可以当作现金使用，所以它属于现金及现金等价物的范畴。\n一、现金流量表的要素和结构 表5-8　现金流量表基本格式\n现金流量表主要包含经营、投资、筹资三大部分，分别对应经营活动产生的现金流、投资活动产生的现金流和筹资活动产生的现金流。每一类现金流又分流入和流出两 个方向：每类现金流净额=现金流入总额－现金流出总额。\n现金及现金等价物净增加额 = 经营活动产生的现金流量净额 + 投资活动产生的现金流量净额 + 筹资活动产生的现金流量净额 ± 汇率变动对现金的影响 期末现金及现金等价物余额 = 期初现金及现金等价物余额 + 现金及现金等价物净增加额 二、经营活动现金流 经营活动是指除投资和筹资活动之外的，与企业日常经营相关的所有交易和事项。不同公司业务经营范围不同，所列的各类与现金收付相关的项目也不尽相同\n表5-9　经营活动现金流部分\n需要重点关注的科目是“销售商品、提供劳务收到的现金”。\n通常用该科目金额和营业收入作对比，如果远远小于营业收入，企业可能有大量应收账款被拖欠。这种现象的出现，或者是由于缺乏竞争力，造成账期上的话语权较 弱，或者是企业虚增了收入，无论何种原因都不是好事。 还有一个“支付给职工以及为职工支付的现金”科目值得一提\n这指的是付给职工的工资和奖金，但要注意某些企业该科目的金额并不完全等于企业员工的实际薪酬。因为股权激励作为员工薪酬重要的组成部分，并不会在这里体 现。例如像腾讯、阿里这类互联网企业或某些尚处成长期的公司，会用大量的股权激励来缓解正常形式的工资带来的现金流压力。 优秀企业的经营活动现金流净额不仅大于0，往往还大于净利润。两者接近可说明企业的净利润大多都变成了实实在在的现金，而如果经营活动现金流净额远大于净利 润，则说明企业的应付账款或预收账款比较高，通常是因为产品竞争力突出，或是占据较强的市场地位。\n三、投资活动现金流 投资活动是指企业长期资产的购建和不包括在现金等价物内的投资及其处置活动，包括实物资产投资和金融资产投资两块。\n投资活动现金流的流出项主要包括购买固定资产、无形资产等扩大企业资产规模所支付的现金，以及购买债券、股票或者其他企业股权等支出。流入项主要包括投资本 金的回流，以及相应收益的获取。\n表5-10　投资活动现金流部分\n可以通过投资现金流情况来判断企业当前的发展趋势，净额为正可能预示着扩张速度变慢或者正处于收缩状态。\n对企业投资要重点关注两点：一是投资项目是否在其能力控制范围之内，相当一部分上市公司的跨界投资都算不上成功，毕竟隔行如隔山；二是关注投资收益情况，回 报率至少要大于社会平均回报水平，否则这投资就比较失败，还不如买点理财产品合适。\n四、筹资活动现金流 筹资活动是指导致企业资本及债务规模和构成发生变化的活动，如再次发行股票、向银行贷款、向社会发行债券等。\n筹资活动现金流的流入项目主要包括企业从外部获取资金的进账，现金流流出主要包括企业归还外部资金和相关成本。这部分钱可能是借的（债务性筹资），可能是通 过发股票（权益性筹资）募集而来，对应的成本分别是贷款利息、现金红利等。\n表5-11　筹资活动现金流部分\n投资者需重点观察债务性筹资，如果融资利率较低，说明企业信用评级较好，反之则说明企业可能存在某些瑕疵，令资金融出方提高溢价来覆盖风险。\n五、自由现金流 自由现金流就是在企业通过经营活动赚来的钱中，扣除维持企业正常运转和保持企业竞争力等必要投入后剩余的部分。\n只要企业还要持续发展就必须进行再投资，只有在扣除这些投资之后才能向股东分红。我们常说的只有为股东持续创造价值的上市公司才值得长期持有，指的就是那 些拥有充沛自由现金流的企业。 自由现金流=税后净营业利润+折旧和摊销-资本性支出-营运资金支出\n资本性支出为企业对新增固定资产、无形资产的支出，属于投资活动现金流。 营运资金就是维持企业正常生产经营所需要的资金，其支出=期末－期初。营运资金=（流动资产－货币资金）-（流动负债－短期借款－应付短期债券－一年内到期 的长期借款－一年内到期的应付债券） 单看一年的自由现金流并不全面，投资者同样需要进行企业自身历史纵向和同业横向的对比。根据近几年自由现金流的变化趋势，分析增加或减少的原因。\n六、上市公司的现金流画像 企业的现金流被经营、投资和筹资三种活动分成三类，每类又有净流入（+）、净流出（-）两种状态，排列组合后便得到了八种不同的现金流画像结构\n表5-12　上市公司现金流画像\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%A2%E6%8A%A5/%E7%AC%AC%E5%85%AD%E8%8A%82-%E7%8E%B0%E9%87%91%E6%B5%81%E9%87%8F%E8%A1%A8/","summary":"现金流量表是反映在一定时间内企业经营、投资和筹资活动对其现金及现金等价物流入和流出所产生影响的财务报表。它区别于利润表和资产负债表的一个重要","title":"第六节 上市公司的供血站——现金流量表"},{"content":"9.1 服务器中的数据库 redis.h/redisServer\n1 2 3 4 5 6 7 8 9 struct redisServer { // ... //一个数组，保存着服务器中的所有数据库 redisDb *db; // ... //服务器的数据库数量 int dbnum; // ... }; dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16\n图9-1 服务器数据库示例\n9.2 切换数据库 1 2 3 4 5 6 7 8 9 10 11 12 redis\u0026gt; SET msg \u0026#34;hello world\u0026#34; OK redis\u0026gt; GET msg \u0026#34;hello world\u0026#34; redis\u0026gt; SELECT 2 OK redis[2]\u0026gt; GET msg (nil) redis[2]\u0026gt; SET msg\u0026#34;another world\u0026#34; OK redis[2]\u0026gt; GET msg \u0026#34;another world\u0026#34; 在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库\n1 2 3 4 5 6 typedef struct redisClient { // ... //记录客户端当前正在使用的数据库 redisDb *db; // ... } redisClient; redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。\n图9-2 客户端的目标数据库为1号数据库\n建议显式地切换到指定的数据库，然后才执行命令\n9.3 数据库键空间 redis.h/redisDb\n1 2 3 4 5 6 7 typedef struct redisDb { // ... // 数据库键空间，保存着数据库中的所有键值对 dict *dict; // ... } redisDb; 每个键都是一个字符串对象 每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象 图9-4 数据库键空间例子\n9.3.6 读写键空间时的维护操作 在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个 值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。 在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。 如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作 如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改 过 如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知 9.4 设置键的生存时间或过期时间 通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL）\n客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。\nTTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间\n9.4.1 设置过期时间 实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的\nEXPIRE命令可以转换成PEXPIRE命令 PEXPIRE命令又可以转换成PEXPIREAT命令 EXPIREAT命令也可以转换成PEXPIREAT命令 图9-11 设置生存时间和设置过期时间的命令之间的转换\n9.4.2 保存过期时间 redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：\n过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。 过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。 1 2 3 4 5 6 typedef struct redisDb { // ... //过期字典，保存着键的过期时间 dict *expires; // ... } redisDb; 图9-12 带有过期字典的数据库例子\n为了展示方便，图9-12的键空间和过期字典中重复出现了两次alphabet键对象和book键对象。在实际中，键空间的键和过期字典的键都指向同一个键对象，所以不 会出现任何重复对象，也不会浪费任何空间。\n9.4.3 移除过期时间 PERSIST命令可以移除一个键的过期时间：\n1 2 3 4 5 6 7 8 redis\u0026gt; PEXPIREAT message 1391234400000 (integer) 1 redis\u0026gt; TTL message (integer) 13893281 redis\u0026gt; PERSIST message (integer) 1 redis\u0026gt; TTL message (integer) -1 9.4.4 计算并返回剩余生存时间 TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间：\n1 2 3 4 5 6 redis\u0026gt; PEXPIREAT alphabet 1385877600000 (integer) 1 redis\u0026gt; TTL alphabet (integer) 8549007 redis\u0026gt; PTTL alphabet (integer) 8549001011 TTL和PTTL两个命令都是通过计算键的过期时间和当前时间之间的差来实现的\n9.4.5 过期键的判定 通过过期字典，程序可以用以下步骤检查一个给定键是否过期：\n检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。 检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。 9.5 过期键删除策略 定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。 9.5.1 定时删除 使用定时器\n优点\n尽快删除过期键, 释放内存 缺点\ncpu不友好, 有大量过期键时可能影响响应时间和吞吐量 时间事件使用无序链表, 查找事件事件复杂度O(N), 效率不高 9.5.2 惰性删除 程序只会在取出键时才对键进行过期检查\n优点\ncpu友好 缺点\n内存不友好, 过期了只要不访问就不删除(视为内存泄漏) 9.5.3 定期删除 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。 除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。 定期删除策略的难点是确定删除操作执行的时长和频率：\n9.6 Redis的过期键删除策略 Redis服务器实际使用的是惰性删除和定期删除两种策略\n9.6.1 惰性删除策略的实现 过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查\n图9-15 命令调用expireIfNeeded来删除过期键\n9.6.2 定期删除策略的实现 过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle 函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。\n9.7 AOF、RDB和复制功能对过期键的处理 在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。\n9.7.2 载入RDB文件 在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：\n如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略 如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的 时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。 9.7.3 AOF文件写入 当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。\n当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。\n9.7.4 AOF重写 在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。\n","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC9%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"9.1 服务器中的数据库 redis.h/redisServer 1 2 3 4 5 6 7 8 9 struct redisServer { // ... //一个数组，保存着服务器中的所有数据库 redisDb *db; // ... //服务器的数据库数量 int dbnum; // ... }; dbnum属","title":"第9章 数据库"},{"content":"Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和 有序集合对象这五种类型的对象\n8.1 对象的类型与编码 Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另 一个对象用作键值对的值（值对象）。\nRedis中的每个对象都由一个redisObject结构表示\n1 2 3 4 5 6 7 8 9 typedef struct redisObject { //类型 unsigned type:4; //编码 unsigned encoding:4; //指向底层实现数据结构的指针 void *ptr; // ... } robj; 8.1.1 类型 对象的type属性记录了对象的类型\n表8-1 对象的类型\n对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种\nTYPE命令用于查看值对象的类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #键为字符串对象，值为字符串对象 redis\u0026gt; SET msg \u0026#34;hello world\u0026#34; OK redis\u0026gt; TYPE msg string #键为字符串对象，值为列表对象 redis\u0026gt; RPUSH numbers 1 3 5 (integer) 6 redis\u0026gt; TYPE numbers list #键为字符串对象，值为哈希对象 redis\u0026gt; HMSET profile name Tom age 25 career Programmer OK redis\u0026gt; TYPE profile hash #键为字符串对象，值为集合对象 redis\u0026gt; SADD fruits apple banana cherry (integer) 3 redis\u0026gt; TYPE fruits set #键为字符串对象，值为有序集合对象 redis\u0026gt; ZADD price 8.5 apple 5.0 banana 6.0 cherry (integer) 3 redis\u0026gt; TYPE price zset 8.1.2 编码和底层实现 表8-3 对象的编码\n表8-4 不同类型和编码的对象\n8.2 字符串对象 编码\nint raw embstr 如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成 long），并将字符串对象的编码设置为int。\n图8-1 int编码的字符串对象\n如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的 编码设置为raw。\n图8-2 raw编码的字符串对象\n如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值\n图8-3 embstr编码创建的内存块结构\n图8-4 embstr编码的字符串对象\n如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。\n8.2.1 编码的转换 对于int编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw。\n1 2 3 4 5 6 7 8 9 10 redis\u0026gt; SET number 10086 OK redis\u0026gt; OBJECT ENCODING number \u0026#34;int\u0026#34; redis\u0026gt; APPEND number \u0026#34; is a good number!\u0026#34; (integer) 23 redis\u0026gt; GET number \u0026#34;10086 is a good number!\u0026#34; redis\u0026gt; OBJECT ENCODING number \u0026#34;raw\u0026#34; 因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序, 所以embstr编码的字符串对象实际上是只读的。当我们对embstr编码的字符串对象执行任何 修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。\n1 2 3 4 5 6 7 8 redis\u0026gt; SET msg \u0026#34;hello world\u0026#34; OK redis\u0026gt; OBJECT ENCODING msg \u0026#34;embstr\u0026#34; redis\u0026gt; APPEND msg \u0026#34; again!\u0026#34; (integer) 18 redis\u0026gt; OBJECT ENCODING msg \u0026#34;raw\u0026#34; 8.2.2 字符串命令的实现 表8-7 字符串命令的实现\n8.3 列表对象 编码\nziplist linkedlist 图8-5 ziplist编码的numbers列表对象\n图8-6 linkedlist编码的numbers列表对象\n8.3.1 编码转换 当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：\n列表对象保存的所有字符串元素的长度都小于64字节； 列表对象保存的元素数量小于512个； 不能满足这两个条件的任意一个时, 列表对象需要使用linkedlist编码。\n以上两个条件的上限值是可以修改的，具体请看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 所有元素的长度都小于64 字节 redis\u0026gt; RPUSH blah \u0026#34;hello\u0026#34; \u0026#34;world\u0026#34; \u0026#34;again\u0026#34; (integer)3 redis\u0026gt; OBJECT ENCODING blah \u0026#34;ziplist\u0026#34; #将一个65字节长的元素推入列表对象中 redis\u0026gt; RPUSH blah \u0026#34;wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\u0026#34; (integer) 4 #编码已改变 redis\u0026gt; OBJECT ENCODING blah \u0026#34;linkedlist\u0026#34; 8.3.2 列表命令的实现 表8-8 列表命令的实现\n8.4 哈希对象 编码\nziplist hashtable ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保 存了值的压缩列表节点推入到压缩列表表尾\n图8-9 ziplist编码的profile哈希对象\n图8-10 profile哈希对象的压缩列表底层实现\nhashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：\n字典的每个键都是一个字符串对象，对象中保存了键值对的键； 字典的每个值都是一个字符串对象，对象中保存了键值对的值。 图8-11 hashtable编码的profile哈希对象\n8.4.1 编码转换 当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：\n哈希对象保存的所有键值对的键和值的字符串长度都小于64字节； 哈希对象保存的键值对数量小于512个； 不能满足这两个条件的任意一个时, 哈希对象需要使用hashtable编码。\n这两个条件的上限值是可以修改的，具体请看配置文件中关于hash-max-ziplist-value选项和hash-max-ziplist-entries选项的说明。\n1 2 3 4 5 6 7 8 9 10 11 #哈希对象只包含一个键和值都不超过64个字节的键值对 redis\u0026gt; HSET book name \u0026#34;Mastering C++ in 21 days\u0026#34; (integer) 1 redis\u0026gt; OBJECT ENCODING book \u0026#34;ziplist\u0026#34; #向哈希对象添加一个新的键值对，键的长度为66字节 redis\u0026gt; HSET book long_long_long_long_long_long_long_long_long_long_long_description \u0026#34;content\u0026#34; (integer) 1 #编码已改变 redis\u0026gt; OBJECT ENCODING book \u0026#34;hashtable\u0026#34; 8.4.2 哈希命令的实现 表8-9 哈希命令的实现\n8.5 集合对象 编码\nintset hashtable intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。\n图8-12 intset编码的numbers集合对象\nhashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。\n图8-13 hashtable编码的fruits集合对象\n8.5.1 编码的转换 当集合对象可以同时满足以下两个条件时，对象使用intset编码：\n集合对象保存的所有元素都是整数值； 集合对象保存的元素数量不超过512个。 不能满足这两个条件的任意一个时, 集合对象需要使用hashtable编码。\n第二个条件的上限值是可以修改的，具体请看配置文件中关于set-max-intset-entries选项的说明。\n1 2 3 4 5 6 7 8 redis\u0026gt; SADD numbers 1 3 5 (integer) 3 redis\u0026gt; OBJECT ENCODING numbers \u0026#34;intset\u0026#34; redis\u0026gt; SADD numbers \u0026#34;seven\u0026#34; (integer) 1 redis\u0026gt; OBJECT ENCODING numbers \u0026#34;hashtable\u0026#34; 8.5.2 集合命令的实现 表8-10 集合命令的实现方法\n8.6 有序集合对象 编码\nziplist skiplist ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第 二个元素则保存元素的分值（score）。\n压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。 图8-14 ziplist编码的有序集合对象\n图8-15 有序集合元素在压缩列表中按分值从小到大排列\nskiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：\n1 2 3 4 typedef struct zset { zskiplist *zsl; dict *dict; } zset; zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素： 跳跃表节点的object属性保存了元素的成员 跳跃表节点的score属性则保存了元素的分值。 通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK、ZRANGE等命令就是基于跳跃表API来实现的。 zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员 字典的值则保存了元素的分值。 通过这个字典，程序可以用O(1)复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的 有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。值得一提的是，虽然zset结构同时使用跳跃表和字典来保存有序集 合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分值\n为什么有序集合需要同时使用跳跃表和字典来实现？\n有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现, 但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低 如果我们只使用字典来实现有序集合，那么虽然以O(1)复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行 范围型操作——比如ZRANK、ZRANGE等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少O(NlogN)时间复杂度，以及额外的O(N)内存 空间（因为要创建一个数组来保存排序后的元素）。 如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1) 上升为O(logN)。 图8-16 skiplist编码的有序集合对象\n图8-17 有序集合元素同时被保存在字典和跳跃表中\n为了展示方便，图8-17在字典和跳跃表中重复展示了各个元素的成员和分值，但在实际中，字典和跳跃表会共享元素的成员和分值，所以并不会造成任何数据重复，也 不会因此而浪费任何内存。\n8.6.1 编码的转换 当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：\n有序集合保存的元素数量小于128个； 有序集合保存的所有元素成员的长度都小于64字节； 不能满足以上两个条件的任意一个时, 有序集合对象将使用skiplist编码。\n以上两个条件的上限值是可以修改的，具体请看配置文件中关于zset-max-ziplist-entries选项和zset-max-ziplist-value选项的说明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #对象包含了128个元素 redis\u0026gt; EVAL \u0026#34;for i=1, 128 do redis.call(\u0026#39;ZADD\u0026#39;, KEYS[1], i, i) end\u0026#34; 1 numbers (nil) redis\u0026gt; ZCARD numbers (integer) 128 redis\u0026gt; OBJECT ENCODING numbers \u0026#34;ziplist\u0026#34; #再添加一个新元素 redis\u0026gt; ZADD numbers 3.14 pi (integer) 1 #对象包含的元素数量变为129个 redis\u0026gt; ZCARD numbers (integer) 129 #编码已改变 redis\u0026gt; OBJECT ENCODING numbers \u0026#34;skiplist\u0026#34; 8.6.2 有序集合命令的实现 表8-11 有序集合命令的实现方法\n8.7 类型检查与命令多态 8.7.1 类型检查的实现 类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的\n8.7.2 多态命令的实现 Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。\n8.8 内存回收 因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制， 程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。\n每个对象的引用计数信息由redisObject结构的refcount属性记录：\n1 2 3 4 5 6 typedef struct redisObject { // ... //引用计数 int refcount; // ... } robj; 对象的引用计数信息会随着对象的使用状态而不断变化：\n在创建一个新对象时，引用计数的值会被初始化为1； 当对象被一个新程序使用时，它的引用计数值会被增一； 当对象不再被一个程序使用时，它的引用计数值会被减一； 当对象的引用计数值变为0时，对象所占用的内存会被释放。 表8-12 修改对象引用计数的API\n对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。\n8.9 对象共享 在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：\n将数据库键的值指针指向一个现有的值对象； 将被共享的值对象的引用计数增一。 图8-20 未被共享的字符串对象\n图8-21 被共享的字符串对象\nRedis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值\n创建共享字符串对象的数量可以通过修改redis.h/REDIS_SHARED_INTEGERS常量来修改。\n如果我们创建一个值为100的键A，并使用OBJECT REFCOUNT命令查看键A的值对象的引用计数，我们会发现值对象的引用计数为2：\n1 2 3 4 redis\u0026gt; SET A 100 OK redis\u0026gt; OBJECT REFCOUNT A (integer) 2 引用这个值对象的两个程序分别是持有这个值对象的服务器程序\n图8-22 引用数为2的共享对象\n那些在数据结构中嵌套了字符串对象的对象（linkedlist编码的列表对象、hashtable编码的哈希对象、hashtable编码的集合对象，以及zset编码的有序集合 对象）都可以使用这些共享对象。\n为什么Redis不共享包含字符串的对象？\n只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂 度就会越高，消耗的CPU时间也会越多：\n如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为O(1)； 如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)； 如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N^2)。 8.10 对象的空转时长 redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：\n1 2 3 4 5 typedef struct redisObject { // ... unsigned lru:22; // ... } robj; OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 redis\u0026gt; SET msg \u0026#34;hello world\u0026#34; OK #等待一小段时间 redis\u0026gt; OBJECT IDLETIME msg (integer) 20 #等待一阵子 redis\u0026gt; OBJECT IDLETIME msg (integer) 180 #访问msg键的值 redis\u0026gt; GET msg \u0026#34;hello world\u0026#34; #键处于活跃状态，空转时长为0 redis\u0026gt; OBJECT IDLETIME msg (integer) 0 OBJECT IDLETIME命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性。\n如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设 置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。\n配置文件的maxmemory选项和maxmemory-policy选项的说明介绍了关于这方面的更多信息。\n8.11 重点回顾 Redis数据库中的每个键值对的键和值都是一个对象。 Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象 的使用效率。 服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。 Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。 Redis会共享值为0到9999的字符串对象。 对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。 ","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC8%E7%AB%A0-%E5%AF%B9%E8%B1%A1/","summary":"Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、","title":"第8章 对象"},{"content":"一、利润表的要素和结构 净利润=收入－成本－费用±其他\n基本表现形式主要有多步式和单步式两种，按照企业会计制度的规定，我国利润表主要采用多步式结构，描述收入一步一步变成利润的过程：\n第一步，以主营业务收入为基础，减去主营业务成本、主营业务税金及附加，计算出主营业务利润； 第二步，以主营业务利润为基础，加上其他业务利润减去营业费用、管理费用、财务费用，计算出营业利润； 第三步，以营业利润为基础，加上投资收益、补贴收入、营业外收入，减去营业外支出，计算出利润总额； 第四步，以利润总额为基础，减去所得税，计算出净利润（或亏损）。 表5-6　利润表基本格式\n续表\n因为人们容易在瞄一眼利润表数据后，就简单得出业绩好坏的结论, 利润表成了“三张表”中最容易财务造假的重灾区\n在权责发生制这一会计核算准则下，收入和费用天然存在较大操作空间。\n权责发生制，又称“应收应付制”。它是以本期发生的费用和收入来确定本期损益的会计制度。凡在本期发生的收入和费用，不论本期是否已收到或付出现金，均应作为 本期的收入和费用做处理。某些不良企业会利用这种制度，将尚不确定的收入和费用提前确认，从而达到调整利润或掩盖亏损等目的。\n二、利润表的阅读逻辑 从营业收入到毛利润 营业收入－营业成本=毛利润\n毛利率 = 毛利润/营业收入\n一家企业的毛利率是否正常需要在同业维度下作比较\n毛利率提升的原因，要么是成本下降，要么是售价上升。当企业的毛利率发生变动，首先分析是成本端还是销售端的原因，然后再思考这种变化是否合理。\n从毛利润到营业利润 “毛”主要包括税金及附加、期间费用、资产减值损失以及其他收益等，拔过毛的利润就是企业的营业利润。\n税金及附加是指企业在营业中应负担的相关税费，包括消费税、增值税、城市维护建设税、资源税、房产税、城镇土地使用税、车船税和印花税等。\n期间费用指的是营业费用、管理费用以及财务费用这三大费用。\n营业费用又叫销售费用，主要是企业在销售产品和提供服务等日常经营过程中产生的各项费用。销售费用通常会与销售收入同向变动，且变动比例不会太大。 管理费用 管理费用是指在企业管理环节产生的各项费用，包含管理者工资福利、工会经费、职工教育经费、行政开支、董事会经费、中介机构费用、无形资产摊销以及管理机 构资产折旧、业务招待费、计提的各类准备等。这个科目是个大杂烩，各种名目的支出，各种费用调节，甚至有些找不到科目归属的费用，都会丢到管理费用中。 管理费用还包含一个经常被忽视的重要内容——诉讼费。被忽视是因为该科目的金额一般不会很大，十几万元甚至几万元的也常见。而一旦出现这个科目，说明企业可 能处于法律纠纷或仲裁中，账面十几万元费用的背后可能是天文数字的赔偿金额。在终审判决之前，审计师通常无法将其确认为负债，只能列为前一节介绍过的 “或有负债”，在表外进行披露，故须引起重视。 财务费用主要包括自有资金的利息收入、债务的利息支出、外汇结算的汇兑损益以及在银行等金融机构办理业务时产生的各项手续费。因为此费用有收入项也有支出 项，所以可正可负。它主要用来和货币资金以及有息负债进行对比，看是否合理以及会否对企业带来过重财务负担。 资产减值损失指的是资产的可回收金额低于账面价值所造成的损失，前一节提到的固定资产、无形资产、商誉和存货等资产都有可能出现这一问题。需要重点关注的是 存货、应收账款以及持有到期投资这几项的减值损失，因为这些计提转出后，如果发现提错了还可以再转回来。\n这一特点的存在，让这个科目成了上市公司调节利润最常耍手段的地方之一。 其他收益包括投资收益和公允价值变动收益。投资收益指的是企业对外投资取得的利润、股利、利息等收入减去投资损失后的净收益。公允价值变动收益指的是金融资 产和投资性房地产公允价值变动带来的收益或损失。看报表时要留意这块占营业利润的比例，占比较大可能说明企业的主营业务发展得并不好。\n营业利润率 = 营业利润/营业收入\n它直接反映企业的运营效率高不高，数值越高代表运营效率越高。在竞争比较充分的行业中，各企业毛利率差别不会很大，但净利润却相差悬殊，此种差异主要就是 由运营效率不同造成的 从营业利润到净利润 净利润 = 营业利润 + 营业外收入 - 营业外支出 - 所得税\n营业外收入就是与主营业务无关的偶然性收入。\n营业外支出出自营业外收入相对应的科目，因被罚款或者火灾、地震造成的损失就算作营业外支出。\n计算净利润前的最后一项是企业所得税，这是根据企业最终的盈余来征收的。利润总额如果为负数，亏损的这一部分还能用来抵扣将来需缴纳的企业所得税，这在税法 里叫作弥补亏损。\n有净利润并不等于就挣到了钱，还要将其和现金流量表中的“经营现金流净额”对照起来看。如果净利润总是小于经营现金流净额就需要提高警惕——这类上市公司或者是 有大量应收或预付款项，或者是存在虚增营业利润的可能。而无论哪一种情况，投资者都尽量远离。\n三、利润表的重点关注对象 首先是营业收入。选股时应优选营业收入持续增长的企业，这说明其在不断扩张市场。另外，对比同行的营业收入增长率，能看出该企业在行业中的地位强弱，龙头公 司的该项数据一般会高于其他企业。另外，再强的龙头公司也很难保持永远高速增长\n其次是毛利率。毛利率高的企业在产品或服务的价格方面往往有着较强的竞争优势。但是，在选择时为防止刻意做高毛利润，还要看一下高毛利率的原因是什么，如缺 少合理解释也不能排除财务造假的可能。\n再次是费用率。有运营就必然会产生费用，研究财报要谨慎对待费用率高或剧烈波动的公司。销售费用高的公司往往是因为产品竞争力有限，需要庞大的销售团队铺开 渠道，这样会造成企业的扩张成本较高，降低利润空间。\n再次是营业利润率。营业利润率越大说明企业的盈利能力越强，但在求大的同时也要做历史纵向比较和同业横向比较，看看高营业利润率是否合理，是否能够持续。\n最后还要比对净利润和现金流量表，确保全部或至少大部分的净利润能以真正的现金流形式流入企业。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%A2%E6%8A%A5/%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%88%A9%E6%B6%A6%E8%A1%A8/","summary":"一、利润表的要素和结构 净利润=收入－成本－费用±其他 基本表现形式主要有多步式和单步式两种，按照企业会计制度的规定，我国利润表主要采用多步式结","title":"第五节 上市公司的成绩单——利润表"},{"content":"一、审计报告 审计类型共有五种，分别表达了会计师的五种态度\n表5-1　会计师出具意见与真实意图对照\n二、资产负债表的要素和结构 资产负债表主要是用来反映企业有多少家当，家底厚不厚。此表中的内容直接决定了企业资产质量和持续获取稳定利益的能力。\n资产=负债+所有者权益\n资产表明企业的钱以何种形式存在，通常按变现的便捷程度进行排序，容易变现的货币及其等价物放在最上面，难以变现的资产放在后面。负债及所有者权益表明企业 的钱从哪里来，负债就是企业借了或欠了外面多少钱，所有者权益就是企业有多少钱是股东的（也可以理解为一种永久负债，只要没破产清算就不用还）。此处排序同 样有讲究，一般按还钱的紧急程度进行排序，距离还钱期限越短的越往上排。\n表5-3　资产负债表基本格式\n三、资产及主要会计科目 资产的分类方法有多种，如按可变现能力可将一年内能变现或者运用的资产归为流动资产，一年以上的称为非流动资产；按是否具备实物形态可分为有形资产和无形资 产；按资产的来源可分为自有资产和租入资产等。对投资者而言，将资产分为货币资产、经营相关资产、生产相关资产以及投资相关资产更具实际意义。\n货币资产主要指货币资金； 经营相关资产主要包括应收账款、预付账款和存货； 生产相关资产主要包括固定资产、在建工程、无形资产、商誉等； 投资相关资产，主要指的是投资性房地产、交易性金融资产、可供出售金融资产等。 关注经常性资产, 重点关注资产变动情况\n经常性资产主要包括货币资金、存货、应收票据及应收账款、预付账款、固定资产和在建工程等。对于这类资产的分析，主要是通过与历年数据对比，看是否存在异 常变动，如有，则需要努力寻找其变动的原因。 “重点关注”资产主要包括投资性房地产、交易性金融资产、可供出售金融资产、无形资产、商誉、长期待摊费用和其他应收款等。对这类资产，除需要和往年对比外， 还要重点观察其绝对金额，科目余额较大时必须深究其原因。 货币资金 这是最容易出现财务造假的科目。资产负债表之中该科目只有期初值和期末值，因此需要借助财报的附注部分的“合并财务报表项目注释”科目来进行详细分析。重点是 要关注现金、银行存款、其他货币资金和其他流动资产的构成以及金额是否符合常理。\n投资者可以把企业的货币资金和短期债务及实际经营情况进行对比。与短期债务匹配，代表企业的偿债能力强；与经营情况匹配，代表资金使用效率高。\n货币资金占总资产的比例同样也值得关注，这一数据在不同行业之间差异较大。\n通过对比一家企业年平均货币资金（用货币资金期初值加上期末余额后再除以2）和利息收入的关系，可以判断财报上的数字是不是临时“借”来的或者存在资金占用的 问题。\n企业购买的银行理财产品会体现在“其他流动资产”这个科目里，当投资者需要考察货币资金状况时，需把这部分资金计算进去。\n存货 存货是指企业在日常活动中持有以备出售的生产成品或商品、处在生产过程中的在产品、在生产过程或提供劳务过程中耗用的材料或物料等。此处同样是财务造假的重 灾区，通过它进行财务造假的方式主要有三种。\n调整存货减值计提 主要产品具备上下游价格波动大、新鲜程度要求高（如牛奶等农副产品）或迭代速度快（如手机、芯片等）等特征的企业，容易存在通过存货减值计提来对利润进行调 整甚至财务造假的风险。\n通过虚构交易来虚增利润 某些上市公司为虚增利润，先是通过购买价值不易评估的产品和服务，使资金流出企业，再通过虚假出售上述产品虚构收入和利润。这类造假的破绽在于，存货的增幅 远大于同期营业成本增幅，且存货与产品销售速度也显著高于同行。因此，在进行同业对比时如果出现上述现象就要多加警惕。\n通过加大生产，降低单位成本，提升毛利率，虚增本期利润 这种造假方式常见于固定成本比较高、边际成本比较低的企业。\n这么做的上市公司不但投资价值没有提升，反而由于存货增加、各种税费增加令经营负担加重，时间拉长只会越来越差。\n应收票据、应收账款和预付账款 应收票据和账款通俗地说就是销售完商品或服务，但目前还没收到的钱。预付账款则是已经付了钱，但是暂时还没收到的商品或服务。\n这三个科目能够体现出企业在产业链上的地位，余额占比越高说明其在产业链上的话语权越低。\n账龄反映了应收账款的质量，也是坏账准备金计提标准之一。如果某家上市公司大多数应收账款都在一年以上，那就有点危险：账龄越长，收回的可能性越低，成为坏 账的可能性越大。\n应收账目还有个指标叫应收账款周转天数\n应收账款周转率=营业收入／平均应收账款 平均应收账款=（期初应收账款+期末应收账款）/2 应收账款周转天数=360/应收账款周转率 应收账款周转天数主要表示当产品卖出后，要多久才能把钱收回来。这个指标通常用来和同行进行对比，应收账款周转天数较低的企业通常在行业中处于优势地位，一 般多为行业龙头。\n应收账款周转率也是一个检验财务是否造假的好工具，企业应收账款周转率低的同时应收账款却很高，就存在财务造假的可能。\n固定资产、在建工程 这两个科目通常连在一起去看：“在建工程”通过消耗“工程物资”转化成“固定资产”，如果迟迟无法转化，那这个“在建工程”可能就是造假的结果。\n固定资产最重要的特点就是需要计提折旧和减值准备。所谓计提折旧，就是把固定资产折损按照一定的方法提取出来，计提部分要作为企业当期经营的成本费用从利润 表中进行扣除。计提减值准备，就是对损坏的、跌价的或长期不用的资产做减值准备，这部分也要从利润表中扣除。\n固定资产的增长速度也是值得观察的指标，太快或者太慢都不好。增长太快，利润跟不上，一旦折旧就会让报表很难看；增长太慢，则有可能是陷入发展瓶颈，没有空 间或必要扩张规模、提高产能了。\n投资性房地产、交易性金融资产、可供出售金融资产 这部分资产主要指的是企业进行投资的资产。绝对金额或总资产占比大并不见得就是好事，优秀的公司应该专注主业，如果和主业经营无关的资产占比过高，利润增长 点主要靠各类资产投资创造，即便业绩可能因此好看，却是在侧面提醒我们该企业可能正在经历某种瓶颈。\n无形资产、长期待摊费用 无形资产主要指企业研发费用的资本化部分或直接外购的无形资产，主要包括专利权、专利技术、版权、商标权和土地使用权等。对于无形资产过大的企业一定要谨慎， 因为无形资产难以清点，估值或多或少都存在一些争议。如果一家企业无形资产太多，很有人为做大资产总量的嫌疑。\n长期待摊费用指的是装修费、预付租金、预付广告费等预计受益期超过一年的费用。这类费用在支付时已经一次性全额支出，而且几乎没有任何变现价值。这块同样是 一个容易财务造假的点，有的企业会把并不需要长期分摊的费用做成长期待摊费用，从而对企业的利润进行调整。\n商誉 商誉是指企业在兼并收购外部公司时所支付的溢价，这可以说是企业各项资产中“水分”最足的地方，除了长期趴在资产负债表或者通过减值进入利润表之外，它几乎不 会为企业带来任何新的经济利益流入。\n其他应收款 其他应收款是指与正常经营关系之外的第三方之间的款项往来，如提供商品或服务后暂留给对方的质保金、房屋租赁提供给业主的押金、股东借款等\n该科目可以说是资产负债表中的藏污纳垢之处，有的大股东用它转移资金，占用企业资金；有的用它来隐藏利润或费用，调节报表。\n在负债中与其对应的是“其他应付款”，包含内容和风险程度与其较为相似。优秀企业的这两个科目金额一般都不会太大，当发现数字较大时一定要提高警惕。\n四、负债及主要会计科目 负债反映在企业的家底中，有多少钱是借来的（金融负债），或目前尚欠的外债有多少（经营负债）。借贷是现代企业的正常商业行为，上市公司有负债并不是坏事， 只要控制在合理范围内就是健康的。\n或有负债不算负债，不计入资产负债表中，一般只在资产负债表的附注中披露。\n在会计上，负债同样以一年为分界点分为流动负债和非流动负债。但站在投资者的角度上，通常按照负债性质分为经营性负债、融资性负债以及分配性负债。\n对于负债下的各科目，需要重点关注两点：一是财务风险，二是有息负债占总资产的比例。具体来说，就是看上市公司的现金及现金等价物能否覆盖有息负债，这样在 极端情况下还可以断臂求生，用现金及现金等价物偿还有息负债。至于有息负债占总资产比例，主要是和同行作对比，如果和同行相差较远，就需要提高重视程度。\n负债中吸收存款以及同业存款、向中央银行借款这几个科目也是比较特殊的负债科目。这些科目只会出现在银行、非银金融机构财报中，是这类企业的特权。\n五、所有者权益 所有者权益中的“所有者”指的是股东，所以又叫股东权益。它是指企业资产中属于股东的那部分，由企业总资产减去总负债得出。投资者通常说的 “净资产”就是所有者权益中的“归属于母公司所有者权益合计”的部分，可以由“所有者权益”减去“少数股东权益”得到。\n所有者权益主要由四部分，即实收资本、资本公积、盈余公积和未分配利润构成。\n实收资本 实收资本又叫“股本”，就是企业营业执照上的注册资金。它等于上市公司发行的股份总额乘以股票面值，由于绝大多数股票面值为1元，所以实收资本也可以理解为上 市公司一共发行了多少股的股票。\n资本公积 股票的发行价往往高于股票的面值，多出来的部分就是资本溢价（又叫股本溢价），这部分会进入资本公积。\n资本公积转增股票不用交税，这是因为资本公积是股东投入的，而不是通过利润得来的。在企业存续期间，非交易产生的所得都会被归入资本公积。\n盈余公积和未分配利润 企业赚钱后，利润分配不是随便分，而是有顺序要求的。\n首先要用来弥补以前的年度亏损； 其次，要按照当年母公司利润表的税后利润的10%计提法定盈余公积； 再次，由股东自行决定是否继续提取额外的盈余公积（具体数额股东商定）； 最后，才决定是否向股东分配。 盈余公积是从利润里留下继续投入扩大再生产的钱。其中法定盈余公积是强制股东留下的，累积到注册资本的50%以后可不再提取。企业可以利用盈余公积或未分配利 润送红股，用盈余公积送股的，需保证送股后盈余公积不得低于注册资本的25%。\n四看\n首先看各科目的总资产占比，并对比比率是否合理； 其次看资产质量是否有水分，有的话会对企业有什么影响； 再次看企业有息负债和货币资金的匹配关系，是否有潜在的财务风险； 最后看各资产的运转效率（用营业收入除以各资产的平均余额，具体参考应收账款周转率）。 分析时还要纵向对比各年份数据，判断其数值变动是否处于合理范围；同时横向对比同业，正常情况和行业的平均水平不会相差太多，如果偏差异常就要提高警惕。\n最后，理解公司的行业特征、商业模式和业务流程是读懂资产负债表的前提，不同行业上市公司的资产负债表差异会很大\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%A2%E6%8A%A5/%E7%AC%AC%E5%9B%9B%E8%8A%82-%E8%B5%84%E4%BA%A7%E8%B4%9F%E5%80%BA%E8%A1%A8/","summary":"一、审计报告 审计类型共有五种，分别表达了会计师的五种态度 表5-1 会计师出具意见与真实意图对照 二、资产负债表的要素和结构 资产负债表主要是用来反","title":"第四节 上市公司的家底——资产负债表"},{"content":"一、公司业务概要 这一部分将对公司主营业务、经营模式、业务发展情况及目标，乃至企业核心竞争力等内容进行全方位的阐述。\n年报每年都在更新，通过对比这一部分内容的变化，有时还能窥见公司对行业和自身发展的观点，据此研判其在业务、技术和客户等方面是否有重大突破。\n二、经营情况讨论与分析 仔细阅读和分析这一节内容，可获取比前一部分更多的重要信息。一是从管理层的角度解释公司过去一年的业绩是如何形成的；二是经营业绩会有大量更细节的数据， 有的数据是在财务报表及附注中也没有的；三是会对企业的未来进行展望；四是可以体现管理层的能力与眼光。\n概述及主营业务分析 这一节通过对业务发展的定性描述，解读了财务数据背后的逻辑。\n库存量, 实物销售表会显示企业各类产品的库存量，有些企业会通过这部分来对营业收入进行调整 研发投入, 对于创新型企业的这部分尤需重点关注 前5名客户及前5名供应商资料，可以从总额占比看出上市公司对上下游某单一企业的依赖程度 非主营业务情况和资产及负债状况分析 非主营业务情况主要阐述企业非主营业务所带来的收入，以及这类收入是否能够持续。\n资产及负债状况分析主要罗列资产负债表的主要科目、敏感科目（应收应付类科目）以及变化较大的科目。\n投资状况分析 此处要重点关注的是“募集资金使用情况”，上市公司IPO时许下的承诺、愿景，到底是讲故事还是真正兑现了，在这里能够展现出来。这一项下还有一个分项叫做 “募集资金变更项目情况”，阅读后可推断公司是准备赖账，还是在各种主客观原因下应时而变。\n公司未来发展的展望 这部分是站在企业管理者的角度分析上市公司在市场、行业中的优劣势，及未来的发展前景。尤其是“公司未来经营计划”，有可能会在此处给出下一年的业绩预期。投 资者平常所说的“不及预期”有两种，一种是不及研究机构分析师的预期，另一种就是指不及董事会上一年的预期。\n从这部分还可看出管理层的能力、诚信和战略眼光。一方面可以去翻阅往年财报，看业务规划是否实现、行业趋势判断是否正确、许下的承诺有无兑现。\n另一方面还可横向比对同行业公司的管理层，对企业竞争力和行业发展趋势的总结。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%A2%E6%8A%A5/%E7%AC%AC%E4%B8%89%E8%8A%82-%E4%B8%8D%E5%8F%AF%E8%BD%BB%E8%A7%86%E7%9A%84%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/","summary":"一、公司业务概要 这一部分将对公司主营业务、经营模式、业务发展情况及目标，乃至企业核心竞争力等内容进行全方位的阐述。 年报每年都在更新，通过对比","title":"第三节 不可轻视的定性分析"},{"content":"一、财报的获取渠道 上海证券交易所和深圳证券交易所官网 巨潮资讯网 第三方软件和网站 二、财报的公布时间 从披露时间上来说，一季报、三季报是要求在季度结束后的一个月内进行披露；半年报是在上半年结束后的两个月内进行披露（即每年8月31日前）；年报是在年度结 束后的4个月内进行披露（即每年4月30日前）。由于时间上的差异，年报信息最为详细和完整，半年报次之，一季报、三季报只有一些基本数据。同时，和其他报告比， 年报必须经过会计师事务所审计，所以通常被认为更有研究和分析价值。\n三、财报的主要结构 图5-1　爱美客公司2020年年报目录\n需要细读的重要内容\n经营情况讨论与分析（也有的报告以“董事会报告”一类作为标题） 重要事项 财务报告 适当关注的内容\n第一节的重要提示部分 第六节的股份变动及股东情况 第九节的董事、监事、高级管理人员和员工情况。 企业情况的基本信息\n第一节的释义部分以及第二、第三节 对于首次关注的企业可以浏览掌握基本情况 四、财报各部分要点 重要提示、目录和释 重要提示通常在首节首页，这一节之所以重要，是因为它通常会把涉及股东权益变动，如分红、送股、转增一类的重大事项放在此处，有的还会把审计报告的结果写在 这里。\n公司简介和主要财务指标 展示了公司的主要财务数据，需要快速了解财务情况的投资者，只须蜻蜓点水般浏览此部分简表即可。\n看完营业收入、净利润以及和上年同期数据的对比，再确认一下非经常性损益项目与净利润的比例，可以得到一个该公司财务基本面的大致印象。\n公司业务概要 是对上市公司进行定性分析的捷径之一\n经营情况讨论与分析 由董事会自己书写的企业分析报告，内容可靠性和准确性一般会高于各机构研究报告。\n重要事项 如果真正想全面掌握一家企业的基本面概况，其中仍有很多内容值得留意，如重大合同及履约情况、涉诉情况、股权激励、员工持股计划等，都可能是影响未来业绩表 现及股价的潜在因素。\n“聘任、解聘会计师事务所情况”一项中如出现换所的情况，也需要多加留意。一般情况下上市公司不会轻易更换会计师事务所，一旦为之，有可能是其财报出现某种状 况\n股份变动及股东情况 这里重点关注的，是股东人数和前十大股东的变化。\n股东人数的变化通常会有两个数字，一个是报告期末股东人数，另一个是披露日前上一月末普通股股东总数。\n优先股相关情况 可转换公司债券相关情况 董事、监事、高级管理人员和员工情况 通过这部分可了解高管的履历和薪酬情况，最重要的是还可以了解员工人数及结构。从员工的人数变化可看出公司业务现阶段是处于扩张还是收缩阶段，员工结构年轻 化、高学历化能侧面说明公司景气度高，研发人员占比高代表着公司重视科研创新，未来产品或服务更新换代的效率会更快。\n公司治理 公司治理包括公司的组织机构上，是否建立健全的内部管理和控制制度体系，是否提升公司经营管理水平和风险防范能力。\n公司债券相关情况 财务报告 资产负债表、利润表和现金流量表\n备查文件目录 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%A2%E6%8A%A5/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E8%B4%A2%E5%8A%A1%E6%8A%A5%E5%91%8A%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/","summary":"一、财报的获取渠道 上海证券交易所和深圳证券交易所官网 巨潮资讯网 第三方软件和网站 二、财报的公布时间 从披露时间上来说，一季报、三季报是要求在季度","title":"第二节 财务报告的基本结构"},{"content":"一、个股基本面的两个方向 主要分为定性研究和定量研究两个方向, 对应要解决的两个核心问题，分别是上市公司质地是否健康以及赚钱能力究竟是强还是弱。\n定性分析需要全面了解公司的业务开展情况：从产品到渠道，从价格到促销、营销管理，从研发到供应链的完整运营链路，等等。再结合行业的基本格局和竞争态势来 理解企业的发展战略，辅助判断公司是否具有可持续的竞争优势和投资价值。\n定量分析主要是对企业的经营业绩进行数字化分析，测算关键财务指标，判断企业的盈利能力、财务状况和运营效率，并通过对比自身历史数据进行趋势分析以及与国 内外同行横向对比等手段，来确定公司的业绩是否优秀。\n专业投资机构使用全球通用的商业分析模型, 主要包括波特五力、SWOT、ECIRM、SCP等。\n财报是普通投资者收集企业“情报”的重要工具。\n二、财报分析的意义 财报是部《致富经》，能帮我们增强持股信心 通过研读目标公司的历年财报（也包括上市时的招股说明书），了解企业主的创富故事，洞悉企业的前世今生，能帮我们更好地理解企业的价值观，判断未来的走向； 透过各种量化指标了解公司的战略、运营、风险和绩效，掌握其在行业内的竞争优势和不足。只有财富积累过程正当，与我们的价值观和方法论吻合，瑕不掩瑜或暂时 的缺点最终能克服的企业，才能让我们更确信其能从优秀走向卓越，强化持股信心。\n财报是本《相亲指南》，能帮我们找到适合自己的对象 读财报也是如此：要带着企业“过去发生了什么”，去判断企业未来“会产生怎样的变化”。在分析方法上，主要是用财务比率和同业、企业自身历史进行对比。财务比率， 就是各种财务指标的比率，诸如毛利率、净利率、净资产收益率、资产负债率等。当企业的财务比率和同业相差较大或者较过去有较大的波动，就要去深挖这种情况出 现的原因，然后再考虑这种原因是否合理。\n财报是份《体检报告》，能帮我们避免投资“踩雷” 并不是好的财务数据造就了好的企业，而是好的企业产出了好的财务数据。因此，看财报要像看《体检报告》一样，不能只看好的地方，而要多关注不好的指标，发现 企业潜在的问题。\n财报分析只是个股基本面分析的工具之一，既是工具就有其适用范围，它并不能涵盖全部的企业信息，而且各家上市公司财务报告的含金量参差不齐。我们的目标，是 通过财报信息结合各方资讯，尽可能地掌握目标企业更多的真实情况，努力提高下注的准确率。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%A2%E6%8A%A5/%E7%AC%AC%E4%B8%80%E8%8A%82-%E8%B4%A2%E6%8A%A5%E5%88%86%E6%9E%90%E7%9A%84%E6%84%8F%E4%B9%89/","summary":"一、个股基本面的两个方向 主要分为定性研究和定量研究两个方向, 对应要解决的两个核心问题，分别是上市公司质地是否健康以及赚钱能力究竟是强还是弱。","title":"第一节 财报分析的意义"},{"content":"一、行业龙头的优势 行业龙头由于自身实力或其他原因（如行政垄断），往往在其行业中有举足轻重的地位。 行业龙头更容易享受到政策红利，很多时候在行业政策的制定阶段，就会邀请龙头企业参与，并参考这些企业的建议，对政策进行调整 龙头在行业发展进入整合和成熟期后最为受益 随着注册制改革的推进，市场容量在快速增加的同时退市制度也得到强化，A股将会呈现出类似美股和港股的二八分化现象。选择那些抗风险能力强，持续盈利能力 靠谱的龙头企业更安全 二、如何挑选龙头 对于多数行业来说，最大的企业一般也是竞争力最强的企业\n企业的综合竞争力强通常有两方面体现：一是有着较深的护城河，二是当行业开始衰退时能够展现较强的抗性。\n垄断、品牌、技术、市场占有率以及管理能力。 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%8C%E4%B8%9A/%E7%AC%AC%E4%B8%83%E8%8A%82-%E9%87%8D%E8%A7%86%E8%A1%8C%E4%B8%9A%E4%B8%AD%E7%9A%84%E9%BE%99%E5%A4%B4/","summary":"一、行业龙头的优势 行业龙头由于自身实力或其他原因（如行政垄断），往往在其行业中有举足轻重的地位。 行业龙头更容易享受到政策红利，很多时候在行业","title":"第七节 重视行业中的龙头"},{"content":"迈瑞医疗、药明康德、恒瑞医药和爱尔眼科\n医疗行业是一个强政策主导的行业。对它的研究离不开对政策的了解，需要密切关注国家医保局、国家药品监督管理局和卫健委这三个部门的政策动向。现阶段三部门 各司其职，医保局负责医保，药监局负责医药，卫健委负责医疗。\n医疗行业对投资专业度的要求甚至比科技行业还要高。因为大板块下细分赛道极多，包括原料药、化学制剂、医疗器械、医事服务、医药流通等。各条赛道还可以继续 往下分，如化学制剂又可分为仿制药和创新药。\n不同赛道的投资逻辑迥异\n对于原料药的研究可采用周期行业的投资逻辑 创新药有必要借用科技行业分析框架进行研究 连锁药房则与零售商超存在一定相似性。 一、原料药赛道 原料药分为大宗和特色两个领域\n所谓大宗原料药就是指市场需求相对稳定、应用普遍和规模较大的传统药品原料药，如抗生素、维生素、氨基酸、激素等。这类产品毛利率较低，价格波动就是主导股 价变动的核心，产品价格会受到供给、产能、原材料价格的影响而周期性地波动。\n特色原料药通常指尚处于专利保护期，或专利保护期结束后药品的原料药。这类原料药种类众多规模偏小，价格受到下游产品影响较大。对这类企业的研究要重点去分 析下游药品的需求量和与各下游药企合作关系的稳定性。\n总体而言，无论是大宗还是特色，原料药整体是受价格影响较大的行业，呈现出较强的周期品特征。\n美诺华 二、化学制剂赛道 无论是仿制药还是创新药，管线（pipeline）都是化学制剂行业投资必须要了解的重要术语，它是指还未上市的、处于临床阶段或者临床前阶段的药品，其数量体现 了药企后续产品布局线的丰富程度，亦即业绩增长的潜力。\n对于创新药行业，通常用管线估值法进行研究。\n对于创新药企尤其是其中的中小公司，其现金流状况也需要重点关注。\n三、生物制药赛道 疫苗比较类似创新药，可以采用创新药的方法去研究。需要注意的是由于疫苗在产品稳定性和安全性上要求更高，所以对于政策也更会敏感一些。\n血制品无论是自身还是其“来源”——血浆，天生行业壁垒较高，呈现典型的寡头市场特征。对于血制品企业的研究也要采用类似资源周期品行业的方法，重点了解其浆站 数量、采浆量、投浆量的情况。\n四、医疗器械赛道 医疗器械也是一个值得关注的赛道，一来行业尚处蓝海发展空间巨大，二来国产替代是未来发展的趋势。对于医疗器械的研究方法可参照化学制剂的思路，需要多注意 的就是观察目标公司的销售能力和创新壁垒。\n五、医事服务赛道 如眼科、口腔、体检和医美等都属于其下的细分赛道。与其他医药行业比，医事服务受政策影响较小，但对可复制性和品牌效应要求更高。\n六、CXO（医药外包服务）赛道 广义的医事服务下，还包括一个近年来最为亮眼的黄金赛道，被称为CXO，是对为制药企业提供各类外包服务的“铲子型”机构的统称。其中间的字母X相当于汉语中的 某，在细分不同的服务类型时可将具体单词的首字母代入。\nCRO CMO CDMO CSO 对于该赛道的研究重点要关注企业的客户结构、生产能效以及订单量这几个关键点\n总而言之，医药行业对于专业知识和精力投入的要求较高，很多保守投资者会基于敬畏而回避这一行业。但考虑到天花板仍远未触及，医药行业尤其是创新药和CXO等 重点赛道，对收益率有进取心的投资者来说绝不能轻易绕过！\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%8C%E4%B8%9A/%E7%AC%AC%E5%85%AD%E8%8A%82-%E5%8C%BB%E7%96%97%E8%A1%8C%E4%B8%9A%E5%8F%8A%E7%BB%86%E5%88%86%E8%B5%9B%E9%81%93/","summary":"迈瑞医疗、药明康德、恒瑞医药和爱尔眼科 医疗行业是一个强政策主导的行业。对它的研究离不开对政策的了解，需要密切关注国家医保局、国家药品监督管理","title":"第六节 医疗行业及细分赛道"},{"content":"一、科技行业的特性 科技行业具备成长性、周期性和易泡沫化三大典型特征，这让它相对于稳定性和确定性都更高的消费行业，投资难度要大不少。\n成长性, 做得最好的那一家或者那几家公司往往会占据整个行业中绝大部分的市场份额 周期性主要体现在一长一短两个周期上，长周期指的是研发周期长. 短周期指的是产品的迭代周期相对较短 科技行业的弊端\n经常出现题材炒作 经常都处于一个相对高估的状态 对于普通投资者而言，投资科技行业要更加理性、谨慎和细致。\n二、科技行业的研究方法 首先，投资科技企业要以5～10年的维度去看。(回报周期较长) 其次，对企业的业务、产品和技术路线等基本面要有更深入地了解，并在同行业或同类型的公司中进行对比，这样在投资时才会更有底，也能把真正做产业的和只是 做主题性炒作的公司区分开，避免踩坑。 再次，无论牛熊市，科技行业的高波动在所难免。故而在投资时需要做一些仓位控制，不能把全部仓位都放在波动大的科技上。 最后，对科技股难以用传统的市盈率或现金流折现等估值法进行估值。可以根据互联网、电子商务、半导体等赛道不同的特性，用市销率、分部估值或研发费用估值 等方法，并从行业景气度的角度把握投资节奏，或许是更好的选择。 科技是典型的朝阳行业，但其特性决定了投资要以年为单位。因此一方面是要学会守拙，坚持对这一行业的信仰；另一方面就是要挑选其中未来景气度最高的几个赛道， 如消费电子、半导体材料和设备、软件服务、新能源产业链以及互联网科技等。\n三、消费电子赛道 消费电子赛道是科技行业中确定性相对较强的，逻辑也是比较清晰的，从它的发展历程来看，其属于典型的技术迭代型周期行业（2014年开始4G基站大规模铺设， 2014—2016年4G手机销量大幅提升，2019—2020年开始大规模铺设5G基站，同期5G手机销量大幅提升），因此对于该赛道主要看终端销量增长。简单来说就是企业 垄断能力越强，就越值得关注。\n除了终端销量，技术升级带来的零部件使用量以及产品附加值的提升等也是该赛道需关注的重点。\n四、半导体赛道 无论从需求端还是从供给端看，半导体材料和设备都是一个值得长期关注的赛道。\n芯片行业通常被划分为设计、制造和封测三个主要环节。我国在封测环节的实力最强，设计次之，制造环节的实力最弱。芯片封测中长电科技排名全球第三，另外还有 通富微电和天水华天这两家公司也能跻身前十，三家公司的全球市场份额合计大概占20%。\n五、软件服务（SaaS, Software-as-a-Service）赛道 诸如金蝶国际、广联达、金山办公、金山软件、微软和谷歌等企业都是软件服务赛道的代表企业。伴随全球企业云化、数字化进程持续推进，SaaS将会是未来科技领域 值得关注的赛道。从美股市场来看，其IGV（北美软件服务）指数连续四年跑赢标普500指数，全球SaaS产业处于快速演进和变化过程中，新的市场机会不断孕育。\n对于软件服务赛道，可以从其产品的渗透率来判断景气程度。\n在市场渗透率达到20%之前，市场扩张处于一个相对缓慢的过程。 但是一旦到了20%就会进入一个高速增长的阶段 之后到50%～60%就再次进入了一个缓慢增长的阶段。 投资的时候我们可以在企业渗透率达到20%～30%的时候介入，享受其业绩高速增长带来的红利，然后在过了50%后，如果还没有新产品迭代的话就可以提前离场。\n六、新能源赛道 在“碳中和”成为时代进步超强音的背景下，新能源技术是未来科技发展重要的方向之一。\n新能源产业链覆盖面极广，从传统能源到新型能源，从材料研发到系统芯片，新能源赛道几乎覆盖了所有和科技沾边的行业。\n七、互联网赛道 互联网赛道有一个特点，就是其往往喜欢涉足多个领域。相对于其他不重要的枝节，对于这些企业的研究更建议从最核心的“护城河”入手。如腾讯的社交和游戏、阿里 的电商和支付、美团的本地生活和点评系统等。当其“护城河”受到影响或挑战的时候，企业也就会出现较大的波动。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%8C%E4%B8%9A/%E7%AC%AC%E4%BA%94%E8%8A%82-%E7%A7%91%E6%8A%80%E8%A1%8C%E4%B8%9A%E5%8F%8A%E7%BB%86%E5%88%86%E8%B5%9B%E9%81%93/","summary":"一、科技行业的特性 科技行业具备成长性、周期性和易泡沫化三大典型特征，这让它相对于稳定性和确定性都更高的消费行业，投资难度要大不少。 成长性, 做","title":"第五节 科技行业及细分赛道"},{"content":"赛道通常是指行业里面的某个细分行业或领域\n一、牛股辈出的消费行业 这一行业最大的特征就是需求稳定，背后的底层逻辑就是人口——只要社会仍在发展、人口仍在增长，消费的整体需求就是不断向上、稳定增长的，所以从需求的角度看， 这几乎堪称“永动机”行业。\n消费行业的分析方法 消费需求端的演变 需求的演进变化指的是由于地域、收入等多种因素带来的消费理念的变化，也就是通常说的消费分级——一、二线城市消费者更关注品牌背后的附加内容，愿意为品牌支 付超额溢价；而三、四线城市则对消费品的价格更加敏感，降价打折的消费品通常更受欢迎。\n对于消费品的需求演变，通常又得观察稳定性和延展性这两个特性。\n稳定性 观察目标企业的需求端能否在未来一段时间内保持稳定：需求越稳定，投资的可行性和确定性就越高。 关注业绩能否保持较稳定的增速 延展性 消费品市场扩张的延展性. 比如一、二线城市的消费理念比较超前，消费者更多注重个性化、多样化和体验式的消费；三、四线城市更多是温饱型消费，得到满 足之后开始转向享受型消费；县域、乡镇或农村的消费者个性化意识并没有完全觉醒，更注重的是消费品的性价比。 消费升级，是指随着经济的发展，消费者需求的逐渐多样化和个性化. 在研究消费公司时还要看其产品是否因消费升级而被替代，以及应对消费升级的进阶战略 是否足够清晰。 消费供给端的变化 消费品需求端的演进主要围绕稳定性、扩张性和升级性变化，而企业供给端的变化，则主要是渠道、产品和品牌的变迁。\n过去网购没有兴起，交通也没那么发达。那时候哪家消费企业的销售渠道广，哪家的竞争优势就更大。但随着物流业的发达，产品的渠道差异越来越弱化，此时市场占 有率的决定性因素更加回归到产品本身。\n随着行业发展，产品差异不断缩小后，消费品对于消费者心智的占领变得更加重要，这个阶段消费品牌拼的就是品牌力，具有品牌优势的龙头企业会占据更多的市场份 额。\n消费行业还需要关注的，是民族品牌和国货的崛起。\n在分析消费赛道时要注重渠道、产品和品牌这三个要点，看其能否与这三者的变迁保持同步甚至领先。具体来说，白酒、调味品和乳制品等食品饮料，家电、旅游出行 和“Z世代”新消费等都是值得关注的好赛道。\n二、白酒赛道 具有令其他赛道艳羡的极宽护城河\n一是保质期极长，不但无需考虑存货贬值的问题，某些“越陈越香”的老酒甚至还会逐年升值； 二是毛利率极高，普遍在70%以上； 三是品牌效应强、复购率高，具备一定的社交属性； 四是酿造技术变化不大，无须像科技企业那样必须投入高昂的研发费用。 对于白酒赛道的投资重点应放在高端和次高端酒上，关注目标企业的销量、提价速度以及是否具备“收藏属性”。对于在消费升级中获得更多市场份额的企业，可以投入 更多的关注。\n三、调味品赛道 据统计，当前只有30%的调味品消费发生在家庭厨房，20%是食品加工，剩下的大头是餐饮服务业在埋单。这种终端消费者构成，让调味料具备了较强的现代工业化属 性。\n那些建立了一定品牌效应，并且能够实现标准化生产的企业是值得青睐的。 调味品的另一个趋势就是功能性和高附加值带来的高端化 功能性主要体现在调味品的结构调整升级，过去一瓶酱油如今分成了生抽、老抽、耗油、海鲜酱油等 高附加值主要体现在品牌、健康化等特色上 还有一点更重要的是，与调味品庞大市场相对应的是其“大行业小公司”的赛道特征。也就是说调味品企业的赛道空间还很大，未来谁可以占据更大的市场份额，谁就会 有更好的发展。可以重点关注品牌效应好、市场扩张快的企业。\n四、乳制品赛道 乳制品是一个很有潜力的消费赛道。据统计，国内一线城市液态奶渗透率已达90%，但二、三线城市，大部分中小城市及农村地区渗透率仅分别为70%、50%、20%。随 着低线城市及农村地区人均可支配收入的提升及消费渠道的覆盖普及，未来乳制品市场渗透率将向二、三线城市靠拢，这将给乳制品带来巨大渗透空间。\n另外，乳制品还有一个现象：如今超市中单价较高的脱脂奶、低温奶、益生菌的占比越来越多，高单价也就意味着更高的毛利率和净利率，也就意味着企业利润有望进 一步提升。\n投资者应该将重点放在那些自控奶源充足、市场占有率高的企业上。\n五、家电赛道 未来大家电市场将更多地依靠技术进步来促进销量，因此要重点关注那些在智能化、场景化、套系化上做得更好的企业。\n另外，还可以着重挖掘电磁炉、扫地机器人、智能马桶和投影等小家电企业。一方面随着居民可支配收入的增加和消费升级，小家电的需求将迎来提升；另一方面，从 2020年开始，小家电的出口和海外渗透率都在明显加快。\n六、“Z世代”新消费赛道 随着“90后”“00后”成为新一代消费人群主力，诸如潮玩、宠物、美妆、医美、新式茶饮等新消费成了当下消费行业中颇具潜力的黄金赛道。\n对于新消费赛道的研究，要重点围绕着“90后”和“00后”的人群特性——这批人群有着较强的消费欲望和一定消费能力，注重品质与服务，同时对新事物有较高的接受度， 追求个性化、多样化以及体验式消费，更热衷于消费升级。\n此外，对于该赛道的研究还要比传统消费更重视品牌效应和产品质量。产品质量不错，品牌口碑更好的新兴企业往往有着更好的发展空间，反而传统消费行业中占有绝 对地位的价格因素没那么重要。可以更多关注铁杆客群庞大、提价能力超强的新兴消费企业。\n随着中国经济的发展，会有越来越多优秀的消费企业成长起来。在各行业中，消费有望继续保持牛股摇篮“C位”。另外，消费行业的产品和普通大众的日常生活息息相 关，一般人理解起来难度不算大。更重要的是，消费企业的财报也相对简单，不需要太多的财务知识也能看懂。\n消费完全有理由成为初学者投资组合中的必配行业。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%8C%E4%B8%9A/%E7%AC%AC%E5%9B%9B%E8%8A%82-%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A%E5%8F%8A%E7%BB%86%E5%88%86%E8%B5%9B%E9%81%93/","summary":"赛道通常是指行业里面的某个细分行业或领域 一、牛股辈出的消费行业 这一行业最大的特征就是需求稳定，背后的底层逻辑就是人口——只要社会仍在发展、人","title":"第四节 消费行业及细分赛道"},{"content":"投资圈使用较多的是申银万国、中信和万得等机构编制的行业分类标准。最常用的申万行业分类分为三级，一级分类有28个行业，二级分类有104个行业，三级分类有 227个行业。\n一、农林牧渔 农林牧渔主要包括种植业、渔业、林业、饲料、农产品加工、农业综合、畜禽养殖和动物保健等子行业。\n周期性极强 市场庞大 风险较高 由于需求量大，价格稍微变动都会对利润造成巨大的影响 盈率这一指标往往在农林牧渔上容易失真 由于农产品的生物特性，生产资料、动植物产品、存货天然不容易清点，交易结算方式现金交易占较多等因素，使得农林牧渔行业容易沦为财务造假重灾区 由于多年来中央“一号文件”均聚焦农业，每年年末和年初该板块都会出现一定投资机会。 二、采掘、钢铁和有色金属 采掘（主要是石油和煤炭）、钢铁和有色金属行业周期性极强，其股价也经常会跟随大宗商品的价格潮涨潮落。\n行业高峰期急速扩张后，会导致供给需求关系的恶化。加之近年来环保等政策压力剧增，牛转熊后的蛰伏期也会很长。所以除个别优质龙头外，多数采掘、钢铁和有色 类个股只适合抓波段，并不太适合长期持有。\n这类行情同样来得快去得也快，所以对于采掘、钢铁和有色这三个强周期行业还是建议只阶段性地参与。\n三、化工 化工包含的细分领域很多, 分析它时主要围绕四个要点：\n一是要根据其上下游产业链，判断供给和需求特点； 二是要关注其产品价格的变化趋势并和历史进行对比； 三是要关注更细分领域的竞争； 最后也是最重要的一点，需要密切关注企业的库存和开工率。 由于大多数化工行业或多或少都需要进口一些原材料，所以其上游原材料的价格也会对它造成不小的影响，因此也就容易受到国际市场美元和原油等大宗商品价格的影 响。\n四、传媒、电子、计算机及通信 通常所说的TMT（Technology, Media, Telecom）就是这四个行业的统称。\n高成长性 一定周期性 成长性、周期性和易泡沫化这三者凑到一起，就决定了TMT是一个高波动的领域。因此，投资TMT需要紧跟时代潮流，跟踪行业景气趋势，并重点关注能够保持持续创 新劲头的优质公司。这是潜在“十倍股”聚集区，但伴随的是投资风险较大，更适合积极进取、能接受股价较大回撤的激进投资者。\n五、食品饮料和家用电器 食品饮料和家用电器是消费板块的主力，也是必选和可选消费这两大消费分支的代表。必选消费就是对于人们来说刚需的消费品，比如乳业、调味品等，而部分消费品 人们收入达到一定水平后才会产生需求，如高端白酒和智能电视等，被归类为可选消费。\n消费板块牛股频出，和以下几个特征有关\n需求稳定, 以食品饮料为主的必选消费一般价格不太高，无论经济环境如何，人们的需求并不会有太大差异。随着生活水平的提高还会出现消费升级，又进一步延 展到对可选消费的需求。 易形成品牌效应。消费品往往在竞争到寡头局面后就容易形成品牌效应，进而实现规模效应 现金流充裕。大多数消费品都是一手交钱，一手交货，甚至先钱后货。所以读消费行业公司的财报经常会发现应收账款很少，反而预收账款较高。 投资者在研究该行业时应围绕业绩稳定性、现金流充裕度、市占率变化等因素进行分析。\n六、休闲服务、纺织服装和商业贸易 休闲服务就是通常说的餐饮服务、休闲旅游等，它和纺织服装和商业贸易都属于消费行业的一个分支，但在行业特征上有具备了很多服务业的特点。对于这三大行业的 分析，要重点围绕“人、货、场”这零售三要素进行。\n人，即创造业绩的主体。一方面指广大的消费者这一需求方，另一方面也指为需求方提供服务的服务方。对前者要看市占率以及市场扩张模式，后者的优势主要体现 在企业的管理上。 对于企业来说，货品是决定销售业绩最关键的因素。成本更低也好，奇货可居也好，货品优质也好，总之能让自己的“货”在某方面有优势就能构成企业快速发展的强 动力。 场，顾名思义就是场地，即门店卖场。这三个行业的门槛都不算高，同业竞争较大，如若能开辟更多的“场”，并让“场”的效率提升，在业绩增长上就会赢得巨大优势。 七、医疗 随着全民健康意识的觉醒和老龄化时代的渐行渐近，这一行业在国民经济中的地位也愈发重要。\n医疗行业主要包括制药、生物科技及医疗保健三大板块。由于覆盖面广、行业构成相对复杂，针对不同的细分行业，采用的研究方法也不尽相同。如对于高成长、周期 性的创新药要从科技的视角去看；对于定价权强的制药行业要用消费行业的分析逻辑去研究\n该行业还容易受政策影响 八、制造业 制造业是国民经济中占比较大的行业，涵盖电气设备、国防军工、机械设备、轻工制造、汽车等子行业，其发展对国计民生影响深远。从改革开放到21世纪初，中国一 直扮演着全世界制造工厂的角色。但随着东南亚国家在中低端制造业上开始发力，我国劳动密集型制造业的优势逐渐消退，制造业开始面临结构调整实现产业升级的重 要考验。\n所以对制造业的投资，要围绕产业升级、自主知识产权和新“智造”等关键词进行。\n具体可关注芯片、精密机床、航空航天、新能源、新材料和精密制造等方向。另外，传统制造业中研发能力和国际竞争力强的细分行业，如轨交设备、锂电池制造设备、 航空航天设备、工业激光设备等，也具备一定投资价值。\n九、金融业 对银行业的研究，重点在于内生性增长和收入来源。\n所谓内生性增长，是指不依赖于外部股权融资的情况下能够持续经营，并且保持银行对股东的回报持续增长。 收入来源方面，银行主要靠净利息收入和非利息收入。 其中，净利息收入的决定因素是吸收存款的规模和净息差。就增厚净息差而言，一种是提升资产收益率，另一种思路就是控制核心负债的成本。能在这两点上保持 领先的银行，就能在日趋残酷的市场竞争中占得先机。 非利息收入方面，想要增收，除保持必要的零售客户规模外，必须保持和客户的黏性。一般客户黏性越强，使用银行服务的种类就越多，频率就越高。所以一家银 行要想在收入上得到大的提升，就必须在零售业务、小微企业贷款、财富管理等新兴业务上取得优势 对保险行业的研究有两个要点需要关注：一是保险公司特有的研究指标EV（内含价值）。\n证券是一个和市场高度关联的行业，牛市期间，由于市场热情较高，证券公司的盈利也就大幅提高，这也是牛市的开始和结束时券商通常会大涨的原因。前者出于预期， 后者则是由实际业绩增长带来的。\n十、房地产、建筑材料和建筑装饰 在过去，房地产业的金融属性较强，但随着“房住不炒”的理念逐渐深入人心，房地产业开始逐渐回归其“住”的定位。而建筑材料和建筑装饰作为房地产的上下游，行业 发展会在很大程度上受到房地产业的影响。\n周期波动大 现金压力大 对于房地产行业的研究还要看两个“三角形”。\n一个是以周转率、利润率和杠杆为主的进攻三角形。 另一个是包括成本、融资和配套产品的防御三角形。 建筑材料和装饰行业则要重点关注产品质量和品牌口碑。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%8C%E4%B8%9A/%E7%AC%AC%E4%B8%89%E8%8A%82-%E4%B8%BB%E8%A6%81%E8%A1%8C%E4%B8%9A%E5%8F%8A%E5%85%B6%E6%8A%95%E8%B5%84%E8%A6%81%E7%82%B9/","summary":"投资圈使用较多的是申银万国、中信和万得等机构编制的行业分类标准。最常用的申万行业分类分为三级，一级分类有28个行业，二级分类有104个行业，","title":"第三节 主要行业及其投资要点"},{"content":"一、把握宏观环境与行业发展趋势的关系 一看行业与经济环境的相关性，二看行业未来发展趋势。\n在选行业时结合总体经济形势，把握行业政策、发展趋势和发展空间三方面，能帮助我们判断哪些行业更具增长前景，哪些可能遭遇发展瓶颈。\n行业政策对于行业的影响是致命的。积极的行业政策能够助推行业的发展，甚至逆市上涨；偏空的行业政策不仅会阻碍行业的发展，甚至可能给企业带来灭顶之灾。多 了解时政要闻，多读机构行业研报，或亲自登录中央及各地方政府官网了解当前和未来2～3年的行业政策，总归是个好习惯。\n行业空间是行业分析时必不可少的一环，它通常包含两个方面：一个是行业的品牌集中空间，另一个是行业的增量空间。前者相对来说好判断一些，毕竟在品牌集中的 过程中，龙头企业会有较大的竞争优势而且会滚雪球般快速积累，并在这个过程中形成行业壁垒、品牌护城河。而对行业的增量空间的判断则相对复杂，首先要搞懂 “行业的真正产品是什么”。\n二、把握行业结构和产业结构的关系 行业本身的结构主要指的是行业由哪些企业构成，以及各细分行业正处于生命周期的哪一个阶段。\n企业构成指包含的企业都有哪些？每个企业擅长的细分领域是哪个？哪些企业是龙头？龙头的市场占有率又是多少？这些研究能加深投资者对拟介入行业的了解。 对于细分行业的生命周期，主要是了解各细分行业当前正处于行业生命周期的哪一个阶段，是初创期、成长期、消退期、成熟期或是衰退期？了解这一块能让投资者 在选择行业时更容易乘上发展的“东风”。 对于产业结构方面，主要是需要了解行业所处的产业链位置以及行业替代品风险。行业所处产业链位置就是通常说的上游、中游和下游。上游行业通常是原材料供应端， 中游行业则主要是中间环节的制造加工端，至于下游，一般是直接面向市场或者客户的设计端或者销售端。在通常情况下，上游和下游的溢价和议价空间都会比较大， 中游行业则相对弱势。\n三、把握本行业的特有属性 有些行业天生就是好生意。比如白酒\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%8C%E4%B8%9A/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90%E7%9A%84%E6%96%B9%E6%B3%95/","summary":"一、把握宏观环境与行业发展趋势的关系 一看行业与经济环境的相关性，二看行业未来发展趋势。 在选行业时结合总体经济形势，把握行业政策、发展趋势和发","title":"第二节 行业分析的方法"},{"content":"一、行业分析的定义 投资中的行业分析则是对行业的发展历史、现状与格局等进行分析，从而找出行业的特征和结构，来对行业的市场容量、发展趋势等进行预测，进而找出最适宜投资的 行业。\n二、行业分析的意义 寻找具有投资潜力的行业 行业天花板指的是行业的产品（或服务）趋于饱和、达到或接近供大于求的状态。行业的天花板有三种：\n一种是已经达到天花板的行业，如钢铁，这类行业要重点关注市场份额和定价权； 第二是随着产业升级，旧天花板被解构，新天花板尚未或正在形成的行业，如随新能源发展出现变革的汽车制造业，要分析在达成新的行业平衡前行业的扩张速度； 最后是那些天花板尚不明确的行业，这些行业多处在新兴领域，对于该类企业要重点挖掘那些细分行业里具备领军地位的优秀企业。 根据各经济周期下行业分化表现顺势而为 除少数能够穿越经济周期的行业，大多数行业都是随着经济周期的盛衰而涨落。通过研究行业的特点来选择在合适的经济周期介入能更好地把握投资时机。\n在经济复苏初期考虑利润快速增长的家电、汽车等可选消费 在经济衰落时投资利润受经济影响小的食品饮料、调味品等必选消费 纵向分析行业生命周期确定投资策略 行业也有自己的生命周期，按照不同的阶段可分为初创期、成长期、成熟期以及衰退期。\n初创期：这个阶段的行业容量相对较小，消费者对产品缺乏认知，行业内企业的产品和技术发展方向不明晰，研发和市场开拓成本较大，亏损的可能性较大。但由于 整个行业发展水平都很低，竞争不是很激烈，行业进入壁垒也不高。此时要重点关注现金流较稳定，能够活下去的企业。 成长期：行业产品逐渐被消费者认可，市场需求和增长率都较高。随着行业内企业销售规模的增大，行业整体容量在快速扩大。该阶段行业利润率较高，行业内各企 业有竞争但并不强烈。此时要重点关注市场占用率提升迅速的企业。 成熟期：整个行业的需求已经接近或达到饱和，产品和技术已经完全形成，企业间竞争激烈。行业平均利润逐渐走低，开始出现企业淘汰和兼并重组，行业集中度逐 渐走高。此时那些技术壁垒高、市场占有率高的企业更值得关注。 衰退期：行业内产品和技术逐渐开始老化，新产品和新技术开始出现，原有产品的市场份额逐渐萎缩。此时拥有稳定市场份额、具备较强创新技术的行业更值得青睐。 横向对比同行业内各企业找准最优目标 可以横向对比毛利率、营收、增速、估值、市占率等财务指标，分析与同行相比存在哪些优势，还有哪些弱点和不足（指标明显低于行业平均不投，异常优秀的还需考 虑是否存在财务造假），在所处行业中的地位是否稳固等。同行对比，优中选优是买入个股前必做的功课，持有过程中也需要紧密关注行业动态。\n利用板块协同效应迅速响应市场 熟悉各行业板块的另一大作用就是，能充分利用股市中的板块协同效应。当某一行业政策出台或热点事件发生后迅速反应有哪些上市公司会受利好或利空影响，进行短 线逐利或及时避险，同时也可以分析是否存在错杀带来的投资机会。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%8C%E4%B8%9A/%E7%AC%AC%E4%B8%80%E8%8A%82-%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90%E5%AF%B9%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E7%9A%84%E6%84%8F%E4%B9%89/","summary":"一、行业分析的定义 投资中的行业分析则是对行业的发展历史、现状与格局等进行分析，从而找出行业的特征和结构，来对行业的市场容量、发展趋势等进行预","title":"第一节 行业分析对股票投资的意义"},{"content":"一、四大周期理论 基钦周期 整个周期的时间大约是5年，且往往是企业的存货（可简单理解为卖剩的东西）发生变化、起伏所导致的，所以又叫存货周期或库存周期。具体来说，就是在大规模的 机器设备、技术生产线没有办法改变的情况下，企业家依据经济形势的变化，调整存货而导致的经济波动。\n朱格拉周期 又称设备更新周期，周期时长通常为10年。朱格拉周期指向的是生产所用的机器设备的更新换代，因而比存货周期持续时间会更长，对整个经济的影响更大。\n库兹涅茨周期 又称房地产周期，周期时长大概是15～20年。\n康德拉季耶夫周期 又称技术革新周期，周期时长大概是50年左右。比如从最早的蒸汽技术到电力技术，再到互联网技术，从最早的马车到汽车、火车等，这种涉及基础设施领域的重大技 术突破所带来的经济周期波动。\n二、经济周期与股市的关系 股指本身就是经济的先行指标，市场往往会先于经济周期发生变动\n经济处于底部开始复苏前，股市已经开始上涨，经济露出衰退迹象时，股市已经悄悄下跌了一段时间。 经济在走向高峰之前股指已经提前见顶，经济还没有正式出现底部拐点，股市却可能先一步反弹 所以衰退期要以保本为主，此时多持有现金和短期存款等货币类资产形式，避免投资随经济衰退出现亏损，等经济复苏时再进入股市；而到经济繁荣期，当各种不懂投 资盲目跟进的人都开始在股市赚钱时，则考虑逐步收缩战线保护投资收益。\n三、经济周期与行业的关系 经济周期对不同行业的影响：有的行业在经济复苏期就有优异的表现，如能源、设备（机械、电子）等；而有的则是在衰退期发挥出较强的抗跌能力，如公用事业、必 选（日用）消费等。总之，投资者还应该考虑各行业本身的特性，在不同的市况下做出具体选择。\n图3-19　不同经济周期各行业股价表现示意\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E5%85%AB%E8%8A%82-%E7%BB%8F%E6%B5%8E%E5%91%A8%E6%9C%9F%E4%B8%8E%E8%82%A1%E5%B8%82-%E8%A1%8C%E4%B8%9A%E7%9A%84%E5%85%B3%E7%B3%BB/","summary":"一、四大周期理论 基钦周期 整个周期的时间大约是5年，且往往是企业的存货（可简单理解为卖剩的东西）发生变化、起伏所导致的，所以又叫存货周期或库存","title":"第八节 经济周期与股市、行业的关系"},{"content":"一、基础货币与货币乘数 货币政策是货币管理当局为实现其特定的经济目标而采用的各种调节和控制货币供应量的方针、政策和措施的总称。\n基础货币是由央行发行的那部分“原始的钱”，通过商业银行存贷款业务能够实现成倍地扩张或收缩，具备创生其他货币的功能，因而也有“高能货币”之称。基础货币是 货币发行量和商业银行法定存款准备金及超额存款准备金的总和，这在央行每个月公布的资产负债表上都有体现\n币发行完成后会通过各类政策工具投放到市场，过程很复杂，但最终会转化为商业银行的库存现金及企业和居民手中持有的现金，也就是上一节讲过的M0。\n表3-2　2020年8月央行资产负债表\n货币乘数正是通过商业银行体系的信用创造功能最终形成的货币供应总量与最初央行基础货币的比值。\n可以将货币乘数近似地视为法定准备金率的倒数 实际上各商业银行一般不会将杠杆放到最大，而是会根据实际流动性和自身经营规划，在法定存款准备金之外再多留一部分自行保管或缴存央行以备不时之需，即所 谓超额准备金率。 或缴存央行以备不时之需，即所谓超额准备金率。另外，现实中人们在获得资金后，也会基于各种原因留下部分现金。这些钱很可能再也回不到银行体系的信用创造 大循环中，即所谓的“现金损漏”。 二、几个重要的货币政策工具 央行想通过货币政策实现宏观调控目标，无非就是在法定存款准备金率和基础货币这两方面做文章。因此，旨在调控二者的再贴现、存款准备金率和公开市场操作被合 誉为一般性货币政策工具中的“三大法宝”。\n调控基础货币有量和价两个方向，也就是规模和利率。再贴现是央行通过买进商业银行持有的已贴现但尚未到期的商业汇票，向商业银行提供融资支持的行为，其本质 就是央行作为家长一样给各商业银行“发钱”。通过降低或提高再贴现利率，扩大或缩小再贴现额度，便可以达到释放或回笼流动性的目的。\n降低或提高存款准备率是股民更加熟悉的操作\n货币政策的四大目标分别是稳定物价、充分就业、经济增长及国际收支平衡，可从不包括“刺激股市”。请勿简单地将降准等同于必然大涨，从历次降准后的市场表现 看都是有涨有跌，特别是如果此前市场对降准消息已经有高度预期，指数已经累积一定涨幅，一旦利好落地反而得严防冲高后大幅回落。 公开市场操作是Open Market Operation的中文译名，简称OMO。它是由央行直接在金融市场上买卖政府债券、央行票据和外汇，用以吞吐基础货币的一种政策性 工具。2013年以前每年外汇占款规模较大，有多少外汇流入需要投放对应人民币兑换方可流通，当时央行主要用正回购和央票来回笼过剩的流动性。而此后外汇占款逐 步降低，主要矛盾开始转向需要用新的工具补充金融市场间歇性的流动性不足。\n短期流动性调节工具（SLO）、常备借贷便利（SLF）、中期借贷便利（MLF）等。目标定位为缓解流动性不足的它们每次出现都令股民倍感欣慰——只要规模扩大， 利率降低就简单粗暴地认为是股市利好，并亲切地冠以“酸辣圈”“酸辣粉”“麻辣粉”等昵称。 这几个品种本质区别不大，都是由央行以招标的方式，对符合条件的商业银行或政策性银行要求提供国债、央票、政策性金融债等优质债券为质押，满足条件即可获 得定额定价，期限长短不一的流动性支持，期满后还款赎回票据。 三、降息及其与降准的区别 银行从央行处获得资金的价格，包括SLF、MLF、再贷款、再贴现等利率调整，自然会传导到货币市场、债券市场和信贷市场。它们的下调和存贷款基准利率下降一起， 才构成财经媒体口中广义的“降息”。\n贷款市场报价利率（LPR）是在公开市场操作利率（主要就是MLF）基础上加点形成，各家银行再在LPR基础上自主定价 存款利率因和老百姓（尤其是中低收入人群）生活更为密切，为保民生，央行很少对存款基准利率“动刀子” 常见诸报端的“降息”通常是指MLF和LPR利率下降，真正的存贷款利率双降的“全面降息”较为罕见。 降息与降准的区别在于\n降准是释放新的流动性，为市场提供增量资金； 降息则并没有增加市场资金，只是改变资金投向，鼓励人们更多地去消费和投资。 降准是“量”的工具，主要影响金融机构，传导到实体经济和百姓生活尚需时日； 而人们对降息这种“价”的工具更敏感，降息比降准对国计民生的影响更大，央行对此慎之又慎。而正因为谨慎使用，一旦祭出这种“核武器”，市场会视为更强烈的 政策信号，对股市的影响也会比降准更大些。 降息到底是“重大利好”还是“利好落地”，都必须结合当时市场环境和指数所处位置综合判断\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E4%B8%83%E8%8A%82-%E8%B4%A7%E5%B8%81%E6%94%BF%E7%AD%96%E7%9B%B8%E5%85%B3%E6%8C%87%E6%A0%87/","summary":"一、基础货币与货币乘数 货币政策是货币管理当局为实现其特定的经济目标而采用的各种调节和控制货币供应量的方针、政策和措施的总称。 基础货币是由央行","title":"第七节 与货币政策相关的指标与概念（下）"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/eastmoney/","summary":"主页","title":"东方财富 数据中心"},{"content":"生成数字序列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 生成1～5的数字序列 $ seq 1 5 1 2 3 4 5 # 指定使用空格为分隔符 $ seq -s\u0026#39; \u0026#39; 1 5 1 2 3 4 5 # 指定步长为2，输出偶数 $ seq 2 2 10 2 4 6 8 10 # 不指定起始位置时，则默认起始位置为1 $ seq -s\u0026#39; \u0026#39; 8 1 2 3 4 5 6 7 8 # 支持调用变量 $ i=5 $ j=10 $ seq -s\u0026#39; \u0026#39; $i $j 5 6 7 8 9 10 ","permalink":"https://jdxj.github.io/posts/cmd/seq/","summary":"生成数字序列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 生成1～5的数字序列 $ seq 1 5 1 2 3 4 5 # 指定使用空格为分隔符 $ seq -s\u0026#39; \u0026#39; 1 5 1 2","title":"seq"},{"content":"“通货”一词的本义正是“流通中的货币”\n一、货币分层与M0/M1/M2 作为金融学名词，流动性是指某一资产或金融工具在不影响到其价格的情况下，在市场上快速成交转变为现金的能力。如股票交易方便容易出手而流动性好，而房子、 汽车和古董等不好变现故流动性较差。\n具体到货币上，流动性则特指其作为流通手段和支付手段的便利程度：流动性越高，在流通和交易中越容易被人接受，因此购买力也更强；流动性越差，周转不方便， 购买力也就更弱。\n以流动性作为统计口径，将货币分为M0、M1和M2等多个层次（M是英文money的首字母大写）。\n图3-13　我国货币分层体系\nM0是央行印发的，肉眼可见、可以直接拿来花的“钞票”，故而流动性最强，也和普通人生活消费最相关。 M1即所谓狭义货币，是在M0的基础上，再加上各企事业单位在银行的活期存款和居民个人手中的信用卡余额。这部分钱都是企业和个人随时准备好要用的，故而流 动性较高，可以体现当前的实际购买力。 广义货币M2涵盖内容更多，除M1之外，还要加上企事业单位定期存款、居民定活期存款、信托类存款、券商客户保证金和其他存款等。这部分钱流动性较差，只能 代表未来的潜在购买力，因此也被称为“准货币”。 二、M1和M2之间的关系及影响 多数年份两者都呈现同涨同跌的正相关关系，但在某些特殊的时期，也会出现“剪刀差”的情况\n图3-14　2001—2020年M1、M2同比增速\nM1增速高于M2，表征消费、生产领域需求和物价增高，持续6个月以上可判定为通胀的信号。一般M1增速快一点是好事，但如果剪刀差过大或持续时间过长，短期内资 金都往股市和房市涌入的话，也会推升资产泡沫而引来调控或打压。\nM1增速低于M2（即所谓“负剪刀差”）的时间过长，表明市场对经济悲观，实体经济中投资机会减少，人们更愿意把钱存起来而不是花出去，地产企业房产销售资金回 笼后也不再投入新的开发项目，或资金存留在金融系统内空转，管理层其实更担忧这种通缩的风险。\n三、社会融资规模 社会融资规模（简称“社融”）。它是指一定时期内（每月、每季或每年）实体经济从金融体系获得的资金总额，由金融机构表内业务（人民币和外币各项贷款）、金融 机构表外业务、直接融资（非金融企业境内股票筹资和企业债券融资）和其他项目四大类构成。\n图3-16 2020年存量社融各分项结构占比\n图3-17　社融与M2关系示意图\n社融是GDP、CPI和进出口等重要经济数据的先行指标（先行1～3个季度），且相关系数甚至比M2更高。它反映的是金融系统对实体经济的支持程度，而M2反映的是金 融系统向社会提供的流动性，体现全社会的购买力水平。\n四、实战举例 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E5%85%AD%E8%8A%82-%E8%B4%A7%E5%B8%81%E6%94%BF%E7%AD%96%E7%9B%B8%E5%85%B3%E6%8C%87%E6%A0%87/","summary":"“通货”一词的本义正是“流通中的货币” 一、货币分层与M0/M1/M2 作为金融学名词，流动性是指某一资产或金融工具在不影响到其价格的情况下，在","title":"第六节 与货币政策相关的指标与概念（上）"},{"content":"一、CPI和PPI的概念 CPI全称Consumer Price Index，中文译为消费者价格指数，是用以反映与居民生活有关的消费品及服务价格水平变动情况的经济指标。它不光与普通消费者的生 活息息相关，更是管理层经济决策的重要参考。其高低走向会影响国家宏观调控措施的出台与力度（如是否调息、是否调整存款准备金率等），因而也会波及各资本市 场。一般可以将CPI大于3%视为即将通货膨胀的信号，连续多月在3%以上居高不下可以判断通胀已经发生，如果发生CPI持续在5%之上的情况，可以视为严重的通货膨 胀。\n图3-9 1980—2020年中国CPI统计\nPPI，全称Producer Price Index，中文是生产者价格指数。它是从生产者角度观察的物价指数，用以测量制造业厂商在初级市场（非零售市场）上首次购进或卖 出某种货物价格的变动情况，因此又可以分为生产者购进价格指数和生产者出厂价格指数。两者分别代表了投入和产出，差值刚好可以反映工业生产的利润水平。 财经新闻和研报点评中常见的一般是狭义PPI，即生产者出厂价格指数。\n二、CPI和PPI的统计方法 CPI和PPI用百分数表示，均由国家统计局和地方统计部门负责统计，近年来月度数据基本在次月9日前后公布。\nCPI的统计方法\n第一步是确定纳入CPI核算的商品和服务项目。 第二步需要根据居民消费支出的比重，为8大类及262个子类分别赋予不同权重。 图3-10 CPI统计构成\n第三步是抽选约500个市县，确定采集价格的调查点，包括食杂店、百货店、超市、便利店、专业市场、购物中心、农贸市场等共6.3万个。按照“定人、定点、 定时”的方式，派近4000名调查员到各个调查点现场采集价格。价格采集频率因商品而异 最后，根据审核后的原始价格资料，按消费水平不同给各地区定权重，逐级统计汇总出各省市和全国的CPI。 PPI的统计编制原理和CPI类似，但因统计对象是制造厂商购买或生产的产品价格，可以不用派调查员四处出击，只要抽选有代表性的工业企业要求定期填报即可\n图3-11 工业生产者出厂价格调查问卷样式\n和CPI上下波动很大程度由猪肉蔬果决定类似，PPI主要受“三黑一色”，即石油、煤炭、钢铁和有色等生产资料价格的影响，此外，化工化纤行业亦有所贡献。\n三、CPI和PPI之间的关系 理论上同时期CPI和PPI应该呈涨跌方向一致的趋势，学界一般也将PPI视为CPI的先行指标。\n但在现实经济运行中，由于国际环境（如金融危机、国际原油暴涨暴跌等），各行业供需关系和国内宏观调控等方面的变化，CPI和PPI原本和谐共进退的关系也会走 向背离。\n四、CPI和PPI对股市的影响 PPI中细项又和A股部分板块关联度较高。如有色、钢铁、煤炭、水泥和玻璃等价格指数的暴涨暴跌，容易激发相关产业链中周期股的跟随性涨跌。当然，CPI中重要分 项猪肉价格的走势和A股中的“猪股”（生猪养殖、屠宰、饲料和动物疫苗等）也有“共进退”的现象。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E4%BA%94%E8%8A%82-cpi-ppi/","summary":"一、CPI和PPI的概念 CPI全称Consumer Price Index，中文译为消费者价格指数，是用以反映与居民生活有关的消费品及服务价格水平变动情","title":"第五节 最重要的通货膨胀观察指标——CPI和PPI"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/pmiii/","summary":"主页","title":"中采咨询"},{"content":"一、PMI的概念 Purchasing Manager\u0026rsquo;s Index，中文译为采购经理指数, 通过对企业采购经理的月度调查结果统计编制而成的综合指数。它涵盖制造业和非制造企业的采购、 生产和流通各环节，是国际通用的监测宏观经济走向的先行指标，具有较强的预测和预警作用。\n指标体系已包括新订单、积压订单、新出口订单、产量、雇员、供应商配送、库存和价格等多项商业活动指标。除制造业和服务业PMI外，有的国家还建立起了建筑 业甚至更多行业的PMI数据体系。 各国一般以50为荣枯分界线：PMI高于50意味着经济在扩张，数值越高扩张速度越快；低于50则意味着经济开始收缩，数值越低收缩得越厉害。 图3-6 2005—2020年美国PMI走势\n二、PMI的统计方法 PMI由5个分项指数加权计算而成，分别是\n反映需求端强弱情况的新订单指数，权重为30%； 反映生产端强弱情况的生产指数，权重为25%； 反映就业状况和企业招工意愿的从业人员指数，权重为20%； 反映交货时间快慢的供应商配送时间指数，权重为15%，需要指出的是，这一分项是一个逆指数，也就是数值越大交货时间越慢，表明经济越不活跃，因此在综合成 PMI指数时需要进行反向处理； 此外还有权重为10%的原材料库存指数，它反映库存状况和企业信心，企业补充原材料库存趋于增加，说明企业要加快生产，这个指标越大，表明未来经济保持平稳 增长的概率越大。 在每个月的22—25日，统计方以问卷调查的形式询问样本企业的采购经理或者主管企业运行的负责人对本企业的生产、订单、库存、雇员、配送时间等情况的看法\n图3-7 制造业采购经理调查问卷样式\n选项一般只有三个：比上月增加、持平和减少。然后对作出每一种回答的企业个数的占比赋予不同的权重（100%、50%、0），计算得出分项的指数，再按各分项权重 进行加总得到总体的PMI指数。\n假设有300家制造业企业参与调查，其中100家认为本月的生产比上个月上升（占比1/3），150家企业认为本月的生产与上个月持平（占比1/2），50家企业认为本月 的生产比上个月是下降的（占比1/6）。根据上述三项的权重，所得数据如下：\n本月生产指数=33.3×100%+50×50%+16.7×0=58.3 以此类推计算出其他四项分项指数之后，再按公式（PMI指数=新订单指数×30%+生产指数×25%+从业人员指数×20%+供应商配送时间指数×15%+原材料库存指数×10%） 加总计算即可。\n由上述可以得出两个结论：\n一是PMI是一个典型的“月对月”环比指标； 二是由于统计时间是每个月的22—25日，所以当月公布的PMI实际反映的是上月26日到当月25日样本企业的生产经营情况，并非完全是当月的经济情况。 PMI也会存在前文提及的“季节性调整”的问题。\n三、官方PMI与财新PMI 我国主流的PMI指数有两个。\n官方PMI由国家统计局和中国物流与采购联合会联合发布（也称“中采PMI”）。 财新PMI也称“民间PMI”，由英国研究公司Markit集团编制，目前由财新传媒冠名发布 两者的区别主要有以下几点。\n第一，发布时间不同。官方是统计当月最后一天发布，财新是次月第一天。 第二，统计口径不同。官方PMI统计口径更广泛多元，样本企业包括分布全国各地的超3000家大、中、小型企业；财新PMI以东部地区中小企业为采集对象，数量也 就400余家。官方PMI一般趋势性更强，反映大型经济主体景气状况，财新PMI波动性更大，反映中小企业生产经营情况为主。由此，某些时点两者会发生所谓数据 背离（即变化不一致的情况），但这反而能更全面地展示经济图景，辅助管理层和各类投资者做出更具针对性的决策。 第三，具体指标有所差异。官方公布的是制造业和非制造业PMI，财新PMI包括制造业和服务业两大分项。由于产业层级和GDP占比权重等原因，非制造业或服务业 PMI和股市相关性偏低，一般重点关注制造业PMI即可。 四、PMI与股市的关系 图3-8 2005—2020年PMI和上证综指走势\n单纯读取PMI数据并不能预判后市涨跌\nPMI统计只是基于受访者的主管定性判断，并不基于完整严谨的定量分析。先导性决定了它会提前3～6个月反映经济走势，会和同样为领先指标的股指存在时差。且 务必记住PMI是一个环比指标，如上一统计期基数低，会造成隔月数据反升较快的情况。 PMI冲得太快或高位滞涨时会引来管理层为经济降温，严重垮塌时会有量化宽松、降准降息等货币政策或减税降费等财政政策积极护盘 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E5%9B%9B%E8%8A%82-pmi/","summary":"一、PMI的概念 Purchasing Manager\u0026rsquo;s Index，中文译为采购经理指数, 通过对企业采购经理的月度调查结果统计编制而成的综合指数。它涵盖制造业和非制造企业的采购","title":"第四节 最受市场关注的先行指标——PMI"},{"content":"一、GDP的概念 GDP(Gross Domestic Product)国内生产总值, 指一个国家或地区所有常住单位在一定时期内（一般考察一个季度或一年）生产经营活动产出的全部产品和劳 务成果 GNP(Gross National Product)国民生产总值 一个在中国常驻的美国企业，所生产的产品计入中国而不是美国的GDP，只能计入美国的GNP。\n二、GDP的统计方法 GDP有价值、产品和收入三种表现形态，分别对应三种统计方法，即生产法、支出法和收入法，它们从不同视角衡量经济总量及构成，拥有各自的指标体系\n表3-1　我国GDP主要统计方法\n支出法的基本逻辑是，既然任何一种国民产出最终都会以某种方式被购买，那只要把花费在最终产品或劳务上的所有支出相加，总额就应该等于国民产出的总价值。其 下有一个著名的宏观经济学恒等式——GDP=C+I+G+（EX-IM）。\nC是家庭消费，G是政府采购商品和劳务的支出，两者和而构成“最终消费”； I是各类企业为维持经营所进行的生产性资产的投资； EX-IM即出口额减进口额所得出的净出口总值 三驾马车\n消费 投资 净出口 理论上，无论用何种方法统计，最终结果应该都能吻合。但在实践中由于各种方法的资料来源不同，数据加工换算方式不同等原因，三种结果会出现一定差异。西方国 家一般以支出法的结果为准，我国由于全面核算的基础相对较弱，部门的产值核算基础较好，以生产法统计为主。\n三、GDP增速高不一定意味着股市牛 GDP还有“名义GDP”和“实际GDP”之分。名义GDP很好理解，是用生产物品和劳务的当年价格计算的全部最终产品的市场价值，而实际GDP用从前某一年作为基准年 （这个年份经常变动，如2018年实际GDP统计以2010年为基准年，2019年则转而以2015年为基准年）的价格计算出当年全部最终产品的市场价值。\n二者通常不等，名义GDP增长率等于实际国内生产总值增长率与通货膨胀率之和，由通货膨胀引发的价格变动，即使产量一直没有变动，名义GDP仍然会上升。统计局 先根据统计数字得出名义GDP，然后再综合CPI、PPI、出口价格指数和进口价格指数等数据计算GDP平减指数，最后由名义GDP和平减指数得出实际增长率。GDP之外 的其他数据也存在类似问题，人们应关心的是剔除过物价上涨因素后的实际增长率，因为这才能更真实地反映经济增长情况。\n即便经济真的增长质量很高，股市就能蒸蒸日上吗？不好意思，答案还是不一定。\n解读数据务必综合存量（基数）、增量和增速考虑，很多GDP增速快的国家可能只是基数低，且增长质量不一定上佳。而对同一国而言，由于股市本身是领先指标， GDP反而是同步指标甚至有点滞后，经济增长同样不一定和股市呈正相关关系。\n四、GDP总量健康发展才是股市成长的关键 图3-4　中国GDP增速与A股走势\n图3-5　中国GDP与A股走势\nGDP应当用于看大势，其总量和增长质量好坏是决定“做或者不做”的关键，尽管增速可能非常缓慢，但国际资本更热衷于在GDP总量稳健向上的发达国家投资，而不会 在GDP动辄上天入地的新兴国家资本市场下重注。\n随着我国经济的发展和管理层对资本市场投融资功能的愈加重视，A股总市值占GDP比值不断提高，指数增长与GDP增速也有望往正相关回归，A股未来依然大有可为。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E4%B8%89%E8%8A%82-gdp/","summary":"一、GDP的概念 GDP(Gross Domestic Product)国内生产总值, 指一个国家或地区所有常住单位在一定时期内（一般考察一个季度或一年）生产经营活动产出的全部产","title":"第三节 最核心的宏观经济指标——GDP"},{"content":"注意事项\n解读数据要同时关注存量（基数）、增量和增速。以GDP为例，2007年后我国整体经济增速明显放缓，这是由于改革开放后经济高速发展，GDP基数不断提升，但不 能由此武断得出经济不景气的结论。 不能看数字直接下结论，要注意“同比”和“环比”的问题。同比的意思是本期数据与历史同时期比较，一般是与上一年度同一月份或同一季度比较，环比则是本期与 相邻最近的一段时期的数据对比，如本月比上月，本季度与上一季度对比。看到异常好或者特别差的数据时，要注意是否由去年同期数据或上月、上季度数据基数异 常造成。 季调数据. 自然气候、生产生活消费习惯、节假日等因素，两个相邻季度在季节上容易存在较大差距，若直接比对会放大季节性因素造成的短期波动。因此世界 各国在统计季度环比指标时，会采用各种季节性调整方法优化数据。 春节 各数据之间有千丝万缕的相互影响关系，还要学会整体、辩证甚至是逆向去解读宏观数据对股市的影响。 宏观数据还有先行指标、同步指标和滞后指标之分 先行指标又称领先指标或超前指标，是指在总体经济活动达到高峰或低谷之前，先行出现高峰或低谷的指标。常用的先行指标有采购经理指数（Purchasing Managers\u0026rsquo;Index, PMI）、货币供应量、十年期国债收益率等，它们往往能在总体经济发生变化前半年达到顶峰或低谷，是经济景气分析的有力工具。 同步指标又称一致指标，是指达到高峰或低谷的时间与总体经济出现高峰或低谷的时间大致相同的指标。同步指标可描述总体经济的运行轨迹，确定总体经济运行 的高峰或低谷位置。 滞后指标又称落后指标，是指其高峰或低谷出现的时间晚于总体经济出现高峰或低谷的时间的指标。它有助于分析前一经济循环是否已结束，下一循环将会如何变 化。 各类指标均有用途和优缺点，全面分析和预判经济形势走向需要密切跟踪各类数据的波动和勾稽关系，而一般投资者只需对此有所了解即可。但请注意股票操作要避免 受滞后指标干扰，因为股市指数本身也是一个先行指标，会提前6～9个月反映实体经济的变化\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%A7%A3%E8%AF%BB%E5%AE%8F%E8%A7%82%E6%8C%87%E6%A0%87/","summary":"注意事项 解读数据要同时关注存量（基数）、增量和增速。以GDP为例，2007年后我国整体经济增速明显放缓，这是由于改革开放后经济高速发展，GD","title":"第二节 如何正确解读宏观指标"},{"content":"图3-1　宏观经济研究的范围和对象\n一、对宏观分析的傲慢与偏见 连高善文自己也曾戏谑式地创作过一副对联，上联是“解释过去头头是道，似乎有理”，下联是“预测未来躲躲闪闪，误差惊人”，横批：经济分析。\n，对任何人、事和物过度的拔高和诋毁可能都是有失偏颇的。经济发展的宏观整体由无数个微观切面共同组成，同时各行各业的微观经济活动又需要在良好的宏观经济 状况保障下才能得以稳定运行。个体和社会的关系如鱼和水，良性互动方能水清鱼活。\n二、宏观分析的真正价值 研判政经大势有助于决定能否买股票 一旦把时间轴拉长，我们会发现股市长期表现与经济大势基本趋同，股指能在长期经济增长线上获得支撑。\n图3-2　1973—2019年纽交所指数与美国GDP走势\n明白经济周期有助于决定配置多少股票，以及买哪一大类股票 在确定某一国的股票市场值得参与后，还可以通过经济周期判断，在繁荣、滞胀、衰退和复苏等各个阶段，决定在各大类资产中配置多少比例的股票。\n读懂政策和重大事件能避免“听风就是雨” 宏观经济学浩如烟海，让普通投资者搞宏观研究并不现实，亦无必要。但了解基本的宏观常识对看明白财经新闻和读懂券商研报大有助益\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E/%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%88%86%E6%9E%90%E5%AF%B9%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E7%9A%84%E6%84%8F%E4%B9%89/","summary":"图3-1 宏观经济研究的范围和对象 一、对宏观分析的傲慢与偏见 连高善文自己也曾戏谑式地创作过一副对联，上联是“解释过去头头是道，似乎有理”，下联","title":"第一节 宏观经济分析对股票投资的意义"},{"content":" 上证综指 深证成指 创业板指 上证50指数 沪深300指数 中证500指数 中证1000指数 道琼斯工业指数 标准普尔指数 纳斯达克指数 恒生指数 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AD%E8%8A%82-%E9%87%8D%E8%A6%81%E8%82%A1%E5%B8%82%E6%8C%87%E6%95%B0%E4%BB%8B%E7%BB%8D/","summary":"上证综指 深证成指 创业板指 上证50指数 沪深300指数 中证500指数 中证1000指数 道琼斯工业指数 标准普尔指数 纳斯达克指数 恒生指数","title":"第六节 重要股市指数介绍"},{"content":"维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。\n如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。 如果此数据没有在缓存链表中，又可以分为两种情况： 如果此时缓存未满，则将此结点直接插入到链表的头部； 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。 ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0lru/","summary":"维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。 如果此数据之前已经被缓存在","title":"链表实现LRU"},{"content":"单向链表 插入, 删除操作时间复杂度为O(1)\n链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。\n循环链表 双向链表 双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。\n双向循环链表 链表 VS 数组性能大比拼 数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。\n数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足 （out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。\n链表本身没有大小的限制，天然地支持动态扩容\n如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。 而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片\n","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%93%BE%E8%A1%A8/","summary":"单向链表 插入, 删除操作时间复杂度为O(1) 链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。 循环链表 双向链表 双向链表可以支持 O(1) 时间复杂度的情","title":"链表"},{"content":"7.1 压缩列表的构成 图7-1 压缩列表的各个组成部分\n表7-1 压缩列表各个组成部分的详细说明\n图7-2 包含三个节点的压缩列表\n7.2 压缩列表节点的构成 个压缩列表节点可以保存一个字节数组或者一个整数值\n字节数组可以是以下三种长度的其中一种：\n长度小于等于63（2^6–1）字节的字节数组； 长度小于等于16383（2^14–1）字节的字节数组； 长度小于等于4294967295（2^32–1）字节的字节数组； 整数值则可以是以下六种长度的其中一种：\n4位长，介于0至12之间的无符号整数； 1字节长的有符号整数； 3字节长的有符号整数； int16_t类型整数； int32_t类型整数； int64_t类型整数。 图7-4 压缩列表节点的各个组成部分\n7.2.1 previous_entry_length previous_entry_length属性的长度可以是1字节或者5字节：\n如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。 如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值254），而之后的 四个字节则用于保存前一节点的长度。 图7-5 当前节点的前一节点的长度为5字节\n图7-6 当前节点的前一节点的长度为10086字节\n图7-7 通过指针运算计算出前一个节点的地址\n7.2.2 encoding 节点的encoding属性记录了节点的content属性所保存数据的类型以及长度：\n一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两 位之后的其他位记录； 一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录； 表格中的下划线“_”表示留空，而b、x等变量则代表实际的二进制数据，为了方便阅读，多个字节之间用空格隔开。\n表7-2 字节数组编码\n表7-3 整数编码\n7.2.3 content 图7-9 保存着节数组\u0026quot;hello world\u0026quot;的节点\n图7-10 保存着整数值10086的节点\n7.3 连锁更新 图7-13 连锁更新过程\n因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)。\n尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：\n首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见； 其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的； 因为以上原因，ziplistPush等命令的平均复杂度仅为O(N)\n7.4 压缩列表API 表7-4 压缩列表API\n7.5 重点回顾 压缩列表是一种为节约内存而开发的顺序型数据结构。 压缩列表被用作列表键和哈希键的底层实现之一。 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。 ","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC7%E7%AB%A0-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/","summary":"7.1 压缩列表的构成 图7-1 压缩列表的各个组成部分 表7-1 压缩列表各个组成部分的详细说明 图7-2 包含三个节点的压缩列表 7.2 压缩列表节点的构成 个压缩","title":"第7章 压缩列表"},{"content":"linux环境变量, 保存0~32767之间的随机整数\n1 2 3 $ echo $RANDOM $ echo $[RANDOM%10+1] 9 ","permalink":"https://jdxj.github.io/posts/cmd/random/","summary":"linux环境变量, 保存0~32767之间的随机整数 1 2 3 $ echo $RANDOM $ echo $[RANDOM%10+1] 9","title":"RANDOM"},{"content":" 面向对象与面向过程不是对立的\nOOP 更加能够应对大规模复杂程序的开发\n面向过程是线性的思维方式, 思考大规模程序的网状结构会吃力 面向对象先建模为类, 再按照流程将类组织起来 OOP 风格的代码更易复用、易扩展、易维护\n封装, 易维护 抽象, 易扩展 函数本身是一种抽象, 面向对象和面向过程都支持 面向对象支持基于接口的抽象 继承, 易复用 多态, 易扩展, 易复用 OOP 语言更加人性化、更加高级、更加智能\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9B%B8%E6%AF%94%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF/","summary":"面向对象与面向过程不是对立的 OOP 更加能够应对大规模复杂程序的开发 面向过程是线性的思维方式, 思考大规模程序的网状结构会吃力 面向对象先建模为类, 再","title":"面向对象编程相比面向过程编程有哪些优势"},{"content":"面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分 离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B/","summary":"面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方","title":"什么是面向过程编程"},{"content":"面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","summary":"面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。","title":"什么是面向对象编程"},{"content":"一、有关参与者的行话 多头（多方）：对股市未来行情乐观，预计股价还会继续节节攀升的人。 空头（空方）：对股市前景悲观，预计股价会下跌的人。 大户：资金实力雄厚、投资金额巨大、大批量买卖股票，甚至能够影响某只个股涨跌的投资者。 庄家：庄家必然是大户，但大户不一定是庄家。庄家是通过刻意买入大量股票，在一段时间内操纵股价涨跌，以达到某种特定目的的资金大户。 散户：这是与大户、庄家对应的概念, 但散户和“韭菜”不能画等号，在“七亏二平一赚”的A股中，还是有小部分散户能够脱颖而出，有的甚至能成长为“牛散”。 韭菜: 在金融圈，“韭菜”特指长期被各类“砖家”忽悠，不经过学习和思考就无脑买入股票、基金和理财等金融产品，次次赔钱甚至赔本，但偏偏屡教不改、不长记 性的人。 夹头：这是对价值投资者简称的谐音调侃。切忌在长期投资和短线投机之间摇摆不定，骑墙派会被市场教训得体无完肤，那才是真的“夹头”。 白衣骑士：当成为他人的并购目标后（一般为恶意收购），上市公司的控股方或管理层会寻找友好人士或其他企业的帮助，达到驱逐恶意收购者的目的。这提供资金 或其他资源，帮忙解救危难的第三方，便是财经报道中经常出现的“白衣骑士”。 二、有关市场的行话 牛市：也称多头市场，当多头占绝对优势时，牛市行情波澜壮阔，个股交易活跃，股价和指数屡创新高。2006年11月—2007年10月，上证指数从1833点一路高歌 猛进到6124点。2014年9月—2015年6月，上证指数从2401点启动，一直飙涨到5178点见顶。 熊市：也称空头市场，当多头散去，转由空头主导局面时，行情会变得萎靡不振，股价和指数开始一路下跌。熊市中管理层出台利好政策，甚至直接出手救市时，也 无人敢于出手做多。2007年11月—2008年10月，上证指数从6005点飞流直下到1664点。2015年6月开始的股灾，从5178点一路跌到2016年2月的2638点方才见 底反弹。 猴市和羊市：典型的牛市和熊市之间，更多时候是涨跌互相交织的震荡市。当震荡幅度较大，指数和股价动辄上蹿下跳时，被人们称为“猴市”；而指数窄幅波动， 股价温和整理的市场，则被称为“羊市”。 结构性牛市：猴市和羊市中，也会存在某些特定行业、板块走得比其他行业板块明显更强的情况，或某一风格主导市场. 结构性牛市也可以和“结构性熊市”同在。 技术性牛市：在各国央行大手笔货币宽松和财政放水后，多个市场都进入了“技术性牛市”。但严格意义上这并不是真牛市，站在技术分析的角度，从大盘指数最低点 算起涨幅超过20%时，才可以称之为技术性牛市。也有人将大盘稳定站上60日均线并且拐头向上定性为技术性牛市，还有更稳健的则将大盘站上120日均线定性为技 术性牛市。 回档和反弹：在指数上升至一定阶段和一段较长时间后，有可能面临短期下跌。也许是为了回避“跌”字，人们美其名曰“回档”；反之，跌跌不休的熊市也可能会迎 来一段回暖行情，江湖人称“反弹”。千金难买牛回头，牛市中的回档是不可错过的上车机会；而熊市中的反弹只是回光返照，重仓套牢者能抓住这难得的机会逃离也 算是一桩幸事。 反转: 反转由回档和反弹发展而来，当回档和反弹达到一定强度，甚至足以扭转当前趋势时，可以称之为“反转”。反转分为向上反转和向下反转，前者是熊市向牛市 的转换，后者则意味着牛市开始转熊。 盘整：在多数时候，指数会在某一段区间内上下波动，并无明显趋势性行情，这被称为盘整（或曰“横盘”）。盘整期间，投资者应静观其变，短线操作意义有限。 突破：突破也就是盘面开始发生变化，当指数上涨涨破前高，或下跌跌破前低时，即是盘整行情发生变化的信号（变盘）。前者为向上突破，后者为向下突破。突破 信号此后的技术图形如果确认有效，即是反转时刻的到来。 三、交易术语 吸货和出货：“货”即股票，吸货和出货就是买入和卖出股票的意思。 和“仓”有关的术语：货物储存的地方，就是仓库。交易账户中储存股票的地方，被人们形象地称为“仓”。 开始有计划地买入股票的过程是“建仓” 建仓后持有股票的状态，被称作“持仓” 持仓三成以内是“轻仓”，五成时是“半仓”，超过七成是“重仓” 现金全部买入，仓库里堆满股票后，就是传说中的“满仓” 有计划地抛售股票的过程，叫“减仓” 因某种原因被迫把账户内的股票全部卖出，叫“平仓” 主动把剩余全部股票一次性卖出的行为叫“清仓” 如果是赔本卖出的，也可以称为“斩仓” 整体仓位不变，但调换股票的行为，被称为“调仓” 出现浮亏，为降低持仓成本再次买入股票的行为叫“补仓” 本有浮盈，因看好某只股票选择再次买入的行为叫“加仓” 踏空：投资者本来持仓成本不高，但因为看空某只股票的后市表现选择卖出，结果此后股价一路上扬，只能眼巴巴看着别人赚钱，自己却守着一堆现金吃活期利息， 被江湖侠客们戏称为“踏空”。 套牢：意思刚好和踏空相反，指投资者看好某只股票的后市表现选择买入，结果此后股价一路下跌，又不舍得及时认亏卖出股票（俗称“割肉”，好听点叫“止损”）， 最后深度亏损的状态。 解套：深度亏损的股票股价回升，从而使套牢者可以以不赔本的价格卖出股票。 做T：是指通过先低买再高卖或先高卖再低买的交易手法，以达到赚取买卖价差、降低持仓成本等目的，过去老股民也俗称“抢帽子”。根据做T的顺序不同，可以分 为“正T”和“倒T”（也称“负T”）。上涨趋势中的个股可以在分时低点先买入，然后在后面的分时高点卖出，这是做正T；反之，下降趋势中的个股可以在分时高点先 卖出，待股价下跌后再在分时低点接回，是为倒T。当然能否真正达到降低成本的效果，依赖于准确判断分时高低点 对倒：游资、庄家开立多个账户自买自卖，让股票成交量和换手率升高，显得股性活跃，以达到吸引散户注意入场参与买卖股票的行为。 坐轿子和抬轿子：庄家通常会选择在某些小众低位股，将其股价抬升至高位后卖出盈利。普通投资者通过某些内幕信息，或技术图形预判股价会涨，在拉升之前提前 买入股票，这样的行为就是“坐轿子”。股价拉高后，庄家为了更好地出货，会通过刻意构造走势较好的技术图形，或在出货前散布利好消息，吸引投资者跟风买入。 如果投资者不幸中招，很可能面临亏损，沦为“抬轿子”的轿夫。 戴帽子和摘帽子：因财务或其他状况出现异常（如连续两年亏损）的上市公司股票交易，会被交易所进行特别处理（Special Treatment），具体的措施包括股 价涨跌幅限制为5%，股票名称前加“ST”，以及上市公司的中期报告必须经过审计等。被冠以ST“荣誉称号”的动作，就叫“戴帽子”。如果业绩持续无法改善，ST股 还会被再戴一个“*型帽子”（所以也叫“戴星”），*ST股风险更大，投资者务必谨慎参与，新手应该回避这类绩差股的炒作。 考察期内业绩改善，经营状况回归正常后，ST股和*ST股也有去除股票名前加冠的字母符号的机会，这个动作被称为“摘帽子”或“摘星”。一旦提前有摘帽子的消 息发布，股价很可能迎来一波上涨行情。 打板和翘板：在我国，除新股上市当天外，普通单日交易都有10%或20%的涨跌幅限制。所谓“打板”，是指股价异动，快速拉升至接近涨停时突击买入的交易行为。 专门从事类似短线交易的股民，也称为“打板族”。当股票跌停后抄底买入，豪赌股价当日回升的行为，则为“翘板”。围绕打板和翘板，也衍生出众多操作技法和专 有名词，如“天地板”，即指股价从涨停直接打到跌停；反之则为“地天板”。 在头一天股票涨停封板后，第二天继续涨停，就是打板族常说的“1进2”，如果第二天继续涨停，即是“2进3”。这种连续涨停板的赚钱效应很强，但盲目追高打板 也可能在高位接盘，遭遇各种“割韭菜大法”清洗。近几年流行的新名词“核按钮”，即是指在盘前盘中以跌停价格挂卖单，保证持股者以最快速度抛出筹码以换取 现金。 四、盘口术语 “盘口”是在股市交易过程中，观察大盘或个股交易动向的统称。在长期的股市实践中，习惯看图（分时图、日周月线图等）说话的技术分析派发明了大量的概念和指标， 共享着一整套分析盘面信息的概念和术语。\n洗盘：为减轻后续拉升股价顺利出货的压力，主力或庄家有时会通过“洗盘”有意制造恐慌，迫使低价买入却又意志不坚定的散户卖出股票。洗盘之后往往还会有拉升， 但究竟是洗盘还是真跌出货，就要看投资者自己的判断了。 崩盘：由于政治经济因素（次贷危机）或突发某种利空（战争、疫情），导致市场指数和绝大多数股票无限度暴跌，包括机构、主力和散户在内的所有参与者都在恐 慌情绪下集体抛售股票. 华尔街对崩盘有一个量化标准，通常被定义为单日或数日累计跌幅超过20%。 护盘：与崩盘对应的概念为“护盘”，股指持续下跌，人心惶惶之时，管理层甚至会动用国家力量直接参与救市。而个股股价大崩时，产业资本或机构、主力也会开始 发力护盘，即购入股票维持股价不再下跌，以防止造成更严重的连锁反应。 高开：指数或个股开盘价超过上一交易日收盘价，但未超过最高价的现象。如果买入力道过强，甚至超过前一日最高价，则为“跳空高开”。 低开: 指数或个股开盘价低于上一交易日收盘价，但未低于最低价的现象。如果卖出力道过强，甚至低于前一日最低价，则为“跳空低开”。 缺口：跳空高开或低开会在K线图中留下痕迹，即相邻两根K线之间的一段空白。通常情况下，如果缺口不被迅速回补，表明行情有延续的可能，如果缺口被回补， 表明行情有反转的可能。 平开：指数或个股开盘价与前一交易日收盘价持平 盘档: 指当天股价变动幅度很小，最高价与最低价之间差价不超过2%。对市场指数而言，行情进入盘整期后，指数上下波动幅度不大的情况 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%88%9D%E5%85%A5%E6%B1%9F%E6%B9%96%E9%9C%80%E4%BA%86%E8%A7%A3%E7%9A%84%E8%82%A1%E5%B8%82%E8%A1%8C%E8%AF%9D/","summary":"一、有关参与者的行话 多头（多方）：对股市未来行情乐观，预计股价还会继续节节攀升的人。 空头（空方）：对股市前景悲观，预计股价会下跌的人。 大户：","title":"第五节 初入江湖需了解的股市行话"},{"content":"一、技术分析派 根据所持“武器”的不同，技术分析派内部可细分为K线流、切线流、形态流、指标流和波浪流等，在我国还异化出了以“缠论”为代表的一批颇具个人特色的神奇学说， 被信徒们广泛用于股市、期市、汇市等投资领域。\n技术分析这一江湖名门下的各分支都笃信所有的宏观政策、市场讯息、企业的基本面变化、资金和情绪面的种种变化，最终都将体现在技术图形和各类技术指标的波动 当中。他们看重的是结果，而不是像基本面分析者一样去追寻原因。且各支流间一般没有太大分歧，各种技术理论的背后都是“量、价、时（间）、空（间）”这核心四 字在体现功效，各类指标和图形也能得到互相验证。因此，很多人会选择几种技术分析工具进行综合分析\n二、价值投资派 价值投资派的信仰是基于财务报表的基本面分析\n格雷厄姆一派致力于价值发现并长期持有 巴菲特在受费雪《怎样选择成长股》一书以及亲密挚友芒格的影响后，开创了价值投资派中新的一流——价值成长流 在承袭其师格雷厄姆关于企业的内在价值和安全边际理论后，巴芒一派还提出了独创的“能力圈”理论。 林奇不拘泥于持股时长和投资企业的行业属性，更看重股票背后公司在行业中的竞争地位和成长性。 其本人更是号称“不论什么股票他都喜欢”，持股数和换手率都比正统价投派更像个“投机者”。所以从某种意义上，也可以称该流派为“价值投机”。 三、组合投资派 哈里·马科维茨1952年发表的《资产选择》一文标志着现代投资组合理论（portfolio theory）的开端。他利用均值－方差模型分析，得出通过投资组合可以有效 降低风险的结论\n组合投资派信奉的基础教义其实只有最朴素的三条：\n第一，不要把所有的鸡蛋都放在一个篮子里面，否则“倾巢之下，难有完卵”； 第二，组合的风险与组合中资产的收益之间的关系有关； 第三，随着组合中资产种数增加，组合的风险下降，但是组合管理的成本提高，当组合中资产的种数达到一定数量后，风险无法继续下降。 四、量化交易派 量化交易派和组合投资派相比，对金融、数学、计算机等学科能力的要求更高，其中的高频交易流、对冲流对投资资金、交易系统的要求也相当苛刻，因此普通散户并 不容易学习和模仿。西方发达国家的量化交易派已经渐有称霸江湖之势，但国内量化交易派才刚起步，多由具有海外留学背景、金融工程或高等数学专业出身的高智商 “侠客”组成。\n图2-10　国内外量化基金发展历程\n对中小散户而言，直接运用量化交易模型的难度较大，但可以关注擅长于量化交易的公／私募基金（如华泰柏瑞、幻方、锐天等）推出的产品，作为个人资产配置组合 中的一环。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%9B%9B%E8%8A%82-%E8%82%A1%E5%B8%82%E6%B1%9F%E6%B9%96%E5%90%84%E5%A4%A7%E6%8A%95%E8%B5%84%E9%97%A8%E6%B4%BE%E7%AE%80%E4%BB%8B/","summary":"一、技术分析派 根据所持“武器”的不同，技术分析派内部可细分为K线流、切线流、形态流、指标流和波浪流等，在我国还异化出了以“缠论”为代表的一批","title":"第四节 股市江湖各大投资门派简介"},{"content":"一、各路资金齐聚A股 龙虎榜\n通常只有日内股票价格涨跌幅7%以上、股票价格日内换手率超过20%、股票价格日内上行振幅15%以上，或者连续三日内涨跌幅偏离值超过20%，数据处于前三的股 票才有资格上榜。 通过龙虎榜可以关注主力资金参与的交易，对证券营业部、机构、游资、基金或是大股东的交易进行观察参考。 虽然每天的龙虎榜都是在收盘之后才会公布，但是主力资金大概率不会一次性出货（除游资外）。所以投资者可以关注主力资金买入或者卖出股票的情况，进行投资 参考。 二、庄家、游资、主力一定能赚钱吗？ 各个炒股软件对机构、主力、散户，以及大单、中单、小单等概念的定义均不相同，这就导致每个公司同一天的市场统计、对同一只个股的资金流向记录各不相同。 庄家不一定赚钱 三、A股投资者结构 各主流机构的分类方法各有不同，如国金证券研究所采用个人投资者、一般法人（即所谓产业资本）、境内机构和境外机构的“四分法”\n图2-6　A股投资者结构分类之一\n申万宏源则将财政部、汇金、证金等政府机构纳入，增加了一类“政府持股”，也就是我们平时津津乐道的“国家队”\n图2-7　A股投资者结构分类之二\n图2-8　A股各类投资者持股占比\n四、各类参与者风格差异 占比最大的产业资本是不会轻易增减持的，其特点是对自家公司的经营现状和发展前景有较外界更为清楚的认识\n当市场极度悲观时（如2017—2018年），会趁股价便宜时制定并执行增持、回购计划，反之也会大手笔减持。 很多不明就里的散户对减持很反感，认为是“割韭菜”。但对减持必须视具体情况区分对待——底部减持多半是前景确实不乐观或重要股东缺钱，而高位减持更可以理 解为股价飙涨后，估值连管理者自己都认为高了，将心比心地说，这种情况下减持无可厚非，散户何必还去苦苦追高呢？ 政府投资股市，则更多是以支持产业发展（如国家集成电路产业投资基金，俗称“大基金”）或为完成某种特定目的而来（如股灾中救市）。\n我们可以在大方向上参考“国家队”入场和退场的节奏，当管理层对市场的急跌程度不能忍受，都已经出手救市时，深跌的个股就要考虑是否还需要在踩踏中割肉； 当“大基金”已经明确减仓甚至清仓某只热门牛股（如2020年的汇顶科技和闻泰科技等）时，就没有再傻乎乎地冲进去接盘的必要啦！ 内资专业机构中，公募基金占比最大。它的特点是崇尚价值投资\n散户在选股时可以选择优质基金“抄作业”，但当“抱团股”估值明显偏离常识，已经无法靠业绩增长支撑时，也不能犯盲从和盲目追高的错误。 和公募基金的一团和睦不同，私募基金良莠不齐的特点明显。私募基金中各种投资流派都有，有崇尚价值投资并知行合一的高瓴资本、高毅资产，也有量化大拿幻方、 明汯和锐天等，还有做超短的投机派。\n私募基金并不乐于在耳熟能详的大白马股中抱团，更多强调“价值发现”，做一些尚在底部的冷门小众股，且没有对外公开持仓的义务，偶尔透露出来的重仓股，也有 可能是故意放消息出来忽悠别人接盘，所以并不建议抄他们的作业 在挑选私募时，尽量买市场公认好公司的优质基金，规避买小众产品的踩雷风险 险资和社保基金性质类似，目标不在于多高的超额收益，保值是第一要务，其次才是追求稳健增值。因此这一类型的资金更愿意配置蓝筹权重，青睐有更高安全边际以 及低估值、高分红的银行股、地产股。长线或资金体量较大的散户可以适当借鉴，但热衷于短线投机的玩家没有研究它们持仓和操作风格的必要。\n近几年外资投资A股的热情居高不下，呈逐年稳步流入的特点。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%89%E8%8A%82-%E8%82%A1%E5%B8%82%E5%8D%9A%E5%BC%88%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8F%82%E4%B8%8E%E5%8A%9B%E9%87%8F/","summary":"一、各路资金齐聚A股 龙虎榜 通常只有日内股票价格涨跌幅7%以上、股票价格日内换手率超过20%、股票价格日内上行振幅15%以上，或者连续三日内涨","title":"第三节 股市博弈的主要参与力量"},{"content":"查看底层编码\n1 2 3 4 redis\u0026gt; SADD numbers 1 3 5 7 9 (integer) 5 redis\u0026gt; OBJECT ENCODING numbers \u0026#34;intset\u0026#34; 6.1 整数集合的实现 intset.h/intset\n1 2 3 4 5 6 7 8 typedef struct intset { //编码方式 uint32_t encoding; //集合包含的元素数量 uint32_t length; //保存元素的数组(可以视为[]byte) int8_t contents[]; } intset; contents数组按从小到大的顺序保存元素\ncontents数组并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值\n如果encoding属性的值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里的每个项都是一个int16_t类型的整数值（最小值为 -32768，最大值为32767）。 如果encoding属性的值为INTSET_ENC_INT32，那么contents就是一个int32_t类型的数组，数组里的每个项都是一个int32_t类型的整数值（最小值为 -2147483648，最大值为2147483647）。 如果encoding属性的值为INTSET_ENC_INT64，那么contents就是一个int64_t类型的数组，数组里的每个项都是一个int64_t类型的整数值（最小值为 -9223372036854775808，最大值为9223372036854775807）。 图6-1 一个包含五个int16_t类型整数值的整数集合\n6.2 升级 每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元 素添加到整数集合里面。\n根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性 质不变。 将新元素添加到底层数组里面。 向整数集合添加新元素的时间复杂度为O(N)。\n扩容复杂度?\n6.3 升级的好处 6.3.1 提升灵活性 避免类型错误\n6.3.2 节约内存 只在有更大的数据需要保存时才升级\n6.4 降级 不支持降级操作\n6.5 整数集合API 表6-1 整数集合API\n6.6 重点回顾 整数集合是集合键的底层实现之一。 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。 整数集合只支持升级操作，不支持降级操作。 ","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC6%E7%AB%A0-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/","summary":"查看底层编码 1 2 3 4 redis\u0026gt; SADD numbers 1 3 5 7 9 (integer) 5 redis\u0026gt; OBJECT ENCODING numbers \u0026#34;intset\u0026#34; 6.1 整数集合的实现 intset.h/intset 1 2 3 4 5 6 7 8 typedef struct intset { //编码方式 uint32_t encoding; //集合包含的元素数量 uint32_t length; //保","title":"第6章 整数集合"},{"content":"Linux系统中的文件链接分为软链接和硬链接两种。\n软链接创建后，如果源文件被删除，则软链接将无法继续使用，可以跨分区和磁盘创建软链接。 硬链接创建后，如果源文件被删除，则硬链接依然可以正常使用、正常读写数据，但硬链接不可以跨分区或磁盘创建。 硬链接与源文件使用的是相同的设备、相同的inode编号。使用ls -l命令查看硬链接文件的属性时，文件属性与普通文件是一样的，而软链接的文件属性则可以看 到被l标记，表示该文件为软链接。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/linux/%E8%BD%AF%E9%93%BE%E6%8E%A5-%E7%A1%AC%E9%93%BE%E6%8E%A5/","summary":"Linux系统中的文件链接分为软链接和硬链接两种。 软链接创建后，如果源文件被删除，则软链接将无法继续使用，可以跨分区和磁盘创建软链接。 硬链接","title":"软链接 硬链接"},{"content":"为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：\n上半部用来快速处理中断(硬中断)，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。 下半部用来延迟处理上半部未完成的工作(软中断)，通常以内核线程的方式运行。 上半部会打断 CPU 正在执行的任务，然后立即执行中断处理程序。而下半部以内核线程的方式执行，并且每个 CPU 都对应一个软中断内核线程，名字为 “ksoftirqd/CPU 编号”，比如说， 0 号 CPU 对应的软中断内核线程的名字就是 ksoftirqd/0。\n软中断不只包括了刚刚所讲的硬件设备中断处理程序的下半部，一些内核自定义的事件也属于软中断，比如内核调度和 RCU 锁（Read-Copy Update 的缩写，RCU 是 Linux 内核中最常用的锁之一）等。\n查看中断 /proc/softirqs 提供了软中断的运行情况； /proc/interrupts 提供了硬中断的运行情况。 1 2 3 4 5 6 7 8 9 10 11 12 13 # 各种软中断的次数 $ cat /proc/softirqs CPU0 CPU1 HI: 0 0 TIMER: 811613 1972736 NET_TX: 49 7 NET_RX: 1136736 1506885 BLOCK: 0 0 IRQ_POLL: 0 0 TASKLET: 304787 3691 SCHED: 689718 1897539 HRTIMER: 0 0 RCU: 1330771 1354737 查看软中断内核线程\n1 2 3 $ ps aux | grep softirq root 7 0.0 0.0 0 0 ? S Oct10 0:01 [ksoftirqd/0] root 16 0.0 0.0 0 0 ? S Oct10 0:01 [ksoftirqd/1] ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/cpu/%E4%B8%AD%E6%96%AD/","summary":"为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部： 上半部用来快速处理中断(硬中断)","title":"中断"},{"content":"RWMutex 一般都是基于互斥锁、条件变量（condition variables）或者信号量（semaphores）等并发原语来实现。Go 标准库中的 RWMutex 是基于 Mutex 实现的。\n读写锁的设计策略\nRead-preferring: 只有所有的读都释放了锁之后，写才可能获取到锁, 会导致写饥饿 Write-preferring: 会导致读饥饿 如果已经有一个 writer 在等待请求锁的话，它会阻止新来的请求锁的 reader 获取到锁 如果有一些 reader 已经请求了锁的话，新请求的 writer 也会等待已经存在的 reader 都释放锁之后才能获取 不指定优先级: 某些场景下这种不指定优先级的设计反而更有效 Go 标准库中的 RWMutex 设计是 Write-preferring 方案。一个正在阻塞的 Lock 调用会排除新的 reader 请求到锁。\n1 2 3 4 5 6 7 8 9 type RWMutex struct { w Mutex // 互斥锁解决多个writer的竞争 writerSem uint32 // writer信号量 readerSem uint32 // reader信号量 readerCount int32 // reader的数量 readerWait int32 // writer等待完成的reader的数量 } const rwmutexMaxReaders = 1 \u0026lt;\u0026lt; 30 // 最大的 reader 数量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func (rw *RWMutex) RLock() { if atomic.AddInt32(\u0026amp;rw.readerCount, 1) \u0026lt; 0 { // rw.readerCount是负值的时候，意味着此时有writer等待请求锁，因为writer优先级高，所以把后来的reader阻塞休眠 runtime_SemacquireMutex(\u0026amp;rw.readerSem, false, 0) } } func (rw *RWMutex) RUnlock() { if r := atomic.AddInt32(\u0026amp;rw.readerCount, -1); r \u0026lt; 0 { rw.rUnlockSlow(r) // 有等待的writer } } func (rw *RWMutex) rUnlockSlow(r int32) { if atomic.AddInt32(\u0026amp;rw.readerWait, -1) == 0 { // 最后一个reader了，writer终于有机会获得锁了 runtime_Semrelease(\u0026amp;rw.writerSem, false, 1) } } 一旦一个 writer 获得了内部的互斥锁，就会反转 readerCount 字段，把它从原来的正整数 readerCount(\u0026gt;=0) 修改为负数（readerCount-rwmutexMaxReaders），让这个字段保持两个含义（既保存了 reader 的数量，又表示当前有 writer）。\n1 2 3 4 5 6 7 8 9 10 func (rw *RWMutex) Lock() { // 首先解决其他writer竞争问题 rw.w.Lock() // 反转readerCount，告诉reader有writer竞争锁 r := atomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders // 如果当前有reader持有锁，那么需要等待 if r != 0 \u0026amp;\u0026amp; atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0 { runtime_SemacquireMutex(\u0026amp;rw.writerSem, false, 0) } } 1 2 3 4 5 6 7 8 9 10 11 func (rw *RWMutex) Unlock() { // 告诉reader没有活跃的writer了 r := atomic.AddInt32(\u0026amp;rw.readerCount, rwmutexMaxReaders) // 唤醒阻塞的reader们 for i := 0; i \u0026lt; int(r); i++ { runtime_Semrelease(\u0026amp;rw.readerSem, false, 0) } // 释放内部的互斥锁 rw.w.Unlock() } 注意死锁\n重入 RLock中调用Lock writer 依赖活跃的 reader -\u0026gt; 活跃的 reader 依赖新来的 reader -\u0026gt; 新来的 reader 依赖 writer ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/rwmutex/","summary":"RWMutex 一般都是基于互斥锁、条件变量（condition variables）或者信号量（semaphores）等并发原语来实现。Go 标准库中的 RWMutex 是","title":"rwMutex"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 # 列出listen/非listen套接字 $ netstat -a # 列出tcp套接字 $ netstat -at # 展示端口号 $ netstat -ltn # 展示进程 $ netstat -ltnp # 显示 8080 端口所有处于 ESTABLISHED 状态的连接 $ netstat -atnp | grep \u0026#34;:8080\u0026#34; | grep ESTABLISHED ","permalink":"https://jdxj.github.io/posts/cmd/netstat/","summary":"1 2 3 4 5 6 7 8 9 10 11 # 列出listen/非listen套接字 $ netstat -a # 列出tcp套接字 $ netstat -at # 展示端口号 $ netstat -ltn # 展示进程 $ netstat -ltnp # 显示 8080 端口所","title":"netstat"},{"content":"ab（apache bench）是一个常用的 HTTP 服务性能测试工具\n安装\n1 $ apt install apache2-utils 使用\n1 2 3 4 5 6 7 8 # 并发10个请求测试Nginx性能，总共测试100个请求 $ ab -c 10 -n 100 http://192.168.0.10:10000/ This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1706008 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, ... Requests per second: 11.63 [#/sec] (mean) Time per request: 859.942 [ms] (mean) ... ","permalink":"https://jdxj.github.io/posts/cmd/ab/","summary":"ab（apache bench）是一个常用的 HTTP 服务性能测试工具 安装 1 $ apt install apache2-utils 使用 1 2 3 4 5 6 7 8 # 并发10个请求测试Nginx性能，总共测试1","title":"Ab"},{"content":"perf 是 Linux 2.6.31 以后内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问 题。\n安装\n1 $ apt install linux-perf 实时显示占用 CPU 时钟最多的函数或者指令\n1 2 3 4 5 6 7 8 $ perf top Samples: 833 of event \u0026#39;cpu-clock\u0026#39;, Event count (approx.): 97742399 Overhead Shared Object Symbol 7.28% perf [.] 0x00000000001f78a4 4.72% [kernel] [k] vsnprintf 4.32% [kernel] [k] module_get_kallsym 3.65% [kernel] [k] _raw_spin_unlock_irqrestore ... 第一行包含三个数据，分别是采样数（Samples）、事件类型（event）和事件总数量（Event count）。\n再往下看是一个表格式样的数据，每一行包含四列\n第一列 Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示。 第二列 Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等。 第三列 Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。 最后一列 Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。 perf top 虽然实时展示了系统的性能信息，但它的缺点是并不保存数据，也就无法用于离线或者后续的分析。而 perf record 则提供了保存数据的功能，保存后 的数据，需要你用 perf report 解析展示。\n1 2 3 4 5 $ perf record # 按Ctrl+C终止采样 [ perf record: Woken up 1 times to write data ] [ perf record: Captured and wrote 0.452 MB perf.data (6093 samples) ] $ perf report # 展示类似于perf top的报告 1 2 # -g开启调用关系分析，-p指定进程号21515 $ perf top -g -p 21515 ","permalink":"https://jdxj.github.io/posts/cmd/perf/","summary":"perf 是 Linux 2.6.31 以后内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问 题。 安装 1 $","title":"perf"},{"content":"CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比\n查看cpu节拍数 单位是USER_HZ(10ms, 100HZ)\n1 $ cat /proc/stat | grep ^cpu 也可以用每一个场景的 CPU 时间，除以总的 CPU 时间，计算出每个场景的 CPU 使用率。\n直接用 /proc/stat 的数据直接算出来的，是开机以来的平均 CPU 使用率，一般没啥参考价值。为了计算 CPU 使用率，性能工具一般都会取间隔一段时间（比如 3 秒）的两次值，作差后，再计算出这段时间内的平均 CPU 使用率\ncat /proc/stat | grep ^cpu各列含义\nuser（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。 nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。 system（通常缩写为 sys），代表内核态 CPU 时间。 idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。 iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。 irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。 softirq（通常缩写为 si），代表处理软中断的 CPU 时间。 steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。 guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。 guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。 查看cpu使用率 top 1 2 3 4 5 6 7 8 9 10 11 12 13 # 默认每3秒刷新一次 $ top top - 11:58:59 up 9 days, 22:47, 1 user, load average: 0.03, 0.02, 0.00 Tasks: 123 total, 1 running, 72 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.3 us, 0.3 sy, 0.0 ni, 99.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 8169348 total, 5606884 free, 334640 used, 2227824 buff/cache KiB Swap: 0 total, 0 free, 0 used. 7497908 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 78088 9288 6696 S 0.0 0.1 0:16.83 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.05 kthreadd 4 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 kworker/0:0H ... %CPU表示进程的 CPU 使用率。它是用户态和内核态 CPU 使用率的总和，包括进程用户空间使用的 CPU、通过系统调用执行的内核空间 CPU 、以及在就绪队列等 待运行的 CPU。在虚拟化环境中，它还包括了运行虚拟机占用的 CPU。\npidstat 1 2 3 4 5 6 7 8 9 # 每隔1秒输出一组数据，共输出5组 $ pidstat 1 5 15:56:02 UID PID %usr %system %guest %wait %CPU CPU Command 15:56:03 0 15006 0.00 0.99 0.00 0.00 0.99 1 dockerd ... Average: UID PID %usr %system %guest %wait %CPU CPU Command Average: 0 15006 0.00 0.99 0.00 0.00 0.99 - dockerd 用户态 CPU 使用率 （%usr）； 内核态 CPU 使用率（%system）； 运行虚拟机 CPU 使用率（%guest）； 等待 CPU 使用率（%wait）； 总的 CPU 使用率（%CPU）。 小结 CPU 使用率是最直观和最常用的系统性能指标，更是我们在排查性能问题时，通常会关注的第一个指标。所以我们更要熟悉它的含义，尤其要弄清楚用户（%user）、 Nice（%nice）、系统（%system） 、等待 I/O（%iowait） 、中断（%irq）以及软中断（%softirq）这几种不同 CPU 的使用率。\n用户 CPU 和 Nice CPU 高，说明用户态进程占用了较多的 CPU，所以应该着重排查进程的性能问题。 系统 CPU 高，说明内核态占用了较多的 CPU，所以应该着重排查内核线程或者系统调用的性能问题。 I/O 等待 CPU 高，说明等待 I/O 的时间比较长，所以应该着重排查系统存储是不是出现了 I/O 问题。 软中断和硬中断高，说明软中断或硬中断的处理程序占用了较多的 CPU，所以应该着重排查内核中的中断服务程序。 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/cpu/cpu%E4%BD%BF%E7%94%A8%E7%8E%87/","summary":"CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比 查看cpu节拍数 单位是USER_HZ(10ms, 100HZ) 1 $ cat /proc/stat | grep ^cpu 也可以用每一个场景的","title":"CPU使用率"},{"content":" 查看某key的内部编码\n1 2 3 4 redis\u0026gt; RPUSH lst 1 3 5 10086 \u0026#34;hello\u0026#34; \u0026#34;world\u0026#34; (integer)6 redis\u0026gt; OBJECT ENCODING lst \u0026#34;ziplist\u0026#34; raw embstr hashtable linkedlist ziplist intset skiplist ","permalink":"https://jdxj.github.io/posts/articles/jdxj/redis%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81/","summary":"查看某key的内部编码 1 2 3 4 redis\u0026gt; RPUSH lst 1 3 5 10086 \u0026#34;hello\u0026#34; \u0026#34;world\u0026#34; (integer)6 redis\u0026gt; OBJECT ENCODING lst \u0026#34;ziplist\u0026#34; raw embstr hashtable linkedlist ziplist intset skiplist","title":"Redis内部编码"},{"content":"5.1 跳跃表的实现 图5-1 一个跳跃表\n图片最左边的是zskiplist结构\nheader：指向跳跃表的表头节点 tail：指向跳跃表的表尾节点 level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内） length：记录跳跃表的长度，跳跃表目前包含节点的数量（表头节点不计算在内） 位于zskiplist结构右方的是四个zskiplistNode结构\n层（level）：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。 每个层都带有两个属性：前进指针和跨度。 前进指针用于访问位于表尾方向的其他节点， 跨度则记录了前进指针所指向节点和当前节点的距离。 在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。 当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。 后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用 分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列 成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象 注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表 头节点的各个层。\n5.1.1 跳跃表节点 redis.h/zskiplistNode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 typedef struct zskiplistNode { //层 struct zskiplistLevel { //前进指针 struct zskiplistNode *forward; //跨度 unsigned int span; } level[]; //后退指针 struct zskiplistNode *backward; //分值 double score; //成员对象 robj *obj; } zskiplistNode; 层 一般来说，层的数量越多，访问其他节点的速度就越快 每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这 个大小就是层的“高度” 图5-2 带有不同层高的节点\n前进指针 level[i].forward, 用于从表头向表尾方向访问节点\n图5-3 遍历整个跳跃表\n注意虚线标识的访问路径, 可以在不同层之间前进 跨度 level[i].span用于记录两个节点之间的距离\n两个节点之间的跨度越大，它们相距得就越远 指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点 跨度实际上是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。 图5-4 计算节点的排位\n图5-5 另一个计算节点排位的例子\n后退指针 backward每次只能后退至前一个节点。\n图5-6 从表尾向表头方向遍历跳跃表\n分值和成员 score是double类型的浮点数, 跳跃表中的所有节点都按分值从小到大来排序 obj指向一个字符串对象，而字符串对象则保存着一个SDS值 分值相同的节点将按照成员对象在字典序中的大小来进行排序 图5-7 三个带有相同分值的跳跃表节点\n5.1.2 跳跃表 redis.h/zskiplist\n1 2 3 4 5 6 7 8 typedef struct zskiplist { //表头节点和表尾节点 structz skiplistNode *header, *tail; //表中节点的数量 unsigned long length; //表中层数最大的节点的层数 int level; } zskiplist; 图5-8 由多个跳跃节点组成的跳跃表\n图5-9 带有zskiplist结构的跳跃表\nheader和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为O(1)。 通过使用length属性来记录节点的数量，程序可以在O(1)复杂度内返回跳跃表的长度。 level属性则用于在O(1)复杂度内获取跳跃表中层高最大的那个节点的层数量，注意表头节点的层高并不计算在内。 5.2 跳跃表API 表5-1 跳跃表API\n5.3 重点回顾 跳跃表是有序集合的底层实现之一。 Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而 zskiplistNode则用于表示跳跃表节点。 每个跳跃表节点的层高都是1至32之间的随机数。 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。 ","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC5%E7%AB%A0-%E8%B7%B3%E8%B7%83%E8%A1%A8/","summary":"5.1 跳跃表的实现 图5-1 一个跳跃表 图片最左边的是zskiplist结构 header：指向跳跃表的表头节点 tail：指向跳跃表的表尾节点 leve","title":"第5章 跳跃表"},{"content":"4.1 字典的实现 4.1.1 哈希表 dict.h/dictht\n1 2 3 4 5 6 7 8 9 10 11 typedef struct dictht { //哈希表数组 dictEntry **table; //哈希表大小 unsigned long size; //哈希表大小掩码，用于计算索引值 //总是等于size-1 unsigned long sizemask; //该哈希表已有节点的数量 unsigned long used; } dictht; 图4-1 一个空的哈希表\n4.1.2 哈希表节点 dict.h/dictEntry\n1 2 3 4 5 6 7 8 9 10 11 12 typedef struct dictEntry { //键 void *key; //值 union{ void *val; uint64_tu64; int64_ts64; } v; //指向下个哈希表节点，形成链表 struct dictEntry *next; } dictEntry; next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。\n图4-2 连接在一起的键K1和键K0\n4.1.3 字典 dict.h/dict\n1 2 3 4 5 6 7 8 9 10 11 typedef struct dict { //类型特定函数 dictType *type; //私有数据 void *privdata; //哈希表 dictht ht[2]; // rehash索引 //当rehash不在进行时，值为-1 int rehashidx; /* rehashing not in progress if rehashidx == -1 */ } dict; type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。 privdata属性则保存了需要传给那些类型特定函数的可选参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 typedef struct dictType { //计算哈希值的函数 unsigned int (*hashFunction)(const void *key); //复制键的函数 void *(*keyDup)(void *privdata, const void *key); //复制值的函数 void *(*valDup)(void *privdata, const void *obj); //对比键的函数 int (*keyCompare)(void *privdata, const void *key1, const void *key2); //销毁键的函数 void (*keyDestructor)(void *privdata, void *key); //销毁值的函数 void (*valDestructor)(void *privdata, void *obj); } dictType; ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行 rehash时使用。 图4-3 普通状态下的字典\n4.2 哈希算法 Redis计算哈希值和索引值的方法\n1 2 3 4 5 #使用字典设置的哈希函数，计算键key的哈希值 hash = dict-＞type-＞hashFunction(key); #使用哈希表的sizemask属性和哈希值，计算出索引值 #根据情况不同，ht[x]可以是ht[0]或者ht[1] index = hash \u0026amp; dict-＞ht[x].sizemask; 图4-4 空字典\n图4-5 添加键值对K0和v0之后的字典\n当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。\n这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。 4.3 解决键冲突 Redis的哈希表使用链地址法（separate chaining）来解决键冲突\n图4-6 一个包含两个键值对的哈希表\n因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置（复杂度为O（1）），排在其他已有节 点的前面。\n图4-7 使用链表解决k2和k1的冲突\n4.4 rehash Redis对字典的哈希表执行rehash的步骤\n为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值） 如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n； 如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n。 将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。 当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次 rehash做准备。 图4-8 执行rehash之前的字典\nht[0].used当前的值为4，4*2=8，而8（2^3）恰好是第一个大于等于4的2的n次方，所以程序会将ht[1]哈希表的大小设置为8。\n图4-9 为字典的ht[1]哈希表分配空间\n将ht[0]包含的四个键值对都rehash到ht[1]\n图4-10 ht[0]的所有键值对都已经被迁移到ht[1]\n释放ht[0]，并将ht[1]设置为ht[0]，然后为ht[1]分配一个空白哈希表\n图4-11 完成rehash之后的字典\n当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作\n服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5 哈希表的负载因子\n1 2 #负载因子=哈希表已保存节点数量/哈希表大小 load_factor = ht[0].used / ht[0].size 根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中， Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，所以在子进程存在期间，服务器会 提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。\n当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。\n4.5 渐进式rehash 扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但是，这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。\n为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键 值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完 成。 图4-12 准备开始rehash\n图4-13 rehash索引0上的键值对\n图4-14 rehash索引1上的键值对\n图4-15 rehash索引2上的键值对\n图4-16 rehash索引3上的键值对\n图4-17 rehash执行完毕\n因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、 更新（update）等操作会在两个哈希表上进行。例如，要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht[1]里面进 行查找，诸如此类。\n在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减 不增，并随着rehash操作的执行而最终变成空表。\n4.6 字典API 表4-1 字典的主要操作API\n4.7 重点回顾 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。 Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。 哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进 式地完成的。 ","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC4%E7%AB%A0-%E5%AD%97%E5%85%B8/","summary":"4.1 字典的实现 4.1.1 哈希表 dict.h/dictht 1 2 3 4 5 6 7 8 9 10 11 typedef struct dictht { //哈希表数组 dictEntry **table; //哈希表大小 unsigned long size; //哈希表大小掩码，用于计算索引值 //总是等于si","title":"第4章 字典"},{"content":"两个或两个以上的进程（或线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下去，此时，我们 称系统处于死锁状态或系统产生了死锁。\n死锁产生的必要条件\n互斥： 至少一个资源是被排他性独享的，其他线程必须处于等待状态，直到资源被释放。 持有和等待：goroutine 持有一个资源，并且还在请求其它 goroutine 持有的资源，也就是咱们常说的“吃着碗里，看着锅里”的意思。 不可剥夺：资源只能由持有它的 goroutine 来释放。 环路等待：一般来说，存在一组等待进程，P={P1，P2，…，PN}，P1 等待 P2 持有的资源，P2 等待 P3 持有的资源，依此类推，最后是 PN 等待 P1 持有的资源，这就形成了一个环路等待的死结。 ","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/%E6%AD%BB%E9%94%81/","summary":"两个或两个以上的进程（或线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下","title":"死锁"},{"content":"演化过程 初版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // CAS操作，当时还没有抽象出atomic包 func cas(val *int32, old, new int32) bool func semacquire(*int32) func semrelease(*int32) // 互斥锁的结构，包含两个字段 type Mutex struct { key int32 // 锁是否被持有的标识 sema int32 // 信号量专用，用以阻塞/唤醒goroutine } // 保证成功在val上增加delta的值 func xadd(val *int32, delta int32) (new int32) { for { v := *val if cas(val, v, v+delta) { return v + delta } } panic(\u0026#34;unreached\u0026#34;) } // 请求锁 func (m *Mutex) Lock() { if xadd(\u0026amp;m.key, 1) == 1 { //标识加1，如果等于1，成功获取到锁 return } semacquire(\u0026amp;m.sema) // 否则阻塞等待 } func (m *Mutex) Unlock() { if xadd(\u0026amp;m.key, -1) == 0 { // 将标识减去1，如果等于0，则没有其它等待者 return } semrelease(\u0026amp;m.sema) // 唤醒其它阻塞的goroutine } Unlock 方法可以被任意的 goroutine 调用释放锁，即使是没持有这个互斥锁的 goroutine，也可以进行这个操作。这是因为，Mutex 本身并没有包含持有这把锁的 goroutine 的信息，所以，Unlock 也不会对此进行检查。Mutex 的这个设计一直保持至今。\n给新人机会 1 2 3 4 5 6 7 8 9 10 type Mutex struct { state int32 sema uint32 } const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // mutex is locked mutexWoken // 是否存在被唤醒的goroutine mutexWaiterShift = iota ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func (m *Mutex) Lock() { // Fast path: 幸运case，能够直接获取到锁 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } awoke := false for { old := m.state new := old | mutexLocked // 新状态加锁 if old\u0026amp;mutexLocked != 0 { // 锁未释放 new = old + 1\u0026lt;\u0026lt;mutexWaiterShift //等待者数量加一 } if awoke { // goroutine是被唤醒的， // 新状态清除唤醒标志 new \u0026amp;^= mutexWoken } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) {//设置新状态 if old\u0026amp;mutexLocked == 0 { // 锁原状态未加锁 break } runtime.Semacquire(\u0026amp;m.sema) // 请求信号量 awoke = true } } } \u0026amp;^含义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func (m *Mutex) Unlock() { // Fast path: drop lock bit. new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) //去掉锁标志 if (new+mutexLocked)\u0026amp;mutexLocked == 0 { //本来就没有加锁 panic(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } old := new for { if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken) != 0 { // 没有等待者，或者有唤醒的waiter，或者锁原来已加锁 return } new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken // 新状态，准备唤醒goroutine，并设置唤醒标志 if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { runtime.Semrelease(\u0026amp;m.sema) return } old = m.state } } 多给些机会 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func (m *Mutex) Lock() { // Fast path: 幸运之路，正好获取到锁 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } awoke := false iter := 0 for { // 不管是新来的请求锁的goroutine, 还是被唤醒的goroutine，都不断尝试请求锁 old := m.state // 先保存当前锁的状态 new := old | mutexLocked // 新状态设置加锁标志 if old\u0026amp;mutexLocked != 0 { // 锁还没被释放 if runtime_canSpin(iter) { // 还可以自旋 if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() iter++ continue // 自旋，再次尝试请求锁 } new = old + 1\u0026lt;\u0026lt;mutexWaiterShift } if awoke { // 唤醒状态 if new\u0026amp;mutexWoken == 0 { panic(\u0026#34;sync: inconsistent mutex state\u0026#34;) } new \u0026amp;^= mutexWoken // 新状态清除唤醒标记 } if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { if old\u0026amp;mutexLocked == 0 { // 旧状态锁已释放，新状态成功持有了锁，直接返回 break } runtime_Semacquire(\u0026amp;m.sema) // 阻塞等待 awoke = true // 被唤醒 iter = 0 } } } 解决饥饿 在极端情况下，等待中的 goroutine 可能会一直获取不到锁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 type Mutex struct { state int32 sema uint32 } const ( mutexLocked = 1 \u0026lt;\u0026lt; iota // mutex is locked mutexWoken mutexStarving // 从state字段中分出一个饥饿标记 mutexWaiterShift = iota starvationThresholdNs = 1e6 ) func (m *Mutex) Lock() { // Fast path: 幸运之路，一下就获取到了锁 if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { return } // Slow path：缓慢之路，尝试自旋竞争或饥饿状态下饥饿goroutine竞争 m.lockSlow() } func (m *Mutex) lockSlow() { var waitStartTime int64 starving := false // 此goroutine的饥饿标记 awoke := false // 唤醒标记 iter := 0 // 自旋次数 old := m.state // 当前的锁的状态 for { // 锁是非饥饿状态，锁还没被释放，尝试自旋 if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) { if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() iter++ old = m.state // 再次获取锁的状态，之后会检查是否锁被释放了 continue } new := old if old\u0026amp;mutexStarving == 0 { new |= mutexLocked // 非饥饿状态，加锁 } if old\u0026amp;(mutexLocked|mutexStarving) != 0 { new += 1 \u0026lt;\u0026lt; mutexWaiterShift // waiter数量加1 } if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 { new |= mutexStarving // 设置饥饿状态 } if awoke { if new\u0026amp;mutexWoken == 0 { throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } new \u0026amp;^= mutexWoken // 新状态清除唤醒标记 } // 成功设置新状态 if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // 原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回 if old\u0026amp;(mutexLocked|mutexStarving) == 0 { break // locked the mutex with CAS } // 处理饥饿状态 // 如果以前就在队列里面，加入到队列头 queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } // 阻塞等待 runtime_SemacquireMutex(\u0026amp;m.sema, queueLifo, 1) // 唤醒之后检查锁是否应该处于饥饿状态 starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs old = m.state // 如果锁已经处于饥饿状态，直接抢到锁，返回 if old\u0026amp;mutexStarving != 0 { if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } // 有点绕，加锁并且将waiter数减1 delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift) if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { delta -= mutexStarving // 最后一个waiter或者已经不饥饿了，清除饥饿标记 } atomic.AddInt32(\u0026amp;m.state, delta) break } awoke = true iter = 0 } else { old = m.state } } } func (m *Mutex) Unlock() { // Fast path: drop lock bit. new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) if new != 0 { m.unlockSlow(new) } } func (m *Mutex) unlockSlow(new int32) { if (new+mutexLocked)\u0026amp;mutexLocked == 0 { throw(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } if new\u0026amp;mutexStarving == 0 { old := new for { if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken|mutexStarving) != 0 { return } new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { runtime_Semrelease(\u0026amp;m.sema, false, 1) return } old = m.state } } else { runtime_Semrelease(\u0026amp;m.sema, true, 1) } } vet发现Mutex复制原理 检查是通过copylock分析器静态分析实现的。 这个分析器会分析函数调用、range 遍历、复制、声明、函数返回值等位置，有没有锁的值 copy 的情景，以此来判断有没有问题。可以说，只要是实现了 Locker 接口，就会被分析。\n","permalink":"https://jdxj.github.io/posts/books/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BE/mutex/","summary":"演化过程 初版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // CAS操作，当时还没有抽象出atomic包 func cas(val *int32, old, new int32) bool","title":"mutex"},{"content":"一、股票的概念 股票是有价证券的一种，是股份公司在筹集资本时公开或不公开向出资人发行的，用以证明出资人股东身份和权利，并根据股东所持股份数享有权利和承担义务的可转 让的书面凭证。\n二、股票的特点 图2-2　上海飞乐音响股票\n永久且不可偿还 上市公司通过发行股票融资，投资者认购股票后成为其股东，股票所载明的权责义务的有效性是无限期的。公司在，股票就在，你购买股票后就已经成为公司管理层的 一分子，中小股东和大股东是“同事”关系，不存在售后又后悔要求退股的“好事”，投资要慎重哦！\n可转让可流通 如果有幸参与了新股的一级市场发行，经过锁定期后股票达到目标价位，你又不想继续持有，当然可以选择转让给市场上的其他参与者；二级交易市场上，只要不是停 牌或涨跌停，如果股价涨超或跌破心理预期，或者发现公司质地欠佳，都可以选择卖给别人。\n参与人数较少、流动性欠佳、不方便随时变现的新三板股票，普通散户也尽量少参与\n收益与风险并存 收益既包括股价上扬部分，也包括每年从公司取得的股息、分红。 即便几十年间被誉为“只挤奶，不吃草”的优质公司，也会因为宏观经济环境、业绩变化和突发事件等影响出现股价大幅波动，如果基本面持续无法改观，中长期投资 逻辑也会发生变化。 其他不可忽视的权利 中小投资者往往容易忽视身为股东，还享有出席公司股东大会、参与制定影响公司未来走向的重大决策、选举公司董事会等权利。 当上市公司因信息披露不规范、虚假陈述、恶意隐瞒导致股价波动的消息等行为被监管处罚后，持股投资者可以依法发起诉讼索赔； 当企业经营不善破产清算时，中小股东同样拥有对公司在清偿债务和支付雇员报酬后剩余资产的分配权。 三、股票的分类 根据持有者享有权利的不同，可分为优先股和普通股 优先股的“优先”二字，主要体现在利润分红和公司剩余财产分配权上优于普通股。\n优先股股东每年收取固定的股息率，不参与上市公司管理，没有选举和被选举权，对公司重大经营事项无投票权，在某些特定的关系到优先股股东相关事项上有受严 格限制的投票权； 而普通股股东有着正常公司股东所应有的一切权利。但在公司经营不善的情况下，普通股股东的分红权利要次于优先股，破产清算时对剩余财产的分配上，优先股股 东优先于普通股股东。 一般情况下，中小散户在二级市场买卖的股票基本都是普通股，优先股在极特殊情况下才能够进入二级市场流通\n根据购买主体的不同，可分为国有股、法人股和社会公众股 国有股指有权代表同家投资的部门或机构以国有资产向公司投资形成的股份，包括以公司现有国有资产折算成的股份。 法人股指企业法人或具有法人资格的事业单位和社会团体以其依法可经营的资产向公司非上市流通股权部分投资所形成的股份。 社会公众股是指我国境内个人和机构，以其合法财产向公司可上市流通股权部分投资所形成的股份。对于大多数股民来说，在股票市场买卖的股票都是社会公众股。 根据上市地点的不同，可分为A/B、H、S、N、T、L股等 A股、B股都在中国内地注册并上市，A股以人民币认购和交易，参与者为内资机构和个人；B股以人民币标明面值，只能以外币认购和交易，参与者主要为港澳台居民及 外国人。\nB股日渐式微，走向边缘化。不建议散户尤其是新手参与该板块。 H、S、N、T、L股分别代表的是内地注册，在香港（Hong Kong）、新加坡（Singapore）、纽约（New York）、东京（Tokyo）和伦敦（London）上市的外资 股。\n有重点关注价值的是H股和N股，即港股和美股。这两个市场都比A股更成熟，整体估值也更为合理。很多大型金融和能源企业在内地、 香港两地上市（也称“红筹股”），但A股较H股溢价较多，从长期持有的角度看港股更为合适。 根据上市板块的不同，可分为主板、中小板、创业板、科创板和新三板股票 表2-1　A股各板块概况\n图2-3　中国资本市场体系分层\n其他分类 根据行业不同可分为金融股、消费股、医药股、科技股、有色股、化工股等； 根据市值大小可分为大盘股（蓝筹股）和中小盘股； 根据业绩优秀还是纯炒概念，可分为白马股和题材股； 根据企业风格又能分成价值股和成长股； 根据行业周期或特性还可分为周期股、防御股和进攻股等。 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%A6%82%E5%BF%B5-%E7%89%B9%E7%82%B9%E5%8F%8A%E5%88%86%E7%B1%BB/","summary":"一、股票的概念 股票是有价证券的一种，是股份公司在筹集资本时公开或不公开向出资人发行的，用以证明出资人股东身份和权利，并根据股东所持股份数享有","title":"第二节 股票的概念, 特点及分类"},{"content":"一、金融市场的分类 根据金融交易的期限\n一年以内的短期市场为货币市场，满足买卖双方短线资金流动性需求； 一年以上的长期市场就是我们经常在财经新闻中听到的高频词——资本市场，它存在的意义在于满足中央、地方政府弥补财政赤字和拟上市、拟发债企业的中长期投融 资需求。 根据金融交易交割期限的不同分为\n现货市场 期货市场 根据交易标的品种的不同分为\n股票市场 债券市场 贵金属市场 外汇市场等 几组分类并不完全周延，会存在交织重叠的情况。广义的资本市场概念之下又包括银行中长期存贷款市场和证券市场。人们常挂在嘴边的资本市场，一般约定俗成指的 就是证券市场。\n二、何谓证券市场 所谓证券，是指代表持有者某种所有权、收益权，或债权的法律凭证。现在常见，还在经济生活中发挥重要作用的有股票、债券、国库券、支票、汇票等，而已经退出 或正在逐渐退出历史舞台的粮票、邮票等，也都是广义证券的一种。\n证券市场即是股票、债券等有价证券发行和交易的场所，参与者包括\n发行人（融资方，包括政府、拟上市公司等） 投资者（包括金融机构和非金融机构、企事业单位、个人等） 中介机构（券商、资信评级机构、证券投顾公司等） 自律性组织（如证券交易所）等。 中国证券监督管理委员会，也就是证监会。 基金，包括证券投资基金、私募股权基金、上市公司并购基金、政府产业基金（如被大伙亲切称为“大基金”的国家集成电路产业投资基金）、创业投资基金等多种类型。 其中的证券投资基金可以在场内或场外买卖，同样属于证券概念范畴。\n所谓的“场”特指证券交易所，封闭式基金可以像股票一样在上交所或深交所买卖，而开放式基金可以在基金公司以及各个代销机构（如券商，银行，蚂蚁金服、天天 基金等互联网第三方平台）进行申购（买入）和赎回（卖出）。 无论场内、场外均属于证券市场统辖范围，证券交易所只是证券市场的组成部分之一，这是容易混淆需要厘清的地方。 二、中国证券市场的萌芽 三、中国证券市场的发展 四、中国证券市场终将走向成熟 图2-1　2019年全球资本市场竞争力指数排名\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E8%8A%82-%E4%B8%AD%E5%9B%BD%E8%AF%81%E5%88%B8%E5%B8%82%E5%9C%BA%E6%A6%82%E5%86%B5/","summary":"一、金融市场的分类 根据金融交易的期限 一年以内的短期市场为货币市场，满足买卖双方短线资金流动性需求； 一年以上的长期市场就是我们经常在财经新闻中","title":"第一节 中国证券市场概况"},{"content":"2.1 智能化脚本的基础之测试 条件判断的方式\n[[ expr ]] [ expr ] test expr 不管使用哪种方式进行条件判断，系统默认都不会有任何输出结果，可以通过echo $?命令，查看上一条命令的退出状态码，或者使用\u0026amp;\u0026amp;和||操作符结合其他命令进 行结果的输出操作。\n表达式两边要有空格 操作符两边要有空格 使用[[]]和test进行排序比较时，使用的比较符号不同 在test或[]中不能直接使用\u0026lt;或\u0026gt;符号进行排序比较(因为是输入输出重定向符号) 在一行中执行多个命令\n; 按顺序执行命令, 退出码以最后一个命令为准 \u0026amp;\u0026amp; 前一条命令成功后才会执行之后的命令, 都成功执行后退出码为0 || 前一条命令失败后才会执行之后的命令, 存在成功执行退出码为0 2.2 字符串的判断与比较 1 2 $ test a == b; echo $? $ [ a == b ]; echo $? -z测试字符串是否为空\n1 $ [ -z $TEST ] -n测试字符串是否非空\n1 $ [ -n $TEST ] 使用-n时最好使用\u0026quot;\u0026ldquo;将变量扩起来, 否则会测试随后空格, 返回值永为真 1 2 3 4 5 6 $ [ -n ] \u0026amp;\u0026amp; echo Y || echo N Y $ [ -n $Jacob ] \u0026amp;\u0026amp; echo Y || echo N Y $ [ -n \u0026#34;$Jacob\u0026#34; ] \u0026amp;\u0026amp; echo Y || echo N N 2.3 整数的判断与比较 表2-1 整数的比较运算符\n1 $ test 3 -eq 3 \u0026amp;\u0026amp; echo Y || echo N 2.4 文件属性的判断与比较 更多文件属性操作符可以参考命令帮助手册（man test）\n表2-2 文件属性操作符\n1 2 $ [ ! -e docs ] \u0026amp;\u0026amp; echo 对 || echo 错 错 在测试权限时需要注意，超级管理员root在没有rw权限的情况下，也是可以读写文件的，rw权限对超级管理员是无效的。但是如果文件没有x权限，哪怕是root也不 可以执行该文件。\n2.5 探究[[]]和[]的区别 多数情况下[]和[[]]是可以通用的，两者的主要差异是：test或[]是符合POSIX标准的测试语句，兼容性更强，几乎可以运行在所有Shell解释器中，相比较而言 [[]]仅可运行在特定的几个Shell解释器中（如Bash、Zsh等）。事实上，目前支持使用[[]]进行条件测试的解释器已经足够多了。使用[[]]进行测试判断时甚至 可以使用正则表达式。\n在[[]]中使用\u0026lt;和\u0026gt;符号时，系统进行的是排序操作，而且支持在测试表达式内使用\u0026amp;\u0026amp;和||符号。在test或[]测试语句中不可以使用\u0026amp;\u0026amp;和||符号。\n[[]]中的表达式如果使用\u0026lt;或\u0026gt;进行排序比较，使用的是本地的locale语言顺序。可以使用LANG=C设置在排序时使用标准的ASCII码顺序。 1 2 $ LANG=C $ [[ b \u0026gt; A ]] \u0026amp;\u0026amp; echo Y || echo N 虽然[]也支持同时进行多个条件的逻辑测试，但是在[]中需要使用-a和-o进行逻辑与和逻辑或的比较操作，而[[]]中可以直接使用\u0026amp;\u0026amp;和||进行逻辑比较操作，更直 观，可读性更好。\n1 2 $ [ yes == y -a no == no ] \u0026amp;\u0026amp; echo Y || echo N $ [[ yes == y \u0026amp;\u0026amp; no == no ]] \u0026amp;\u0026amp; echo Y || echo N 在[[]]中==是模式匹配，模式匹配允许使用通配符。例如，Bash常用的通配符有*、? 、[…]等。而==在test语句中仅代表字符串的精确比较，判断字符串是否一模 一样。\n1 2 3 4 5 $ name=Jacob $ [[ $name == J* ]] \u0026amp;\u0026amp; echo Y || echo N Y $ [[ $name == J?cob ]] \u0026amp;\u0026amp; echo Y || echo N Y 在[[]]中还支持使用=～进行正则匹配，而在[]中则完全不支持正则匹配\n1 2 3 $ name=\u0026#34;welcome to beijing\u0026#34; $ [[ $name =~ w ]] \u0026amp;\u0026amp; echo Y || echo N Y [[]]支持分组测试()(类似数学计算中的括号), 仅部分shell的[]支持()\n1 2 $ [[ a == a \u0026amp;\u0026amp; (b == b || c == d) ]] \u0026amp;\u0026amp; echo Y || echo N Y 表2-3 [[]]和[]的对比\n2.6 实战案例：系统性能监控脚本 2.7 实战案例：单分支if语句 1 2 3 4 5 6 7 8 if cond then cmd fi if cond; then cmd fi 任何有退出码的命令都可以写在if后面\n1 2 3 if grep -q AMD /proc/cpuinfo; then echo \u0026#34;AMD CPU\u0026#34; fi 2.8 实战案例：双分支if语句 1 2 3 4 5 if cond; then cmd else cmd fi 2.9 实战案例：如何监控HTTP服务状态 2.10 实战案例：多分支if语句 1 2 3 4 5 6 7 if cond; then cmd elif cond; then cmd else cmd fi 2.11 实战案例：简单、高效的case语句 1 2 3 4 5 6 7 8 9 case word in 模式1） 命令序列1; ; 模式2） 命令序列2; ; ...... ＊） 命令序列n; ; esac 1 2 3 4 5 6 7 8 9 case word in 模式1|模式2|模式3） 命令序列1; ; 模式4|模式5|模式6） 命令序列2; ; ... ... *） 命令序列n; ; esac word关键字展开支持使用~（根目录）、变量展开$、算术运算展开$[]、命令展开$()等。每个模式匹配中也都支持与word关键字一样的展开功能。 如果命令序列的最后使用了;;（双分号），则case命令不再对后续的模式进行匹配比较，即匹配停止。 如果使用;\u0026amp;替代;;会导致case继续执行下一个模式匹配中附加的命令序列。 如果使用;;\u0026amp;替代;;则会导致case继续对下一个模式进行匹配，如果匹配则执行对应命令序列中的命令。 2.12 实战案例：编写Nginx启动脚本 2.13 揭秘模式匹配与通配符、扩展通配符 表2-7 通配符\n使用shopt命令将Shell的extglob控制选项开启，则在Shell中可以支持如表2-8所示的扩展通配符。\n1 2 3 4 # 开启选项 $ shopt -s extglob # 关闭选项 $ shopt -u extglob 表2-8 扩展通配符\n2.14 Shell小游戏之石头剪刀布 ","permalink":"https://jdxj.github.io/posts/books/linux-shell%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/%E7%AC%AC2%E7%AB%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%84%9A%E6%9C%AC/","summary":"2.1 智能化脚本的基础之测试 条件判断的方式 [[ expr ]] [ expr ] test expr 不管使用哪种方式进行条件判断，系统默认都不会有任何输出结果，可以通过echo $?命令，","title":"第2章 人工智能, 很人工, 很智能的脚本"},{"content":"数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。\n随机访问 数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。\n低效的“插入”和“删除” 需要保证顺序时的情况\n插入\n最好, 在末尾插入, O(1) 最坏, 在开头插入, O(n) 平均, O(n) 删除\n最好, 在末尾删除, O(1) 最坏, 在开头删除, O(n) 平均, O(n) ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%95%B0%E7%BB%84/","summary":"数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 随机访问 数组支持随机访问，根据下标随机访问的时","title":"数组"},{"content":"封装（Encapsulation） 仅暴露必要的操作\n抽象（Abstraction） 只关注功能点不关注实现的设计思路\n继承（Inheritance） 复用代码\n多态（Polymorphism） 提高代码的可扩展性和复用性\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7/","summary":"封装（Encapsulation） 仅暴露必要的操作 抽象（Abstraction） 只关注功能点不关注实现的设计思路 继承（Inheritance","title":"面向对象四大特性"},{"content":"sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况。\n1 $ apt install sysbench 使用\n1 2 # 以10个线程运行5分钟的基准测试，模拟多线程切换的问题 $ sysbench --threads=10 --max-time=300 threads run ","permalink":"https://jdxj.github.io/posts/cmd/sysbench/","summary":"sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况。 1 $ apt install sysbench 使用 1 2 # 以10个线程运行5分钟的基准测试，模拟多线程切","title":"sysbench"},{"content":"pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。\n使用\n1 2 3 4 # 间隔5秒后输出一组数据 $ pidstat -u 5 1 13:37:07 UID PID %usr %system %guest %wait %CPU CPU Command 13:37:12 0 2962 100.00 0.00 0.00 0.00 100.00 1 stress 1 2 3 4 5 6 7 8 # 每隔5秒输出1组数据 $ pidstat -w 5 Linux 4.15.0 (ubuntu) 09/23/18 _x86_64_ (2 CPU) 08:18:26 UID PID cswch/s nvcswch/s Command 08:18:31 0 1 0.20 0.00 systemd 08:18:31 0 8 5.40 0.00 rcu_sched ... cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数 自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。 nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数 非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下 文切换。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 每隔1秒输出1组数据（需要 Ctrl+C 才结束） # -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标 $ pidstat -w -u 1 08:06:33 UID PID %usr %system %guest %wait %CPU CPU Command 08:06:34 0 10488 30.00 100.00 0.00 0.00 100.00 0 sysbench 08:06:34 0 26326 0.00 1.00 0.00 0.00 1.00 0 kworker/u4:2 08:06:33 UID PID cswch/s nvcswch/s Command 08:06:34 0 8 11.00 0.00 rcu_sched 08:06:34 0 16 1.00 0.00 ksoftirqd/1 08:06:34 0 471 1.00 0.00 hv_balloon 08:06:34 0 1230 1.00 0.00 iscsid 08:06:34 0 4089 1.00 0.00 kworker/1:5 08:06:34 0 4333 1.00 0.00 kworker/0:3 08:06:34 0 10499 1.00 224.00 pidstat 08:06:34 0 26326 236.00 0.00 kworker/u4:2 08:06:34 1000 26784 223.00 0.00 sshd 1 2 3 4 5 6 7 8 9 10 11 # 每隔1秒输出一组数据（需要 Ctrl+C 才结束） # -wt 参数表示输出线程的上下文切换指标 $ pidstat -wt 1 08:14:05 UID TGID TID cswch/s nvcswch/s Command ... 08:14:05 0 10551 - 6.00 0.00 sysbench 08:14:05 0 - 10551 6.00 0.00 |__sysbench 08:14:05 0 - 10552 18911.00 103740.00 |__sysbench 08:14:05 0 - 10553 18915.00 100955.00 |__sysbench 08:14:05 0 - 10554 18827.00 103954.00 |__sysbench ... ","permalink":"https://jdxj.github.io/posts/cmd/pidstat/","summary":"pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。 使用 1 2 3 4 # 间隔5秒后输出一组数据 $ pidstat -u 5","title":"pidstat"},{"content":"mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。\n使用\n1 2 3 4 5 6 7 # -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据 $ mpstat -P ALL 5 Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU) 13:30:06 CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 13:30:11 all 50.05 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 49.95 13:30:11 0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 13:30:11 1 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 ","permalink":"https://jdxj.github.io/posts/cmd/mpstat/","summary":"mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。 使用 1 2 3 4 5 6 7 # -P ALL 表示监控所有CPU，后面数字5","title":"mpstat"},{"content":"vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。\n1 2 3 4 5 # 每隔5秒输出1组数据 $ vmstat 5 procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 7005360 91564 818900 0 0 0 0 25 33 0 0 100 0 0 cs（context switch）是每秒上下文切换的次数。 in（interrupt）则是每秒中断的次数。 r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。 b（Blocked）则是处于不可中断睡眠状态的进程数。 ","permalink":"https://jdxj.github.io/posts/cmd/vmstat/","summary":"vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。 1 2 3 4 5 # 每隔5秒输出1组数据 $ vmstat 5","title":"vmstat"},{"content":"进行竞争CPU也会导致负载升高\nCPU上下文\n寄存器 程序计数器(Program Counter, PC) CPU 上下文切换，就是先把前一个任务的 CPU 上下文保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行 新任务。\n而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。\n操作系统管理的“任务”\n进程 线程 中断 根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景\n进程上下文切换 线程上下文切换 中断上下文切换 进程上下文切换 进程上下文切换，是指从一个进程切换到另一个进程运行\n内核空间（Ring 0）具有最高权限，可以直接访问所有资源； 用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。 从用户态到内核态的转变，需要通过系统调用来完成, 这个过程会发生CPU上下文切换. 系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用 户空间继续运行进程, 也会发生CPU上下文切换.\n系统调用过程通常称为特权模式切换，而不是上下文切换。但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的。\n进程上下文切换 vs 系统调用\n进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、 寄存器等内核空间的状态。 Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变 慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。\n进程在什么时候触发调度(切换上下文)\n某个进程终止 时间片耗尽 进程所需系统资源不足 进程通过sleep挂起 优先级更高的进程运行 硬件中断 线程上下文切换 线程与进程最大的区别在于，线程是调度的基本单位，而进程则是资源拥有的基本单位。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线 程提供了虚拟内存、全局变量等资源。\n当进程只有一个线程时，可以认为进程就等于线程。 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。 线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。 线程的上下文切换其实就可以分为两种情况\n前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。 前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。 中断上下文切换 跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局 变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。\n对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行， 所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。\n观察中断\n1 2 3 4 5 6 # -d 参数表示高亮显示变化的区域 $ watch -d cat /proc/interrupts CPU0 CPU1 ... RES: 2450431 5279697 Rescheduling interrupts ... 重调度中断（RES），这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制， 通常也被称为处理器间中断（Inter-Processor Interrupts，IPI）。\n每秒上下文切换多少次才算正常\n这个数值其实取决于系统本身的 CPU 性能。在我看来，如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过 一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。\n这时，你还需要根据上下文切换的类型，再做具体分析\n自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题； 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈； 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/cpu/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/","summary":"进行竞争CPU也会导致负载升高 CPU上下文 寄存器 程序计数器(Program Counter, PC) CPU 上下文切换，就是先把前一个任务的 CPU 上下文保存起来，然后加载新","title":"上下文切换"},{"content":"sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。\n1 $ apt install sysstat 包含的命令\nmpstat pidstat ","permalink":"https://jdxj.github.io/posts/cmd/sysstat/","summary":"sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。 1 $ apt install sysstat 包含的命令 mpstat pidstat","title":"sysstat"},{"content":"stress 是一个 Linux 系统压力测试工具\n1 $ apt install stress 使用\n1 2 3 $ stress --cpu 1 --timeout 600 $ stress -i 1 --timeout 600 $ stress -c 8 --timeout 600 ","permalink":"https://jdxj.github.io/posts/cmd/stress/","summary":"stress 是一个 Linux 系统压力测试工具 1 $ apt install stress 使用 1 2 3 $ stress --cpu 1 --timeout 600 $ stress -i 1 --timeout 600 $ stress -c 8 --timeout 600","title":"stress"},{"content":"一、股民常犯的错 毫无准备，仓促上阵 入市的准备应该是多方面的，包括规划资金、储备投资知识、了解目标股基本情况等。\n在买入标的上，优先选择流动性好、股价表现稳健的蓝筹股、白马股入手。在熟悉股市风格和个股股性后，再考虑买入更为激进的成长股、小盘股。科创板和新三板一 类本就有投资年限和资金门槛，即便具备了资格，也要对其抱有敬畏之心，多远观，不要随意“亵玩”。至于美股、港股和股指期货等高阶玩家的战场，新手最好回避。\n眼高手低，执迷于“快速致富” 盲目追求高收益只会导致短期行为，错误理解复利效应渴望每天一个涨停板更不可取。\n勇武有余，谋略不足 这体现在操作上，就是习惯于满仓甚至加杠杆杀进杀出，单独押宝单只个股。\n瞻前顾后，犹豫不决 首先，在观念上就不要总抱有买在最低点和卖在最高点这一不切实际的想法，能神奇逃顶抄底的永远只是传说，普通人不可能每次精准卡点。 其次，止盈止损都可以分批进行，分批卖出平滑收益或损失，避免一次性操作犯错后又后悔伤心。 第三，分批操作的依据应该结合基本面和技术面的变化，如估值过高、图形顶背离或跌破关键支撑时考虑卖出，估值合理、图形底背离或仍位于关键支撑之上时不必 急于马上止损。 无视风险，盲从他人 我国国情决定了券商轻易不会发看空研报，一般“中性”和“增持”的观点其实已经隐含了没那么看好个股后市的意思。\n多股评文章并非原创，都是在各个热点题材中找研报抄，找同行文章抄，这些人写的东西可能自己都不相信吧！\n所谓的小道消息，也就是深受散户喜欢的“内幕”，且不说是否属实，即便是真的，传到你那里也基本已是“八手消息”。路人皆知的利好一般发布在股价高位，也就是基 本涨到了找接盘侠接货的时候了。真正有价值的内幕必须是一手消息。而这又有违法违规之嫌，得是多愿意为你两肋插刀的好友会冒如此大风险给你送钱呢？\n二、解决办法 从基础知识学起，不管在现实生活中取得了多大的成就，都请以空杯心态进入这个对你而言全新的领域。建立良好的投资观，严格遵守纪律，做到知行合一。在股市中 慢就是快，只有耐得住寂寞才能守得住繁华。\n常反省错误，总结经验教训，在各类投资方法中选择适合自己的武器，打造自己的交易体系。唯有如此，才能离入门以及将来取得成功更进一步。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E5%BF%B5/%E7%AC%AC%E4%B8%83%E8%8A%82-%E6%96%B0%E6%89%8B%E8%82%A1%E6%B0%91%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/","summary":"一、股民常犯的错 毫无准备，仓促上阵 入市的准备应该是多方面的，包括规划资金、储备投资知识、了解目标股基本情况等。 在买入标的上，优先选择流动性好","title":"第七节 新手股民常犯的错误"},{"content":"一、何为好股 先拉一个“负面投资清单”，将爆出财务造假、业绩急速下滑、实控人或高管层道德品质瑕疵等丑闻的“雷股”，以及行业红利期已过、业绩常年表现不佳、高估值低分红 率的“渣股”，股价长期低位徘徊、成交量换手率明显过低、市场人气不足的“底部股”排除，A股上市公司中能选的标的就没那么多了。\n好行业 自古消费、医药出牛股，这些行业与人们的日常生活息息相关，茅台、格力、恒瑞等“名牌好股”已经持续强势多年。 在科技创新备受重视的当下，科技行业也不能忽视，这一领域可能会出现引领未来十年的好公司和新白马股。 而农业、军工、环境等行业中能持续走强的优质企业较少，和经营不透明、上市部分资产盈利能力弱、单一客户依赖性强、回款能力差等原因相关。 石油、煤钢、有色和化工等周期行业则容易受大经济周期和主营品种小周期等因素影响，股价容易急涨急跌、波动太大而不适合长期持有。 总的来说，好行业就是指那些国计民生需要、国家政策支持、日常经营可持续发展的行业。\n好赛道 在选定大行业后，还可以去挖掘小而美的细分赛道。一个好的赛道，除观察当前规模外，更要深挖其未来潜力及潜在市场。\n旧的赛道经过多年发展，新成员很难再有机会进入。龙头企业经过多年整合，市场份额占比大，经营环境稳定有序，行业话语权强，现金流稳定，每年提供可观的分 红。身骑白马可能跑得不是最快的，但一般会较稳。 而新赛道技术创新快，商业模式变革快，经常会出现新人颠覆旧人的现象。这种背景下选择那些跑得非常快的马，更容易在市场份额争夺战中成为赢家，赚取超额收 益。但参与黑马博弈需要更加谨慎——冷不丁会有马掉坑里或把腿摔断的情况。 好指标 很多质疑价值投资的人会问，财务造假怎么办？这一问题不可回避，但可以通过持续跟踪财务指标变化，定期检视关键指标勾稽关系，以及合理分配投资占比等办法来 解决或优化。此外，选择财务指标比较好的“优等生”至少比去买常年成绩不及格的“差等生”踩雷概率低。\n表1-5 2016—2020年ROE大于15%的上市公司\n好团队 一家优秀的企业离不开优秀的管理团队。 核心成员的道德风险也很重要。 好价格 因市场整体表现、经营环境及突发事件的变化，好股同样会发生股价的颠簸，有时调整的周期还会很长。在选股时，除基于财务指标等基本面分析外，还有必要参考技 术指标或信号。\n二、“长持”的正确姿势 首先是对长线的定义认识不准确。和高矮胖瘦一样，长短也是相对概念，每个人对长短线的定义和感知都会不同。一般而言，短线交易一般会在三五天内了结，今天买 明天卖的模式可谓之“超短”。\n要做好短线，必须对热点概念和题材有敏感而准确的把握，技术图形用5分钟、15分钟、30分钟或日线图来观察和分析。 而对企业业绩、基本面的分析则不是必要的——业绩对股价的影响除在季报、年报集中披露期较为明显外，多数时候两者关系有限。 其次，长持并不是一买了之，买完之后就可以高枕无忧。\n当宏观环境发生对企业根本不利的变化、护城河被竞争对手攻克、业绩被证伪或转为逐年下滑、市盈率飙涨到明显不合理的程度时，我们都应该对长持逻辑进行干预 和修正。 A股存在部分企业账务造假的问题，这要求我们必须对拟长期投资的公司进行密切跟踪和定期检视。如存货、应收账款、周转率和商誉等容易爆雷的指标亮起红灯时， 必须第一时间跟进和处理。 三、如何做到“静” “静”的前提必须是对个股基本面有深刻的认识 “静”还必须不断提高自己的学习和认知水平 四、收获盛开的复利之花 表1-6 初始投资10 000元的回报演练\n简单按财务指标，提取十年净利润增速平均高于25%、ROE高于20%，特殊年份（如2012年的白酒）股价回撤不超过20%的公司。近4000家上市企业中共有77家符合标 准，再剔除上市不足三年和股价波动异常的，剩下不到50只股票，如表1-7所示。\n表1-7 长期财务指标优异个股\n注：根据的是截至2020年5月底的数据。 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E5%BF%B5/%E7%AC%AC%E5%85%AD%E8%8A%82-%E5%A5%BD%E8%82%A1%E9%95%BF%E6%8C%81-%E9%9D%99%E5%BE%85%E8%8A%B1%E5%BC%80/","summary":"一、何为好股 先拉一个“负面投资清单”，将爆出财务造假、业绩急速下滑、实控人或高管层道德品质瑕疵等丑闻的“雷股”，以及行业红利期已过、业绩常年","title":"第六节 好股长持, 静待花开"},{"content":"一、投资和投机的区别 在英文语境中，投资（investment）本身就有买进买入的含义，投机可以被包括在广义的“投资”一词中；而投机（speculation）有沉思、思索、推测、猜测的语 义，本身不带价值判断色彩，更可以理解为是一种经过深思熟虑后，追求交易差价的投资行为。\n格老又在《聪明的投资者》一书中重新阐释了投机和投资的区别——他认为，两者之间最大的区别在于其对股市的态度。投机者的主要兴趣在于预测市场波动，并从中获 利；投资者的主要兴趣在于按合适的价格购买并长期持有合适的股票。\n二、部分股票或许只适合投机的原因 第一，A股牛短熊长，个股经常“坐过山车”。短促的牛市里不分好股、差股，股价都能暴涨。而在漫长的熊市里，很多股将长期下跌。如因追高套牢后自欺欺人骗自己 是“价值投资”，始终无法改变“解套思维”，无疑将白白浪费交易机会，极大降低资金效率。\n第二，“渣男股”太多，雷暴不断。\n蓝田 獐子岛 康美药业 第三，业绩和股价容易大幅波动的公司也尽量少做长持，突出的代表是有色、化工等周期股。\n华友钴业 第四，大量不分红低净资产回报率（ROE）的“铁公鸡”公司股票，不具备长持的逻辑基础。这类企业往往不仅利润质量差，而且盈利能力也很弱。\n紫鑫药业 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E5%BF%B5/%E7%AC%AC%E4%BA%94%E8%8A%82-%E5%A4%9A%E6%95%B0%E8%82%A1%E7%A5%A8%E6%88%96%E8%AE%B8%E5%8F%AA%E9%80%82%E5%90%88%E6%8A%95%E6%9C%BA/","summary":"一、投资和投机的区别 在英文语境中，投资（investment）本身就有买进买入的含义，投机可以被包括在广义的“投资”一词中；而投机（spec","title":"第五节 多数股票或许只适合投机"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/go/go-race-detector/","summary":"原文","title":"Introducing the Go Race Detector"},{"content":"大 O 复杂度表示法 1 2 3 4 5 6 7 8 int cal(int n) { int sum = 0; int i = 1; for (; i \u0026lt;= n; ++i) { sum = sum + i; } return sum; } T(n) = (2n+2)*unit_time\n1 2 3 4 5 6 7 8 9 10 11 int cal(int n) { int sum = 0; int i = 1; int j = 1; for (; i \u0026lt;= n; ++i) { j = 1; for (; j \u0026lt;= n; ++j) { sum = sum + i * j; } } } T(n) = (2n2+2n+3)*unit_time\nT(n) 表示代码执行的时间； n 表示数据规模的大小； f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。 公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度 （asymptotic time complexity），简称时间复杂度。\n当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。 时间复杂度分析 只关注循环执行次数最多的一段代码 第4, 5行 O(n) 1 2 3 4 5 6 7 8 int cal(int n) { int sum = 0; int i = 1; for (; i \u0026lt;= n; ++i) { sum = sum + i; } return sum; } 加法法则：总复杂度等于量级最大的那段代码的复杂度 sum_1: 100 sum_2: O(n) sum_3: O(n^2) 整段代码的时间复杂度就为O(n^2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int cal(int n) { int sum_1 = 0; int p = 1; for (; p \u0026lt; 100; ++p) { sum_1 = sum_1 + p; } int sum_2 = 0; int q = 1; for (; q \u0026lt; n; ++q) { sum_2 = sum_2 + q; } int sum_3 = 0; int i = 1; int j = 1; for (; i \u0026lt;= n; ++i) { j = 1; for (; j \u0026lt;= n; ++j) { sum_3 = sum_3 + i * j; } } return sum_1 + sum_2 + sum_3; } 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 ret: O(n) sum: O(n) cal: O(n^2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int cal(int n) { int ret = 0; int i = 1; for (; i \u0026lt; n; ++i) { ret = ret + f(i); } } int f(int n) { int sum = 0; int i = 1; for (; i \u0026lt; n; ++i) { sum = sum + i; } return sum; } 几种常见时间复杂度实例分析 非多项式量级 非多项式量级的算法问题叫作 NP, Non-Deterministic Polynomial\nO(2^n) O(n!) 多项式量级 O(1) 1 2 3 int i = 8; int j = 6; int sum = i + j; O(logn), O(nlogn) O(log_2 n)\n1 2 3 4 i=1; while (i \u0026lt;= n) { i = i * 2; } O(log_3 n)\n1 2 3 4 i=1; while (i \u0026lt;= n) { i = i * 3; } 如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。\nO(m+n), O(m*n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int cal(int m, int n) { int sum_1 = 0; int i = 1; for (; i \u0026lt; m; ++i) { sum_1 = sum_1 + i; } int sum_2 = 0; int j = 1; for (; j \u0026lt; n; ++j) { sum_2 = sum_2 + j; } return sum_1 + sum_2; } 空间复杂度分析 空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。\n只分配了new int[n]个空间, 复杂度为O(n)\n1 2 3 4 5 6 7 8 9 10 11 void print(int n) { int i = 0; int[] a = new int[n]; for (i; i \u0026lt;n; ++i) { a[i] = i * i; } for (i = n-1; i \u0026gt;= 0; --i) { print out a[i] } } 常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。\n内容小结 其他时间复杂度 最好情况时间复杂度（best case time complexity） 最坏情况时间复杂度（worst case time complexity） 平均情况时间复杂度（average case time complexity） 均摊时间复杂度（amortized time complexity） ","permalink":"https://jdxj.github.io/posts/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","summary":"大 O 复杂度表示法 1 2 3 4 5 6 7 8 int cal(int n) { int sum = 0; int i = 1; for (; i \u0026lt;= n; ++i) { sum = sum + i; } return sum; } T(n) = (2n+2)*unit_time 1 2 3 4 5 6 7 8 9 10 11 int cal(int n) { int sum = 0; int i = 1;","title":"复杂度分析"},{"content":"一、组合投资是平衡收益和风险的艺术 股票与其他投资品种一样，也是有风险的，其风险程度较存款、理财等防守型品种更大。股票投资的风险既包括市场整体下跌的系统性风险，还包括行业、个股的各类 黑天鹅事件。\n二、正确理解集中和分散的辩证统一 巴菲特对此曾有过经典论述：“分散投资是对无知者的保护，对于那些清楚自己在干什么的投资者，分散没有太多意义。”\n表1-4　2020年四季度伯克希尔·哈撒韦十大重仓股\n对新人的建议是根据资金体量大小\n10万元以内资金可购置3～5只个股进行组合 百万级别的资金可以适当买多一些，数量控制在6～10只为宜。 千万资金？炒股小白不应该拿这么多钱来练手，先考虑做资产配置吧！ ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E5%BF%B5/%E7%AC%AC%E5%9B%9B%E8%8A%82-%E8%82%A1%E7%A5%A8%E7%BB%84%E5%90%88%E6%8A%95%E8%B5%84%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/","summary":"一、组合投资是平衡收益和风险的艺术 股票与其他投资品种一样，也是有风险的，其风险程度较存款、理财等防守型品种更大。股票投资的风险既包括市场整体","title":"第四节 股票组合投资的必要性"},{"content":"制订资产配置计划，则是根据具体的理财目标配置不同比例的各类资产。\n一、主要资产分类 进攻型资产 进攻型资产大多是牺牲较多安全性和流动性来提高收益的产品，按照风险由大到小排序，主要包括：原油和商品期货、VC/PE等一级市场股权投资、股票和偏股型基金 等。\n稳定型资产 这类资产在牺牲部分流动性和小部分安全性的基础上尽可能提升收益，按照风险由大到小排序，主要包括：基金定投、信托、债券型基金、公募类REITs、理财、国债 等。\n防守型资产 按照收益由高到低排序，防守型资产主要包括定期存款、货币基金或现金管理类理财、活期存款、外汇、黄金和保险等。\n其中的黄金更是属于零息资产，本身没办法生息，却有较高的避险属性，这种避险属性能在经济、政治环境突发重大变化时起到缓冲作用。 同样是避险资产的美元和日元等，则可以在经济环境缺乏流动性时发挥作用，且安全性优于黄金。 而保险从某种角度来说是负息资产，通过牺牲收益率和流动性来降低遭遇风险后的损失。 二、资产配置的目标 资产配置目标应该与人生各阶段的所得和所需相结合，建议按所处的年龄层（生命周期）确定自己的资产配置目标，可分为三个时期。\n青年时期 踏入社会，开始赚工资的年轻人要学习自己打理资产。此时没有财富积累，每月结余也有限，却有“初生牛犊不怕虎”般的好奇心。学习如何理财的兴趣较浓，通常风险 偏好也比较高，可以通过基金定投这种形式每月进行投资。\n指数类基金是一个比较好的选择，可以理解为强制储蓄，建议初学者设置一个止盈目标位。 假如没有时间了解基金类产品，可以选择货币基金、债权类基金以及年金类保险，以季度、年度为单位进行强制储蓄。 如果极度保守，定期存款和国债就是更适合的投资工具。 很多学生初入大学就开启了财富之旅，建议通过债券型基金进行配置，可以兼顾流动性和安全性需求。 中年时期 事业渐入佳境后，收入增多，也相对稳定。但在上有老下有小的压力下，要维持一定水准的生活水平，需要在做好风险防控的前提下加大投资力度。\n该阶段可以将相对较多的资产放在股票、基金等权益型产品中，同时也要设置一些周期较长的“目标投资”，为未来的退休生活作准备。 具体可以选择那些长期风险低、收益稳健的产品，如养老目标FOF、专项基金定投和股债均衡的混合基金等。 同时，为了抗衡风险，有必要配置部分重疾险和意外险。 这个阶段，利用自己青年时期积累的知识和经验，均衡配置进攻型和稳定型资产，并开始逐渐增加保险等防守型资产。\n老年时期 赚钱已不再是第一要务，而应该享受承欢膝下的美好时光，并收获一生资产配置的成果。\n此阶段的消费需求逐渐减少，在资金安排上比较规律，尽量避免做股权、期货、股票和偏股型基金等高风险投资，可以选择中长期的固收类产品，同时可选择护理险、 意外险等保障类保险产品作为老年的风险保障补偿。 有些老年人考虑比较多的还有财富传承问题，这一目标可通过配置黄金、家族信托、终身寿险和保险金信托等实现。 对于这个时期的人群，自身的资产要以防守型和稳定型资产为主，其中保守型资产的结构也以流动性为首要考虑因素。\n三、各类人群的资产配比建议 职场新人 这类人有着“后浪”的锐气，特点是收入和积蓄有限，但因一人吃饱全家不饿，风险承受能力较强。\n图1-4　职场新人核心资产配置比例\n年轻就是资本，职场新人的核心资产配置可围绕“勇于尝试，积累经验”主题进行。\n将60%的资金投入股票或权益基金中，感受市场的残酷，在不断的成功和失败中积累经验，为未来的大额投资打下地基； 再将30%的资金投入偏债基金或进行基金定投，切身感受市场冷暖和经济周期对不同资产的影响，同时发挥基金定投强制储蓄的特性为自己的人生积累财富； 最后剩余10%的资金主要投资于货币型资产，一方面满足自己的日常消费，另一方面则用于提升自己的“硬件”——考证书、看书，学习各种技能。 中产“夹心层” “夹心层”人群的特点是在单位已有一定资历，但又还没站上领导岗位；家中上有老下有小，家庭开支压力较大。增加收入、防范未知风险和为未来谋划是“夹心层”群体 资产配置的核心需求。\n图1-5　中产“夹心层”核心资产配置比例\n用大约20%的家庭资产配置现金类资产和家庭保险 剩下的80%资产均衡地配置在进攻和稳定型资产中。 其中40%的进攻型资产要以股票和权益基金为主 40%的防守型资产均衡地配置在基金定投、债券型、“固收+”或理财等产品中。 所谓“固收+”，是指通过主投较低风险的债券等固定收益类资产构建一定的基础收益，同时辅以小部分权益资产来增强收益的基金，这部分增强收益的方式可以是通过 打新、定增、投资可转债或者二级市场股票等形式。在标准的基金分类中并没有所谓的“固收+”基金，“固收+”更多的是一个营销概念。但由于采取债券固收类为主、 权益为辅投资策略的产品普遍回撤都较小，客户体验好，于是人们就用“固收+”代指采取这种投资策略、回撤较小的基金。\n可以搜索\u0026quot;固收+\u0026ldquo;相关内容\n2021年，终于有人把固收+说清楚了！ 值得注意的是，此阶段无论是进攻型资产还是稳定型资产，在投资周期和期限上都要开始逐渐拉长。股票要以优质公司为主，只用小部分资产参与热点炒作，基金以长 期绩优稳定的主动管理基金为主。而稳定型资产，为未来养老、子女教育等特定目标设置的“专款账户”采用基金定投、偏债基金等波动较大的形式配置，迫在眉睫的短 期目标则尽量以理财、中短债等收益确定性高的产品为主。\n现金类资产以6～12个月日常生活所需的现金量为主，保险则以“保大不保小，保重不保轻”的原则配置。优先保障极端的情况，如重疾险和意外险，优先保障家庭中作 为主要经济来源的成员。另外需要注意，保险就要购买纯粹的保障性产品，不要选择那些把保障、投资、保值混为一谈的产品。冠以各类花名的万能险、分红险、投连 险等产品失去了保险的初心，且真实性价比并不如所宣传的那么高。\n全职美太太 这类人群的特点是有钱且有闲，缺少基本的投资知识却又总想“赚大钱”。这种心理可能和她们想向家人证明自己虽退出职场但依然有能力存在一定关系。\n图1-6　全职美太太核心资产配置比例\n把较多的资金投资于基金是为了充分借助基金经理的专业知识和投研能力，在牛市中帮自己抓住更多的热点，在熊市中减少进攻型资产的损失。如果是浸淫股市却依 然难以实现正收益的老股民，建议不要再炒股，而是通过偏股型基金实现“曲线救国”。 除了进攻型资产，“美太太”们还要用30%的资产均衡配置理财、债基等稳定型资产或定投基金，让自己的资产组合更加稳定。如果本身对风险比较厌恶的话，还可配 置一定比例（不超过10%）的黄金，提高资产组合的保值性和安全性。 最后一定要将20%的资产留作6～12个月的日常生活金，还要给在外辛苦赚钱的丈夫配置一份“爱的保障”——保险。 有钱老板 老板的特点是见识广、收入高，对资本市场有一定认识且风险承受能力强。但因发展事业奇缺时间，经常还有急需的大额资金缺口出现，所以资产配置时要保证充足的 流动性，进攻型资金可以往长持方向摆布。\n图1-7　有钱老板核心资产配置比例\n老板们首先可以拿出40%的资金配置大额存单、活期存款和货币基金等高流动性产品以备不时之需，同时要为自己这根家庭顶梁柱购买保险以提高家庭保障。 剩下的资产中，将40%左右的资金投资于进攻型资产，可以选择基金或者值得长持的好股，毕竟老板们都是大忙人，并没有太多工夫花费在短线炒作上。 稳定型资产以稳健的债券型基金和长期理财为主，建议少有时间管理账户的老板们减少指数基金定投的参与度，因为指数基金波动不小，不能及时止盈止损的话，很 容易频繁坐过山车。 近年来，定投指数基金这种“傻瓜式”的投资形式在财经媒体和财经博主的宣传下火爆“出圈”。但它其实并不像很多人臆想的那样，只要无脑坚持就能坐等收益。\n表1-3　定投沪深300指数基金收益情况\n图1-8　某中证500指数基金累计收益率波动统计\n所以指数定投建议采用适时止盈再定投的策略，即当收益达到目标收益后进行止盈，通过加大定投金额再投资来让收益最大化。\n退休族 该群体的特点是收入下滑但空暇增多，风险承受能力也开始降低。应围绕低风险、低波动和高流动性等关键词展开资产配置\n图1-9　退休族核心资产配置比例\n首先将资产中的30%用于配置流动性现金类资产，以备不时之需（看病、住院等）。 剩下70%的资金建立一个“固收+”组合 20%的股票或基金等进攻型资产加上50%的理财、债基、国债等稳定型固收资产。 这样即便出现极端的市场情况，股票、基金大亏40%，依靠固收类资产的稳定收益，也能把整个资产配置的损失降到5%以内。 最后，建议所有初学者，无论何种人群，无论处在哪个年龄阶段，在资产配置过程中都要尽可能少用杠杆。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E5%BF%B5/%E7%AC%AC%E4%B8%89%E8%8A%82-%E7%A8%B3%E5%81%A5%E8%87%B4%E5%AF%8C%E9%9C%80%E6%A0%91%E7%AB%8B%E8%B5%84%E4%BA%A7%E9%85%8D%E7%BD%AE%E7%90%86%E5%BF%B5-%E4%B8%8B/","summary":"制订资产配置计划，则是根据具体的理财目标配置不同比例的各类资产。 一、主要资产分类 进攻型资产 进攻型资产大多是牺牲较多安全性和流动性来提高收益的","title":"第三节 稳健致富需树立资产配置理念(下)"},{"content":"股票只是各大类资产中的一部分，要想稳健致富，需要依靠配置在各类市场环境中表现不一的资产，实现平滑风险、“东边不亮西边亮”的效果。\n过去很长一段时间里，普通人可投资品种匮乏。除了存款、理财和买房，似乎钱并没有其他太好的去处。而在房地产进入滞涨周期，世界各国不断降息齐步迈入负利率 时代的背景下，这样的配置结构显然不利于对抗通胀。\n图1-1　2019年各国居民资产配置结构\n图1-2　中国财富管理主要产品图谱\n一、资产配置理论简介 图1-3　美林投资时钟模型\n托宾教授“不要把鸡蛋放在同一个篮子”经典之语的后半句是“但也不要放在太多的篮子里”。\n资产配置绝不是让你分散投资同一品种，而是要在各大类资产中进行均衡配置，因为同一品种的资产往往有着较强的相关性，而不同的大类资产的相关性较弱甚至完全 相反。\n资产配置中所谓的相关性，是指两个投资标的在某段时间区间内的涨跌相似性（或者叫作关联程度）。 二、资产配置的基本准则 一是非法的东西不碰。 二是不懂的东西不碰。 三是安全性、收益性和流动性难以兼得。 表1-2　各类金融产品合理收益率\n四是风险应与自身相匹配。 ","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E5%BF%B5/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E7%A8%B3%E5%81%A5%E8%87%B4%E5%AF%8C%E9%9C%80%E6%A0%91%E7%AB%8B%E8%B5%84%E4%BA%A7%E9%85%8D%E7%BD%AE%E7%90%86%E5%BF%B5-%E4%B8%8A/","summary":"股票只是各大类资产中的一部分，要想稳健致富，需要依靠配置在各类市场环境中表现不一的资产，实现平滑风险、“东边不亮西边亮”的效果。 过去很长一段","title":"第二节 稳健致富需树立资产配置理念(上)"},{"content":"一、短线交易是“负和”游戏 “零和博弈”是博弈论（Game Theory）中的一个经典概念，意指参与博弈的各方，在残酷竞争下，一方的收益必然意味着另一方的损失，博弈各方的收益和损失相加 总和永远为0。\n买卖过程要收取印花税，券商和交易所还要收取各类佣金和费用\n表1-1　上海、深圳证券交易所各类交易税费对比\n所以，对短线交易者而言，炒股连零和交易都算不上，而是标准的“负和”游戏——随着交易次数的增多，买卖双方都可能沦为输家，稳赚不赔的只有税收部门、交易所和 券商。\n二、长线投资能实现共赢 股市零和博弈论者犯的是类似刻舟求剑的机械主义错误，他们将股票视为静态的商品，却忽视了股票背后企业的生命力，也就是股票代表的权益会随时间而变化。\n对于价值投资者而言，股市是一个正和博弈的场所。他们关注的是估值而不是单纯的股价，更注重价格与价值之间的偏离情况，以及公司未来的成长空间。当优质 白马龙头股的股价明显低于合理估值时，价值投资者就会择机介入，当估值存在泡沫时则会卖出。这一部分赚的同样是买卖价差的钱，但和频繁押大小赌博式的交易行 为有本质区别。\n","permalink":"https://jdxj.github.io/posts/books/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8-%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E5%BF%B5/%E7%AC%AC%E4%B8%80%E8%8A%82-%E8%82%A1%E5%B8%82%E5%B9%B6%E9%9D%9E%E9%9B%B6%E5%92%8C%E5%8D%9A%E5%BC%88/","summary":"一、短线交易是“负和”游戏 “零和博弈”是博弈论（Game Theory）中的一个经典概念，意指参与博弈的各方，在残酷竞争下，一方的收益必然意味","title":"第一节 股市并非零和博弈"},{"content":"平均负载 平均负载(load average)是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数\n可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。 CPU使用率 CPU使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。\nCPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的； I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高； 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。 ","permalink":"https://jdxj.github.io/posts/books/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/cpu/%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD/","summary":"平均负载 平均负载(load average)是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数 可运行状态的进程","title":"平均负载"},{"content":"3.1 链表和链表节点的实现 adlist.h/listNode\n1 2 3 4 5 6 7 8 typedef struct listNode { // 前置节点 struct listNode * prev; // 后置节点 struct listNode * next; //节点的值 void * value; }listNode; 图3-1 由多个listNode组成的双端链表\nadlist.h/list\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 typedef struct list { // 表头节点 listNode * head; // 表尾节点 listNode * tail; // 链表所包含的节点数量 unsigned long len; // 节点值复制函数 void *(*dup)(void *ptr); // 节点值释放函数 void (*free)(void *ptr); // 节点值对比函数 int (*match)(void *ptr,void *key); } list; 图3-2 由list结构和listNode结构组成的链表\nRedis的链表实现的特性\n双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O（1）。 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O（1）。 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O（1）。 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不 同类型的值。 3.2 链表和链表节点的API 表3-1 链表和链表节点API\n","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC3%E7%AB%A0-%E9%93%BE%E8%A1%A8/","summary":"3.1 链表和链表节点的实现 adlist.h/listNode 1 2 3 4 5 6 7 8 typedef struct listNode { // 前置节点 struct listNode * prev; // 后置节点 struct listNode * next; //节点的值 void * value; }listNode; 图3-1 由多个listNode组成的","title":"第3章 链表"},{"content":"2.1 SDS的定义 sds.h/sdshdr\n1 2 3 4 5 6 7 8 9 struct sdshdr { //记录buf数组中已使用字节的数量 //等于SDS所保存字符串的长度 int len; //记录buf数组中未使用字节的数量 int free; //字节数组，用于保存字符串 char buf[]; }; 图2-1 SDS示例\nlen不统计\\0 \\0由SDS函数自动处理 遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数 图2-2 带有未使用空间的SDS示例\n2.2 SDS与C字符串的区别 图2-3 C字符串\n2.2.1 常数复杂度获取字符串长度 获取C字符串的长度必须遍历整个字符串, 复杂度为O(N)\n图2-4 计算C字符串长度的过程\nSDS只要访问len属性即可\n图2-5 5字节长的SDS\n2.2.2 杜绝缓冲区溢出 C字符串不记录剩余空间, 拼接字符串会覆盖其后数据\n1 char *strcat(char *dest, const char *src); 图2-7 在内存中紧邻的两个C字符串\n1 strcat(s1, \u0026#34; Cluster\u0026#34;); 图2-8 S1的内容溢出到了S2所在的位置上\nSDS会检查剩余空间, 不足时会扩容\n1 2 // redis字符串拼接函数 sdscat(s, \u0026#34; Cluster\u0026#34;); 图2-9 sdscat执行之前的SDS\n图2-10 sdscat执行之后的SDS\n2.2.3 减少修改字符串时带来的内存重分配次数 空间预分配 修改后的len\u0026lt;1MB时, 会分配free=len的空闲空间 修改后的len\u0026gt;=1MB时, 会分配free=1MB的空闲空间 图2-11 执行sdscat之前的SDS\n1 sdscat(s, \u0026#34; Cluster\u0026#34;); 图2-12 执行sdscat之后SDS\n1 sdscat(s, \u0026#34; Tutorial\u0026#34;); 有足够空间, 无须内存分配\n图2-13 再次执行sdscat之后的SDS\n惰性空间释放 不立即释放空间, 使用free记录\n图2-14 执行sdstrim之前的SDS\n1 sdstrim(s, \u0026#34;XY\u0026#34;); //移除SDS字符串中的所有\u0026#39;X\u0026#39;和\u0026#39;Y\u0026#39; 图2-15 执行sdstrim之后的SDS\n有真正释放未使用空间的API\n2.2.4 二进制安全 C字符串以\\0来表示结束, 所以数据中不能包含\\0 SDS使用len来判断是否结束 图2-18 保存了特殊数据格式的SDS\n2.2.5 兼容部分C字符串函数 重用\u0026lt;string.h\u0026gt;\n1 2 strcasecmp(sds-＞buf, \u0026#34;hello world\u0026#34;); strcat(c_string, sds-＞buf); 2.2.6 总结 表2-1 C字符串和SDS之间的区别\n2.3 SDS API 表2-2 SDS的主要操作API\n2.4 重点回顾 Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS（Simple Dynamic String，简单动态字符串）作为字符串表示。 比起C字符串，SDS具有以下优点 常数复杂度获取字符串长度。 杜绝缓冲区溢出。 减少修改字符串长度时所需的内存重分配次数。 二进制安全。 兼容部分C字符串函数。 2.5 参考资料 ","permalink":"https://jdxj.github.io/posts/books/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC2%E7%AB%A0-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"2.1 SDS的定义 sds.h/sdshdr 1 2 3 4 5 6 7 8 9 struct sdshdr { //记录buf数组中已使用字节的数量 //等于SDS所保存字符串的长度 int len; //记录buf数组中未使用字","title":"第2章 简单动态字符串 Simple Dynamic String"},{"content":" 面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。 设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等） 的指导原则。 设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来 讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。 编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要 就是编程规范。 重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。 ","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E4%BA%94%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/","summary":"面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。 设计原则是","title":"面向对象、设计原则、设计模式、编程规范和代码重构五者之间的联系"},{"content":"设计思想、设计原则、设计模式一个最重要的应用场景就是在重构的时候。\n","permalink":"https://jdxj.github.io/posts/books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E4%BD%95%E6%97%B6%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","summary":"设计思想、设计原则、设计模式一个最重要的应用场景就是在重构的时候。","title":"何时应用设计模式"},{"content":"1.1 脚本文件的书写格式 多行注释, \u0026lt;\u0026lt;后的字符串区分大小写\n1 2 3 4 #!/usr/bin/env bash \u0026lt;\u0026lt;comment something comment 1.2 脚本文件的各种执行方式 脚本文件自身没有可执行权限 1 2 $ bash xxx.sh $ sh xxx.sh 脚本文件具有可执行权限 1 2 $ chmod +x xxx.sh $ xxx.sh 开启子进程执行的方式 不管是直接执行脚本，还是使用bash或sh这样的解释器执行脚本，都是会开启子进程的。\n不开启子进程的执行方式 1 2 $ source xxx.sh # 或者使用 . xxx.sh 1.3 如何在脚本文件中实现数据的输入与输出 使用echo命令创建一个脚本文件菜单 1 $ echo [选项] 字符串 1 2 3 4 5 6 7 8 9 10 11 12 #!/usr/bin/env bash #version:1.0 #这个脚本仅演示菜单输出，没有具体的功能实现 echo \u0026#34;这是一个打印菜单的例子\u0026#34; echo \u0026#34;1.查看网卡信息\u0026#34; echo \u0026#34;2.查看内存信息\u0026#34; echo \u0026#34;3.查看磁盘信息 4.查看CPU信息 5.查看账户信息\u0026#34; 表1-1 常见转义符号\n扩展知识，使用printf命令创建一个脚本菜单 1 $ printf [格式] 参数 表1-2 常用的格式字符串及功能描述\n1 2 3 $ printf \u0026#34;%d\u0026#34; 12 # 左对齐 $ printf \u0026#34;%-5d\u0026#34; 12 使用read命令读取用户的输入信息 1 $ read [选项] [变量名] 如果未指定变量名，则默认变量名称为REPLY 表1-3 read命令常用的选项\n1 2 3 4 $ read input1 input2 abc def $ echo $input1 $input2 abc def 1.4 输入与输出的重定向 标准输出的文件描述符为1 标准错误输出的文件描述符为2 标准输入的文件描述符则为0 分别重定向标准输出, 标准错误\n1 $ ls -l /etc/hosts /nofile \u0026gt; ok.txt 2\u0026gt; error.txt 重定向标准输出, 标准错误到同一个文件\n1 $ ls -l /etc/hosts /nofile \u0026amp;\u0026gt; test.txt 将标准错误重定向到标准输出或反过来\n1 $ ls /nofile 2\u0026gt;\u0026amp;1 图1-3 ls命令对比\n1 $ echo \u0026#34;hello\u0026#34; 1\u0026gt;\u0026amp;2 图1-4 echo命令对比\n1 $ ls /etc/passwd /nofile \u0026gt;test.txt 2\u0026gt;\u0026amp;1 图1-5 标准输出与错误输出\n输出黑洞/dev/null\n数据一旦导入黑洞将无法找回 用文件重定向输入\n1 $ mail -s warning root@localhosts \u0026lt; /etc/hosts 用\u0026lt;\u0026lt;(Here Document)重定向输入\n1 2 3 4 5 6 7 8 9 10 11 #!/usr/bin/env bash #语法格式: #命令 \u0026lt;\u0026lt; 分隔符 #内容 #分隔符 #系统会自动将两个分隔符之间的内容重定向传递给前面的命令，作为命令的输入。 #注意：分隔符是什么都可以，但前后分隔符必须一致。推荐使用EOF(end of file) mail -s warning root@localhost \u0026lt;\u0026lt; EOF This is content. This is a test mail for redirect. EOF 同时使用重定向输入, 重定向输出\n1 2 3 4 5 6 #!/usr/bin/env bash cat \u0026gt; /tmp/test.txt \u0026lt;\u0026lt; HERE 该文件为测试文件。 测试完后，记得将该文件删除。 Welcome to Earth. HERE 如果数据和EOF前有Tab, 可以用\u0026lt;\u0026lt;-来忽略Tab\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/usr/bin/env bash #不能屏蔽Tab键,缩进将作为内容的一部分被输出 #注意hello和world前面是tab键 cat \u0026lt;\u0026lt; EOF hello world EOF #Tab键将被忽略,仅输出数据内容 cat \u0026lt;\u0026lt;- EOF hello world EOF 1.5 各种引号的正确使用姿势 单引号与双引号 \u0026quot;\u0026quot; 引用一个整体 '' 引用一个整体 不解析特殊字符 \\ 不解析随后的一个特殊字符 命令替换 使用``\n1 $ tar -czf /root/log-`date +%Y%m%d`.tar.gz /var/log/ 使用$()\n1 $ echo \u0026#34;当前系统账户登录数量: $(who|wc -l)\u0026#34; 1.6 千变万化的变量 变量名由字母, 数字, _ 组成 不能用数字开头 赋值时=两边不能有空格. 表1-4 变量名示例\n使用$var或${var}方式读取变量值 删除变量\n1 2 $ test=123 $ unset test 表1-5 常见的系统预设变量\n1.7 数据过滤与正则表达式 1 $ grep [选项] 匹配模式 [文件] -i 忽略大小写 -v 取反匹配 -w 匹配单词 -q 静默匹配，不将结果显示在屏幕上 基本正则表达式（Basic Regular Expression） 表1-6 基本正则表达式及其含义\n扩展正则表达式（Extended Regular Expression） 表1-7 扩展正则表达式及其含义\ngrep命令默认不支持扩展正则表达式，需要使用grep -E或者使用egrep命令进行扩展正则表达式的过滤。\nPOSIX规范的正则表达式 表1-8 POSIX规范字符集\n1 $ grep \u0026#34;[[:digit:]]\u0026#34; /tmp/passwd GNU规范 \\b（边界字符，匹配单词的开始或结尾） \\B（与\\b为反义词，\\Bthe\\B不会匹配单词the，仅会匹配the在中间的单词，如atheist） \\w（等同于[_[:alnum:]]） \\W（等同于[^_[:alnum:]]） \\d表示任意数字 \\D表示任意非数字 \\s表示任意空白字符（空格、制表符等） \\S表示任意非空白字符 1 2 #匹配i结尾的单词 $ grep \u0026#34;i\\b\u0026#34; /tmp/passwd 1.8 各式各样的算术运算 整数运算\n$((expr)) $[expr] let expr 表1-9 常用运算符号\n1 $ echo $((2+4)) 使用let命令计算时，默认不会输出运算的结果，一般需要将运算的结果赋值给变量，通过变量查看运算结果。另外，使用let命令对变量进行计算时，不需要在变量 名前添加$符号。\n1 2 3 $ x=5 $ let x++ $ echo $x 非交互模式使用bc\n1 2 3 4 5 6 $ x=$(echo \u0026#34;(1+2)*3\u0026#34;|bc) $ echo $x $ $ echo \u0026#34;2+3; scale=2;8/19\u0026#34; | bc 5 .42 ","permalink":"https://jdxj.github.io/posts/books/linux-shell%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/%E7%AC%AC1%E7%AB%A0-%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B-%E8%B5%B7%E9%A3%9E%E4%BA%86/","summary":"1.1 脚本文件的书写格式 多行注释, \u0026lt;\u0026lt;后的字符串区分大小写 1 2 3 4 #!/usr/bin/env bash \u0026lt;\u0026lt;comment something comment 1.2 脚本文件的各种执行方式 脚本文件自身没有可执行权限 1 2 $","title":"第1章 从这里开始, 起飞了"},{"content":"原文\n普通代理\n代理服务器解析客户端req, 之后代理服务器向目标服务器发送该req 隧道代理\n代理服务器监听CONNECT方法, 之后转发客户端发来的tcp流量到目标服务器 ","permalink":"https://jdxj.github.io/posts/articles/imququ/http%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/","summary":"原文 普通代理 代理服务器解析客户端req, 之后代理服务器向目标服务器发送该req 隧道代理 代理服务器监听CONNECT方法, 之后转发客户端发来的","title":"HTTP 代理原理及实现（一）"},{"content":"原文\n少使用反射 优先使用 strconv 而不是 fmt 少量的重复不比反射差 慎用 binary.Read 和 binary.Write 避免重复的字符串到字节切片的转换 指定容器容量 行内拼接字符串推荐使用运算符+ 非行内拼接字符串推荐使用 strings.Builder strings.Builder.Grow() 遍历 []struct{} 使用下标而不是 range 使用空结构体节省内存 type Set map[string]struct{} ch := make(chan struct{}) type Door struct{} struct 布局要考虑内存对齐 将字段宽度从小到大由上到下排列，来减少内存的占用 当 struct{} 或空 array 作为结构体最后一个字段时，需要内存对齐 减少逃逸，将变量限制在栈上 小的拷贝好过引用 一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择返回指针。对于只读的占用内存较小的结构体，直接返回值能够获得更好的性能。 如果变量类型不确定，那么将会逃逸到堆上 sync.Pool 复用对象 并发情况采用无锁设计 CAS 串行无锁 分片减少锁竞争 优先使用共享锁而非互斥锁 限制协程数量 开销 内存开销 调度开销 GC开销 池化 使用 sync.Once 避免重复执行 使用 sync.Cond 通知协程 ","permalink":"https://jdxj.github.io/posts/articles/weixin/go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/","summary":"原文 少使用反射 优先使用 strconv 而不是 fmt 少量的重复不比反射差 慎用 binary.Read 和 binary.Write 避免重复的字符串到字节切片的转换 指定容器容量 行内拼接字符串推荐使用运算符+ 非行","title":"Go语言高性能编程手册"},{"content":"原文\n可用的简单配置\n# 禁用旧版本的有漏洞的 SSH 协议 # (旧版本的 sshd 默认允许新旧版本(2,1)的协议，新版本的 sshd 默认只接受新版本(2)的协议） Protocol 2 # 禁止使用密码登入（默认允许） # 注意：需先配置好有 root 权限的用户的公私钥对登入后再禁止密码登入， # 避免自己无法登入服务器，或使用低权限用户登入服务器后无法取得 root 权限。 PasswordAuthentication no # 禁止空密码账户登入（默认禁止） PermitEmptyPasswords no # 禁止 root 账户通过密码登入（默认允许） # （root 账户仍可以通过公私钥对登入，如果配置了的话） PermitRootLogin without-password # （新版本的 sshd 也支持使用更符合直觉的名字 prohibit-password） #PermitRootLogin prohibit-password # 或：禁止 root 账户通过 SSH 登入（默认允许） #PermitRootLogin no ","permalink":"https://jdxj.github.io/posts/articles/zzz/ssh%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/","summary":"原文 可用的简单配置 # 禁用旧版本的有漏洞的 SSH 协议 # (旧版本的 sshd 默认允许新旧版本(2,1)的协议，新版本的 sshd 默认只接受新版本(2)的协议） Protocol 2 #","title":"SSH 安全加固的一些措施"},{"content":"安装Docker Install Docker Engine on Debian 配置containerd\n1 2 3 4 $ containerd config default | tee /etc/containerd/config.toml \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 $ vim /etc/containerd/config.toml SystemdCgroup = true $ systemctl restart containerd 安装K8s 关闭交换\n1 2 $ swapoff -a $ vim /etc/fstab 官方安装教程\n容器运行时 安装 kubeadm 使用 kubeadm 创建集群 网络插件weave\nInstallation 允许控制平面调度pod\n1 $ kubectl taint nodes --all node-role.kubernetes.io/control-plane- bash补全\n启动 kubectl 自动补全功能 参考 如何用 Kubeadm 在 Debian 11 上安装 Kubernetes 集群 master节点部署Pod处于Pending状态 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/k8s/","summary":"安装Docker Install Docker Engine on Debian 配置containerd 1 2 3 4 $ containerd config default | tee /etc/containerd/config.toml \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 $ vim /etc/containerd/config.toml SystemdCgroup = true $ systemctl restart containerd 安装K8s 关闭交换 1 2 $ swapoff -a $ vim /etc/fstab 官方安装教","title":"安装K8s"},{"content":"延迟确认在很多 linux 机器上是没有办法关闭的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible) { struct tcp_sock *tp = tcp_sk(sk); /* More than one full frame received... */ if (((tp-\u0026gt;rcv_nxt - tp-\u0026gt;rcv_wup) \u0026gt; tp-\u0026gt;ack.rcv_mss /* ... and right edge of window advances far enough. * (tcp_recvmsg() will send ACK otherwise). Or... */ \u0026amp;\u0026amp; __tcp_select_window(sk) \u0026gt;= tp-\u0026gt;rcv_wnd) || /* We ACK each frame or... */ tcp_in_quickack_mode(tp) || /* We have out of order data. */ (ofo_possible \u0026amp;\u0026amp; skb_peek(\u0026amp;tp-\u0026gt;out_of_order_queue))) { /* Then ack it now */ tcp_send_ack(sk); } else { /* Else, send delayed ack. */ tcp_send_delayed_ack(sk); } } 需要立马回复 ACK 的场景\n如果接收到了大于一个frame 的报文，且需要调整窗口大小 处于 quickack 模式（tcp_in_quickack_mode） 收到乱序包（We have out of order data.） 其它情况一律使用延迟确认的方式\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4/","summary":"延迟确认在很多 linux 机器上是没有办法关闭的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible) { struct tcp_sock *tp = tcp_sk(sk); /* More than one full frame received... */ if (((tp-\u0026gt;rcv_nxt - tp-\u0026gt;rcv_wup) \u0026gt; tp-\u0026gt;ack.rcv_mss /* ...","title":"延迟确认"},{"content":"减少发送端频繁的发送小包给对方。\n算法思路\nif there is new data to send if the window size \u0026gt;= MSS and available data is \u0026gt;= MSS send complete MSS segment now else if there is unconfirmed data still in the pipe enqueue data in the buffer until an acknowledge is received else send data immediately end if end if end if ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/nagle/","summary":"减少发送端频繁的发送小包给对方。 算法思路 if there is new data to send if the window size \u0026gt;= MSS and available data is \u0026gt;= MSS send complete MSS segment now else if there is unconfirmed data still in the pipe enqueue data in the buffer until an acknowledge is received else send data immediately end if","title":"Nagle"},{"content":"拥塞窗口 Congestion Window，cwnd 拥塞窗口指的是在收到对端 ACK 之前自己还能传输的最大 MSS 段数。\nTCP 头部的 window 字段其实讲的接收窗口（rwnd）大小。 拥塞窗口初始值等于操作系统的一个变量 initcwnd，最新的 linux 系统 initcwnd 默认值等于 10。 真正的发送窗口大小 = 「接收端接收窗口大小」 与 「发送端自己拥塞窗口大小」 两者的最小值 拥塞处理 算法1: 慢启动 Slow Start 算法过程\n三次握手以后，双方通过 ACK 告诉了对方自己的接收窗口（rwnd）的大小，之后就可以互相发数据了 通信双方各自初始化自己的「拥塞窗口」（Congestion Window，cwnd）大小 cwnd 初始值较小时，每收到一个 ACK，cwnd + 1，所以每经过一个 RTT，cwnd 变为之前的两倍 拥塞窗口达到 N 所花费的时间公式为\n假设 RTT 为 50ms，客户端和服务端的接收窗口为65535字节（64KB），初始拥塞窗口为：10段，那么要达到 64KB 的吞吐量，拥塞窗口的段数 = 65535 / 1460 = 45 段，需要的 RTT 次数 = log2（45 / 10）= 2.12 次，需要的时间 = 50 * 2.12 = 106ms。也就是客户端和服务器之间的 64KB 的吞吐量，需要 2.12 次 RTT，100ms 左右的延迟。\n慢启动阈值 Slow Start Threshold，ssthresh ssthresh 就是一道刹车，让拥塞窗口别涨那么快。\n当 cwnd \u0026lt; ssthresh 时，拥塞窗口按指数级增长（慢启动） 当 cwnd \u0026gt; ssthresh 时，拥塞窗口按线性增长（拥塞避免） todo: ssthresh 的初始值哪里来的?\n算法2: 拥塞避免 Congestion Avoidance 在这个阶段，每一个往返 RTT，拥塞窗口大约增加1个 MSS 大小，直到检测到拥塞为止。\n实际的算法是\n每收到一个 ACK，将拥塞窗口增加一点点（1 / cwnd）: cwnd += 1 / cwnd 算法3: 快速重传 Fast Retransmit 快速重传的含义是：当接收端收到一个不按序到达的数据段时，TCP 立刻发送 1 个重复 ACK，而不用等有数据捎带确认，当发送端收到 3 个或以上重复 ACK，就 意识到之前发的包可能丢了，于是马上进行重传，不用傻傻的等到重传定时器超时再重传。\n选择确认 Selective Acknowledgment，SACK ack中携带已收到的包序号, 只重传丢失的包\n算法4: 快速恢复 Fast Recovery 当收到三次重复 ACK 时，进入快速恢复阶段。\n拥塞阈值 ssthresh 降低为 cwnd 的一半：ssthresh = cwnd / 2 拥塞窗口 cwnd 设置为 ssthresh 拥塞窗口线性增加 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/","summary":"拥塞窗口 Congestion Window，cwnd 拥塞窗口指的是在收到对端 ACK 之前自己还能传输的最大 MSS 段数。 TCP 头部的 window 字段其实讲的接收窗口（rwnd）大小。 拥塞","title":"拥塞控制"},{"content":"TCP 包状态分类 粉色部分#1 (Bytes Sent and Acknowledged)：表示已发送且已收到 ACK 确认的数据包。 蓝色部分#2 (Bytes Sent but Not Yet Acknowledged)：表示已发送但未收到 ACK 的数据包。发送方不确定这部分数据对端有没有收到，如果在一段时间内没有收到 ACK，发送端需要重传这部分数据包。 绿色部分#3 (Bytes Not Yet Sent for Which Recipient Is Ready)：表示未发送但接收端已经准备就绪可以接收的数据包（有空间可以接收） 黄色部分#4 (Bytes Not Yet Sent，Not Ready to Receive)：表示还未发送，且这部分接收端没有空间接收 发送窗口（send window）与可用窗口（usable window） 发送窗口是 TCP 滑动窗口的核心概念，它表示了在某个时刻一端能拥有的最大未确认的数据包大小（最大在途数据），发送窗口是发送端被允许发送的最大数据包大 小，其大小等于上图中 #2 区域和 #3 区域加起来的总大小 可用窗口是发送端还能发送的最大数据包大小，它等于发送窗口的大小减去在途数据包大小，是发送端还能发送的最大数据包大小，对应于上图中的 #3 号区域 窗口的左边界表示成功发送并已经被接收方确认的最大字节序号，窗口的右边界是发送方当前可以发送的最大字节序号，滑动窗口的大小等于右边界减去左边界。\nTCP Zero Window 零窗口探测包其实就是一个 ACK 包\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","summary":"TCP 包状态分类 粉色部分#1 (Bytes Sent and Acknowledged)：表示已发送且已收到 ACK 确认的数据包。 蓝色部分#2 (Bytes Sent but Not Yet Acknowledged)","title":"滑动窗口"},{"content":"Retransmission TimeOut，RTO\n计算RTO 经典方法 适用 RTT 波动较小的情况 取平均值 Smoothed round trip time，SRTT\nα 是平滑因子，建议值是0.8 ~ 0.9 SRTT = ( α * SRTT ) + ((1- α) * RTT) 超时重传时间 RTO 的计算公式\nβ 是加权因子，一般推荐值为 1.3 ~ 2.0 RTO = min(ubound, max(lbound, β * SRTT)) 标准方法（Jacobson / Karels 算法） 公式\nSRTT = (1 - α) * SRTT + α * RTT // 已平滑的 RTT 平均偏差估计器 round-trip time variation RTTVAR = (1 - β) * RTTVAR + β * (|RTT-SRTT|) RTO= µ * SRTT + ∂ * RTTVar 权重因子 α 的建议值是 0.125 平均偏差是标准方差的良好近似，计算较为容易，无需标准方差的求平方根运算。 β 取建议值 0.25 μ 建议值取 1，∂ 建议值取 4 这种算法下 RTO 与 RTT 变化的差值关系更密切，能对变化剧烈的 RTT做出更及时的调整。\n重传二义性与 Karn / Partridge 算法 Karn / Partridge 算法就是为了解决重传二义性的。它的思路也是很奇特，解决问题的最好办法就是不解决它：\n既然不能确定 ACK 包到底对应重传包还是非重传包，那这次就忽略吧，这次重传的 RTT 不会被用来更新 SRTT 及后面的 RTO 只有当收到未重传过的某个请求的 ACK 包时，才更新 SRTT 等变量并重新计算RTO Karn 算法采用了出现重传就将 RTO 翻倍的方法，指数级退避（Exponential backoff）。\n/proc/sys/net/ipv4/tcp_retries2 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0/","summary":"Retransmission TimeOut，RTO 计算RTO 经典方法 适用 RTT 波动较小的情况 取平均值 Smoothed round trip time，SRTT α 是平滑因子，建议值是0.8 ~ 0.9 SRTT = ( α * SRTT )","title":"超时重传"},{"content":"当发送端收到 3 个或以上重复 ACK，就意识到之前发的包可能丢了，于是马上进行重传，不用傻傻的等到超时再重传。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0/","summary":"当发送端收到 3 个或以上重复 ACK，就意识到之前发的包可能丢了，于是马上进行重传，不用傻傻的等到超时再重传。","title":"快速重传与SACK"},{"content":"SO_LINGER SO_LINGER 参数是一个 linger 结构体\n1 2 3 4 struct linger { int l_onoff; /* linger active */ int l_linger; /* how many seconds to linger for */ }; l_onoff 用来表示是否启用 linger 特性，非 0 为启用，0 为禁用 ，linux 内核默认为禁用。这种情况下 close 函数立即返回，操作系统负责把缓冲队 列中的数据全部发送至对端 l_linger 在 l_onoff 为非 0 （即启用特性）时才会生效 如果 l_linger 的值为 0，那么调用 close，close 函数会立即返回，同时丢弃缓冲区内所有数据并立即发送 RST 包重置连接 如果 l_linger 的值为非 0，那么此时 close 函数在阻塞直到 l_linger 时间超时或者数据发送完毕，发送队列在超时时间段内继续尝试发送，如果发送 完成则皆大欢喜，超时则直接丢弃缓冲区内容 并 RST 掉连接。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/socket-options/","summary":"SO_LINGER SO_LINGER 参数是一个 linger 结构体 1 2 3 4 struct linger { int l_onoff; /* linger active */ int l_linger; /* how many seconds to linger for */ }; l_onoff 用来表示是否启用 linger 特性，非 0 为启用，0 为禁用 ，linux 内核默认为禁","title":"Socket Options"},{"content":"端口未监听 断电丢失连接 设置SO_LINGER为true 如果设置 SO_LINGER 为 true，linger 设置为 0，当调用 socket.close() 时， close 函数会立即返回，同时丢弃缓冲区内所有数据并立即发送 RST 包 重置连接。\n参考SO_LINGER\n丢失RST 如果客户端收到了这个 RST，就会自然进入CLOSED状态释放连接。如果 RST 依然丢失，客户端只是会单纯的数据丢包了，进入数据重传阶段。如果还一直收不到 RST，会在一定次数以后放弃。\nConnection reset by peer 其实就是收到了RST\nBroken pipe 在一个 RST 的套接字继续写数据\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E5%B8%B8%E8%A7%81rst/","summary":"端口未监听 断电丢失连接 设置SO_LINGER为true 如果设置 SO_LINGER 为 true，linger 设置为 0，当调用 socket.close() 时， close 函数会立即返回，同时丢弃缓冲","title":"发生RST的情景"},{"content":"3.1 中间业务概述 什么是中间业务 商业银行的中间业务广义上是指“不构成商业银行表内资产、表内负债，形成银行非利息收入的业务”\n中间业务可以分成两大类：\n金融服务业务, 不形成或有资产、或有负债 表外业务。会形成或有资产、或有负债 所谓或有资产和或有负债，是指因过去的交易或事项，今后可望获得的资产和负债，也就是说或有资产和或有负债的产生具有不确定性。因此，在结果未发生前不能将 其计入银行的资产负债表，只能记录在表外。\n信用卡的未使用额度就属于或有资产 为其他公司提供的债务担保就属于或有负债 在金融服务业务中，商业银行是以代理人的身份为客户办理各种业务，并从中收取手续费。由于金融服务业务完全不产生任何资产，所以这一类业务是完全不承担风险 的，相应也不会产生任何减值需求。这类业务主要包括：\n清算结算业务 银行卡业务 代理业务 托管业务 咨询顾问业务等。 在表外业务中，虽然在业务发生时并不直接涉及资产负债表，但是这类业务与银行的资产业务和负债业务关系紧密，而且未来很可能由于某些条件触发转换为资产业务 和负债业务。这类业务主要包括：\n担保业务 承诺业务 金融衍生业务。 中间业务的优势 中间业务对于商业银行来说是非常重要的一项业务, 因为中间业务最大的特征是没有风险资产（金融服务类业务）或者风险资产很少（表外业务的或有资产有一定的折 算比例）。虽然中间业务的费率不高（通常是在0.5%～1%），办理时消耗的人力资源也很大，但是由于完全不消耗或者消耗极少的资本金，其依然是商业银行未来发 展的重要方向。\n发展中间业务的另外一个好处就是可以增加客户的黏性，不论是对公还是零售。\n对利润表影响较大的中间业务主要包括资管业务和代理业务。\n3.2 资管业务 金融市场发展的产物 资产管理业务（以下简称“资管业务”）是指证券、期货、基金等金融机构作为资产管理人，根据资产管理合同约定的方式、条件、要求及限制，对客户资产进行经营运 作，为客户提供证券及其他金融产品的投资管理服务，并从中收取一定的管理费甚至是提成。\n资管业务的内容 银行的资管业务主要包括通道业务、委托投资业务和理财业务。\n对于理财业务，就是我们常说的在银行购买理财产品。银行把募集的资金按照理财契约的规定投向某类资产，包括基金、债券、非标资产等。而在这个过程中，银行 要收取一定的管理费。 通道业务，起源于银行受限制于资本充足率或者监管的行业禁贷令而不得对某些客户提供信贷服务，那么这个时候，银行就会找第三方金融公司，可以是信托也可以 是券商，由第三方将贷款放给客户，然后将收益权包装成理财产品卖给最终的个人客户。 可以看到，这个操作和投资业务中的应收类投资很相似，唯一的区别是理财通道业务的负债和资产都不进入银行的资产负债表。银行在其中只收取管理费或手续费， 风险和收益都是由个人投资者承担。 委托投资业务，通常是委托行以委托理财服务的名义吸收个人客户的资金，然后以同业存款的方式投给受托行，之后再跟受托行签订一个“抽屉协议”，规定了受托行 必须将此笔资金投向指定的投资对象。 可以看到，通道业务和委托投资业务很多是为了绕开监管，这其中有一定的风险。 相对来说，在资管业务中，银行开展更多的还是理财业务。 对资管新规的解读 公募理财产品除了配置标准的债券和股票外可以在一些封闭型产品中配置非标产品，但是要求期限不得错配，且资金流向必须是国家支持的重点工程或者小微信贷。 理财产品必须打破刚兑，坚持净值型为主。但是在过渡期货币 类理财产品和6个月以上的定期开放产品可以参考货币基金的估值方法和摊余成本法，未来过渡期结束后对于封闭型理财产品可以继续使用摊余成本法。 拓宽了公募理财产品投资公募基金的范围。 单只公募理财的起售点从5万元降低到1万元。 对于过渡期结束后非标资产回表给予补充资本工具的支持。 3.3 代理业务 代理业务是代理人接受客户委托，以被代理人的名义代为办理其指定的经济事务的业务。\n代理业务和信托业务非常相似，其中最本质的差别是：\n在信托业务中，委托人需要将信托财产的财产权转移给受托人； 而在代理业务中，财产的权属是不发生转移的。 这一根本特征决定了在代理业务中，代理机构能够帮助被代理人执行的任务是相对简单的，以被代理人的提前授权为执行任务的基础。但是，正是由于代理业务不涉及 财产转移，银行相对来说承担的风险和连带责任就更小，可以说是无风险的业务。\n代理业务涉及的业务种类繁多，对银行的影响也不同，最常见的代理业务包括：\n代收代付业务 代理证券业务 代理保险业务 其他代理业务等。 代收代付业务对于银行的作用主要在于增加客户黏性，通过代发工资，代付水电、煤气、电话费，给客户节省时间，让更多的零售客户将主要资金账户留在银行。\n理证券业务包括第三方存管、债券承销、国债的代发代兑、代销基金等。代理证券业务对于银行来说具有两方面的意义：\n第一，可以给客户提供更加丰富的资产保值增值手段，这也是留住客户的一种策略。 第二，可以收取丰厚的手续费。 表3.1　2014—2018年招商银行基金、保险代销金额与手续费\n代理保险业务，也就是大家经常说的银保业务。保险公司通过银行的渠道销售保险，并支付给银行一定的回佣作为报酬。从表3.1中可以看到，代销保险的回佣远高于 代销基金。从2017年开始保监会明显加大了对银保渠道的监管力度，特别是开始强调保险的保障功能。以前在银保渠道畅销的红利险和万能险开始明显收缩，反映在 银行的财报上是这部分收入呈逐年萎缩的状态。但是，随着银行系保险公司的崛起，未来银保业务借着保险业快速发展的“东风”，依然会是银行中间业务收入的重要组 成部分。\n","permalink":"https://jdxj.github.io/posts/books/%E7%9C%8B%E9%80%8F%E9%93%B6%E8%A1%8C-%E6%8A%95%E8%B5%84%E9%93%B6%E8%A1%8C%E8%82%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC3%E7%AB%A0-%E9%93%B6%E8%A1%8C%E7%9A%84%E4%B8%AD%E9%97%B4%E4%B8%9A%E5%8A%A1/","summary":"3.1 中间业务概述 什么是中间业务 商业银行的中间业务广义上是指“不构成商业银行表内资产、表内负债，形成银行非利息收入的业务” 中间业务可以分成两大类","title":"第3章 银行的中间业务"},{"content":"Max Segment Lifetime MSL（报文最大生存时间）是 TCP 报文在网络中的最大生存时间。这个值与 IP 报文头的 TTL 字段有密切的关系。\nTTL: IP 报文最大可经过的路由数 Linux 的套接字实现假设 MSL 为 30 秒，因此在 Linux 机器上 TIME_WAIT 状态将持续 60秒。 TIME_WAIT 存在的原因 第一个原因是：数据报文可能在发送途中延迟但最终会到达，因此要等老的“迷路”的重复报文段在网络中过期失效，这样可以避免用相同源端口和目标端口创建新连接 时收到旧连接姗姗来迟的数据包，造成数据错乱。\n第二个原因是确保可靠实现 TCP 全双工终止连接。关闭连接的四次挥手中，最终的 ACK 由主动关闭方发出，如果这个 ACK 丢失，对端（被动关闭方）将重发 FIN，如果主动关闭方不维持 TIME_WAIT 直接进入 CLOSED 状态，则无法重传 ACK，被动关闭方因此不能及时可靠释放。\n可以想象为ack(4)马上就要到了, 但是发生了丢包.\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/msl/","summary":"Max Segment Lifetime MSL（报文最大生存时间）是 TCP 报文在网络中的最大生存时间。这个值与 IP 报文头的 TTL 字段有密切的关系。 TTL: IP 报文最大可经过的路由数 Linux 的套接字实","title":"MSL"},{"content":"原文\n修改内核参数的方法\n编辑/etc/sysctl.conf添加配置 执行sysctl -p立即生效 ","permalink":"https://jdxj.github.io/posts/articles/code2life/tcp%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/","summary":"原文 修改内核参数的方法 编辑/etc/sysctl.conf添加配置 执行sysctl -p立即生效","title":"Linux内核参数优化及原理"},{"content":"原文\n可以搜一下该文章的标题, 有很多与bbr相关的.\n","permalink":"https://jdxj.github.io/posts/articles/weixin/bbr%E5%88%86%E6%9E%90/","summary":"原文 可以搜一下该文章的标题, 有很多与bbr相关的.","title":"TCP拥塞控制及BBR原理分析"},{"content":"Debian11应该默认开启了, 验证\nlsmod | grep bbr #或成功则会出现类似的内容 tcp_bbr 20480 1 参考\nDebian11开启bbr ","permalink":"https://jdxj.github.io/posts/articles/ahlxjg/bbr/","summary":"Debian11应该默认开启了, 验证 lsmod | grep bbr #或成功则会出现类似的内容 tcp_bbr 20480 1 参考 Debian11开启bbr","title":"Debian11开启BBR"},{"content":"TFO 是在原来 TCP 协议上的扩展协议，它的主要原理就在发送第一个 SYN 包的时候就开始传数据了，不过它要求当前客户端之前已经完成过「正常」的三次握手。 快速打开分两个阶段：请求 Fast Open Cookie 和 真正开始 TCP Fast Open\n请求 Fast Open Cookie 的过程\n客户端发送一个 SYN 包，头部包含 Fast Open 选项，且该选项的Cookie 为空，这表明客户端请求 Fast Open Cookie 服务端收取 SYN 包以后，生成一个 cookie 值（一串字符串） 服务端发送 SYN + ACK 包，在 Options 的 Fast Open 选项中设置 cookie 的值 客户端缓存服务端的 IP 和收到的 cookie 值 第一次过后，客户端就有了缓存在本地的 cookie 值，后面的握手和数据传输过程如下\n客户端发送 SYN 数据包，里面包含数据和之前缓存在本地的 Fast Open Cookie。（注意我们此前介绍的所有 SYN 包都不能包含数据） 服务端检验收到的 TFO Cookie 和传输的数据是否合法。如果合法就会返回 SYN + ACK 包进行确认并将数据包传递给应用层，如果不合法就会丢弃数据包，走正常三次握手流程（只会确认 SYN） 服务端程序收到数据以后可以握手完成之前发送响应数据给客户端了 客户端发送 ACK 包，确认第二步的 SYN 包和数据（如果有的话） 后面的过程就跟非 TFO 连接过程一样了 TCP Fast Open 的优势\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tfo/","summary":"TFO 是在原来 TCP 协议上的扩展协议，它的主要原理就在发送第一个 SYN 包的时候就开始传数据了，不过它要求当前客户端之前已经完成过「正常」的三次握手。 快速","title":"TFO"},{"content":"用来解决 SYN Flood 攻击的，现在服务器上的 tcp_syncookies 都是默认等于 1，表示连接队列满时启用，等于 0 表示禁用，等于 2 表示始终启用。由 /proc/sys/net/ipv4/tcp_syncookies控制。\nSYN Cookie 机制其实原理比较简单，就是在三次握手的最后阶段才分配连接资源\n参考\n深入浅出TCP中的SYN-Cookies ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/syn-cookie/","summary":"用来解决 SYN Flood 攻击的，现在服务器上的 tcp_syncookies 都是默认等于 1，表示连接队列满时启用，等于 0 表示禁用，等于 2 表示始终启用。由 /proc/sys/net/","title":"SYN Cookie"},{"content":"客户端大量伪造 IP 发送 SYN 包，服务端回复的 ACK+SYN 去到了一个「未知」的 IP 地址，势必会造成服务端大量的连接处于 SYN_RCVD 状态，而服务器的 半连接队列大小也是有限的，如果半连接队列满，也会出现无法处理正常请求的情况。\n如何应对 SYN Flood 攻击\n调大net.ipv4.tcp_max_syn_backlog的值，不过这只是一个心理安慰，真有攻击的时候，这个再大也不够用。 重试次数由 /proc/sys/net/ipv4/tcp_synack_retries控制，默认情况下是 5 次，当收到SYN+ACK故意不回 ACK 或者回复的很慢的时候，调小这个值 很有必要。 tcp_syncookies ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/syn-flood/","summary":"客户端大量伪造 IP 发送 SYN 包，服务端回复的 ACK+SYN 去到了一个「未知」的 IP 地址，势必会造成服务端大量的连接处于 SYN_RCVD 状态，而服务器的 半连接队列大小也是有限的","title":"SYN Flood 攻击"},{"content":" 半连接队列（Incomplete connection queue），又称 SYN 队列 全连接队列（Completed connection queue），又称 Accept 队列 半连接队列（SYN Queue） 当客户端发起 SYN 到服务端，服务端收到以后会回 ACK 和自己的 SYN。这时服务端这边的 TCP 从 listen 状态变为 SYN_RCVD (SYN Received)，此 时会将这个连接信息放入「半连接队列」，半连接队列也被称为 SYN Queue，存储的是 \u0026ldquo;inbound SYN packets\u0026rdquo;。 服务端回复 SYN+ACK 包以后等待客户端回复 ACK，同时开启一个定时器，如果超时还未收到 ACK 会进行 SYN+ACK 的重传，重传的次数由 tcp_synack_retries 值确定。在 CentOS 上这个值等于 5。 一旦收到客户端的 ACK，服务端就开始尝试把它加入另外一个全连接队列（Accept Queue）。 半连接队列的大小与三个值有关\n用户层 listen 传入的backlog 系统变量 net.ipv4.tcp_max_syn_backlog，默认值为 128 系统变量 net.core.somaxconn，默认值为 128 全连接队列（Accept Queue） 包含了服务端所有完成了三次握手，但是还未被应用调用 accept 取走的连接队列。此时的 socket 处于 ESTABLISHED 状态。每次应用调用 accept() 函数会移除队列头的连接。如果队列为空，accept() 通常会阻塞。全连接队列也被称为 Accept 队列。\n如果全连接队列满，内核会舍弃掉 client 发过来的 ack（应用层会认为此时连接还未完全建立）\nSYN+ACK重传的次数是由操作系统的一个文件决定\ncat /proc/sys/net/ipv4/tcp_synack_retries 全连接队列的大小是 listen 传入的 backlog 和 somaxconn 中的较小值\nss命令\nss -lnt | grep :9090 State Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 51 50 *:9090 *:* 对于 LISTEN 状态的套接字，Recv-Q 表示 accept 队列排队的连接个数，Send-Q 表示全连接队列（也就是 accept 队列）的总大小。 多大的 backlog 是合适的 你如果的接口处理连接的速度要求非常高，或者在做压力测试，很有必要调高这个值 如果业务接口本身性能不好，accept 取走已建连的速度较慢，那么把 backlog 调的再大也没有用，只会增加连接失败的可能性 tcp_abort_on_overflow 参数 默认情况下，全连接队列满以后，服务端会忽略客户端的 ACK，随后会重传SYN+ACK，也可以修改这种行为，这个值由 /proc/sys/net/ipv4/tcp_abort_on_overflow决定。\n0表示三次握手最后一步全连接队列满以后 server 会丢掉 client 发过来的 ACK，服务端随后会进行重传 SYN+ACK。 1表示全连接队列满以后服务端直接发送 RST 给客户端。 回给客户端 RST 包会带来另外一个问题，客户端不知道服务端响应的 RST 包到底是因为「该端口没有进程监听」，还是「该端口有进程监听，只是它的队列 满了」。 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/","summary":"半连接队列（Incomplete connection queue），又称 SYN 队列 全连接队列（Completed connection queue），又称 Accept 队列 半连接队列（SYN Queu","title":"连接队列"},{"content":"原文\n学习要结合实践\n","permalink":"https://jdxj.github.io/posts/articles/plantegg/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%AD%A6%E4%B9%A0/","summary":"原文 学习要结合实践","title":"如何在工作中学习"},{"content":"完整的状态转换 三次握手的状态变化 同时打开的状态变化 自连接的状态变化 其实就是同时打开, 步骤5, 6在原文当中是window update包, 所以seq=1了.\n四次挥手的状态变化 同时关闭的状态变化 同时关闭原文和图有点不一致(TIME-WAIT), 这里应该看文字.\n最初客户端和服务端都处于 ESTABLISHED 状态 客户端发送 FIN 包，等待对端对这个 FIN 包的 ACK，随后进入 FIN-WAIT-1 状态 处于FIN-WAIT-1状态的客户端还没有等到 ACK，收到了服务端发过来的 FIN 包 收到 FIN 包以后客户端会发送对这个 FIN 包的的确认 ACK 包，同时自己进入 CLOSING 状态 继续等自己 FIN 包的 ACK 处于 CLOSING 状态的客户端终于等到了ACK，随后进入TIME-WAIT 在TIME-WAIT状态持续 2*MSL，进入CLOSED状态 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/","summary":"完整的状态转换 三次握手的状态变化 同时打开的状态变化 自连接的状态变化 其实就是同时打开, 步骤5, 6在原文当中是window update包, 所以s","title":"连接状态转换"},{"content":"MSS TCP 为了避免被发送方分片，会主动把数据分割成小段再交给网络层，最大的分段大小称之为 MSS（Max Segment Size）。\nMSS = MTU - IP header头大小 - TCP 头大小 MSS指TCP最大载荷的大小 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/mss/","summary":"MSS TCP 为了避免被发送方分片，会主动把数据分割成小段再交给网络层，最大的分段大小称之为 MSS（Max Segment Size）。 MSS = MTU - IP header头大小 -","title":"MSS"},{"content":"MTU 数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层，这个限制被称为「最大传输单元（Maximum Transmission Unit, MTU）」\nMTU是指整个IP数据报的大小 以太网帧格式\nIP分段 当一个 IP 数据包大于 MTU 时，IP 会把数据报文进行切割为多个小的片段(小于 MTU），使得这些小的报文可以通过链路层进行传输\nIP 头部中有一个表示分片偏移量的字段，用来表示该分段在原始数据报文中的位置\n路径 MTU 一个包从发送端传输到接收端，中间要跨越很多个网络，每条链路的 MTU 都可能不一样，这个通信过程中最小的 MTU 称为「路径 MTU（Path MTU）」。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/mtu/","summary":"MTU 数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层，这个限制被称为「最大传输单元（Maximum Transmission Unit, MTU）」 MTU是指整","title":"MTU"},{"content":" 可选项格式\n时间戳选项 TCP Timestamps Option，TSopt\n由4部分组成\n类别（kind） 长度（Length） 发送方时间戳（TS value） 回显时间戳（TS Echo Reply） 是否使用时间戳选项是在三次握手里面的 SYN 报文里面确定的。\n发送方发送数据时，将一个发送时间戳 1734581141 放在发送方时间戳TSval中 接收方收到数据包以后，将收到的时间戳 1734581141 原封不动的返回给发送方，放在TSecr字段中，同时把自己的时间戳 3303928779 放在TSval中 后面的包以此类推 Timestamps 选项的作用\n两端往返时延测量（RTTM） 序列号回绕（PAWS） 测量 RTTM 启用Timestamps选项后可以避免重传包无法计算rtt的问题.\nPAWS TCP 的窗口经过窗口缩放可以最高到 1GB（2^30)，在高速网络中，序列号在很短的时间内就会被重复使用。\n如果有 Timestamps 的存在，内核会维护一个为每个连接维护一个 ts_recent 值，记录最后一次通信的的 timestamps 值，在 t7 时间点收到迷途数据包 2 时，由于数据包 2 的 timestamps 值小于 ts_recent 值，就会丢弃掉这个数据包。等 t8 时间点真正的数据包 6 到达以后，由于数据包 6 的 timestamps 值大于 ts_recent，这个包可以被正常接收。\n","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-options/","summary":"可选项格式 时间戳选项 TCP Timestamps Option，TSopt 由4部分组成 类别（kind） 长度（Length） 发送方时间戳（TS value） 回显时间戳（T","title":"TCP Options"},{"content":" window size只有16位, 起初表示最大窗口为65535B 后来不够用就引入了TCP窗口缩放选项, 范围为0~14 0: 不缩放 !=0: 窗口大小为 windowSize * 2^n 窗口缩放在握手时指定 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-window-size/","summary":"window size只有16位, 起初表示最大窗口为65535B 后来不够用就引入了TCP窗口缩放选项, 范围为0~14 0: 不缩放 !=0: 窗口大小为 windowSize * 2^n 窗口缩放在","title":"TCP窗口大小"},{"content":" 这些标记可以组合使用，比如 SYN+ACK，FIN+ACK 等\nSYN（Synchronize）：用于发起连接数据包同步双方的初始序列号 ACK（Acknowledge）：确认数据包 RST（Reset）：这个标记用来强制断开连接，通常是之前建立的连接已经不在了、包不合法、或者实在无能为力处理 FIN（Finish）：通知对方我发完了所有数据，准备断开连接，后面我不会再发数据包给你了。 PSH（Push）：告知对方这些数据包收到以后应该马上交给上层应用，不能缓存起来 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp-flags/","summary":"这些标记可以组合使用，比如 SYN+ACK，FIN+ACK 等 SYN（Synchronize）：用于发起连接数据包同步双方的初始序列号 ACK（A","title":"TCP Flags"},{"content":"序列号 Sequence Number 序列号指的是本报文段第一个字节的序列号\n32位无符号整数 初始序列号 在建立连接之初，通信双方都会各自选择一个序列号，称之为初始序列号。在建立连接时，通信双方通过 SYN 报文交换彼此的 ISN\n初始序列号是如何生成的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 __u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr, __be16 sport, __be16 dport) { u32 hash[MD5_DIGEST_WORDS]; net_secret_init(); hash[0] = (__force u32)saddr; hash[1] = (__force u32)daddr; hash[2] = ((__force u16)sport \u0026lt;\u0026lt; 16) + (__force u16)dport; hash[3] = net_secret[15]; md5_transform(hash, net_secret); return seq_scale(hash[0]); } static u32 seq_scale(u32 seq) { return seq + (ktime_to_ns(ktime_get_real()) \u0026gt;\u0026gt; 6); } 代码中的 net_secret 是一个长度为16的 int 数组，只有在第一次调用 net_secret_init 的时时候会将将这个数组的值初始化为随机值。在系统重启前保 持不变。 可以看到初始序列号的计算函数 secure_tcp_sequence_number() 的逻辑是通过源地址、目标地址、源端口、目标端口和随机因子通过 MD5 进行进行计算。 如果仅有这几个因子，对于四元组相同的请求，计算出的初始序列号总是相同，这必然有很大的安全风险，所以函数的最后将计算出的序列号通过 seq_scale 函 数再次计算。 seq_scale 函数加入了时间因子，对于四元组相同的连接，序列号也不会重复了。 序列号回绕了怎么处理 1 2 3 4 static inline bool before(__u32 seq1, __u32 seq2) { return (__s32)(seq1-seq2) \u0026lt; 0; } 测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; func main() { var ( seq1 uint8 = 255 seq2 uint8 = 1 ) fmt.Println(\u0026#34;case1(未回绕):\u0026#34;) fmt.Printf(\u0026#34;befort: %t\\n\\n\u0026#34;, before(seq1, seq2)) seq1 = 255 seq2 = 128 fmt.Println(\u0026#34;case2(已回绕):\u0026#34;) fmt.Printf(\u0026#34;befort: %t\\n\u0026#34;, before(seq1, seq2)) } func before(seq1, seq2 uint8) bool { fmt.Printf(\u0026#34;seq1: %d, signed: %d\\n\u0026#34;, seq1, int8(seq1)) fmt.Printf(\u0026#34;seq2: %d, signed: %d\\n\u0026#34;, seq2, int8(seq2)) return int8(seq1-seq2) \u0026lt; 0 } 输出\ncase1(未回绕): seq1: 255, signed: -1 seq2: 1, signed: 1 befort: true case2(已回绕): seq1: 255, signed: -1 seq2: 128, signed: -128 befort: false 确认号 Acknowledgment Number 不是所有的包都需要确认的 不是收到了数据包就立马需要确认的，可以延迟一会再确认 ACK 包本身不需要被确认，否则就会无穷无尽死循环了 确认号永远是表示小于此确认号的字节都已经收到 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp%E5%BA%8F%E5%88%97%E5%8F%B7/tcp%E5%BA%8F%E5%88%97%E5%8F%B7/","summary":"序列号 Sequence Number 序列号指的是本报文段第一个字节的序列号 32位无符号整数 初始序列号 在建立连接之初，通信双方都会各自选择一个序列号，称之为初始序列号。","title":"TCP序列号/确认号"},{"content":" 不变部分为20B ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F/","summary":"不变部分为20B","title":"TCP头部格式"},{"content":" 面向连接 可靠 校验和 序列号解决乱序, 重复 超时重传 流量控制, 拥塞控制 基于字节流 全双工 ","permalink":"https://jdxj.github.io/posts/articles/jdxj/tcp/tcp%E7%89%B9%E7%82%B9/","summary":"面向连接 可靠 校验和 序列号解决乱序, 重复 超时重传 流量控制, 拥塞控制 基于字节流 全双工","title":"TCP的特点"},{"content":"9.1 TCP的低效率因素，以及HTTP TCP运行的基本方式会导致5个主要的问题，它们至少影响到了HTTP：\n有一个连接创建的延迟。要在连接开始时协商发送方和接收方可以使用的序列号。 TCP慢启动算法限制了TCP的性能，它小心翼翼地处理发送的数据量，以尽可能防止重传。 不充分使用连接会导致限流阈值降低。如果连接未被充分使用，TCP会将拥塞窗口的大小减小，因为它不确定在上个最优的拥塞窗口之后网络参数有没有发生变化。 丢包也会导致TCP的限流阈值降低。TCP认为所有的丢包都是由窗口拥堵造成的，但其实并不是。 数据包可能被排队。乱序接收到的数据包会被排队，以保证数据是有序的。 9.1.1 创建HTTP连接的延迟 图9.1　HTTPS连接所需要的TCP和HTTPS设置\n9.1.2 TCP拥塞控制对性能的影响 拥塞控制算法和概念增加了稳定性，但也带来了低效的问题\nTCP慢启动\n表9.1　常见的TCP慢启动增长\n图9.4　TCP慢启动到最佳容量的过程\n当达到最大容量之后，如果没有发生丢包，TCP拥塞控制就进入拥塞避免阶段，随后拥塞窗口还会持续增长，但会变成慢得多的线性增长, 直到它开始看到丢包，认为 到了最大容量\nTCP慢启动很慢吗\n因为TCP慢启动的指数增长特性，所以按大多数定义来说它并不慢。 尽量把东西放到前14KB中\n开始的10个TCP数据包（至少）会被如下消息使用：\n两个HTTPS响应（Server Hello和Change Spec） 两个HTTP/2 SETTINGS帧（服务器发送一个，另外一个用来确认客户端的SETTINGS帧） 一个HEADERS帧，响应第一个请求 表9.2　通常使用6个连接的TCP慢启动增长\n连接闲置降低性能\n在连接刚启动时和连接闲置时，TCP慢启动算法会导致延迟。TCP比较小心谨慎，在闲置一段时间后，网络情况可能发生变化，所以TCP将拥塞窗口大小降低，重新进行 慢启动流程，以再次找到最佳的拥塞窗口大小。\n丢包降低TCP性能\ntcp在遇到丢包时, 直接将拥塞窗口大小减半\n图9.6　TCP拥塞窗口大小受丢包影响\n丢包带来的影响在HTTP/2中尤其严重，因为它只使用单个连接。在HTTP/2的世界中，一次丢包会导致所有的资源下载速度变慢。而HTTP/1.1可能有6个独立的连接， 一次丢包只会减慢其中一个连接，但是另外5个不受影响。\n丢包会导致数据排队\n图9.7　同时传输多个响应\n图9.8　TCP重传一个HTTP/2帧的一部分\n如果没有发生其他的丢包，流7和流9会在重传的数据到来之前被完整接收。但这些响应必须排队，因为TCP要保证顺序，所以尽管已经完整下载，script.js和 image.jpg还不能被使用。\n图9.9　HTTP/1.1下TCP重传只影响需要重传的连接\nHTTP/2在HTTP层解决了队头阻塞（HOL）的问题，因为有多路复用，单个响应的延迟不会影响其他资源使用当前的HTTP连接。但是，在TCP层队头阻塞依然存在。 一个流的丢包会直接影响到其他所有的流，尽管它们可能不需要排队。\n9.1.3 TCP低效率因素对HTTP/2的影响 9.1.4 优化TCP 在Linux中，大多数TCP设置在如下路径中\n/proc/sys/net/ipv4 查看\ncat /proc/sys/net/ipv4/tcp_slow_start_after_idle 设置\nsysctl -w net.ipv4.tcp_slow_start_after_idle=0 提高初始拥塞窗口大小\n这个设置值通常被写死到内核代码中，所以除非升级操作系统，否则不建议修改。 支持窗口缩放\n在传统情况下，TCP所允许的最大拥塞窗口大小是65 535字节，但新版本中添加了缩放因子，理论上允许拥塞窗口最大到1GB。\ncat /proc/sys/net/ipv4/tcp_window_scaling 使用SACK\nSelective Acknowledgment /proc/sys/net/ipv4/tcp_sack 禁止重启慢启动\ncat /proc/sys/net/ipv4/tcp_slow_start_after_idle // 禁用 sysctl -w net.ipv4.tcp_slow_start_after_idle=0 使用TFO\nTCP Fast Open 出于安全的原因，这个数据包只能在TCP重连时使用，而不能在初次连接时使用，它同时需要客户端和服务端的支持。 图9.17　未使用TFO和使用了TFO的TCP和HTTPS重连握手\ncat /proc/sys/net/ipv4/tcp_fastopen 表9.5　TFO设置项的取值\necho \u0026#34;3\u0026#34; \u0026gt; /proc/sys/net/ipv4/tcp_fastopen 使用拥塞控制算法，PRR和BBR\nBBR是Google发明的，从Linux内核4.9版开始可以启用它，它不需要客户端支持。 9.1.5 TCP和HTTP的未来 9.2 QUIC 创建QUIC时考虑到了以下特性\n大量减少连接创建时间。 改善拥塞控制 。 多路复用，但不要带来队头阻塞。 前向纠错。 连接迁移。 FEC（Forward Error Correction，前向纠错）试图通过在邻近的数据包中添加一个QUIC数据包的部分数据来减少数据包重传的需求。这个想法是，如果只丢了 一个数据包，那应该可以从成功传送的数据包中重新组合出该数据包。\n连接迁移旨在减少连接创建的开销，它通过支持连接在网络之间迁移来实现。\n9.2.1 QUIC的性能优势 9.2.2 QUIC和网络技术栈\n图9.18　QUIC在HTTP技术栈中所处的位置\nQUIC不会替代HTTP/2，但它会接管传输层的一些工作，在上层运行较轻的HTTP/2实现。\n9.2.3 什么是UDP，为什么QUIC基于它 为什么不改进TCP\n主要缺点是此类改进的实施速度慢。 为什么不使用SCTP\nSCTP的采用率很低，这主要是因为到目前为止TCP已经足够好。因此，迁移到SCTP可能与升级TCP需要一样长的时间。 为什么不直接使用IP\n直接使用IP与直接使用SCTP具有相同的问题。该协议必须在操作系统级别实现，因为很少有应用程序可以直接访问IP数据包。 UDP的优点\nUDP是一种基础协议，也在内核中实现。在它之上的任何东西都需要在应用层中构建，也就是所说的用户空间。在内核之外构建，可以通过部署应用程序来实现快速创 新，无论是在服务端还是在客户端。\n图9.19　查看www.google.com上部署的QUIC版本\nQUIC会一直使用UDP吗\n9.2.4 标准化QUIC 两个版本的QUIC：gQUIC和iQUIC\ngQUIC（Google QUIC）和iQUIC（IETF QUIC） gQUIC和iQUIC的区别\n随着两个版本协议的发展，它们之间的区别会越来越大 Google使用自定义加密设计，而iQUIC使用TLSv1.3 QUIC标准\nQUIC Invariants —— QUIC中恒定不变的部分 QUIC Transport —— 核心传输协议 QUIC Recovery —— 丢包检测和拥塞控制 QUIC TLS —— QUIC中如何使用TLS加密 HTTP/3 —— 主要基于HTTP/2，但有一些不同 QUIC QPACK —— 使用QUIC的HTTP协议的首部压缩 需要注意的一点是，QUIC旨在成为一种通用的协议，HTTP只是它的一种用途。虽然HTTP目前是QUIC的主要用例，也是工作组目前正在关注的焦点，但该协议的设计 考虑了潜在的其他应用场景。\n9.2.5 HTTP/2和QUIC的不同 QUIC和HTTPS\nHTTPS内置于QUIC中，与HTTP/2不同，QUIC不能用于未加密的HTTP连接。做出这个选择的原因与HTTP/2相同，无论从实际使用上，还是人们的意愿上，只能通过 HTTPS进行Web浏览\n创建一个QUIC连接\n因为QUIC是基于UDP的，连接到Web服务器的浏览器必须先使用TCP连接，然后再升级到QUIC。这个过程就需要依赖基于TCP的HTTP，这就抵消了QUIC带来的一 个关键好处（大量减少连接创建时间）。有一些变通方法，比如同时尝试TCP和UDP，或者就接受第一次的性能损耗，并记住下次服务器使用QUIC。\nQPACK\nQUIC旨在消除连接层顺序传输数据包的要求，以允许流独立处理。HPACK仍然需要这种保证（至少对于HEADERS帧），因此它重新引入了队头阻塞，而这正是它试图 解决的问题。\n因此，HTTP/3需要有一种HPACK的变体，也就是QPACK（原因显而易见）。这个变体很复杂\n其他区别\n一些传输层协议的帧从HTTP/3层中被移除了（例如PING和WINDOW_UPDATE帧），移动到了核心QUIC-Transport层，这不是针对HTTP的（这是合理的，因为这些 帧很可能会用于基于QUIC的非HTTP协议）。\n9.2.6 QUIC的工具 9.2.7 QUIC实现 Caddy 9.2.8 你应该使用QUIC吗 与SPDY不同，gQUIC并未被更广泛的社区所接受，而且iQUIC似乎也不太可能现在被标准化。所以，除非你使用了Google Cloud Platform，否则不推荐你使用 QUIC。\n总结 在TCP和HTTPS层中，当前的HTTP网络栈存在若干低效率因素。 由于TCP的连接建立延迟和谨慎的拥塞控制算法，TCP连接达到最大容量需要时间，HTTPS握手会增加更多时间。 有一些创新可以解决这些低效问题，但它们的推出速度很慢，特别是TCP中的创新。 QUIC是一种基于UDP的新协议。 通过使用UDP，QUIC谋求比TCP创新的速度更快。 QUIC的创建基于HTTP/2，其使用了许多相同的概念，它是在原来的基础上再创新。 QUIC不仅适用于HTTP，它未来也可以用于其他协议。 基于QUIC的HTTP将被称为HTTP/3。 QUIC有两个版本：Google QUIC（gQUIC），当前有少量应用，但没有被标准化；IETF QUIC（iQUIC），正在标准化过程中。 在iQUIC被批准成为正式标准时，gQUIC将被取代，就像HTTP/2取代了SPDY。 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC4%E9%83%A8%E5%88%86-http%E7%9A%84%E6%9C%AA%E6%9D%A5/%E7%AC%AC9%E7%AB%A0tcp-quic-http3/","summary":"9.1 TCP的低效率因素，以及HTTP TCP运行的基本方式会导致5个主要的问题，它们至少影响到了HTTP： 有一个连接创建的延迟。要在连接开始时协","title":"第9章TCP, QUIC和HTTP/3"},{"content":" 如果不再严格要求只针对具体的请求响应推送，HTTP/2推送是否可以代替WebSockets或者SSE？ 当资源更新时，HTTP/2推送是否可以用来更新浏览器缓存？ 它可以用来改进渐进式JPEG吗？ 它可以用于API吗？ 是否会在其他场景中添加通知？ 总结 HTTP/2推送是HTTP/2中的一个新概念，它允许为一个请求返回多个响应。 HTTP/2推送被提议时，目的是作为内联关键资源的替代方案。 很多服务器和CDN通过使用HTTP link首部实现HTTP/2推送。 新的103状态码可用来更早提供link首部。 HTTP/2推送在客户端的实现方式可能没有那么显而易见。 很容易就会推送过多的内容，这会降低网站性能。 HTTP/2推送带来的性能提升可能没那么大，但是风险很高。 相较于使用推送，配合使用预加载和103状态码可能更好。 HTTP/2推送可能有其他应用场景，但有些需要更改协议。 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.9/","summary":"如果不再严格要求只针对具体的请求响应推送，HTTP/2推送是否可以代替WebSockets或者SSE？ 当资源更新时，HTTP/2推送是否可以","title":"5.9 HTTP/2推送的其他应用场景"},{"content":"图5.18　使用状态码103告诉Web服务器更早推送资源\n图5.19　使用带有preload首部的103状态码代替HTTP/2推送\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.8/","summary":"图5.18 使用状态码103告诉Web服务器更早推送资源 图5.19 使用带有preload首部的103状态码代替HTTP/2推送","title":"5.8 对比推送和预加载"},{"content":"高效使用HTTP/2推送的关键是利用连接未被使用时的空闲带宽。\n图5.17　HTTP/2推送的资源和主动请求的资源响应时间不同\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.7/","summary":"高效使用HTTP/2推送的关键是利用连接未被使用时的空闲带宽。 图5.17 HTTP/2推送的资源和主动请求的资源响应时间不同","title":"5.7 HTTP/2推送对性能的影响"},{"content":" 你在使用HTTP/2吗？ 你的服务器支持HTTP/2推送吗？ 你的服务器在其他基础架构之后吗？如果你的服务器之前有负载均衡器，或者其他中断HTTP/2连接的基础架构，则它可能不支持HTTP/2推送，尽管你的服务器本身 是支持的。就算它支持HTTP/2推送，它也有可能不会透传推送的资源，推送的资源应该由边缘节点处理。 服务器正在推送资源吗？可以使用nghttp查看具体的帧 页面需要这些资源吗？如果页面不需要这些资源，则浏览器不会使用它们 你在使用服务器支持的正确方式推送吗？如何推送取决于服务器。很多服务器使用HTTP link首部，但并不是所有的服务器都这么做 服务器是否明确指定不推送这个资源？ 要推送的资源存在吗？ 你是否在一个客户端预料之外的连接上推送？ 你在使用自签名的证书或者其他不受信任的证书吗？对于不受信任的HTTP证书（包含本机使用的自签名的虚假证书），Chrome忽略推送请求 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.6/","summary":"你在使用HTTP/2吗？ 你的服务器支持HTTP/2推送吗？ 你的服务器在其他基础架构之后吗？如果你的服务器之前有负载均衡器，或者其他中断HTT","title":"5.6 HTTP/2推送常见问题"},{"content":"5.5.1 你能推送什么 规范规定了一些HTTP/2推送的基本规则：\n在SETTINGS帧中将SETTINGS_ENABLE_PUSH设置为0，客户端可以禁用推送。此后，服务端不能使用PUSH_PROMISE帧。 推送请求必须使用可以缓存的方法（GET、HEAD和一些POST请求）。 推送请求必须是一些安全请求（通常为GET或者HEAD请求）。 推送请求不能包含请求体（但经常包含响应体）。 只将推送请求发送到权威服务器的域。 客户端不能推送，只有服务端可以。 资源可以在当前请求的响应中推送。如果没有请求，则服务端不可能发起一个推送。 由于这些规则，只有GET请求会被推送。\n5.5.2 应该推送什么 只有关键资源才应该被推送 应该推送很可能缓存里没有的资源。 5.5.3 自动化推送 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.5/","summary":"5.5.1 你能推送什么 规范规定了一些HTTP/2推送的基本规则： 在SETTINGS帧中将SETTINGS_ENABLE_PUSH设置为0，客户端可以","title":"5.5 推送什么"},{"content":"使用HTTP/2推送的风险是推送浏览器不需要的资源\n5.4.1 在服务端跟踪推送的资源 需要记状态, 比较复杂\n会遇到资源限制 负载均衡问题 5.4.2 使用HTTP条件请求 客户端发送一个if-modified-since或者etag首部，而引用这个CSS的页面已经在浏览器的缓存中，但已过期。\n5.4.3 使用基于cookie的推送 在客户端记录哪些资源已经被推送。cookie是做这个的理想载体，当然也可以使用LocalStorage和SessionStorage。\n5.4.4 使用缓存摘要 缓存摘要是一个提议，浏览器用它来告诉服务器缓存里有什么内容。当连接建立时，浏览器发送一个CACHE_DIGEST帧，列出当前域名（或者本连接授权的其他域名） 的HTTP缓存中的所有资源。\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.4/","summary":"使用HTTP/2推送的风险是推送浏览器不需要的资源 5.4.1 在服务端跟踪推送的资源 需要记状态, 比较复杂 会遇到资源限制 负载均衡问题 5.4.2 使用HTTP条件请","title":"5.4 如何实现条件推送"},{"content":"差速器锁\n为什么越野型汽车要配差速器锁？ 限滑差速器只能部分阻止车轮的差速，而对于强调越野性的车型来说，在越野时最好是将差速器锁死，使其完全失去差速作用。将差速器锁死的装置，称为差速器锁。 带有锁止功能的差速器，称为锁止式差速器。\n牙嵌入式差速锁构造图\n差速器锁功能示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E5%8A%A8%E7%B3%BB%E7%BB%9F/5.06/","summary":"差速器锁 为什么越野型汽车要配差速器锁？ 限滑差速器只能部分阻止车轮的差速，而对于强调越野性的车型来说，在越野时最好是将差速器锁死，使其完全失去","title":"5.06 差速器锁Differential Lock"},{"content":"为什么差速器会导致车轮打滑？ 四驱汽车差速器作用示意图\n什么是差速限制器？ 我们将用来限制差速器差速功能的装置，称为差速限制器。差速限制器根据行驶需要，将左右车轮或前后轴的转速差控制在一定范围之内，既保证车辆顺利转弯，又能 阻止车轮打滑。\n根据构造和原理不同，差速限制器可分为转矩感应型、转速感应型和电子限滑型等多种形式。虽然，实现限制差速的手段不同，但是最终目的都是一致的，都是在不需 要差速时限制差速器的差速功能，保证车辆正常行驶。\n差速器锁是差速限制器的极端装置，它使差速器完全失去差速功能，将原本可以差动的两轴硬性地连接在一起，以完全相同的转速转动，使差速为零。\n限滑差速器构造图\n什么是限滑差速器？ 在开放式差速器上装备差速限制器，如电控多片离合器、黏性耦合器等，以便在车轮打滑时对差速器的差速功能进行限制，阻止车轮继续打滑。通常我们把具备差速限 制功能的差速器，称为限滑差速器（Limited Slip Differential，缩写为LSD）。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E5%8A%A8%E7%B3%BB%E7%BB%9F/5.05/","summary":"为什么差速器会导致车轮打滑？ 四驱汽车差速器作用示意图 什么是差速限制器？ 我们将用来限制差速器差速功能的装置，称为差速限制器。差速限制器根据行驶","title":"5.5 差速限制器 Differential Limiter"},{"content":" 为什么汽车需要差速器？ 对于驱动轮来讲，由于左右两侧的车轮都接受来自发动机和变速器的同样的力，要想让它们在接受同样驱动力的情况下又能和谐运转，就需要一种装置来协调或吸收左 右两个驱动轮之间的转速差，这个装置就是差速器。\n差速器是怎样差速的？ 后差速器车上位置示意图\n轮间差速器工作原理示意图\n差速器\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E5%8A%A8%E7%B3%BB%E7%BB%9F/5.04/","summary":"为什么汽车需要差速器？ 对于驱动轮来讲，由于左右两侧的车轮都接受来自发动机和变速器的同样的力，要想让它们在接受同样驱动力的情况下又能和谐运转，","title":"5.4 差速器 Differential"},{"content":"传动轴和半轴起什么作用？ 发动机的动力经变速器调整，最后要传递到驱动轮上。如果是前置发动机、后轮驱动的车辆，要用一根传动轴将动力从车辆前部传递到后差速器上，再用半轴将动力从 后差速器一分为二传递到两个后轮上；如果是前置发动机、前轮驱动的车辆，前差速器和变速器整合在一起，只需要用两根半轴将动力从前差速器一分为二传递到两个 前轮上即可；如果是四轮驱动，基本是将上述两种方式进行整合，要用两根传动轴、四根半轴、三个差速器才能将动力分配到四个车轮上。\n后轮驱动汽车传动轴和半轴示意图\n标致汽车前驱车型前桥构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E5%8A%A8%E7%B3%BB%E7%BB%9F/5.03/","summary":"传动轴和半轴起什么作用？ 发动机的动力经变速器调整，最后要传递到驱动轮上。如果是前置发动机、后轮驱动的车辆，要用一根传动轴将动力从车辆前部传递","title":"5.3 传动轴和半轴 Drive Shaft and Half Shaft"},{"content":"为什么说离合器是动力开关？ 传动系统\n为了让发动机的动力能够平顺地传递到变速器，离合器必须采用摩擦方式进行接触，而不能采用刚性连接。因此，才出现了最常用的摩擦离合器。\n离合器的位置和作用示意图\n离合器工作原理\n离合器构造及液压操纵系统\n发动机和6速手动变速器\n![](https://res.weread.qq.com/wrepub/epub_26688761_260\n离合器工作原理\n离合器工作原理示意图\n膜片弹簧离合器主要部件\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E5%8A%A8%E7%B3%BB%E7%BB%9F/5.02/","summary":"为什么说离合器是动力开关？ 传动系统 为了让发动机的动力能够平顺地传递到变速器，离合器必须采用摩擦方式进行接触，而不能采用刚性连接。因此，才出现","title":"5.2 离合器 Clutch"},{"content":"2.1 资产业务概述 银行通过网点服务客户获得的各种负债，最终必须通过配置到不同类别的资产中，进而获得利息收入。\n收益与风险的平衡\n通常银行的资产收益率并不是越高越好，而是要在风险和收益之间寻找利益最大化的平衡点。 久期与期限错配\n通常来讲，久期越长的资产收益率越高。 配置长久期资产的风险 流动性风险(挤兑) 期限错配引发的利率风险 从金融的角度看，银行本身就是在依靠一定程度的期限错配挣钱。银行既要保持一定的期限错配以获得利润，但是又不能把期限错配做得太过分，造成过高风险。 银行的资产配置\n生息资产: 贷款、投资、存放央行、存放同业或其他金融机构、拆出资金及买入返售资产 存放央行主要是由存款准备金率决定的，属于被动型资产 非生息资产: 现金、贵金属、商誉、其他资产等 越少越好 2.2 贷款/垫款业务 业务分类 贷款/垫款业务是银行现行资产业务中占比最高的业务，也是对银行营收贡献最大的一项业务。\n贷款/垫款业务按照放贷的对象和方式不同，可以分成零售贷款、对公贷款和票据贴现三大类。\n零售贷款，就是发放给个人或者个体经营者的贷款，主要包括：房屋按揭、信用卡、消费贷、汽车贷、助学贷等。零售贷款的特点是：单笔金额小，风险相对较低， 收益率偏高。 对公贷款，顾名思义就是贷款的发放对象是企事业单位。对公贷款的特点是：单笔金额较大，风险相对较高，收益率和放贷对象的信用等级密切相关。 对公与零售的优劣对比 总体来说，对公贷款的平均不良率要高于零售信用贷款，但是平均收益率反而比零售信用贷款低。\n对公贷款和零售贷款相比也有其自身的优势\n第一，对公贷款的贷前尽调成本低。银行在放贷之前需要对被放贷的对象进行贷前风险尽职调查，以确定放贷对象的风险级别。对于对公贷款来说，假设一家公司贷 款1亿元，只需要做一次尽调。如果换成零售贷款，每个对象50万元，需要做200次尽调。 第二，对公贷款可以派生存款。通常企业申请贷款后并不是马上全部用掉，而是为后期项目准备资金。所以，贷款发放后，会有部分资金变成存款，银行又可以用这 些存款去放贷。这变相帮助银行扩张了资产负债规模。而零售贷款发放后多数被直接用掉，所以无法帮助银行派生存款。 零售贷款的风险相对较低，主要得益于两点。\n第一，我国社会信用体系的逐渐完善。随着国家信用体系的建立，对于失信人群的限制越来越多 第二，中国没有个人破产保护制度，意味着银行对于个人债务具有无限追索权。 零售贷款的收益率明显高于对公贷款，除了因为信用卡贷款利率较高外，主要的原因还在于个人在办理贷款的过程中和银行处于不平等的地位。不同于公司对银行有议 息的资格，个人通常只能单方面接受银行规定的利率。\n除了招商银行和平安银行零售贷款高于对公贷款外，其他银行都低于对公贷款。\n表2.2　主要银行的对公、零售贷款占比（%）\n票据贴现 票据贴现是指资金借贷者以手中未到期的商业票据、银行承兑汇票等向银行要求变成现款。\n票据贴现中最常见的票据是银行承兑汇票和商业承兑汇票。\n银行承兑汇票贴现是以票据承兑银行的信用为基础进行的融资行为； 而商业承兑汇票贴现是以票据承兑企业的商业信用为基础进行的融资行为。 一般来说，承兑的银行或企业信用级别越高，票据贴现融资就越容易成功。\n2.3 投资业务 中庸的投资策略 主要的投资方向包括：债券、非标资产、投资基金、贵金属、股权投资等。其中，多数银行占比较多的是债券和非标资产，但是也有少数银行对投资基金配置量较大。\n在银行的资产负债表中，政府债券的配置比例是最高的，政策性银行债券次之，企业债占比最少。\n配置国债有很多好处\n国债的风险加权资产因子为零，也就是说配置国债是完全不消耗银行资本金的； 国债的利息收入免征所得税，按照现行的监管规则，国债和货币基金的利息收入可以免征； 国债作为最优秀的抵押品，在流动性紧张的时候随时可以作为担保品抵押给同业或者央行进行头寸拆借。 金融创新的产物：非标资产 非标准化债权资产，简称非标资产，指的是未在银行间市场及证券交易所上市交易的债权性资产，包括但不限于信贷资产、信托贷款、委托债权、承兑汇票、信用证、 应收账款、各类受（收）益权、带回购条款的股权性融资等。\n做非标业务主要有以下的动力\n规避贷款监管指标限制。 可以减少资本金消耗和资产减值损失计提。 目前非标资产受到的监管越来越严格，要求银行对非标资产进行穿透管理，足额计提资本金和风险减值，在严监管下银行做非标的好处会减少，所以未来这部分资产会 显著收缩。\n投资资产的划分 对于未实施IFRS9的银行，投资资产里面报表上最大的几类是：\n可供出售金融资产, 指银行的交易类资产和其他不打算持有至到期的股票和债券等，这部分资产主要的目的是在交易中获利。 持有至到期金融资产, 指企业打算并且能够持有至到期的债券等。 应收款项类投资, 指银行用资金承接第三方的非标资产包，其中以非标票据资产和非标贷款资产为主。 按照IFRS9国际新会计准则, 投资资产主要包括如下几项：\n以公允价值计量且其变动计入当期损益的投资 以公允价值计量且其变动计入其他综合收益的债务工具投资 以摊余成本计量的债务工具投资 新的分类将取代原有的可供出售金融资产、持有至到期金融资产和应收款项类投资。\n投资类资产是银行资产表中相对最复杂的，变化最多的，也是最容易隐藏风险的地方。由于银行的报表中不需要强制披露和投资资产相关的风险和资产细节，这对于投 资者准确评估银行的风险情况造成了不小的障碍，所以，建议投资者对投资资产占比过高的银行要更加谨慎。\n2.4 信用卡业务 信用卡业务简要介绍 在信用卡使用的场景中，一个最普通的刷卡消费场景就涉及了五方\n发卡行, 信用卡的发行银行，也是最终提供垫付资金的银行。 收单行, 刷卡机（POS机）的提供银行，它负责接受发卡行通过信用卡组织转过来的消费款并计入商家在自家银行的对公账户中。 商家 消费者 信用卡组织, 负责在发卡行和收单行之间进行交易清算和手续费分配。 在整个刷卡消费的过程中，手续费由商家负责支付，手续费的比例在国内一般按照刷卡金额的0.6%收取. 在我国，信用卡组织主要就是银联，信用卡刷卡手续费在国 内按照7∶2∶1的比例在发卡行、收单行和银联之间分配。\n信用卡的免息期通常是指在消费者刷卡后，到最后还款期限之前的这一段时间。\n发卡行每月会在固定日期通过电子邮件或者纸质账单的形式给客户寄送信用卡账单。 账单日后15～20个日历日就是最后还款日，客户在最后还款日之前偿还账单上的全部欠款则不需要支付任何利息。 所以，理论上来说，信用卡的最长免息期可达到45～50个自然日。 如果在最后还款日之前无法全额还款，那么发卡行将对消费者收取罚息，实际上就是贷款利息。 这种贷款利息和普通的贷款利息有很大不同\n利率高。默认的信用卡罚息是日利率0.05%，年化利率18%。 利滚利计息。如果在逾期后的第二个月，消费者依然没有全额还款，那么第一个月产生的逾期罚息将会在第二个月滚存入本金产生逾期利息 全额罚息。所谓全额罚息是指在规定的最后还款期限内，如果消费者没有全额还款，那么第二个月的利息计算是以全部消费额计算，而不是以未偿还消费额计算。 在消费者产生逾期后，实际上可以有三种不同的处理方式\n不做任何处理，放任银行按照逾期进行处理。 申请最低还款额，并偿还超过最低还款额的部分。 申请分期支付。 这三种处理方式对于消费者的区别是：\n第一种会产生不良征信记录，影响未来的贷款、买房等。 第二种虽然不会产生不良征信记录，但是会利滚利，甚至全额罚息。 第三种，分期偿还既不会产生不良征信记录，也不会出现利滚利和罚息问题。 信用卡分期费率探讨 分歧年化利率计算公式\n年化利率 = 24*分期数*分期利率/(分期数+1) 表2.4　分期费率和年化利率的对应（%）\n","permalink":"https://jdxj.github.io/posts/books/%E7%9C%8B%E9%80%8F%E9%93%B6%E8%A1%8C-%E6%8A%95%E8%B5%84%E9%93%B6%E8%A1%8C%E8%82%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC2%E7%AB%A0-%E9%93%B6%E8%A1%8C%E7%9A%84%E8%B5%84%E4%BA%A7%E4%B8%9A%E5%8A%A1/","summary":"2.1 资产业务概述 银行通过网点服务客户获得的各种负债，最终必须通过配置到不同类别的资产中，进而获得利息收入。 收益与风险的平衡 通常银行的资产收益率","title":"第2章 银行的资产业务"},{"content":"具体和实现有关, 服务器推送的资源, 大多数浏览器不会立即使用, 而是放到缓存中, 如果浏览器需要某资源先去缓存中查找.\n5.3.1 查看推送缓存如何工作 推送的资源存放在单独的内存中（HTTP/2推送缓存），等待浏览器请求，而后它们会被加载到页面中。 如果设置了缓存首部，则在后来使用它们时它们照旧会被保存到浏览器的HTTP缓存中。 基于Chromium的浏览器不会缓存不受信任的HTTP/2推送 浏览器可能先去HTTP缓存中查找资源, 然后是HTTP/2推送缓存 图5.15　浏览器和HTTP/2推送的交互\n图5.16　在Chrome中对未声明的推送资源进行跟踪\nHTTP/2推送缓存和连接绑定，这意味着如果连接关闭，推送资源也就无法使用了。 如果使用另外一个连接，也用不到推送的资源。 当资源从连接的推送缓存中被“认领”并拿出后，就不能再从推送缓存中使用它了。 5.3.2 使用RST_STREAM拒绝推送 在服务端收到RST_STREAM帧并做出响应之前，可能整个推送的资源已经发完了。\n只有在浏览器知道它不需要推送的资源时，RST_STREAM帧才有用 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.3/","summary":"具体和实现有关, 服务器推送的资源, 大多数浏览器不会立即使用, 而是放到缓存中, 如果浏览器需要某资源先去缓存中查找. 5.3.1 查看推送缓存如何工作 推送的","title":"5.3 HTTP/2推送在浏览器中如何运作"},{"content":"汽车都有哪些传动形式？ 前置发动机、前轮驱动车型（F F），对车内空间安排比较有利，发动机、变速器、传动机构都整合在车头部位，甚至都在前车轴上方，这样可以从容安排驾乘室空间 和行李箱空间。但是，这种驱动形式会造成车头过重，在制动时易出现“点头”现象。\n发动机放置方式和传动形式示意图\n发动机的动力是怎样传递到车轮上的？ 动力从发动机到车轮要经过多个环节，要经过离合器、变速器、传动轴、差速器和半轴等才能到达车轮。根据车型定位和性能需要，可以设计多种动力传递形式。通常 情况下，汽车的发动机都放在汽车的前端，也就是前置发动机。根据驱动车轮的位置和数量不同，大致可分为前轮驱动、后轮驱动和四轮驱动三大形式。\n前驱车动力传递路线\n后驱车动力传递路线\n四驱车动力传递路线\n四轮驱动汽车动力传递方向示意图\n前置发动机四轮驱动汽车传动系统构造图\n前置发动机后轮驱动汽车动力传递方向示意图\n前置前驱（FF）有什么特点？ 前置前驱是指发动机放置在车前部，并采用前轮驱动（Front engine Front wheel drive，简称FF）。\n优点\n它的特点是头重尾轻，整车60%以上的重量集中在车身前段。由于车体是被前轮“拉着走”的，因此FF的直线行驶稳定性非常好。 在FF车型上，发动机经差速器后用半轴直接驱动前轮，不需经传动轴，动力损耗较小，所以适合小型车。 FF车后排座椅间少了后驱车必有的传动轴凸包，后座的乘员不用缩脚挤在狭窄的空间里，这一点可说是FF最大的优点。 缺点\n头重尾轻的设计使得车辆在高速行驶时，踩下制动踏板的瞬间，车头容易下沉，车尾易扬起甚至悬空造成危险。 由于前部较重，且前车轮同时负责驱动和转向，因此方向盘较重，转弯半径较大，容易出现转向不足现象。 前置前驱示意图\n前置前驱汽车构造图\n前置后驱（FR）有什么特点？ 前置后驱示意图\n前置后驱汽车构造图\n前置后驱是指将发动机放置在车前部，并采用后轮驱动（Front engine Rear wheel drive，简称FR）。\nFR在轴荷分配上比前驱车平均，可以达到50∶50的最佳比例，因此它拥有较佳的操控性和行驶稳定性。 理论上，FR车在转弯时的最大速度会更高。但是，由于汽车前轮直接受转向系统支配，在已经改变行驶方向的情况下，后面的驱动轮仍有向前的惯性，所以容易出现 转向过度现象。 汽车在起步或加速时，整车重量会向后轮转移，如果后轮是驱动轮，无疑它的起步或加速性能会更好些。同时，前轮负担较轻，在紧急制动时，不致产生车头下沉、 后轮悬空的现象。 后置后驱（RR）有什么特点？ 后置后驱是指将发动机放在后轴的后部，并采用后轮驱动（Rear engine Rear wheel drive，简称RR）。\nRR车的重量大多集中于后方，又是后轮驱动，所以起步、加速性能在所有驱动形式中是最好的。因此，超级跑车一般都采用RR方式。 RR的转弯性能比FF和FR更加敏锐，但后轴承受较大负荷，因此后轮的抓地力达到极限时，易出现打滑甩尾现象，且不容易控制。 RR的另一特点，就是车头较轻，所以开始进入转弯时，较容易造成转向过度的现象。 后置后驱示意图\n后置后驱汽车构造图\n中置后驱（MR）有什么特点？ 中置后驱示意图\n后中置后驱汽车构造图\n中置后驱是指发动机放在驾乘室与后轴之间，并采用后轮驱动（后中置后驱），或发动机放在前轴后面并用后轮驱动（前中置后驱）。其英文是Middle engine Rear wheel drive，简称MR。\n它的最大特点，就是将车辆中惯性最大的、沉重的发动机置于车体的中央，这是使MR车获得最佳运动性能的最主要保证。 MR兼具FF、FR的优点，转向灵敏准确，制动时不会出现头沉尾翘的现象。 MR有一个先天毛病：直线稳定性较差。为解决这一问题，所有MR汽车的后轮尺寸均比前轮大。 第二个缺点是车厢太窄，一般只能有两个座位。 另外，由于驾乘人员离发动机太近，因此噪声较大。 前轮驱动和后轮驱动哪个更好？ 前轮驱动（Front Wheel Drive，简称FWD）相当于发动机在前面“拉”着汽车前进，而后轮驱动（Rear Wheel Drive，简称RWD）相当于从后面推着汽车前进。 “拉”和“推”的不同方式，造成驱动力对汽车的作用点不同，从而使汽车在行驶中具有不同的行驶特性。\n前轮驱动的优势\nFWD汽车的直线行驶性较好 动力传递效率高 FWD结构较RWD紧凑，部件少，一般可减轻质量25～40千克，因此比同级别的RWD汽车更省油 一般说来，F W D汽车的车内空间利用好 前轮驱动的劣势\n发动机、变速器、差速器、转向系统等都放置在车辆前部，使车辆的前部要比后部重得多 当汽车起步和加速时，汽车的重心后移，使前轮的附着力减少，如果急加速就很容易造成前轮打滑，使汽车不能很快地起步和加速 制动时由于重心前移，加上前部重量较大，很容易使汽车在制动时点头，从而降低舒适性。 在过弯时，前轮既承担驱动力，也承担转向力。 如果在弯道中加速或减速，也就是改变驱动力的大小，就会影响转向力的发挥，从而会使汽车的转向特性发生变化。 如果在弯道中急加速，就可能使驱动力突破前轮的附着力，从而使转向力为零，此时汽车便不再转向，而是直直地往弯道外侧冲去，也就是发生转向不足现象，俗 称“推头”。 后轮驱动的优势\n由于发动机可纵向放置在车头，可允许较窄的前轮距和较低的发动机罩，以减小风阻，获得较佳的空气动力性能。另外，由于各总成较分散并独立，从组装到维修保 养都比较方便。 与F W D汽车相比，RWD汽车加速时还可获得更大的驱动力。 R W D汽车的前轮负责转向，后轮负责驱动，可保证车辆拥有充分的转向力。 R W D汽车具有较灵活的转向特性，并且更容易实现前后50∶50的配重比，因此驾驶乐趣更强。 后轮驱动的劣势\nR W D汽车对驾驶技术要求更高 与F W D汽车相比，RWD汽车要增加一些部件，从而导致车重增加。另外，它的动力传递路线较长，也比较曲折，因此动力传递效率也不如FWD汽车高，这都可能造 成RWD汽车的油耗稍高。 四轮驱动可以前拉后推 四轮驱动汽车最大的特点，是将原本集中在两个车轮上的驱动力分摊给四个车轮，即使有部分车轮打滑，汽车仍有车轮存在驱动力，可以帮助汽车摆脱困境。\n四驱汽车构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E5%8A%A8%E7%B3%BB%E7%BB%9F/5.01/","summary":"汽车都有哪些传动形式？ 前置发动机、前轮驱动车型（F F），对车内空间安排比较有利，发动机、变速器、传动机构都整合在车头部位，甚至都在前车轴上方","title":"5.1 传动形式 Drive Type"},{"content":"变速器档位数的多少对汽车性能有什么影响？ 对于汽车来说，变速器的档位数较多，那么汽车加速时更顺畅、省力，加速时的顿挫感也较小，舒适性会更好，同时也更省油。如果有级变速器相当于上楼梯台阶，那 么无级变速器就相当于乘坐滚梯了，可以没有台阶地一路斜上，没有顿挫感，非常顺畅，而且更省劲，也更省油了。\n福特双离合变速器\n手动变速器构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.11/","summary":"变速器档位数的多少对汽车性能有什么影响？ 对于汽车来说，变速器的档位数较多，那么汽车加速时更顺畅、省力，加速时的顿挫感也较小，舒适性会更好，同","title":"4.11 变速器档位数"},{"content":"自动离合变速器是怎样变速的？ 自动离合变速器是在手动变速器的基础上加装一套自动换档装置，它可以替代驾驶人进行离合器分离及更换档位的动作。它的基本变速结构和手动变速器是一样的，但 它可以利用电子控制单元收集驾驶人的操作信息和车辆运行信息，指挥电子液压机构来操纵离合器和换档拨叉，从而实现自动换档。\n这类在手动变速器的基础上改进而来的变速器简称为AMT（Automated Manual Transmission），也称半自动变速器等。\n雪铁龙电控自动离合变速器构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.10/","summary":"自动离合变速器是怎样变速的？ 自动离合变速器是在手动变速器的基础上加装一套自动换档装置，它可以替代驾驶人进行离合器分离及更换档位的动作。它的基","title":"4.10 自动离合变速器（AMT）"},{"content":"序列式变速器是怎样变速的？ 序列式变速器简称为SMG（Sequential Manual Gearbox），全称为序列式手动变速器。\n序列式变速器（SMG）构造图\n序列式变速器（SMG）构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.09/","summary":"序列式变速器是怎样变速的？ 序列式变速器简称为SMG（Sequential Manual Gearbox），全称为序列式手动变速器。 序列式变速器（SMG）构","title":"4.9 序列式变速器（SMG）"},{"content":"双离合变速器是怎样变速的？ 双离合变速器（Double Clutch Transmission，简称DCT）是从手动变速器进化而来的，它的变速结构和原理与手动变速器一样，只不过比手动变速器多了一个 离合器，因此称为双离合变速器。或者说，双离合变速器相当于把两个手动变速器整合在一起，交替传递动力。\n雷诺汽车双离合变速器原理示意图\n大众汽车6速双离合变速器\n双离合变速器\n奥迪汽车7速双离合变速器原理示意图\n大众汽车6速双离合变速器原理示意图\n双离合变速器\n奥迪汽车7速双离合变速器构造图（正在3档工作状态）\n奥迪7速双离合变速器\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.08/","summary":"双离合变速器是怎样变速的？ 双离合变速器（Double Clutch Transmission，简称DCT）是从手动变速器进化而来的，它的变速结构和原理与手","title":"4.8 双离合变速器（DCT）"},{"content":"5.2.1 使用HTTP link首部推送 nginx\n例子来源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 server { listen 443 ssl http2 default_server; ssl_certificate ssl/certificate.pem; ssl_certificate_key ssl/key.pem; root /var/www/html; http2_push_preload on; location = /demo.html { add_header Set-Cookie \u0026#34;session=1\u0026#34;; add_header Link $resources; } } map $http_cookie $resources { \u0026#34;~*session=1\u0026#34; \u0026#34;\u0026#34;; default \u0026#34;\u0026lt;/style.css\u0026gt;; as=style; rel=preload, \u0026lt;/image1.jpg\u0026gt;; as=image; rel=preload, \u0026lt;/image2.jpg\u0026gt;; as=image; rel=preload\u0026#34;; } rel=preload属性来指示Web服务器，要将这个资源推送过去 as=style部分（指示资源的类型）是可选的。这个as属性可以用来决定优先级 preload HTTP首部和HTTP/2推送\nhttp/2之前, 这个首部允许浏览器直接获取资源，不用等着下载、读取、解析整个页面之后才决定是否下载另一个资源。 HTTP/2的实现重新修改了preload link首部的使用目的，实现服务端推送 如果想使用原来的preload方式，但不让服务器推送资源，通常可以使用nopush属性 通常只有HTTP首部支持HTTP/2推送。HTTP/2推送通常忽略HTML中的标签，因为对于服务器来说，解析HTML并提取这些首部，比从HTTP首部中获取这些信息要复杂 得多，也要花更多时间。\n5.2.2 查看HTTP/2推送 图5.6　在Chrome开发者工具Network标签中查看HTTP/2推送的资源\n图5.7　与图5.6中一样的页面加载，但是没有服务端推送\n图5.8　在WebPagetest中的一个推送资源\n使用nghttp发送Web请求\n在连接之后，使用SETTINGS和PRIORITY帧完成连接设置。nghttp2使用HEADERS帧发出页面请求\n在收到返回的页面之前，会收到一个PUSH_PROMISE帧。需要注意的是，nghttp先展示收到帧的内容，然后才是帧的详情：\n有点疑惑, 客户端发送HEADERS帧(stream_id=13)请求页面, 为啥返回的PUSH_PROMISE帧还是用stream_id=13\n猜测是因为h2是1对多模型, 1个请求可以有多个响应, 这些响应处于同一流中\nPUSH_PROMISE帧和浏览器在请求资源时发送的HEADERS帧类似，但有两点区别\n这个帧由服务端发送到客户端，而不是由客户端发送到服务端。 它包含一个promised_stream_id，代表所要推送资源的流ID，表明要推送的资源将要通过流2发送。服务端发起的流ID（当前只用以推送）是偶数。 在这之后，服务器返回开始时请求的资源(stream_id=13)，使用HEADERS帧，后面跟着DATA帧。然后服务器在stream_id=2上推送资源，使用一个HEADERS帧， 后面跟着DATA帧\n5.2.3 使用link首部从下游系统推送 图5.9　在HTTP/2下，从下游的应用服务器推送link首部\n图5.10　使用link首部从后端应用服务器推送资源\n创建一个简单的node服务，使用HTTP/1.1\nhtml中的link只是表示渲染页面时需要common.css, 重点在setHeader中.\n该页面在HEAD标签中引用一个样式表（通过link首部引用这个样式表）。在另外一个窗口中使用curl来查看结果：\n图5.11　在link首部中引用的资源下游系统可以推送\nWeb服务器不能给其他域名推送资源\n5.2.4 更早推送 Chrome开发者工具中不显示未使用到的推送资源如果被页面用到，推送的资源会在Chrome开发者工具Network标签页中显示。预加载器会使用preload提示\n图5.12　加载后端处理时间较长的网页\n图5.13　更早推送以尽量利用可能被浪费的时间\n修改这个简单的NodeJS服务来模拟延迟\n如果再次使用nghttp来调用这段代码的服务，然后使用grep过滤输出，只显示recv frame相关的行，你会看到，在连接建立之后有一个10 s的延迟，直到 PUSH_PROMISE帧被发送（对应前面代码中的10 s的sleep）\n如果改变Apache的推送配置，使用H2PushResource而不是等待link首部，则推送会直接发生，不需要10 s的延迟，因为要推送的资源不再被主资源所阻塞\n也就是说应用程序添加link首部会导致类似队头阻塞问题, 所以nginx中的http2_push_preload应该是指示nginx提前推送.\n所以nginx应该记住哪些资源提前推送了?\n使用Web服务器的更早推送指令（如H2PushResource）的缺点是，你不能再使用应用来发起这些推送\n为了解决这个问题，有了一个新的HTTP状态码——103 Early Hints, 其允许通过preload HTTP link首部来提前指示是否需要一个资源。 在HTTP/1.1中，这个代码看起来像是两个请求挨着\n图5.14　使用状态码103告诉Web服务器更早推送资源\n在nghttp中，场景可能看起来像这样\nhttp 103为啥也返回给了客户端, 之前以为是103是给nginx看的.\n书中提到:\nApache支持处理103响应，它会处理其中的link首部来推送资源，但是它故意不将103响应发送给浏览器，因为一些浏览器不支持这些响应，可能会发生错误。\n对103状态码的支持比较少还有一个原因，它需要在一个请求中发送多个响应。\n5.2.5 使用其他方式推送 应用服务器自己也可以使用http/2推送\n需要在全链路上支持推送吗\n需要考虑客户端, 中间代理, 应用服务对http/2的支持情况 HTTP/2规范声明：中间节点可以从服务端接收推送的资源，并选择不将它们推送到客户端。换句话说，如何利用推送的信息取决于中间节点。同样，中间节点可以 选择向客户端推送额外的资源，而不需要后端服务器做任何操作。 实际上，让边缘节点服务器使用HTTP link首部（用不用103 Early Hints均可）来处理推送逻辑会更简单。 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.2/","summary":"5.2.1 使用HTTP link首部推送 nginx 例子来源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 server { listen 443 ssl http2 default_server; ssl_certificate ssl/certificate.pem; ssl_certificate_key ssl/key.pem; root /var/www/html; http2_push_preload on; location = /demo.html { add_header Set-Cookie \u0026#34;session=1\u0026#34;; add_header Link $resources; } } map $http_cookie $resources {","title":"5.2 如何推送"},{"content":"HTTP/2服务端推送（以下称为HTTP/2推送）允许服务器发回客户端未请求的额外资源。\nHTTP/2多路复用技术允许在同一连接上并行请求所有资源，因为这样排队会减少，所以它优于HTTP/1。 如果没有HTTP/2推送，浏览器必须在下载初始页面之后才能请求这些关键的资源。 图5.1　关键资源需要一个额外的请求往返(http/1)\n图5.2　关键资源的往返延迟瀑布图(http/1)\n这个往返延迟催生了一些性能优化手段，如将样式通过\u0026lt;style\u0026gt;标签内联到HTML页面中，或类似的，通过\u0026lt;script\u0026gt;标签将JavasScript内联到HTML中。通过 内联这些关键资源，浏览器可以在原始页面下载解析之后马上开始渲染，而不需要等待附加的关键资源。\n内联资源有几个缺点\n需要将关键CSS提取出来防止页面过大, 但是该操作比较复杂, 也有可能造成重复代码 要求使用JavaScript来加载非关键CSS文件 变更困难(重复的地方都要改) 图5.3　使用HTTP/2推送可以避免关键资源的往返延迟\n服务器岂不是解析html才能发送被关联资源?\n图5.4　使用HTTP/2推送在一个往返中接收所有请求的瀑布图\n图5.5　一个基本的网页请求流，不使用HTTP/2推送（左边）和使用HTTP/2推送（右边）的情况\n如果使用方法正确，HTTP/2推送可以减少加载时间。但如果你多推送了资源（客户端不需要，或者已经在缓存里），则将会延长加载时间。所以，在使用HTTP/2推送 时应该小心，经过考虑后再使用。\nHTTP/2推送是否能替代WebSockets或者SSE\n诸如WebSockets和服务器发送事件（SSE）之类的技术真正允许双向流，HTTP/2中不是真正的双向流，一切都仍然是从客户端请求发起的。按照HTTP/2推送现在的 规范，它不是WebSockets或SSE的替代品，但如果以后它进一步扩展的话，也许有替代它们的机会\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC5%E7%AB%A0-%E5%AE%9E%E7%8E%B0http2%E6%8E%A8%E9%80%81/5.1/","summary":"HTTP/2服务端推送（以下称为HTTP/2推送）允许服务器发回客户端未请求的额外资源。 HTTP/2多路复用技术允许在同一连接上并行请求所有","title":"5.1 什么是HTTP/2服务端推送"},{"content":"4.3.1 查看HTTP/2帧 使用Chrome net-export\n抓包chrome://net-export 查看日志 https://netlog-viewer.appspot.com/#import 图4.7　在Chrome中查看HTTP/2帧\n以下输出来自一个SETTINGS帧：\n使用nghttp\n使用Wireshark\n需要告诉Wireshark HTTPS密钥 对于macOS，设置SSLKEYLOGFILE环境变量 或者直接作为命令行参数提供 在Wireshark中加载密钥 图4.8　设置Wireshark HTTPS密钥文件\n图4.9　Wireshark中显示的HTTP/2魔法字符串\n图4.10　Wireshark中的ClientHello消息中的ALPN扩展\n4.3.2 HTTP/2帧数据格式 每个HTTP/2帧由一个固定长度的头部和不定长度的负载组成。\n表4.1　HTTP/2帧头部格式\nStream Identifier, 将此字段限制为31位的其中一个原因是考虑到Java的兼容性，因为它没有32位无符号整数 4.3.3 HTTP/2消息流示例 可以使用-n参数来隐藏数据，仅显示帧头部：\n首先，通过HTTPS（h2）协商建立HTTP/2连接。nghttp不输出HTTPS建立过程和HTTP/2前奏/“魔术”消息，因此我们首先看到SETTINGS帧： SETTINGS帧 SETTINGS帧（0x4）是服务器和客户端必须发送的第一个帧（在HTTP/2前奏/“魔术”消息之后）。该帧不包含数据，或只包含若干键/值对\n表4.2　SETTINGS帧格式\n规范中的Value是默认值, 顺序与Identifier对应, e.g. 0x1-\u0026gt;4096.\n再回头看第一个消息\n收到的SETTINGS帧有30个8位字节数据，没有设置标志位（因此不是确认帧），使用的流ID为0。流ID 0是保留数字，用于控制消息（SETTINGS和 WINDOW_UPDATE帧），所以服务器使用流ID 0发送此SETTINGS帧是合理的。\n在此示例中有5个设置项（niv=5），每个设置项长度为16位（标识符）+32位（值）。也就是说，每项设置有48位即6字节\n查看接下来的3个SETTINGS帧 nghttp接收初始服务器SETTINGS帧（刚讨论过），然后，客户端发送带有几个设置项的SETTINGS帧。接下来，客户端确认服务器的SETTINGS帧。确认SETTINGS 帧非常简单，只有一个ACK（0x01）标志，长度为0，因此只有0设置（niv=0）。再接下来是服务器确认客户端的SETTINGS帧，格式同样简单。\nWINDOW_UPDATE帧 WINDOW_UPDATE帧（0x8）用于流量控制，比如限制发送数据的数量，防止接收端处理不完。在HTTP/1下，同时只能有一个请求。如果客户端无法及时处理数据，它 会停止处理TCP数据包，然后TCP流量控制（类似HTTP/2流量控制）开始工作，降低发送数据的流量，直到接收方可以正常处理为止。在HTTP/2下，在同一个连接上 有多个流，所以不能依赖TCP流量控制，必须自己实现针对每个流的减速方法。\n表4.3　WINDOW_UPDATE帧格式\nWINDOW_UPDATE帧未定义标志位，该设置用于给定的流，如果流ID指定为0，则应用于整个HTTP/2连接。发送方必须跟踪每个流和整个连接。\n如果流ID指定为0中的流ID应该是帧首部中的Stream Identifier.\nHTTP/2流量控制设置仅应用于DATA帧，所有其他类型的帧（至少目前定义的），就算超出了窗口大小的限制也可以继续发送。这个特性可以防止重要的控制消息（比 如WINDOW_UPDATE帧自己）被较大的DATA帧阻塞。同时DATA帧也是唯一可以为任意大小的帧。\nPRIORITY帧 通过dep_stream_id，它将其他流悬挂在开始时创建的流之下(该流依赖dep_stream_id所指定的流)。使用之前创建的流的优先级，可以方便地对请求进行优先级 排序，无须为每个后续新创建的流明确指定优先级。并非所有HTTP/2客户端都给流预定义优先级\n表4.4　PRIORITY帧格式\nPRIORITY帧（0x2）长度固定，没有定义标志位。\nHEADERS帧 一个HTTP/2请求以HEADERS帧开始发送（0x1）\nHTTP/2定义了新的伪首部（以冒号开始），以定义HTTP请求中的不同部分：\n:authority伪首部代替了原来HTTP/1.1的Host首部 HTTP/2伪首部定义严格，不像标准的HTTP首部那样可以在其中添加新的自定义首部 不能这样创建新的伪首部\n:barry: value 如果应用需要，还得用普通的HTTP首部，没有开头的冒号\nbarry: value 可以依照新的规范来创建新的伪首部\n在Bootstrapping WebSockets with HTTP/2 RFC中添加:protocol伪首部。应用新的伪首部需要使用新的SETTINGS参数，也需要客户端和服务端的支持。 可以在客户端工具中查看这些伪首部，它们表明正在使用HTTP/2请求 图4.11　Chrome开发者工具中的伪首部\nHTTP/2强制将HTTP首部名称小写, HTTP首部的值可以包含不同的大小写字母\nHTTP/2对HTTP首部的格式要求也更严格。开头的空格、双冒号或者换行，在HTTP/2中都会带来问题 当客户端发现首部格式不正确时，报错信息通常含义不明（比如Chrome中的ERR_SPDY_PROTOCOL_ERROR） 表4.5　HEADERS帧格式\n添加Pad Length和Padding字段是出于安全原因，用以隐藏真实的消息长度。 Header Block Fragment（首部块片段）字段包含所有的首部（和伪首部）。这个字段不是纯文本的，不像nghttp里所显示的那样。(首部压缩了) HEADERS首部定义了4个标志位\nEND_STREAM(0x1)，如果当前HEADERS帧后面没有其他帧（比如POST请求，后面会跟DATA帧），设置此标志。有点违反直觉的是，CONTINUATION帧不受此限 制，它们由END_HEADERS标志控制，被当作HEADERS帧的延续，而不是额外的帧。 END_HEADERS（0x4），它表明所有的HTTP首部都已经包含在此帧中，后面没有CONTINUATION帧了。 PADDED(0x8)，当使用数据填充时设置此标志位。这个标志表明，DATA帧的前8位代表HEADERS帧中填充的内容长度。 PRIORITY(0x20)，表明在帧中设置了E、Stream Dependency和Weight字段。 如果HTTP首部尺寸超出一个帧的容量，则需要使用一个CONTINUATION帧（紧接着是一个HEADERS帧），而不是使用另外一个HEADERS帧。\n这个过程相较于HTTP正文来说好像过于复杂，HTTP正文会使用多个DATA帧。因为表4.5中的其他字段只能使用一次，所以如果同一个请求有多个HEADERS帧，并 且它们的其他字段值不同，就会带来一些问题。 要求CONTINUATION帧紧跟在HEADERS帧后面，其中不能插入其他帧，这影响了HTTP/2的多路复用，人们正考虑其他替代方案。 实际上CONTINUATION帧很少使用，大多数请求都不会超出一个HEADERS帧的容量。 再回头看这些日志输出\n每个新的请求都会被分配一个独立的流ID，其值在上一个流ID的基础上自增（在这个示例中上一个流ID是11，它是nghttp创建的PRIORITY帧，所以这个帧使用 流ID13创建，偶数12是服务端使用的）。 同时设置了多个标志位，组合起来的十六进制数为0x25 其中的END_STREAM（0x1）和END_HEADERS（0x4）标志位说明，当前帧包含完整的请求，没有DATA帧（可能用于POST请求）。 PRIORITY标志位（0x20）表明，此帧使用了优先级策略。 将这些十六进制数加起来（0x1 + 0x4 + 0x20），结果是0x25，在帧首部中显示。 这个流依赖流11，所以被分配了对应的优先级，权重为16。 nghttp的注释说，这个流是新建的（Open new stream）， 然后列出了多个HTTP伪首部和HTTP请求首部 HTTP响应在同一个流上也使用HEADERS帧发送\n作者也提到了nghttp将HEADERS帧首部放到帧详情之后是一个疑惑点.\n尾随首部 HTTP/1.1引入了尾随首部的概念，可以在正文之后发送它。这些首部可以支持不能提前计算的信息。例如，在以流的形式传输数据时，内容的校验和或者数字签名可 以包含在尾随首部中。\n实际上，尾随首部的支持很差，很少应用。但是HTTP/2决定继续支持它，所以一个HEADERS帧（或者一个后跟CONTINUATION帧的HEADERS帧）可能出现在流 的DATA帧之前或者之后。\nDATA帧 表4.6　DATA帧格式\nDATA帧定义了两个标志位\nEND_STREAM(0x1)，当前帧是流中的最后一个。 PADDED(0x8)，当使用数据填充时设置此标志位。这个标志表明，DATA帧的前8位代表HEADERS帧中填充的内容长度。 GOAWAY帧 用于关闭连接，当连接上没有更多的消息，或发生了严重错误时使用该帧。\n表4.7　GOAWAY帧格式\n查看之前nghttp输出日志中最后的消息，会看到一个GOAWAY帧的示例\n当响应被处理，并且客户端不再等待更多的数据时，它会发送这个帧来关闭HTTP/2连接。Web浏览器可能会保持连接打开，以供后续的请求使用。\n4.3.4 其他帧 CONTINUATION帧 太大的首部需要使用CONTINUATION帧（0x9），它紧跟在HEADERS帧或者PUSH_PROMISE帧后面。因为在请求可以被处理之前，需要完整的HTTP首部，并且为了应 用HPACK的字典，所以CONTINUATION帧必须紧跟在HEADERS帧后面。\n这种要求降低了HTTP/2的多路复用性 很少被用到 表4.8　CONTINUATION帧格式\nCONTINUATION帧只定义了一个标志位\nEND_HEADERS（0x4），当设置这个标志的时候，表明HTTP首部内容到此帧结束，后续没有别的CONTINUATION帧了。 PING帧 PING帧（0x6）用以计算发送方的消息往返时间，也可以用来保持一个不使用的连接。当收到这类帧的时候，接收方应当马上回复一个类似的PING帧。两个PING帧都 应当在控制流（流ID为0）上发送。\n表4.9　PING帧格式\nPING帧定义了一个可以在通用帧首部中使用的标志位\nACK（0x1）标志位，在发起方的PING帧中不设置，在返回方中需要设置。 PUSH_PROMISE帧 服务器使用PUSH_PROMISE帧（0x5）通知客户端它将推送一个客户端没有明确请求的资源。PUSH_PROMISE帧需要提供将要向其推送资源的客户端信息，所以它包含 通常在HEADERS帧中包含的那些首部信息（同样，如果要推送的资源首部比较大，则它后面也可能会跟一个CONTINUATION帧）。\n表4.10　PUSH_PROMISE帧格式\nPUSH_PROMISE帧定义了两个标志位\nEND_HEADERS（0x4），它表明所有的HTTP首部都已经包含在此帧中，后面没有CONTINUATION帧了。 PADDED(0x8)，当使用数据填充时设置此标志位。这个标志表明，DATA帧的前8位代表PUSH_PROMISE帧中填充的内容长度。 RST_STREAM帧 用于直接取消（重置）一个流。该取消可能是由于一个错误，或者是因为请求已经不需要进行了。可能是客户端已经跳转到其他页面、取消了加载，或者不再需要服务 器推送的资源了。\nHTTP/1.1不提供这种功能。如果你正在下载页面上一个较大的资源，除非中断连接，否则就算跳转到其他页面，这个资源的下载也不会停止。 表4.11　RST_STREAM帧格式\nALTSVC帧 其允许服务端宣告获取资源时可用的其他服务。这个帧可以用来进行升级（比如从h2升级到h2c）或者重定义流量到另外一个版本。\n表4.12　ALTSVC帧格式\nORIGIN帧 服务器使用它来宣告自己可以处理哪些源（比如域名）的请求。当客户端决定是否合并HTTP/2连接的时候，该帧非常有用。\n该帧可以包含多组Origin-Len/Origin。 CACHE_DIGEST帧 客户端可以使用这个帧来表明自己缓存了哪些资源。例如，它指示服务器不必再推送这些资源，因为客户端已经有了。\n表4.14　CACHE_DIGEST帧格式\nCACHE_DIGEST帧定义了如下标志位\nRESET(0x1)，客户端用来告诉服务器重置当前保存的CACHE_DIGEST信息。 COMPLETE(0x2)，表明当前包含的缓存摘要代表所有的缓存，而不是缓存的一部分。 总结 HTTP/2是一个二进制协议，其消息有明确的、精细的格式和结构。 由于这个原因，客户端和服务端在发送HTTP消息之前必须协商都使用HTTP/2。 对于Web浏览器，这个协商的过程主要在HTTPS连接协商中完成，使用一个新的叫ALPN的扩展。 在HTTP/2中，请求和响应通过HTTP/2帧的形式传输。 一个HTTP/2 GET请求，通常以HEADERS帧的形式发送，接收的响应通常是一个HEADERS帧，跟着一个DATA帧。 大多数Web开发者和Web服务器管理员，不需要关心HTTP/2帧的细节，尽管可以使用工具查看这些帧。 当前有几种HTTP/2帧，以后还会添加新的帧。 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC4%E7%AB%A0-http2%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/4.3/","summary":"4.3.1 查看HTTP/2帧 使用Chrome net-export 抓包chrome://net-export 查看日志 https://netlog-viewer.appspot.com/#import 图4.7 在Chrome中查看HTTP/2帧 以下输出","title":"4.3 HTTP/2帧"},{"content":" 使用HTTPS协商。 使用HTTP Upgrade首部。 和之前的连接保持一致。 理论上，HTTP/2支持基于未加密的HTTP（也就是h2c）创建连接，也支持基于加密的HTTPS（即h2）创建连接。实际上，所有的Web浏览器仅支持基于HTTPS（h2） 建立HTTP/2连接，所以浏览器使用第一个方法来协商HTTP/2。服务器之间的HTTP/2连接可以基于未加密的HTTP（h2c）或者HTTPS（h2）。\n4.2.1 使用HTTPS协商 HTTPS需要经过一个协议协商阶段来建立连接，在建立连接并交换HTTP消息之前，它们需要协商SSL/TLS协议、加密的密码，以及其他的设置。这个过程比较灵活， 可以引入新的HTTPS协议和密码，只要客户端和服务端都支持就行。在HTTPS握手的过程中，可以同时完成HTTP/2协商，这就不需要在建立连接时增加一次跳转。\nHTTPS握手\n公钥私钥加密被称为非对称加密, 但它比较慢，所以这种加密方式用于协商一个对称加密的密钥，以便在创建连接之后使用对称密钥加密消息。\n图4.4　HTTPS握手 (TLSv1.2, 与TLSv1.3略微不同)\n握手过程涉及4类消息：\n客户端发送一个ClientHello消息，用于详细说明自己的加密能力。不加密此消息，因为加密方法还没有达成一致。 服务器返回一个SeverHello消息，用于选择客户端所支持的HTTPS协议（如TLSv1.2）。基于客户端在ClientHello中声明的密码，和服务器本身支持的密码， 服务器返回此连接的加密密码（如ECDHE-RSA-AES128-GCM-SHA256）。 之后提供服务端HTTPS证书（ServerCertificate）。 然后是基于所选密码加密的密钥信息（ServerKeyExchange） 以及是否需要客户端发送客户端证书（CertificateRequest，大多数网站不需要）的说明。 最后，服务端宣告本步骤结束（ServerHelloDone）。 客户端校验服务端证书，如果需要发送客户端证书（ClientCertificate，大多数网站不需要）。 然后发送密钥信息（ClientKeyExchange）。这些信息通过服务端证书中的公钥加密，所以只有服务端可以通过密钥解密消息。 如果使用客户端证书，则会发送一个CertificateVerify消息，此消息使用私钥签名，以证明客户端对证书的拥有权。 客户端使用ServerKeyExchange和ClientKeyExchange信息来定义一个加密过的对称加密密钥，然后发送一个ChangeCipherSpec消息通知服务端加密开 始 最后发送一个Finished消息。 配置客户端证书需要私钥吗?\n服务端也切换到加密连接上（ChangeCipherSpec），然后发送一个加密过的Finished消息。 当HTTPS会话建立完成后，在同一个连接上的HTTP消息就不再需要这个协商过程了。类似地，后续的连接（不管是并发的额外连接，还是后来重新打开的连接）可以 跳过其中的某些步骤 —— 如果它复用上次的加密密钥，这个过程就叫作TLS会话恢复。\nTLSv1.3可以将协商过程中的消息往返减少到1个（如果复用之前的协商结果，则可以降到0个）\nALPN\nALPN给ClientHello和ServerHello消息添加了功能扩展，客户端可以用它来声明应用层协议支持（“嗨，我支持h2和http/1，你用哪个都行。”），服务端 可以用它来确认在HTTPS协商之后所使用的应用层协议（“好的，我们用h2吧”）。\n图4.5　使用ALPN的HTTPS握手\nNPN\n在使用NPN时，客户端决定最终使用的协议，而在使用ALPN时，服务端决定最终使用的协议。\n图4.6　使用NPN的HTTPS握手\n现在不再推荐使用NPN，应该使用ALPN。\n使用ALPN进行HTTPS握手的示例(curl)\n4.2.2 使用HTTP Upgrade首部 通过发送Upgrade首部，客户端可以请求将现有的HTTP/1.1连接升级为HTTP/2。这个首部应该只用于未加密的HTTP连接（h2c）。基于加密的HTTPS连接的 HTTP/2（h2）不得使用此方法进行HTTP/2协商，它必须使用ALPN。我们已经说过多次，Web浏览器只支持基于加密连接的HTTP/2，所以它们不会使用这个方法。\n示例1：一个不成功的Upgrade请求\n客户端支持并想要使用HTTP/2，发送一个带Upgrade首部的请求：\n这样的请求必须包含一个HTTP2-Settings首部，它是一个Base-64编码的HTTP/2 SETTINGS帧\n不支持HTTP/2的服务器可以像之前一样返回一个HTTP/1.1消息，就像Upgrade首部没有发送一样：\n示例2：一个成功的Upgrade请求\n支持HTTP/2的服务器可以返回一个HTTP/1.1 101响应以表明它将切换协议，而不是忽略升级请求，并返回HTTP/1.1 200响应：\n然后服务器直接切换到HTTP/2，发送SETTINGS帧（见4.3.3节），之后以HTTP/2格式发送响应。\n示例3：服务端请求的升级\n当客户端认为服务器不支持HTTP/2时，它会发送不带Upgrade的请求：\n一个支持HTTP/2的服务端可以返回一个200响应，但是在响应首部中添加Upgrade来说明自己支持HTTP/2。这个时候，它是一个升级建议，而不是升级请求，因为只 有客户端才发起升级请求。\n如下是一个服务端宣告支持h2（基于HTTPS的HTTP/2）和h2c（基于纯文本的HTTP/2）的示例：\n客户端可以利用这个信息来完成协议升级，并在下一个请求中发送一个Upgrade首部\n发送Upgrade首部的问题\n由于所有的浏览器都只支持基于HTTPS的HTTP/2，因此这个Upgrade方法可能永远不会被浏览器使用，这会带来问题。\n应用服务器可能会发送一个Upgrade首部，帮助升级到HTTP/2以提升性能。反向代理Web服务器可能会透传这个首部。浏览器会收到升级建议，并决定升级。但是 与客户端直接连接的这个反向代理Web服务器并不支持HTTP/2。 在类似的场景中，可能反向代理已经和Web浏览器使用HTTP/2交互，但使用HTTP/1.1将请求代理到后端应用服务器。应用服务器可能会发出升级建议，如果其被反 向代理透传，浏览器就会困惑，因为当前已经使用HTTP/2通信了，服务端还在建议升级到HTTP/2。 4.2.3 使用先验知识 有不同的方法可以让客户端事先知道服务器是否支持HTTP/2。如果你使用反向代理来卸载HTTPS，则可能会通过基于纯文本的HTTP/2（h2c）与后端服务器通信，因 为你知道它们支持HTTP/2。或者，可以根据Alt-Svc首部（HTTP/1.1）或ALTSVC帧（参见4.3.4节）推断先前的连接信息。\n4.2.4 HTTP Alternative Services 第4种方法是使用HTTP Alternative Services（替代服务），它没有被包含在原来的标准中，在HTTP/2发布之后，将其列为单独的标准。此标准允许服务器使用 HTTP/1.1协议（通过Alt-Svc HTTP首部）通知客户端，它所请求的资源在另一个位置（例如，另一个IP或端口），可以使用不同的协议访问它们。该协议可以使用 先验知识启用HTTP/2。\n4.2.5 HTTP/2前奏消息 不管使用哪种方法启用HTTP/2连接，在HTTP/2连接上发送的第一个消息必须是HTTP/2连接前奏，或者说是“魔法”字符串。此消息是客户端在HTTP/2连接上发送的 第一个消息。它是一个24个八位字节的序列，以十六进制表示法显示如下：\n这个序列被转换为ASCII字符串后如下所示：\n这个无意义的看起来像HTTP/1样式的消息，目的是兼容，客户端向不支持HTTP/2的服务端发送HTTP/2消息的情况。然后服务器会尝试解析此消息，就像收到其他 HTTP消息时一样。因为它无法识别这个无意义的方法（PRI）和HTTP版本（HTTP/2.0），所以解析会失败，从而拒绝此消息。注意，此消息前奏是官方规范中唯一一 处使用HTTP/2.0的地方，在其他地方都是HTTP/2，正如4.1节中所讨论的。而对于支持HTTP/2的服务器，可以根据这个收到的前奏消息推断出客户端支持HTTP/2， 它不会拒绝这个神奇的消息，它必须发送SETTINGS帧作为其第一条消息（可以为空）。\n为什么是PRI和SM\n在早期的草稿中，HTTP/2规范中的消息前奏使用FOO和BAR或者BA表示，它们是编程中常见的占位符。但是在规范草稿的第4个版本中，这个占位符变成了PRI SM， 但是没有说为什么。\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC4%E7%AB%A0-http2%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/4.2/","summary":"使用HTTPS协商。 使用HTTP Upgrade首部。 和之前的连接保持一致。 理论上，HTTP/2支持基于未加密的HTTP（也就是h2c）创建连","title":"4.2 如何创建一个HTTP/2连接"},{"content":"新版本的协议与原来的协议有很大的不同，新增了如下概念：\n二进制协议 多路复用 流量控制功能 数据流优先级 首部压缩 服务端推送 HTTP/1.0的Web服务器可以支持HTTP/1.1的消息，并可以忽略后来的版本中新增的功能，但在HTTP/2中，就不能兼容了，HTTP/2使用了不同的数据结构和格式。 出于这个原因，HTTP/2被视为主版本更新。\nHTTP/2.0还是HTTP/2\nHTTP/2定义了新版本HTTP的主要部分（二进制、多路复用等），并且未来的任何实现或变更（如果有HTTP/2.1的话），此规范都兼容。 所以小版本号不太重要.\n此外，与HTTP/1消息不同，在HTTP/2请求中未明确声明版本号。 例如，HTTP/2中没有GET /index.html HTTP/1.1形式的请求。 但是，许多实现会在日志文件中使用次要版本号（.0）。例如，在Apache日志文件中，版本号显示为HTTP/2.0，其甚至会伪造HTTP/1形式的请求 4.1.1 使用二进制格式替换文本格式 使用基于文本的协议，要先发完请求，并接收完响应之后，才能开始下一个请求。\nHTTP的小改进\nHTTP/1.0引入了二进制的HTTP消息体，支持在响应中发送图片或其他媒体文件。 HTTP/1.1引入了管道化和分块编码。 都有队头阻塞（HOL）的问题——在队列首部的消息会阻塞后面消息的发送，更不用说，管道化在实际应用中并没有得到很好的支持。 4.1.2 多路复用代替同步请求 HTTP/1是一种同步的、独占的请求-响应协议。HTTP/1的主要解决方法是打开多个连接，并且使用资源合并以减少请求数，但这两种解决方法都会引入其他的问题和 带来性能开销。\n图4.1　并发多个HTTP/1请求，需要多个TCP连接\nHTTP/2允许在单个连接上同时执行多个请求，每个HTTP请求或响应使用不同的流。通过使用二进制分帧层，给每个帧分配一个流标识符，以支持同时发出多个独立请 求。当接收到该流的所有帧时，接收方可以将帧组合成完整消息。\n图4.2　使用多路复用技术的HTTP/2连接请求三个资源\nHTTP/2连接在请求发出后不需要阻塞到响应返回 服务器发送响应的顺序完全取决于服务器，但客户端可以指定优先级。 每个请求都有一个新的、自增的流ID（如图4.2中所示的流5、7和9）。返回响应时使用相同的流ID 响应完成后，流会被丢弃而且不能重用 为了防止流ID冲突，客户端发起的请求使用奇数流ID, 服务器发起的请求使用偶数流ID。 请注意，在写作本书时，从技术上讲服务器不能新建一个流，除非是特殊情况（服务端推送，但也要客户端先发起请求） ID为0的流（图中未显示出）是客户端和服务器用于管理连接的控制流。 小结\nHTTP/2使用多个二进制帧发送HTTP请求和响应，使用单个TCP连接，以流的方式多路复用。 HTTP/2与HTTP/1的不同主要在消息发送的层面上，在更上层，HTTP的核心概念不变。例如，请求包含一个方法（例如GET）、想要获取的资源 （例如/styles.css）、首部、正文、状态码（例如200、404）、缓存、Cookie等，这些都与HTTP/1保持一致。 图4.3　HTTP/2中的流和HTTP/1中的连接相似\n4.1.3 流的优先级和流量控制 现在HTTP/2对并发的请求数量的限制放宽了很多（在许多实现中，默认情况下允许同时存在100个活跃的流），因此许多请求不再需要浏览器来排队，可以立即发送它 们。这可能导致带宽浪费在较低优先级的资源（例如图像）上，从而导致在HTTP/2下页面的加载速度变慢。所以需要控制流的优先级，使用更高的优先级发送最关键 的资源。\n流的优先级控制是通过这种方式实现的：当数据帧在排队时，服务器会给高优先级的请求发送更多的帧。\n流量控制是在同一个连接上使用多个流的另一种方式。如果接收方处理消息的速度慢于发送方，就会存在积压，需要将数据放入缓冲区。而当缓冲区满时会导致丢包， 需要重新发送。在连接层，TCP支持限流，但HTTP/2要在流的层面实现流量控制。\n4.1.4 首部压缩 HTTP首部（包括请求首部和响应首部）用于发送与请求和响应相关的额外信息。在这些首部中，有很多信息是重复的，多个资源使用的首部经常相同。\nCookie User-Agent Host Accept Accept-Encoding 4.1.5 服务端推送 HTTP/2添加了服务端推送的概念，它允许服务端给一个请求返回多个响应。\nHTTP/2服务端推送是HTTP协议中的新概念，如果使用不当，它很容易浪费带宽。浏览器并不需要推送的资源，特别是，在之前已经请求过的服务器推送的资源，放在 浏览器缓存中。决定什么时候推送、如何推送，是充分利用服务端推送的关键。\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BD%BF%E7%94%A8http2/%E7%AC%AC4%E7%AB%A0-http2%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/4.1/","summary":"新版本的协议与原来的协议有很大的不同，新增了如下概念： 二进制协议 多路复用 流量控制功能 数据流优先级 首部压缩 服务端推送 HTTP/1.0的Web服","title":"4.1 为什么是HTTP/2而不是HTTP/1.2"},{"content":"3.1 HTTP/2的支持 你能否在网站上使用新的网络技术，主要取决于三点：\n浏览器是否支持这项技术？ 你的基础设施是否支持？ 如果这项技术未获得支持，是否有健壮的回退机制？ 3.1.1 浏览器对HTTP/2的支持 图3.1　caniuse.com中的HTTP/2数据\n图3.2　caniuse.com中的HTTP/2数据，Usage Relative视图\n浏览器对HTTP/2和HTTPS的支持\n在前面的图中，每个支持HTTP/2的浏览器都有一个小2作为备注，底部有“仅支持基于TLS的HTTP2（https）”的说明，因此不使用HTTPS的网站无法从HTTP/2中受 益。SPDY也有类似的限制，当HTTP/2被标准化时，人们也对此限制进行了大篇幅的讨论，许多参与方都要求强制将HTTPS作为规范的一部分。后来，这个要求被排除 在HTTP/2的正式规范之外，但是所有浏览器厂商都表示，他们将仅支持基于HTTPS的HTTP/2，这使其成为事实上的标准。要求支持HTTPS无疑会使仅支持HTTP 网站的站长不开心，但这种要求有两个很好的理由。\n第一个理由纯粹从实用方面考虑。仅通过HTTPS使用HTTP/2意味着不太可能出现兼容性问题。网上许多基于HTTP的基础设施，在升级之前不知道如何处理HTTP/2 消息。在HTTPS中包装消息，可以隐藏HTTP消息本身，从而避免兼容性问题。 第二个理由比较主观。许多浏览器厂商（和其他人，包括我）坚信，要远离未加密的HTTP，所有网站都应该转向HTTPS。因此，较新的功能通常仅支持HTTPS，以 鼓励人们切换为HTTPS。 即使你的网站支持了HTTPS，仍可能遇到问题。\n一些浏览器（如Chrome、Firefox和Opera）上的备注4意味着“只有服务器支持ALPN，其才支持HTTP2。 许多浏览器在使用HTTP/2之前需要更新为更安全的密码套件。 中间代理\n为了能够使用HTTP/2，浏览器和服务器都必须支持HTTP/2。但是，如果用户使用代理，把一个HTTP连接变成两个，且这个代理不支持HTTP/2，那HTTP/2还是不能 启用。\n查看计算机是否使用代理的最简单方法，是查看HTTPS证书，看看它是由谁颁发的，由真正的证书颁发机构颁发（有很多证书颁发机构，所以可能弄不清楚）还是由本 地软件颁发。\n图3.3　查看直接连接Google和通过反病毒产品连接Google时的HTTPS证书\n浏览器对HTTP/2支持情况的总结\n有几个情况可能导致无法使用HTTP/2，如服务端HTTPS设置不匹配，在使用拦截代理等。 对HTTPS的要求，尤其对ALPN的要求，使得启用HTTP/2变得更复杂了，会引起疑惑。这里的复杂性主要体现在，要求服务器正确设置 论。网络正朝着HTTPS大步迈进，未加密的HTTP网站受到的惩罚将继续增加，会有更明显的警告，新功能更少。 evergreen浏览器\n一些浏览器（如Chrome和Firefox）会在后台静默更新，不提示用户，我们称之为evergreen浏览器。这些浏览器的用户可能运行的是最新版本的浏览器，它们支持 HTTP/2。\n3.1.2 服务器对HTTP/2的支持 HTTPS库及其对HTTP/2的支持\nChrome和Opera仅支持基于ALPN的HTTP/2，而不支持NPN（Next Protocol Negotiation，下一代协议协商）。与之前的NPN一样，ALPN允许Web服务器在 HTTPS协商的过程中，声明服务器支持哪些应用程序协议；\n问题是ALPN仅包含在最新版本的OpenSSL（1.0.2及更高版本）中，在很多标准版本中并没有包含。 表3.1　不同的Linux系统对ALPN的支持\n服务端支持总结\n3.1.3 兼容不支持HTTP/2的情况 当客户端不支持HTTP/2时，网站仍然能正常工作，因为它们可以降级到HTTP/1.1。HTTP/1.1距离被废弃（如果会的话）还很遥远。从理论上讲，如果可能，应该启 用HTTP/2，因为并没有客户端不支持的问题。\n3.2 网站开启HTTP/2的方法 3.2.1 在Web服务器上开启HTTP/2 图3.4　Web服务器上的HTTP/2\n表3.2　流行的Web服务器开始支持HTTP/2的版本\n3.2.2 反向代理实现HTTP/2 图3.5　通过反向代理实现HTTP/2\n反向代理很常见，主要用于以下两种场景：\n作为负载均衡器 用以卸载一些功能，如HTTPS或者HTTP/2 图3.6　反向代理负载均衡\n是否需要在整个链路中支持HTTP/2\nHTTP/2的主要优点是可以提升高延迟、低带宽连接的速度，连接到边缘服务器（在这种情况下为反向代理）的用户通常处在这样的网络环境下。从反向代理到其他Web 基础架构的流量一般处于低延迟、高带宽、短距离的网络环境中（即使不是同一台机器，也通常是相同的数据中心），因此此场景下通常不需要考虑HTTP/1.1的性能 问题。\n如果反向代理到实际服务器的连接使用HTTP/2，则采用HTTP/2单个连接的方式收益也不高。因为反向代理到服务器的连接数不受限于浏览器设置的6个连接。甚至有 些人担心使用单个连接可能会导致性能问题，具体取决于在反向代理和目标服务器上的实现方式。Nginx已经声明，它不会为代理连接实现HTTP/2，所以也有这 方面原因。\n图3.7　在应用服务器/数据库服务器之前使用Web服务器\n图3.8　添加临时的反向代理，来测试HTTP/2\n3.2.3 通过CDN实现HTTP/2 大多数CDN已经支持HTTP/2了，所以你可以通过使用CDN的方式来启用HTTP/2，而源站只需要支持HTTP/1.1就行了。这个方法和使用反向代理类似，但是CDN有很 多反向代理服务器，它们可以帮你管理这个基础架构。\n图3.9　通过CDN启用HTTP/2\n3.2.4 小结 3.3 常见问题 表3.3　常见TLS库对ALPN的支持\n总结 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC1%E9%83%A8%E5%88%86-%E5%90%91http2%E9%9D%A0%E6%8B%A2/%E7%AC%AC3%E7%AB%A0-%E5%8D%87%E7%BA%A7%E5%88%B0http2/","summary":"3.1 HTTP/2的支持 你能否在网站上使用新的网络技术，主要取决于三点： 浏览器是否支持这项技术？ 你的基础设施是否支持？ 如果这项技术未获得支持，是","title":"第3章 升级到HTTP/2"},{"content":" 1 $ git config --global pager.branch false 执行git branch的结果将直接输出, 而不是输出到类似 more 命令的界面.\n可以利用自动补全查看pager.*下其他可配置东西.\n","permalink":"https://jdxj.github.io/posts/cmd/git/%E7%9B%B4%E6%8E%A5%E5%B1%95%E7%A4%BA%E7%BB%93%E6%9E%9C%E5%88%B0%E7%BB%88%E7%AB%AF%E8%80%8C%E4%B8%8D%E6%98%AFpager/","summary":"要不还得按\u003ccode\u003eq\u003c/code\u003e退出","title":"直接展示结果到终端而不是pager"},{"content":"无级变速器如何实现无级变速的？ 无级变速器的主要部件是两个滑轮和一条金属带，金属带套在两个滑轮上。\n无级变速器\n奥迪无级变速器工作原理示意图\n无级变速器视频\n无级变速器变速原理示意图\n奥迪无级变速器构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.07/","summary":"无级变速器如何实现无级变速的？ 无级变速器的主要部件是两个滑轮和一条金属带，金属带套在两个滑轮上。 无级变速器 奥迪无级变速器工作原理示意图 无级变","title":"4.7 无级变速器（CVT）"},{"content":"自动变速器是怎样利用行星齿轮变速的？ 自动变速器由两大部分组成：一是前面介绍的液力变矩器；二是下面要介绍的行星齿轮变速系统。\n从发动机输出的动力，经液力变矩器后，就会传递到变速结构。这个变速结构虽然也是利用齿轮组合来调节传动比，但它和手动变速器采用普通齿轮的方式截然不同， 而是采用行星齿轮机构，利用行星齿轮机构的特点调节出不同的传动比。\n所谓行星齿轮，是指有自转和公转的齿轮结构。中间的齿轮就像是太阳，只能自转；其周围的小齿轮则像是行星，可以围绕中间的太阳轮进行公转。当将太阳轮或行星 齿轮中的某一种齿轮固定不动时，就会变化出不同的传动比来，包括反转，从而可以输出不同的转速和转矩。\n行星齿轮是怎样实现变速的？ 自动变速器中的行星齿轮机构共有三种齿轮：中间的大齿轮称为太阳轮，黄色的小齿轮称为行星齿轮，最外面的齿圈称为环齿轮。这三种齿轮在进行变速时，分别作为 固定齿轮、主动齿轮和从动齿轮，根据不同的任务分配，就可变换出不同的传动比。\n环齿轮固定：太阳齿轮为主动齿轮，行星轮为从动齿轮，或相反。 行星齿轮固定：太阳齿轮为主动齿轮，环齿轮为从动齿轮，或相反。 太阳齿轮固定：环齿轮为主动齿轮，行星齿轮为从动齿轮，或相反。 自动变速器构造图\n自动变速器\n锁止离合器起什么作用？ 当液力变矩器传递动力时，由于它采用液压油作为传递介质，不是刚性传递，其间大约有10%的能量损失，这对节能降耗很不利，也会影响操控性。为了解决这个问题， 在液力变矩器和飞轮之间设置了一个单向锁止离合器，当车速较高时，用电控的方式起动此离合器，将液力变矩器的输入轴和输出轴锁止在一起，实现刚性直接传递动 力。也就是从发动机曲轴输出的动力，不需经过液力变矩器而直接传递到变速机构，从而提高传动效率。\n采埃孚9速自动变速器\n自动变速器最多档位数是多少？ 自从自动变速器被发明以来，它的前进档位数一直在增长，从最初发明时的3速，已增加到现在最多9速自动变速器，如奔驰、路虎和吉普等就有采用9速自动变速器的 车型。现在，8速自动变速器主要配备在宝马和奥迪等车型上，而7速自动变速器仅在奔驰老款车型上还有使用。现在，市场上主流的还是6速自动变速器，使用5速自动 变速器的越来越少，而使用4速自动变速器就非常落后了。\n奔驰9G-TRONIC PLUS 9速自动变速器 Continuous Variable Transmission\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.06/","summary":"自动变速器是怎样利用行星齿轮变速的？ 自动变速器由两大部分组成：一是前面介绍的液力变矩器；二是下面要介绍的行星齿轮变速系统。 从发动机输出的动力","title":"4.6 行星齿轮变速系统"},{"content":"液力变矩器是怎样工作的？ 液力变矩器主要由三个“轮”组成：泵轮、导轮和涡轮。在三个轮之间充满了液压油。泵轮与发动机曲轴相连，当发动机旋转时，泵轮便会随之旋转，并搅动液压油，将 其“甩向”与后面变速机构相连的涡轮，使涡轮旋转，从而将动力传向后面的变速机构，最终传递到车轮。固定不动的导轮的作用是增大传递转矩。\n液力变矩器\n奥迪A8轿车8速自动变速器\n液力变矩器构造示意图 Planetary Gear Transmission System\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.05/","summary":"液力变矩器是怎样工作的？ 液力变矩器主要由三个“轮”组成：泵轮、导轮和涡轮。在三个轮之间充满了液压油。泵轮与发动机曲轴相连，当发动机旋转时，泵","title":"4.5 液力变矩器 Hydraulic Torque Converter"},{"content":"奥迪汽车6速自动变速器构造示意图\n为什么自动变速器没有离合器？ 自动变速器组成: 液力变矩器、控制器、电磁控制机构、多片离合器和行星齿轮等\n液力变矩器的作用相当于手动档汽车上的离合器。其原理类似两个对吹的电风扇，当一个电扇通电旋转后，另一个电扇也会被吹得随之旋转。对吹电扇传递动力的介质 是空气，而液力变矩器传递动力的介质是油液。通过控制油液的流动状态，就可以控制动力和转速输出的大小。\n液力变矩器的原理类似两个对吹的电风扇，它们通过介质可以传递动力，起到离合器传递动力的作用\n液力变矩器\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.04/","summary":"奥迪汽车6速自动变速器构造示意图 为什么自动变速器没有离合器？ 自动变速器组成: 液力变矩器、控制器、电磁控制机构、多片离合器和行星齿轮等 液力变矩","title":"4.4 自动变速器（AT）Automatic Transmission"},{"content":"为什么手动变速器需要同步器？ 在手动变速器上，所有档位的主动齿轮和从动齿轮副都一直处于啮合状态并持续旋转，但只有一个档位的齿轮副与动力输出轴相接合。当我们操纵变速杆换档时，其实 是更换与动力输出轴接合的齿轮副。\n在与新的齿轮副接合时，由于动力输出轴基本保持原来上个档位的旋转速度，它与新的齿轮副之间的转速有差别，这样在与新齿轮副接合时就会产生一定的速度差，而 不同转速的部件硬性接合时就会产生冲击，损坏齿轮。\n为了避免换档时的冲击，使换档更加顺畅，手动变速器中都设有几个同步器。利用同步器的特殊性能，可以减少换档冲击。\n老式的汽车变速器上没有同步器，为了减少换档冲击，换档时必须采取“两脚离合”的方法：升档时在空档位置稍停顿一下，降档时在空档位置稍踩下加速踏板，以减少 齿轮之间的转速差。\n手动变速器原理示意图\n手动变速器构造图\n同步器是怎样工作的？ 同步器也称为犬牙啮合套，因为它在与档位齿轮接合时如同犬牙一样相互交错在一起。如图所示，当向左推动同步器时，同步器上的同步环就与档位齿轮上的接合齿圈 犬牙交错在一起。同步器毂与动力输出轴是接合在一起的，这样就可以使档位齿轮与动力输出轴接合在一起，从而达到变速的目的。\n同步器与档位齿轮接合示意图\n单件式同步器构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.03/","summary":"为什么手动变速器需要同步器？ 在手动变速器上，所有档位的主动齿轮和从动齿轮副都一直处于啮合状态并持续旋转，但只有一个档位的齿轮副与动力输出轴相","title":"4.3 同步器 Synchronizer"},{"content":"手动变速器\n手动变速器是怎样变速的？ 当离合器接合时，不管是在空档还是在任何档位，变速器中每个档位的主动齿轮（红色齿轮）以及每个档位的从动齿轮（蓝色部分）始终啮合在一起，并按照各自的转 速不停地旋转。但是，在空档时，各个档位的所有从动齿轮并没有和输出轴连接，此时输出轴是静止不转的。\n当挂上1档或其他前进档位时，实际上是将1档或其他档位的从动齿轮通过同步器（或称犬牙啮合套）和输出轴接合起来共同旋转。当变换档位时，则是换成新档位的从 动齿轮来与输出轴接合并共同旋转。\n5速手动变速器原理示意图\n倒档的主动齿轮和从动齿轮之间“夹”了一个中间轮，这样就可使输出轴的旋转方向与其他档位相反。\n4速手动变速器构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.02/","summary":"手动变速器 手动变速器是怎样变速的？ 当离合器接合时，不管是在空档还是在任何档位，变速器中每个档位的主动齿轮（红色齿轮）以及每个档位的从动齿轮（","title":"4.2 手动变速器 (MT) Manual Transmission"},{"content":"为什么汽车需要变速器？ 自行车变速原理示意图\n当主动链轮的直径和转速固定不变时，从动链轮越小，从动链轮的转速也会越高，输出的转矩也会越小；反之亦然\n汽车也是一样，发动机的转速非常高，但输出的转矩非常有限。起步时，不需要较大的车速，但需要较大的转矩，因此在起步阶段最好是让汽车低速、大转矩平稳运行； 在车速提高后，就不需要太大的转矩，而需要较高的车速。变速器的作用就如同自行车的变速齿轮，可以由驾驶人根据行驶情况来调节发动机输出的转速和转矩，从而 使汽车顺利地起步、爬坡和快速行驶等。\n什么是齿轮传动比？ 齿轮传动比简称齿比，是指主动齿轮与被动齿轮的角转速之比，也等于被动齿轮与主动齿轮的齿数之比。变速器的每个档位齿轮组合，都有一个与其他档位不同的传动 比。档位越低，其传动比越大；档位越高，其传动比越小。\n变速器各档位传动比值示例\n为什么变速器中要使用很多齿轮？ 一对相互啮合的齿轮，直径较小的齿轮以较小的力旋转，那么在较大齿轮上就会获得更大的力，但作为获得较大力的代价，大齿轮的转速则会相应降低。或者说，相互 啮合的一对齿轮，直径越大或齿数越多的齿轮，它的转速越低，转矩越大；转速越高，则转矩越小。\n齿轮变速原理示意图\n利用齿轮原理，可以将较大的转速转变为较小的转速，也可以将较小的转速转变为较大的转速\n齿轮放大转矩原理示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%80%9F%E5%99%A8/4.01/","summary":"为什么汽车需要变速器？ 自行车变速原理示意图 当主动链轮的直径和转速固定不变时，从动链轮越小，从动链轮的转速也会越高，输出的转矩也会越小；反之亦","title":"4.1 变速原理 Transmission Principle"},{"content":"1.1　负债概述 银行负债业务的主要目标就是给银行提供放贷用的资金。\n现代银行的业务模式和我们日常生活中的个人借贷不同，平时我们借钱给亲戚朋友是用我们自有的资金，而银行放贷的资金只有很少一部分是自有的，多数是从个人或 机构吸纳或拆借过来的。\n银行本身重要的职能之一就是从社会上吸收闲散资金并贷给需要资金周转的企业或个人。\n考察一家银行的负债业务是优秀还是平庸，最重要的指标就是负债成本。负债成本包含两部分：\n直接成本是指银行全部计息负债的综合利率，用综合利率乘以计息负债就可以得到一家银行的利息支出。 间接成本是指银行为了获取足够多的负债需要投入多少营运费用，包括网点租金、人工薪酬、设备采购费等。 9家典型的大中型银行2017年年报中的负债数据为例进行分析。其中，按照营运费用由负债业务和资产业务各占一半的标准来计算负债的间接成本。\n表1.1　2017年9家典型银行的负债成本\n注：表中负债利率并非精确数据，因此负债总额乘以利率计算得出的利息与表中利息支出有误差。 第一大阵营是四大行（指工、农、中、建四大国有商业银行，下同）。\n四大行的负债成本如此之低，一个重要的原因就是过去几十年开设的遍布全国各地的网点。虽然电子银行、手机银行等金融科技的发展正在逐渐抵消四大行的网点优势， 但是“瘦死的骆驼比马大”，在未来十年内，股份行（指股份制商业银行，下同）都不可能在负债成本优势上赶超四大行。\n第二大阵营就是“浦民兴平”这四家股份行。\n间接成本除了最近开始搞零售的平安银行稍高外，其他几家的间接成本甚至比四大行还要低。这主要是因为这几家股份行都是以对公业务为主，负债结构中零售客户的 负债占比较低。\n对私业务少, 营运费用少.\n招商银行（以下简称“招行”）\n招行的直接负债成本略高于四大行，但是又远低于其他股份行，间接负债成本是表中所有银行中最高的。这和招行“服务高端人群”的战略定位有一定的相关性。\n考察负债能力的另一个指标就是流动性覆盖率。\n这一指标能够反映银行在未来30天内是否有足够多的流动性资金来应对资金流出的压力。这一指标是从2014年开始推行的，并要求逐年提高达标线，2018年以后需 要高于100%。 这一指标的本质是压缩银行利用期限错配进行套利的空间，降低了这种操作带来的流动性风险。 期限错配是什么？\n期限错配在金融行业的表现是资金来源短期化、资金运用长期化。银行的资金成本和资产收益一般和时间周期正相关，久期越长的资金，其成本或者收益率也就越高。 这一模式正常运行的前提条件是：短期负债到期后可以续借，一旦负债不能续借或者利率大幅上行，就会产生流动性风险或利率倒挂。 流动性覆盖率=合格优质流动性资产／未来30天现金净流出量。 可用现金是未来30天流出现金的多少倍.\n为了提高流动性覆盖率，要么做高分子，要么降低分母。\n做高分子需要增加商业银行对高流动性优质资产如国债、政策金融债等利率债的持有，同时降低对二级资产如同业存单、一般工商企业债等的配置。 降低分母则意味着商业银行主动控制现金净流出，即寻求长期负债来替代短期负债、寻求稳定性较高负债（存款等）替代流动性较高负债（同业负债等）。 1.2 存款业务 1.2.1 存款的分类 按照存期划分\n活期存款 定期存款, 定期存款还可以按照久期的不同分为3个月、6个月、1年、2年、3年、5年等 另外有一些比较特殊的存款，包括：通知存款、协议存款和结构化存款等。 通知存款\n通知存款本身是介于活期和定期之间的一种无固定期限的存款，存款人必须预先通知银行方能提取。在我国常见的是1天通知存款和7天通知存款。通知存款按日计息， 利率视通知期限长短而定，一般高于活期、低于定期存款。\n协议存款\n协议存款是银行与其他机构法人或法人授权机构，通过签订协议约定存放利率，办理的一定期限、一定金额以上的存款业务。由于机构法人掌握的资金量大，所以谈判 的筹码就多一些。最终机构能够拿到的协议存款利率远高于银行给出的普通存款利率，而且除此之外可以得到很多流动性的支持。\n错误认识\n很多人认为储户购买了某宝或者某货币基金，银行吸收的存款就减少了。这是一个明显的误解，储户将存款转化为某宝或者某货币基金的时候，实际上是钱从个人存款 科目转移到了公司存款或者同业存款科目。所以，银行业总体的存款不会减少，只是负债的成本可能会上升。类似地，购买股票或者购买国债也都不会减少存款总量， 只是存款从一个个体转移到另一个个体或者机构账户上。\n结构化存款\n结构化存款是一种将存款和金融衍生品相结合的产品。结构化存款通常可以保本，利息可以有保底利息，也可以没有保底利息，但是一般最高可能的收益率会远远高于 普通存款的收益率。具体的产品设计大概是这样的：当用户购买了结构化存款后，银行实际上是把吸纳的资金存了定期，然后通过把定期存款应得的利息用于买入一种 衍生品，比如黄金看多期货或者黄金看空期货，如果压中了正确的衍生品，那么从衍生品获得的额外收入就会计入对客户的利息。\n按照客户性质划分\n对公存款, 就是企业的存款。由于企业的流动性需求比较大，所以，对公存款的活期占比较高，且相对稳定。 零售存款, 就是个人存款 对公贷款的派生存款: 公司向银行贷款, 但是没用完, 暂时又放到银行进行存款\n1.2.2 如何评估银行吸收存款的能力 银行吸收存款的能力主要考察两个方面：数量和质量\n所谓数量就是吸收存款的绝对数量和相对增速, 可以比较较长一段时间的存款增长率 所谓质量就是银行吸收存款的直接成本, 可以横向对比不同银行的存款成本。 表1.2　2008—2017年主要银行存款增速\n虽然股份行的存款增速远高于四大行，但是存款成本高\n表1.3　主要银行的存款成本（%）\n为什么招行的零售存款活期占比那么高?\n看完书上讲的和招行零售AUM突破10万亿意味着什么这篇文章, 我的理解是: 招行以AUM为目标, 在这 过程中会吸引大量需要流动性的资金且不用提高利率, 而以存款为目标的其他银行为获得更多存款提高利率, 从而使存款成本变高.\n感觉是降维打击了.\n1.2.3 和存款相关的指标 衡量货币流动性的指标\nM0=流通中现金，指银行体系以外各个单位和居民持有的现金之和。 M0反映的是流通中的现金量，是最狭义上的货币供应量，也是央行直接发行的钞票扣除银行留存的现金后剩余的部分。 M1=M0+企业在银行的活期存款+机关团体的存款+农村存款。 M1又称为狭义货币供应量，它反映了社会的直接购买力。 M1和社会商品供应量之间需要保持相对稳定，如果M1增幅大幅超越商品供应量的增幅，就会带来经济过热，反之就会带来萧条。 M2=M1+企业的定期存款+个人的储蓄存款+证券客户的保证金。 M2又叫作广义货币供应量，它反映了经济中的现实和潜在购买力。 如果M1增速大幅高过M2，则表明需求强劲，投资不足，存在通货膨胀的风险； 如果M2增速过高、M1增速过低，表明投资过热，需求不旺，可能有资产泡沫。 在这组指标中，M2和银行的关系最大。这是因为在整个货币体系中，M0的量是非常小的，以2018年8月央行披露的数据为例：M0共计7.06万亿元，M1有53.83万亿 元，M2则有178.87万亿元。M2基本上约等于银行体系内存款的数量，也就约等于银行的资产负债表规模。所以， M2的增速也就可以近似看成银行的存款增速和资产规模的增速。\n银行的资产规模增长因子和息差因子共同决定了占银行收入大头的净利息收入的增速，而最近两年一直在谈的金融降杠杆，说的就是要降低M2的增速。也就是说，在 “降杠杆”的经济环境，银行规模增长的因子下降是无法避免的。\n存款准备金：控制货币供给的“蓄水池”\n存款准备金是指金融机构为保证客户提取存款和资金清算需要而准备的资金，是缴存在中央银行的存款，中央银行要求的存款准备金占其存款总额的比例就是存款准备 金率。\n这些存款当中有多少不能动.\n行发放给企业的贷款通常会重新存放在银行形成派生存款。在极端情况下，一笔存款可以派生无限量的贷款和存款，这样会造成M2激增, 这肯定是央行无法容忍的。 所以，央行说：“不行，你们每吸收100份存款，就要缴存若干份到央行作为准备金。”那么在极限状态，一笔存款可以派生的总存款为(存款准备金率设为12%)\n1+0.88+0.88^2+…=（1-0.88^n）/（1-0.88）≈1/0.12≈8.33（倍） 可以看到存款准备金相当于一个控制广义货币的蓄水池。\n当市场流动性泛滥时，央行通过提升存款准备金率(增大分母)来收紧流动性； 而当流动性紧张的时候，央行通过降低存款准备金率(减小分母)来释放流动性。 存贷比：审视银行盈利水平的指标\n“存贷比”其实应该被称为“贷存比”，是银行贷款总额与存款总额的比率。 如果一家银行的存款很多、贷款很少，就意味着它成本高、收入少，银行的盈利能力就较差。 存贷比这个指标实际上已经不是强制性指标了 如果存贷比很高，实际上也反映了银行的存款增长乏力，无法支持银行资产负债表的扩张。这是因为存款不够的时候只能通过同业拆借和向央行拆借来满足负债需 求，而同业拆借的成本和央行借款的成本远高于存款的成本，过多使用拆借负债会显著压低银行的净息差。 1.3 同业负债 从本质上说，同业负债就是金融同业机构间的负债关系，传统的资金端通常以回购、拆借、同业存款的形式建立同业债权。\n对于不同的银行来说，同业负债的作用完全不同。有的银行是把同业负债作为一种短期资金调配方式或者被动负债，而有的银行则是把同业负债作为扩张资产负债表的 武器。银行的态度不同，其同业负债的占比和成本等都会有极大的差别。\n表1.4　不同银行的同业负债特点\n同业负债主要包括同业和其他金融机构存放、同业拆入和卖出回购。\n其中，同业和其他金融机构存放的占比是最大的；而卖出回购是最神秘的，相对也是占比最少的。 同业存放相对来说是比较少的，是指各银行为了方便结算，在各自有关的结算单位开立存款账户，这部分资金和资产表中的存放同业正好是相反的资金流向。 由于这部分资金要求的流动性很高，所以无论是同业存放还是存放同业的利率都是很低的 其他金融机构存放的这部分就有很大差别了。其他金融机构存放之中，有的是其他金融机构在这家银行存放的结算资金，比如：基金公司在托管银行存放的赎回备兑 金等；有的则是其他金融机构冲着高利率放过来的协议存款，比如：银行高息吃入余额宝的协议存款。因此， 不同银行在同业负债上的差异主要体现在其他金融机构存放上。 同业存放和存放同业的区别\n同业拆借, 又称同业拆放市场，是金融机构之间进行短期、临时性头寸调剂的市场。 这个市场产生的最主要原因是我国实行的存款准备金制度。每天银行间市场收市的时候，央行会冻结这部分存款准备金。 央行的存款准备金率远低于其他资产的收益率，所以，没有银行愿意在央行放太多的钱。 但是，由于银行每日的存款余额和汇兑情况都在发生变化，这就造成了有的银行手头资金富余，有的不足以交够存款准备金。那么，资金富余的银行就可以将手头 的闲置资金拆借给缺乏资金的银行。 但需要注意的是，这种拆借资金的权属并没有发生改变，也就是说在约定期限到期后，这些拆借资金必须还给拆出方。 这个和下面要介绍的卖出回购金融资产最大的不同就是拆借没有资产抵押，完全是建立在信用的基础上。 卖出回购资产回款，是同业负债中占比最小的，也是普通投资者接触最少的。 它是指银行将一些债券、股票等资产卖给其他银行，并约定好在什么时间以什么价格回购这些资产。 通常来讲，回购的总金额会高于银行卖出资产获得的资金总额，其中的差值就是卖方支付给买方的利息。 在这个交易过程中，两家银行更像是一种借贷关系，而用来交易的资产可以看作一种抵押物。 同业负债相比存款稳定性较差。同业负债有一定流动性风险，因为同业存放和同业拆借都是短期负债。同业市场本身也有其存在的重要意义, 可以通过同业业务实现资 本合理配置，从而实现“双赢”。\n1.4 同业存单 同业存单是存款类金融机构在全国银行间市场上发行的记账式定期存款凭证。\n同业存单就是一家金融机构向另一家花钱（本金+利息）买存款。 它并不是一直存在的，其实它是在2013年下半年才开始在银行间试行的，是应对利率市场化的一个重要步骤。 同业存单的期限不超过1年，一般可分为1个月、3个月、6个月、9个月和1年。 同业拆借的目的是调剂存款准备金的缺口，通常是短期的，参考的是Shibor利率 而同业存单的目的是补偿负债的缺口，通常是中长期的，参考国债利率。 谁缺钱谁发行.\n同业存单的计息方式有两种：固定利率和浮动利率。一般固定利率是在发行的时候约定一个利率，在兑付的时候按照原先约定的利率进行利息兑付；浮动利率则是按照 Shibor加点的方式计息。\n同业存单，本身在会计科目上一般被计入银行负债表中的“应付债券”。虽然应付债券中也包含其他的负债，但是，同业存单应该是应付债券中的大头。同业存单本身都 是零息债券，所谓零息债券又叫作贴息债券。\n同业存单对于四大行和股份行的作用完全不同。在市场上，国有四大行通常拥有较好的存款基础，所以愿意作为同业存单的买入行；而股份行多数存款不足，所以经常 作为同业存单的发行银行。同业存单的利率实际上形成了银行间中长期资金拆借的利率，能够间接反映银行间的流动性。\n通常在流动性充裕的时候，同业存单利率走低； 在流动性紧张的时候，同业存单利率走高。 表1.5　2018年6月股份银行同业存单发行情况\n表1.6　2018年7月股份银行同业存单发行情况\n同业存单的优势是不需要为其建立相应的网络和基础设施，就可以获取大量的负债，这种优势对于网点较少的股份行非常有诱惑力。通过同业存单拿到负债就意味着不 用像吸储那样付出附加成本（网点营运费用、员工工资等），而且负债规模可以快速扩张。\n但是，同业存单也有其自身的问题。同业存单是所有负债中对流动性最敏感的。如果碰见市场流动性突然紧缩，就很容易出现利差损甚至是拆借不到资金的情况。 同业存单对于银行股的投资者来说具有非凡的意义。因为各家银行发行同业存单的情况是在特定的网站上每天公布的，这样投资者通过查询每天发行的同业存单利率、 金额和久期，就可以评估银行间的流动性松紧情况，同时可以根据同业存单的利率水平推测其他同业负债的利率变化趋势。\n由于股份行中多数同业负债占比较高，所以通过同业存单的数据，可以对这些股份行的息差进行预测。同业存单是少数可以实时窥测银行负债利率和数量变化趋势的工 具，所以，致力于银行基本面研究的读者，绝对不能放过对同业存单这个负债品种的监测。\n1.5 央行借款 向央行借款的途径\n在早期一般情况下，商业银行向中央银行的借款只能用于调剂头寸、补充储蓄的不足和资产的应急调整，而不能用于贷款和证券投资。但是，随着这几年各种流动性政 策调节工具的丰富，向央行借款也可以投向特定的信贷领域。\n因此，在向央行借款的负债科目下，包括三大类：再贷款、再贴现和其他流动性政策工具。\n再贷款是早期我国商业银行向中央银行借款的主要形式，一方面是早期国内商业票据信用市场尚不完善；另一方面是在商业银行改制前，商业银行对于央行资金的依 赖度较高。我国中央银行的再贷款有年度性贷款、季节性贷款和日拆性贷款三种，分别应对商业银行不同周期的头寸调节需求。 再贴现是近些年随着商业票据市场的发展而逐步发展起来的，而且在未来会逐步取代再贷款。所谓再贴现就是商业银行把未到期的已贴现票据作为抵押物向央行进行 再贴现，本质上就是商业银行通过票据债权转让，从央行进行再贷款。 结构性货币政策工具\n从2013年开始，央行开始推出多种结构性货币政策工具，用以调节银行间的流动性。这些工具多数以国债、央行票据等高等级信用票据为质押品，期限从7天到1年不 等。这些工具主要包括：SLF、MLF、TMLF、SLO、PSL、TLF等。央行利用这些工具在公开市场上拿钱买卖有价证券，来调节货币供应量和利率。\n表1.7　货币政策工具概览\n","permalink":"https://jdxj.github.io/posts/books/%E7%9C%8B%E9%80%8F%E9%93%B6%E8%A1%8C-%E6%8A%95%E8%B5%84%E9%93%B6%E8%A1%8C%E8%82%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC1%E7%AB%A0-%E9%93%B6%E8%A1%8C%E7%9A%84%E8%B4%9F%E5%80%BA%E4%B8%9A%E5%8A%A1/","summary":"1.1 负债概述 银行负债业务的主要目标就是给银行提供放贷用的资金。 现代银行的业务模式和我们日常生活中的个人借贷不同，平时我们借钱给亲戚朋友是用我们","title":"第1章 银行的负债业务"},{"content":"跳过\n","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC10%E7%AB%A0-%E5%85%B8%E5%9E%8B%E6%B6%88%E8%B4%B9%E5%93%81%E4%BC%81%E4%B8%9A%E8%B4%A2%E6%8A%A5%E5%88%86%E6%9E%90/","summary":"跳过","title":"第10章 典型消费品企业财报分析"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/httparchive/","summary":"主页","title":"http archive"},{"content":"转子发动机是怎样产生动力的？ 现在所说的转子发动机，是指德国工程师菲利克斯·汪克尔在20世纪50年代设计的三角形活塞式转子发动机。因此，转子发动机也被称为汪克尔发动机。\n转子发动机的主要部件结构简单，体积小，功率大，高速时运转平稳，性能较好，曾引起汽车行业的关注，纷纷进行研制试验。但是，经过几十年的试验证明， 这种机型尚无法与传统往复活塞式发动机相媲美，其边缘磨损严重，油耗较高。\n马自达RX-8跑车转子发动机\n转子发动机工作行程示意图\n转子发动机 转子发动机\n往复式四行程发动机工作原理示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.19/","summary":"转子发动机是怎样产生动力的？ 现在所说的转子发动机，是指德国工程师菲利克斯·汪克尔在20世纪50年代设计的三角形活塞式转子发动机。因此，转子发","title":"3.19 转子发动机 Rotary Engine"},{"content":"奔驰V6柴油发动机构造图\n柴油发动机\n为什么柴油发动机没有点火系统？ 柴油发动机是一种压燃式内燃机，是以柴油为燃料的内燃机。柴油发动机利用气体被压缩后温度会上升的原理，用活塞压缩进入气缸的空气；当空气温度上升到 柴油燃点温度时，用喷油器将柴油喷成雾状射入气缸；柴油一旦与灼热的空气相遇，即发生燃烧；燃烧所产生的高温高压燃气在气缸内膨胀，从而推动活塞做功。 柴油是在高温高压之下“自燃”的，不是被点燃的，所以柴油发动机不需要点火系统。\n随着技术的发展，现在一些柴油发动机也被应用在轿车上，甚至作为跑车的动力系统。尤其在欧洲，柴油发动机在轿车上的应用非常普遍。\n柴油发动机是怎样工作的？ 进气行程. 进气门打开，排气门关闭，空气从进气门被吸入气缸，然后进气门关闭。 压缩行程. 活塞上升并压缩吸入的空气，使空气温度升高。喷油器将燃油喷入气缸，并混入热空气中 做功行程. 柴油与空气的混合气越来越热，以至于温度升高到可以自燃。混合气燃烧爆炸的力量将活塞向下推动，并通过连杆推动曲轴旋转。 排气行程. 排气门打开。旋转的曲轴推动活塞向上运动，活塞将燃烧后的废气从排气门推出气缸。 柴油发动机\n柴油发动机工作行程示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.18/","summary":"奔驰V6柴油发动机构造图 柴油发动机 为什么柴油发动机没有点火系统？ 柴油发动机是一种压燃式内燃机，是以柴油为燃料的内燃机。柴油发动机利用气体被压","title":"3.18 柴油发动机 Diesel Engine"},{"content":"发动机润滑系统示意图\n发动机润滑过程\n机油在发动机内是怎样流动的？ 当发动机不工作时，机油主要储存在油底壳。当发动机运转时，机油从油底壳经机油集滤器被机油泵抽送到机油滤清器中，经机油滤清器过滤后再进入主油道， 然后再通过各分油道进入润滑部位进行润滑。润滑后的机油，在重力作用下再流回到油底壳，参与再循环。\n为什么机油能起润滑作用？ 机油分散在摩擦面上，在摩擦面之间形成隔离层，并可以四处自由流动，这样就可以避免接触面上微小凹凸颗粒之间的摩擦，从而使部件之间的相对运动更加顺 畅。\n通用汽车V8发动机润滑系统示意图\n发动机润滑过程\n为什么要使用机油滤清器？ 为了不断清除润滑系统中的杂质，如金属屑、机油中的胶质等，在机油循环系统中必须装备机油滤清器，并且要定期更换，以保证它拥有较佳的过滤性能。\n下图中，黄色表示还没有过滤的机油，绿色表示已经过滤的机油。\n机油滤清器构造图\n奥迪3.0升V6 TFSI发动机润滑循环系统\n湿式油底壳和干式油底壳有什么不同？ 湿式油底壳，发动机的曲轴曲拐和连杆大头在曲轴每旋转一周时都会浸入油底壳的机油内一次，从而起到润滑作用，同时曲拐每次高速浸入油液内都会激起一定 的油花和油雾，还可以对曲轴和轴瓦进行润滑。\n这种润滑方式对于追求运动性能和越野性能的车型来讲就存在一个比较大的问题，当汽车高速过弯或者在极限越野中车身倾斜很大时，离心力或者重力会造成机 油聚集于油底壳的一个局部，导致部分曲拐不能浸入油液，从而影响润滑。\n为了解决这个问题，把发动机底部的油底壳，改成一个独立安装的机油箱，利用机油泵的压力强制将机油送到各个润滑点，并将润滑后的机油回送到机油箱。这 样的润滑方式，可以不受重力和离心力的影响，这就是干式油底壳。\n奔驰SLS发动机干式油底壳构造图\n保时捷水平对置6缸发动机润滑系统示意图\n为什么水平对置发动机的润滑系统更复杂？ 水平对置发动机的气缸都呈横卧形状，而且是对向排列，因此，要将机油抽送到气缸各处参与润滑，其难度比直列或V形发动机要大得多。更难的是，参与润滑后 的机油无法在重力作用下流回油底壳，必须通过机油泵才能回送到机油箱。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.17/","summary":"发动机润滑系统示意图 发动机润滑过程 机油在发动机内是怎样流动的？ 当发动机不工作时，机油主要储存在油底壳。当发动机运转时，机油从油底壳经机油集滤","title":"3.17 润滑系统 Lubrication System"},{"content":"发动机都有哪些冷却方式？ 风冷是在气缸体周围设计散热片，利用自然风或风扇来吹散发动机的热气，达到降低发动机温度的目的。 水冷是指利用冷却液来降低发动机的温度。 发动机冷却系统\n散热器和风扇构造图\n散热器是怎样散热的？ 汽车发动机冷却系统示意图\n为什么发动机不能过热或过冷？ 如果发动机温度过高，活塞和气门在高温下就可能发生膨胀变形，导致发动机损坏；如果冷却不良，发动机动力输出会下降，甚至引起爆燃等不正常的燃烧现象。 如果发动机过冷，会使汽油雾化效果变差，燃烧效率降低，燃烧不完全，进而降低动力输出，增加油耗。\n发动机内部温度有多高？ 在发动机内部，当发动机以极高速度运转时，它的最高燃烧温度可以高达2500℃，最低也要超过1000℃。可惜的是，这些热量很难被有效利用。不仅如此，它还 会使与其接触的机械部件受热膨胀，因此还必须消耗机械能量使其降温。据测试，燃油燃烧产生的总热量有1/3被吹散到大气中，被白白浪费掉。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.16/","summary":"发动机都有哪些冷却方式？ 风冷是在气缸体周围设计散热片，利用自然风或风扇来吹散发动机的热气，达到降低发动机温度的目的。 水冷是指利用冷却液来降低","title":"3.16 冷却系统 Coolant System"},{"content":"活塞的直线运动怎样转变成曲轴的旋转运动？ 与我们骑自行车的情况类似。\n活塞相当于人的膝盖，连杆相当于人的小腿，曲轴相当于脚蹬子，当活塞上下运动时，便会带动曲轴做旋转运动。 由直线运动转变为旋转运动示意图\n发动机直线运动转为旋转运动构造图\n发动机内部运动\n汽油发动机内部构造 为什么说活塞是心脏中的心脏？ 在发动机中，活塞的工作条件最严酷，不仅要承受巨大的压力，而且要承受非常高的温度。在高速运转中，活塞的行进速度有时可达到20米/秒。因此，活塞对 材质和制作精度等要求都非常高。\n活塞的顶部一般都不是平的，而是凹进去一点，这主要是为燃烧室留出空间。另外，为了减轻活塞的重量，一般都将它设计成空心的。\n被拆解的活塞连杆组件\n发动机活塞\n活塞和连杆构造和分解图\n活塞连杆构造图\n1马力代表1匹马的力量吗？ 马力最早是指一匹货运马在一定时间内所做的功，而不是指一匹马的力量或它的“劲儿”有多大。\n1英制马力（hp）=76千克力·米/秒\n“马力”概念示意图\n后来马力又被定义为：1公制马力（ps）=75千克力·米/秒\n在正规场合或专业术语中，人们基本不再使用马力作为功率的单位，而是使用瓦特（W）或千瓦（k W）作为功率的标准单位，或同时用马力和千瓦来表示。\n1英制马力（hp）=0.746千瓦（kW） 1公制马力（ps）=0.735千瓦（kW） 美国SAE标准常用英制马力（hp），而德国DIN、欧共体EEC和日本JIS标准常用公制马力（ps）。\n怎样理解转矩的概念？ 用一根1米长的扳手去扭动一个螺母，如果你用1牛顿或1千克力的手力量去扭动，那么施加在螺母上的转矩就是“1牛·米”或“1千克力·米”。\n所谓发动机的动力, 其大小是转矩与转速的乘积。\n应该功率.\n什么是曲轴、曲拐、曲柄？ 发动机主要构造分解图\n曲轴上的曲柄长度对发动机性能有直接影响。曲柄长度越大，它的最大转矩输出相对也越大，但最大转速相对较低；反之，如果曲柄越短，则它的发动机最大转 矩相对较小，但最高转速相对较高。另外，气缸的行程等于曲柄长度的2倍。\n曲轴在发动机中的位置示意\n为什么说曲轴是中心轴？ 发动机产生的动力经由活塞、连杆再传到曲轴，使曲轴每分钟旋转数千次，将动力传递到传动系统，使车轮转动。曲轴的旋转也会带动水泵、机油泵、发电机和 凸轮轴带轮等。可以说，曲轴是发动机动力的中转轴，是中心轴。由于它是弯弯曲曲的轴，故称为曲轴。\n为什么需要平衡重和平衡轴？ 平衡重的作用\n曲轴通过连杆将活塞的往复运动转变成圆周运动，既要承受很大的力，又要高速旋转，它的强度必须非常高，刚性也要好，因此一般都比较粗壮，运动起来振动 也较大。为了减小曲轴运转中的振动，一般都会在它上面装有平衡重块，以保证发动机运转平稳。\n平衡轴的作用\n当活塞运行到上止点和下止点时，连杆是倾斜的，会产生一个横向力，从而使曲轴在运转时产生振动。由于活塞完成一次往复运动要产生两次振动，因此又把这 种振动称为二次振动。在曲轴两侧设置两根平衡轴，并且使平衡轴的转速是曲轴的2倍，以平衡二次振动。\n平衡轴有链传动和齿轮传动形式，它们的转速都是曲轴的2倍。\n发动机平衡轴\n发动机曲轴构造图\n链传动的双平衡轴曲轴构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.15/","summary":"活塞的直线运动怎样转变成曲轴的旋转运动？ 与我们骑自行车的情况类似。 活塞相当于人的膝盖，连杆相当于人的小腿，曲轴相当于脚蹬子，当活塞上下运动时","title":"3.15 发动机主运动部件 Engine Major Moving Parts"},{"content":"发动机共有多少个部件？ 根据构造复杂程度的不同，一台发动机不可拆解的零部件总数，大概为300～600个。据称，一辆法拉利跑车的发动机约有800个独立的零部件，而布加迪威航的 W16发动机约有3500个零件。\n雪佛兰克尔维特V8发动机部件分解图\n克尔维特V8发动机\n克尔维特ZR1跑车6.2升V8机械增压汽油发动机分解图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.14/","summary":"发动机共有多少个部件？ 根据构造复杂程度的不同，一台发动机不可拆解的零部件总数，大概为300～600个。据称，一辆法拉利跑车的发动机约有800","title":"3.14 发动机整体构造 Engine Structure"},{"content":"为什么说火花塞像闪电？ 火花塞构造图\n要想产生燃烧，必须满足三个条件：燃料、氧气和温度。\n柴油发动机上没有火花塞，它是先将气缸内的空气强力压缩，直到空气温度升高到柴油的燃点，然后向气缸内喷射柴油，便可瞬间点燃柴油。\n火花塞产生高压放电的原理和雷电产生的原理是一样的。分别带正电和负电的两个电极离得非常近，一般不到1毫米。当它们分别带正电和负电时，一旦接近就会 产生电火花，电压甚至高达1万伏。它可以在瞬间点燃气缸中已被压缩升温的混合气。\n发动机是怎样起动的？ 发动机起动\n汽油发动机起动系统示意图\n汽车起动和点火流程示意图\n发动机起动和充电系统\n起动机是怎样工作的？ 汽车起动机构造示意图\n起动机工作原理\n为什么不能再用“接线法”起动汽车了？ 在传统汽车的点火起动系统中，只要将起动机与蓄电池之间的电路接通，就能利用起动机带动发动机的活塞运转，同时带动分电器工作，控制每个气缸的点火和 喷油，使发动机正常起动。因此，即使不用车钥匙，也能用“接线法”将汽车起动。\n现在的发动机已没有了分电器，不再用机械方式控制每个气缸的点火和喷油，而是由发动机电脑（ECU）控制。因此，即使将起动机的电源线接通，也只能使起 动机转动，并不能使点火和喷油系统正常工作。当车钥匙插入并扭转时，汽车上的防盗系统会识别车钥匙内密码芯片的信息，当确认合法后，才会起动燃油喷射 和点火系统。否则，将拒绝喷油和点火，使车辆无法起动。\n车辆起动防盗系统\n蓄电池的作用是什么？ 蓄电池只是储存电能的设备，而产生电能的部件还是由发动机驱动的发电机。发电机与蓄电池并联使用。\n蓄电池构造图\n汽车发电机构造图\n为什么发动机起动需要飞轮？ 飞轮的作用是储存发动机的运动能量，因为无论旋转速度多高，活塞在完成的四个行程中只有一次是做功的，而进气、压缩、排气三个行程中活塞都会遇到较大 的阻力，需要一定的力量才能完成任务。因此，利用重量和直径都较大的飞轮先把动能储存起来，便可带动曲轴平稳运转。\n飞轮还有另外两个作用：\n一是它的外周镶有齿环，它与起动机直接相连，通过起动机带动飞轮旋转从而起动发动机； 二是利用飞轮圆盘的大面积，可以让它与离合器相连，从而向传动系统传递动力。 发动机的气缸数越多，动力重叠便越多，因此不必储存太多动能，飞轮就可以小一点。虽然飞轮越重，发动机越平稳，但是因为惯性，太重的飞轮也会使发动机 加速或减速都慢。因此，载货车发动机的飞轮大而重，跑车发动机的飞轮则小而轻。\n发动机飞轮构造图\n飞轮作用一：储存能量，带动曲轴平稳旋转。\n飞轮作用二：起动机通过带动飞轮旋转来起动发动机。\n飞轮作用三：与离合器相连，向传动系统传递动力。\n发动机制动是怎么回事？ 当驾驶人完全抬起加速踏板，但不踏下离合器踏板，车辆的惯性力就会带动车轮继续旋转，进而由驱动轮通过半轴、差速器齿轮、变速器齿轮、发动机飞轮等传 动机构，带动发动机曲轴旋转。而此时发动机的压缩行程会产生压缩阻力，加上发动机内摩擦力和进排气阻力等，就会对驱动轮形成制动作用。这种现象就称为 发动机制动。\n发动机制动时，档位越低，发动机制动力就越大；反之，则越小。在下长坡道路行驶时，挂入低速档，利用发动机制动，可以减少制动次数，防止制动器过热引 起制动力热衰减；在冰雪、湿滑路面上行驶，应用发动机制动，可以防止侧滑。\n发动机制动原理示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.13/","summary":"为什么说火花塞像闪电？ 火花塞构造图 要想产生燃烧，必须满足三个条件：燃料、氧气和温度。 柴油发动机上没有火花塞，它是先将气缸内的空气强力压缩，直","title":"3.13 点火起动系统 Ignition Starting System"},{"content":"多点喷射和单点喷射有什么不同？ 如果每个气缸的进气歧管上都单独装配一个喷油器，每个喷油器只向一个气缸喷射燃油，那么就称之为多点喷射（M P I）。反之，只在进气管入口处装配一个 喷油器，由这一个喷油器向进气管处喷射燃油，然后再由进气歧管把混合气分散到各个气缸中，那么就称其为单点喷射。其实，随着多点喷射系统制造成本的下 降，现在轿车上已很少采用单点喷射了。\n单点燃油喷射系统示意图\n多点燃油喷射系统示意图\n发动机燃油喷射\n什么是“双喷”发动机？ “双喷”发动机配有两套燃油喷射装置，除了缸内燃油直喷系统外，还在进气道内设计了一个喷油器。根据行驶状况，缸内喷射与缸外喷射之间可以进行切换或共 同混合喷射，确保高效的动力输出和最佳的燃油经济性。\n丰田“双喷”发动机\n缸内直喷和缸外喷射有什么不同？ 缸外喷射是将燃油喷射到进气道中，与进气混合后再进入气缸内。缸内直喷是直接将燃油喷射入气缸中，如所有的柴油发动机和部分缸内直喷汽油机。由于燃油 缸内直喷对提高燃油经济性、提高动力输出都很有帮助，因此现在采用缸内直喷发动机的车辆越来越多。燃油缸内直喷已成为发动机先进技术的代表之一。\n缸外燃油喷射系统示意图\n缸内燃油喷射系统示意图\n“双喷”发动机喷射系统示意图\n怎样控制喷油时刻和喷油量？ 缸内直喷发动机上最先进的喷油器采用压电式喷嘴，它由无数个相互叠置的微型陶瓷碟片组成。如果给电磁线圈施予电压，陶瓷碟片的晶体结构就会发生改变（ 也就是所谓的压电效应），碟片随后以最低限度强力扩张，快速而精确地作用于控制阀，控制阀则会触发喷射针，从而喷射燃油；当电磁线圈断电后，磁力消失， 在压力弹簧的作用下，喷油针阀回复原位，喷油结束。这样，通过控制电磁线圈的电压，就可以实现喷油时刻和喷油量的精确控制。\n什么是高压油轨？ 缸内直喷发动机的高压油轨系统中的“轨”其实是一个储压器，其中燃油由油泵供给，可在最高200兆帕的压强下存储燃油，这相当于将一辆高档豪华轿车的重量 集中在1平方厘米的面积上。正是由于高压作用以及喷嘴上一个直径只有0.1毫米的精细小孔设计，共轨系统的喷射器能够将燃油雾化为极为精细的微粒，从而确 保出色、均匀的油气混合及高效的燃烧。\n奥迪缸内燃油直喷发动机喷油器\n高压共轨\n奥迪直列4缸汽油发动机燃油喷射系统\n燃油是怎样供给到发动机的？\n燃油被燃油泵从燃油箱中抽出，在进入发动机之前，还要经过燃油滤清器，才能进入燃油轨道，并在发动机电脑（ECU）的控制下喷射到进气道（缸外喷射） 或气缸内（缸内直喷），最终参与燃烧。\n由于燃油喷射的压力较大，在喷入进气歧管时可能造成进气歧管内压力不平衡，从而影响燃烧效率。为此，专门设置了一个压力调节器，当进气歧管内压力差较 大时，压力调节器打开阀门，允许一部分燃油流回燃油箱中。\n燃油供给\n燃油供给路线示意图\n燃油箱和炭罐\n炭罐起什么作用？ 汽油是易挥发的燃料，油箱内的燃油很容易挥发并增加油箱内部的压力，当压力到达一定值时就会产生危险。为了避免危险，在燃油箱和发动机之间设置了一个 充满活性炭的炭罐，让油箱中多余的燃油蒸气不再排到大气中，而是通过蒸气导管引入炭罐中，由活性炭来吸附燃油蒸气。当汽车开动时，炭罐电磁阀适时打开， 新鲜空气进入炭罐中，将炭罐中吸附的燃油“吹”向进气歧管，加入发动机燃烧中，以达到节约燃油和环保的目的。\n燃油箱是怎样布置的？ 现在，轿车用的燃油箱大多采用高分子高密度聚乙烯塑料制成。这种塑料燃油箱的优点是强度高，密封性好，容易制成符合布置空间的异形，从而可充分利用空 间，而且重量轻，耐腐蚀，抗冲击性好，在燃烧时也不易爆炸等。\n奥迪A8轿车燃油箱构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.12/","summary":"多点喷射和单点喷射有什么不同？ 如果每个气缸的进气歧管上都单独装配一个喷油器，每个喷油器只向一个气缸喷射燃油，那么就称之为多点喷射（M P I）。","title":"3.12 燃油供给系统 Fuel Supply System"},{"content":"机械增压器\n机械增压器是怎样工作的？ 机械增压（Supercharger）与涡轮增压的原理完全不同，它并不是依靠排出的废气来压缩进气，而是通过一个机械式的空气压缩机与曲轴相连，通过发动机曲 轴的动力带动空气压缩机旋转来压缩进气。压缩机是通过两个转子的相对旋转来压缩进气的。正因为需要通过曲轴转动的能量来压缩进气，机械增压会对发动机 输出的动力造成一定程度的损耗。\n机械增压器的特性也与涡轮增压器的特性刚好相反，由于机械增压器始终在“增压”，因此在发动机低转速时，其转矩输出就十分出色。另外，由于进气压缩量完 全是按照发动机转速线性上升的，整个发动机运转过程与自然吸气发动机极为相似，加速过程呈线性，没有涡轮增压发动机在涡轮介入那一刻的唐突，也没有涡 轮增压发动机的低速迟滞。但由于高转速时机械增压器对发动机动力的损耗巨大，因此在高转速时，其作用就不太明显了。\n机械增压器构造图\n带中冷器的机械增压发动机进气示意图\n机械增压器\n机械增压发动机工作原理示意图\n梅赛德斯-奔驰机械增压发动机构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.11/","summary":"机械增压器 机械增压器是怎样工作的？ 机械增压（Supercharger）与涡轮增压的原理完全不同，它并不是依靠排出的废气来压缩进气，而是通过一","title":"3.11 机械增压器 Supercharger"},{"content":"涡轮增压器\n涡轮增压器如何增压？ 涡轮增压（Turbocharger）发动机，是指利用排气冲击涡轮来压缩进气的增压发动机，简称Turbo或T。如果在一些轿车尾部看到字母Turbo或T，就表明该车 采用涡轮增压发动机。\n涡轮增压拥有良好的加速持续性，用通俗的话说就是后劲十足，而且最大转矩输出的转速范围宽广，转矩曲线平直。但是，低速时由于涡轮不能及时介入，导致 动力性稍差。\n大众汽车涡轮增压发动机构造图\n为什么要配备增压器？ 涡轮增压发动机原理示意图\n为什么涡轮增压器还要使用中冷器？ 气体有这样一个特性：当它受到压缩时，随着它的密度增加，它的温度也会上升，从而影响发动机的充气效率。如果想要进一步提高增压发动机的充气效率，就 要降低进气温度。\n热胀冷缩\n如果未经冷却的增压空气进入燃烧室，除了会影响发动机的充气效率外，还很容易导致发动机燃烧温度过高，造成爆燃等非正常燃烧，而且会增加废气中氮氧化 物的含量，加重排放污染。\n中冷器实际上就是个散热器，它被放置在通风良好的位置，吸收进气被压缩时产生的热量，从而降低进气温度。\n涡轮增压器\n奥迪2.5升直列5缸涡轮增压发动机\n涡轮增压器工作原理示意图\n为什么排气会有动力？ 排气的冲击力来自活塞上升时挤压燃烧废气的力量，当燃烧废气被“挤出”气缸时，废气就会带有一定的冲击力。\n双涡管单涡轮增压器是怎么回事？ 宝马直列6缸双涡管单涡轮增压发动机原理示意图\n宝马双涡管涡轮增压器\n4缸双涡管单涡轮增压器怎样工作？ 在宝马直列4缸双涡管单涡轮发动机排气系统中，将点火时间相邻的两个气缸的排气歧管两两分开（1和4一组，2和3一组），这样当3缸完成做功进行排气时， 1缸进入进气行程。由于1缸和3缸的排气歧管不相连，3缸的排气不会影响1缸的进气效果。其他缸工作时原理相同。这样点火相邻的两个缸的进排气不受干涉影 响，可以提高各个气缸的进排气量，从而有效提高发动机的效率。\n直列4缸双涡管单涡轮增压器构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.10/","summary":"涡轮增压器 涡轮增压器如何增压？ 涡轮增压（Turbocharger）发动机，是指利用排气冲击涡轮来压缩进气的增压发动机，简称Turbo或T。如","title":"3.10 涡轮增压器 Turbocharger"},{"content":"可变气缸和可变排量是怎么回事？ 每个厂商的可变气缸技术并不完全相同，但基本都是采用关闭气门和停止喷油的方式来关闭气缸的。\nDid You Know?\n在进排气凸轮轴上安装一套零行程的凸轮，当需要关闭部分气缸的工作时，只要指挥步进电动机使凸轮轴左右移动，就可以使部分气门处于零行程的工作状态， 也就是停止工作，使对应的气缸也停止工作\n奥迪可变气缸技术\n奥迪可变气缸发动机构造示意图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.09/","summary":"可变气缸和可变排量是怎么回事？ 每个厂商的可变气缸技术并不完全相同，但基本都是采用关闭气门和停止喷油的方式来关闭气缸的。 Did You Know? 在进排气凸轮轴上","title":"3.9 可变气缸 Variable Cylinder"},{"content":"可变气门有什么优点？ 当高转速时，需要吸入更多的空气（混合气），因此如果能把气门提得更高些（改变升程）或延长气门的打开时间（改变正时），便能满足需求，从而提高动 力； 反之低速时，则可以降低气门的升程或缩短打开时间，少吸入混合气，从而节省燃料。 奔驰可变气门\n宝马V12发动机可变气门发动机\n宝马Valvetronic电子气门是怎样工作的？ 宝马Valvetronic电子气门示意图\n宝马Valvetronic电子气门构造图\n宝马电子气门\n奥迪AVS可变气门是怎么回事？ 奥迪可变气门\n奥迪发动机可变气门构造图\n奥迪发动机可变气门AVS工作原理示意图\n本田VTEC可变气门是怎么回事？ 本田可变气门\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.08/","summary":"可变气门有什么优点？ 当高转速时，需要吸入更多的空气（混合气），因此如果能把气门提得更高些（改变升程）或延长气门的打开时间（改变正时），便能满","title":"3.8 可变气门技术 Variable Valve Technology"},{"content":"气缸内部构造图\n进气门和排气门\n进气门为什么比排气门大？ 因为进气是被“吸”进去的，而排气是被“推”出去的，所以进气比排气更困难，而且进气越多，燃烧得越好，发动机的性能也越好。因此，一般都将进气门设计得 比排气门大，以降低进气难度，提高进气量。有的干脆多设计一个进气门，这才有了3气门（2进1排）和5气门（3进2排）设计。\n气门构造及其辅助零件\n气门数为什么不能太多？ 多气门发动机具有高转速、高效率的优点。由于气门较多，高转速时进排气效果较好，且火花塞放在中央可提高压缩比，因此发动机性能也较好。但是，多气门 设计较复杂，气门驱动方式、燃烧室构造和火花塞位置都要精密安排，而且制造成本高，工艺要求先进，维修也较困难，其带来的效果并不是特别明显，或者说 有点不太划算。因此，现在基本放弃每缸5气门设计，而采用更为流行的每缸4气门设计。\n汽油发动机构造图\n为什么说凸轮轴像是指挥棒？ 在凸轮轴上，有数个圆盘形的凸轮。当凸轮轴旋转时，凸轮便会依序下压而使气门运动，使发动机产生四行程循环运动。同时，通过灵活控制凸轮轴的运行，还 可调节气门的升程和正时，从而提高发动机的性能。\n双顶置凸轮轴（DOHC）构造图\nV12发动机双顶置凸轮轴（DOHC）构造图\n配气正时机构示意图\n什么是顶置凸轮轴和双顶置凸轮轴？ 如果凸轮轴位于气缸的顶部，就称为顶置凸轮轴（Over Head Camshaft，简称OHC）。 如果在顶部只有一根凸轮轴同时负责进气门和排气门的开关，则称为单顶置凸轮轴（Single Over Head Camshaft，简称SOHC）。 如果在顶部有两根凸轮轴分别负责进气门和排气门的开关，则称为双顶置凸轮轴（Double Over Head Camshaft，简称DOHC） 奥迪V6发动机正时机构示意图\n为什么发动机需要正时？ 在进气、压缩、做功和排气四个行程中，曲轴要转两周，而进气门或排气门只动作一次。由此可知，凸轮轴的转速必须是曲轴转速的一半，才能上下合拍，也就 是达到正时。因此，凸轮轴齿（带）轮齿数是曲轴齿（带）轮齿数的两倍，以使它的转速慢下一半来。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.07/","summary":"气缸内部构造图 进气门和排气门 进气门为什么比排气门大？ 因为进气是被“吸”进去的，而排气是被“推”出去的，所以进气比排气更困难，而且进气越多，燃","title":"3.7 气门和气门正时 Valve and Valve Timing"},{"content":"为什么发动机要进气和排气？ 空气由进气口进入，通过空气滤清器过滤后，经进气歧管进入气缸，并在进气歧管内布置有节气门和空气流量计来控制和调节进气量。\n发动机排气系统的作用，是将已燃烧的废气排入大气。它主要由排气歧管、排气管和排气消声器组成，并在排气管段布置有三元催化转化器，以净化排气。\n汽油发动机进气和排气系统构造图\n节气门起什么作用？ 进气系统主要包括两大部件：\n一是空气滤清器，它主要滤清空气，去除空气中的杂质； 二是进气道，它将空气与燃油的混合气引入气缸。 在进气道中有节气门，它可控制进入气缸的混合气的多少。\n此节气门与驾驶人脚下的加速踏板（俗称“油门踏板”）直接相连，加速踏板踏下越深，节气门开度越大，混合气进入就越多，发动机的转速就越高。 如果加速踏板和节气门是通过电信号控制的，而不是拉索硬性连接，那么就称其为电子节气门（俗称“电子油门”）。 节气门体和进气歧管\n节气门在发动机上的位置图\nhttps://res.weread.qq.com/wrepub/epub_26688761_73\n进气歧管系统\n节气门体\n什么是理想空燃比？ 空气与汽油的混合比也称空燃比。根据计算，它的理想值大概在14.7∶1左右，也就是燃烧1千克的汽油需要吸入14.7千克的空气。如果按体积之比，则大概为 9000∶1，就是说要燃烧1升的汽油，必须吸入9000升的空气。这样算来，汽车每分钟要吸入3000～5000升的空气，而我们人体每分钟只需吸入6升空气就够用 了。\n为了提高进气量，人们想出了各种方法，比如增大发动机的排气量、采用进气歧管可变技术、采用气门可变技术、配备增压器等。可以说，现在的发动机技术， 基本就是指怎样精确调节进气的技术，使发动机顺畅呼吸，让燃油得到充分燃烧，从而提高动力，节省燃油，降低排放。\n每分钟吸入空气量比较\n为什么进气歧管长度可以变化？ 原理是根据需要打开或关闭进气歧管中的一些阀门，使进气“走捷径”或“绕道”来改变进气行程，从而调节进气量和进气速率。\n可变进气歧管长度示意图\n可变进气歧管发动机\n为什么排气歧管奇形怪状？ 排气歧管是指从排气门出来的七扭八歪的那部分金属管。由于每个气缸的排气时刻都不一样，为了保证每个气缸的排气顺畅，必须防止不同气缸之间的排气有干 扰。因此，在设计排气歧管时要遵循四项基本原则：\n排气歧管要尽可能长。 各缸排气歧管要尽可能等长。 各缸排气歧管要尽可能独立，互不干涉。 排气歧管内表面要尽可能光滑。 排气管上的部件相对要多一些，如氧传感器（2个）、三元催化转化器（1～2个）、消声器（1～2个），都要安装在排气管上。\n发动机排气歧管造型\n氧传感器起什么作用？ 氧传感器位置示意图\n发动机排气系统\n现在，汽车的发动机都采用电脑（ECU）控制燃油的喷射，必须精确地控制混合气的空燃比（空气和燃油比例的理想值为14.7∶1），才能使燃油的燃烧效率尽可 能高。氧传感器实际上就是测量排气中氧气含量的部件，当排气中氧气含量高于或低于规定时（也就是空燃比偏离理想值时），氧传感器就会向发动机ECU报告， ECU就会根据情况自动调节喷油量。\n目前，车辆大多安装有两个氧传感器，在三元催化转化器前后方各有一个。\n前方氧传感器的作用是检测发动机不同工况的空燃比，同时ECU根据该信号调整喷油量和计算点火时间。 后方氧传感器的作用主要是检测三元催化转化器的工作好坏，即催化器的转化率。通过与前氧传感器数据的比较，来检测三元催化转化器是否工作正常。 ","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.06/","summary":"为什么发动机要进气和排气？ 空气由进气口进入，通过空气滤清器过滤后，经进气歧管进入气缸，并在进气歧管内布置有节气门和空气流量计来控制和调节进气","title":"3.6 进气和排气系统 Intake and Exhaust System"},{"content":"为什么发动机会发出有节奏的声音？ 活塞在气缸中要完成吸气、压缩、燃烧和排气四个行程，才算是完成一个工作循环。在此期间，活塞要在气缸内上下各两次，曲轴则同时要旋转两周。\n为什么发动机的动力能够源源不断？ 活塞在气缸中上下移动，活塞下行到的最低点叫下止点，上行到顶点的位置称为上止点。上止点与下止点之间的距离称为行程。当活塞在上止点时，活塞顶端的 空间称为燃烧室。\n发动机工作原理\n发动机工作原理示意图\n气缸结构示意图\n前面所述的发动机，活塞在气缸中移动四个行程，也就是曲轴转720°（2周）才完成一次动力输出，因此称为四冲程发动机。\n如果活塞在气缸中移动两个行程，也就是曲轴转360°（1周）就可完成一次动力输出，则称为二冲程发动机。以前，在汽车上曾使用过二冲程发动机，但现在只 在摩托车上使用。二冲程发动机的进气和压缩动作可以在一个行程中完成，而燃烧做功和排气动作则在另一个行程完成。\n发动机内部构造图(四冲程)\n发动机工作原理\n二冲程\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.05/","summary":"为什么发动机会发出有节奏的声音？ 活塞在气缸中要完成吸气、压缩、燃烧和排气四个行程，才算是完成一个工作循环。在此期间，活塞要在气缸内上下各两次","title":"3.5 发动机工作循环 Engine Working Cycle"},{"content":"为什么发动机需要吸入大量的空气？ 书中没直接描述原因, 猜测是氧气不足时会导致能量转换效率不高.\n汽油蕴含巨大能量\n同等重量情况下，汽油所含能量大约是糖的3倍，木头的5倍，电池的200倍。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.04/","summary":"为什么发动机需要吸入大量的空气？ 书中没直接描述原因, 猜测是氧气不足时会导致能量转换效率不高. 汽油蕴含巨大能量 同等重量情况下，汽油所含能量大约","title":"3.4 发动机燃烧原理 Engine Combustion Principle"},{"content":"汽油在气缸内燃烧爆炸示意图\n为什么说发动机动力来自于爆炸？ 如果将汽油和空气按照最适合的燃烧比例（1∶14.7）混合，并对它们进行大力压缩使之温度上升，此时点燃它们就会产生更大的爆炸力。 将这种力量通过一系列的机构“引导”到车轮上，便会推动汽车前进。 发动机排气量和压缩比计算方式示意图\n为什么动力与排量大小有关？ 气缸排气量是指活塞从下止点到上止点所扫过的气体容积，它取决于缸径和活塞行程。 发动机排量是各气缸排量的总和，一般用c c（立方厘米）、m L （毫升）或L（升）来表示。 发动机的排量越大，每次吸入的可燃混合气就越多，燃烧时产生的动力就越强。 ","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.03/","summary":"汽油在气缸内燃烧爆炸示意图 为什么说发动机动力来自于爆炸？ 如果将汽油和空气按照最适合的燃烧比例（1∶14.7）混合，并对它们进行大力压缩使之温","title":"3.3 发动机工作过程 Engine Working Process"},{"content":"发动机的气缸有哪几种排列形式？ 最常见的有3种气缸排列形式：直列、V形和水平对置。 还有一种W形气缸排列形式，但这种形式较为少见，而且与V形发动机较为相似。 发动机气缸形式\n直列发动机气缸排列示意图\n水平对置发动机 宝马V8发动机构造示意图\nV8发动机\nV形发动机更先进吗？ V形发动机的气缸成一角度对向布置，还可以抵消一部分振动。V形发动机的缺点，就是必须使用两个气缸盖，结构较为复杂。 W形发动机为什么应用少？ 与V形发动机相比，W形发动机最大的问题，就是发动机由一个整体被分割为两个部分，在运作时必然会引起很大的振动，因此现在应用极少。 针对这一问题，大众汽车在W形发动机上设计了两个反向转动的平衡轴，让两个部分的振动在内部相互抵消。现在，只有大众汽车集团某些品牌车型采用W形发 动机，如W8、W12和W16等发动机。 奥迪W12发动机构造图\nW16气缸形式\nW形发动机气缸夹角示意图\nW12发动机气缸排列示意图\nW12发动机气缸体\n什么是内燃机和外燃机？ 我们经常把汽车发动机称为内燃机，难道还有外燃机？是的，外燃机是存在的，比如原来火车上用的蒸汽机，发电厂和轮船上使用的汽轮机等，都是外燃机。它 们都是利用燃料在发动机气缸的外部燃烧来产生动力的。如早期的蒸汽机，它利用燃料（木材、煤、煤气、柴油等）烧开锅炉中的水，使之产生高压蒸汽并进入 气缸内，利用蒸汽压力推动活塞做功，从而产生动力。\n内燃机则是相对外燃机而言的，它的燃料在气缸内燃烧。现在，汽车上用的汽油发动机和柴油发动机，都是内燃机。\n外燃机工作原理示意图\n内燃机工作原理示意图\n为什么说水平对置发动机更有个性？ 水平对置发动机的英文为Boxer Engine，含义就是“拳击手发动机”，简称为B型发动机。比如B6、B4发动机，分别代表水平对置6缸和4缸发动机。 由于相邻两个气缸水平对置，这种发动机可以很简单地相互抵消振动，使发动机运转更平稳。水平对置发动机的重心低，能让车头设计得又扁又低。这两点都 增强了汽车的行驶稳定性。 水平对置发动机本身就左右对称，因此它可使变速器等放置在车身正中，让汽车左右重量对称，而不会像大多数汽车那样重心偏向一侧。 水平对置发动机的动力输出轴方向与传动轴方向一致，因此不需要改变动力传递方向，而是可以直接与离合器、变速器对接，大大提高了动力传递效率，使汽 车的起动和加速更迅猛。 水平对置发动机的缺点是维修不方便，而且各缸点火间隔不一致，使其排气声音比较怪异。普通汽车极少装配水平对置发动机，现在只有保时捷、斯巴鲁和丰 田等仍在生产和使用这种发动机。 水平对置6缸发动机构造图\n水平对置发动机\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.02/","summary":"发动机的气缸有哪几种排列形式？ 最常见的有3种气缸排列形式：直列、V形和水平对置。 还有一种W形气缸排列形式，但这种形式较为少见，而且与V形发动","title":"3.2 气缸排列形式 Cylinder Arrangement"},{"content":"汽车动力从哪里来？ 汽车动力来源于它的“心脏”，也就是发动机。那么发动机的“心脏”是什么？气缸！\n汽油发动机构造剖视图\n直列4缸汽油发动机构造图\n发动机原理\n气缸数为什么不能太多？ 在同样功率的要求下，缸数越多，缸径就可越小，转速就可提高，发动机的运转平衡性也更好。但是，随着气缸数的增加，发动机的零部件数也成比例增加，从 而使发动机结构更复杂、可靠性降低、重量增加、制造成本和使用费用增加、油耗增加等。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC3%E7%AB%A0-%E5%8F%91%E5%8A%A8%E6%9C%BA/3.01/","summary":"汽车动力从哪里来？ 汽车动力来源于它的“心脏”，也就是发动机。那么发动机的“心脏”是什么？气缸！ 汽油发动机构造剖视图 直列4缸汽油发动机构造图 发","title":"3.1 发动机基本原理 Engine Principle"},{"content":"9.1 新消费主张带来新品牌崛起 我们通常把1995～2010年出生的一代人称为“Z世代”。\n“Z世代”是注重个体、追求悦己的一代。追求品质, 强调个性 “Z世代”是在互联网环境下成长起来的一代，被称为“互联网原住民”，更加习惯于在互联网上获取信息，并通过互联网进行社交活动。 社交平台的风向可以对“Z世代”的消费决策产生较大影响 各种各样的圈层文化，包括“饭圈文化”“二次元文化”等，这些圈层文化会影响人们的消费决策。 “Z世代”是在文化自信下成长起来的一代。喜欢传统文化、国潮元素、红色经典 “Z世代”消费者对国潮的喜爱，对于国产品牌来说是千载难逢的机会。\n表9-1 运动服饰品牌在天猫上的销售额排行(2021)\n“Z世代”消费者对于生活方式的新主张也将带来新的品牌成长机会。\n比如健康食品、无糖饮料赛道， 互联网已经成为“Z世代”相互交流的主要场所。\n“买网友们真实体验后相互种草推荐的商品”是一个新的消费决策方式，我们将其称为“互联网主张” 互联网运营能力将成为决定未来品牌分化趋势的关键变量 总之，未来消费品投资的第一个大方向就是顺着“Z世代”消费者的消费主张，寻找对应品牌标的的成长机会。关键在于对消费群体的了解，对品牌定位的把握，对网络 风向和热点的洞察。比如国潮崛起对应着国产品牌的崛起；健康的生活方式带来了无糖饮料、健康食品等领域的投资机会；互联网传播对应互联网运营能力强的消费品 品牌和新锐品牌的投资机会。\n9.2 关注新消费习惯带来的需求增长 从长远来看，当人们的收入增长之后，消费结构将会发生改变。其中，食品等必需品的支出占比将会下降，而服务类消费的占比将会提升。\n从什么地方能够找到新消费习惯形成的机会？\n人们的根本诉求是一个很好的出发点。比如对美的追求、对娱乐和刺激的需求、对陪伴和认同的渴望、对方便的需求、对新奇事物的好奇等。 图9-1 中国医美市场规模(2021)\n图9-2 2020年部分国家每千人医美诊疗次数\n健康、多元的生活方式也是一个新消费习惯带来的潜在投资机会。健身消费 文娱需求也是一个重要的发展方向。 电影、电视剧、文艺创作、游戏等 旅游 图9-3 全国旅游收入和增速\n懒人经济将是未来的重点方向。 器具，即帮我们省事的商品, 洗碗机, 洗菜机, 烘干机, 扫地机器人 让人们“懒”的服务. 餐饮业, 外卖, 跑腿 新消费需求往往在大家的生活中潜移默化地生成，其发展很多时候具备长期的趋势性，而不会像技术突破那样猛烈。这样的匀速持续增长，恰恰是最适合价值投资者长 期发挥的领域——不但要发现这些投资机会，也要拿得住持续上涨的股票。\n9.3 新技术的突破 增长最迅猛的一类消费品投资机会基于技术突破，更好地满足了人们的一些固有需求。这类技术突破直接体现为消费品渗透率的直接提升\n比如电池技术的量变引发质变带来了电动车的普及 移动互联网带宽的提升带来了短视频和直播电商等。 技术突破带来的投资机会往往来势迅猛，投资者往往会因为错过了新科技龙头企业的成长机会而捶胸顿足。但从另一个角度看，追逐新技术的投资往往也伴随着高风险。 大多数自身无明显信息优势、技术背景不深的投资者，在参与这类机会时，应该三思而后行。\n","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC9%E7%AB%A0-%E6%9C%AA%E6%9D%A5%E6%B6%88%E8%B4%B9%E5%93%81%E6%96%B0%E6%9C%BA%E4%BC%9A/","summary":"9.1 新消费主张带来新品牌崛起 我们通常把1995～2010年出生的一代人称为“Z世代”。 “Z世代”是注重个体、追求悦己的一代。追求品质, 强调个性","title":"第9章 未来消费品新机会"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/hh1024/","summary":"主页","title":"红人点集"},{"content":"2.1 HTTP/1.1和当前的万维网 图2.1　网站加载内容平均大小（2014年—2018年）\n表2.1　美国访问量排名前10网站\n2.1.1 HTTP/1.1根本的性能问题 图2.2　在一个简单的网站示例中，HTTP请求及响应的流程\n处理时间在整个请求流程中占比很小, 大部分时间都在等待, 效率低 现代互联网最大的问题之一是延迟而不是带宽。 2.1.2 HTTP/1.1管道化 图2.3　简单示例网站的HTTP管道化\n管道化技术应该会对HTTP带来巨大的性能改善，但由于多种原因，它很难实现，易于出错，并且没有获得Web浏览器和Web服务器的良好支持。因此，它很少被 使用。没有一个主流的Web浏览器支持管道化技术。\n即使管道化技术得到了更好的支持，它仍然需要按照请求的顺序返回响应。如果图像2可用，但必须从另一台服务器获取图像1，则图像2的响应会等待，即 使应该可以立即发送图像2。此问题被称为队头（HOL）阻塞问题，在其他网络协议及HTTP中很常见。\n2.1.3 网络性能瀑布流图 图2.4　示例网站的请求瀑布图\n图2.5　示例网站使用管道化技术的瀑布图\n在这两个示例中，第一条垂直线表示可以渲染初始页面的时间（称为开始绘制时间或开始渲染时间），第二条垂直线表示页面何时加载完成。浏览器通常会在下 载图像之前尝试绘制页面，并在稍后填充图像，因此图像下载通常在这两个时间之间。\n图2.6　webpagetest.org上的瀑布图\n它将每个请求分成几个部分\nDNS查询 网络连接时间 HTTPS（或SSL）协商时间 请求的资源分类（并且还将资源负载分成两部分，用于请求的颜色较浅，用于响应的颜色较深） 加载页面各个阶段的各种垂直线 其他图表，显示CPU使用率、网络带宽，以及浏览器工作在哪个主线程中 2.2 解决HTTP/1.1性能问题的方案 随着时间的推移，已经有各种突破HTTP/1.1的性能限制的技术，这些技术分为以下两类：\n使用多个HTTP连接。 合并HTTP请求。 其他的和HTTP关联不大的性能优化技术，包括优化用户请求资源的方式（比如先请求关键CSS），减小下载资源的大小（压缩和使用响应式图片），减少浏览器 的渲染任务（更高效的CSS和JavaScript）。这些技术的细节超出了本书的讨论范围，但我们会在第6章涉及一些。Manning出版社所出版的 Web Performance in Action（Jeremy Wagner著）一书，是学习这些技术 的绝佳资料。\n\u0026laquo;Web性能实战\u0026raquo; 内容可能有点旧.\n2.2.1 使用多个HTTP连接 与管道化技术不同，该技术不会导致HOL阻塞，因为每个HTTP连接都独立于其他HTTP连接。因此，大多数浏览器可以为每个域名打开6个连接。\n为了进一步突破6个连接的限制，许多网站从子域提供静态资源, 如图像、CSS和JavaScript，Web浏览器从而可以为每个新域名打开另外6个连接。这种技术称 为域名分片\n除了提高并发数，域名发散还有其他优势，比如减小HTTP请求首部（如cookies） 图2.7　stackoverflow.com使用多个域名加载资源\n使用多个http连接的缺点\n打开TCP连接需要时间 维护连接需要更多的内存和CPU资源。 图2.8　TCP三次握手\nTCP在开启连接时比较小心，在确认网络不拥堵之前只会发送比较少的数据包。CWND（Congestion Window，拥塞窗口）随着时间的推移逐渐增加，只要连接 没发现丢包，就可以处理更大的流量。\nTCP拥塞窗口的大小受TCP慢启动算法控制。 在拥塞窗口中的TCP数据包需要在收到ACK消息之后发送。 在CWND比较小时，可能需要多个TCP ACK消息才能发出一个完整的HTTP请求。 HTTP响应常常比请求大很多，所以它同样也会受到拥塞窗口的影响。 最后，就算没有TCP建立连接的开销和慢启动的问题，使用多个独立的连接也可能导致带宽问题。例如，如果所有带宽都用掉了，就会导致TCP超时，和其他的 连接上的重传。在这些独立的连接之间，没有优先级的概念，这就无法更高效地利用带宽。\n优先级如何使带宽高效利用?\n创建TCP连接之后，安全的网站要求建立HTTPS连接。这个过程可以节约开销，比如，重用TCP连接的参数，不从零开始。但这个过程依然需要更多的网络往返，这意 味着更多的时间。\n使用多个连接会导致额外的tcp/https握手过程, 反而导致延迟问题. 过多的连接数, 收益会比较低 2.2.2 发送更少的请求 减少不必要的请求, 比如在浏览器中缓存静态资源(相当于不发请求) 以更少的HTTP请求获取同样的资源(打包合并静态资源) 对于图片来说，这种打包技术叫作精灵图。\n图2.9　TinyPNG的精灵图\n如果是CSS和JavaScript文件，很多网站就将多个文件合并为一个文件，这样需要的请求数就少了，但是总的代码量并不少。在合并文件的时候，通常还会去掉代码 中不必要的空格、注释和其他不必要的元素，以减小CSS和JavaScript的文件尺寸。这些方法都会提升效率，但是会增加配置的难度。\n其他的技术还包括内联资源到其他文件。比如，Critical CSS经常直接被内联在HTML的\u0026lt;style\u0026gt;标签中。图片可以包含在CSS中，通过行内SVG，或者转换为 Base64编码，也能减少HTTP请求数。\n另外一个问题是，合并会导致文件的浪费。\n一些网页可能只用到一张精灵图中的一两个图标，但却要下载整张精灵图。 当有新的精灵图时，还要重写CSS文件，以防止新的精灵图中图标的位置发生变化。 同样，如果合并了太多文件，JavaScript也可能会变得臃肿。有时候我们只需要其中的很少一部分，却要下载一个大得多的文件。 无论是从网络的方面（特别在开始的时候，TCP启动慢）还是从浏览器执行的方面（浏览器需要处理它不需要的代码）来说，这种技术都不够高效。 最后一个问题是缓存。\n如果把精灵图缓存了很长一段时间（这样用户就不需要频繁下载它），当需要添加一个图标的时候，必须让浏览器再次下载整个精灵图，但访客并不需要。 可以使用很多技术来解决这个问题，比如添加版本号或者使用查询参数，但是这些技术也会浪费资源。使用CSS和JavaScript也一样，改变一行代码就需要重新下 载整个合并文件。 2.2.3 HTTP/1性能优化总结 归根到底，优化HTTP/1性能的方法是一些解决HTTP/1基础缺陷的小技巧。应该有更好的办法在协议层面解决这个问题，从而节省时间，这正是HTTP/2要做的。\n2.3 HTTP/1.1的其他问题 基于文本的协议处理起来复杂易出错, 还会导致安全问题. 文本协议编码效率不高, 体积大 首部内容有重复 就算只有主页需要cookie，每个发向服务器的HTTP请求中都会包含cookie。 纯文本协议的安全和隐私问题（HTTPS加密很好地解决了这个问题） 缺少状态的问题（cookie在一定程度上解决了这个问题）。 2.4 实际案例 用于测试web性能的WebPageTest\n2.4.1 示例网站1: amazon.com 图2.10　www.amazon.com的部分运行结果\n首个请求是主页的请求\n图2.11　首页的第一个请求\nHTML引用了几个CSS文件\n图2.13　图片下载\n图2.14　加载amazon.com的连接视图\n2.4.2 示例网站2：imgur.com 图2.15　imgur.com的瀑布图\n图2.16　Chrome开发者工具中imgur.com的瀑布图\n2.4.3 这个问题究竟有多严重 你必须认识到，和其他性能问题想比，HTTP协议的问题有多严重。导致网站缓慢的原因很多，从网络连接的质量到网站的大小，再到某些网站可能使用荒唐的 JavaScript文件数，再到越来越多的性能低下的广告、数据追踪服务，等等。尽管更高效和更快地下载资源可以解决一部分问题，但是很多网站还是会慢。很多网站 清楚地知道HTTP协议对网站性能的影响，所以他们实现了一些优化HTTP/1.1性能的方法。但是因为这些方法复杂且难以理解，所以很多其他的网站没有实现。\n另外一个问题是，这些解决方案也有一些限制。这些方案本身也会引入低效率的因素，随着网站内容和复杂度的增加，最终这些变通的解决方案也会失效。尽管浏览器 在每个域名上打开6个连接，并且可以增大这个数，但这么做的收益较低，这也是为什么浏览器限制并发的连接数为6个，尽管站长们可以通过域名分片的方法来突破这 个限制。\n2.5 从HTTP/1.1到HTTP/2 工作组曾经展开过新版本的工作（HTTP-NG)，该工作本应对HTTP的工作方式做完全的重新设计，但是1999年该工作被中止了。人们普遍感觉这些变化太复杂，无法 推广。\n2.5.1 SPDY HTTP-NG尝试解决HTTP/1的多种问题，而SPDY的主要目标是解决HTTP/1.1的性能问题。它引入了一些关键的概念来解决HTTP/1.1的问题：\n流多路利用 —— 请求和响应使用单个TCP连接传输数据，它们被分成不同的数据包，以流的方式分组。 请求优先级 —— 在同时发送所有请求时，为了避免引入新的性能问题，引入了请求优先级的概念。 HTTP首部压缩 —— HTTP体早就可以压缩了，现在首部也可以压缩了。 SPDY在HTTP层实现了TCP的相关概念，所以它可以同时传输不同的HTTP消息。\n服务器推送这种高级功能，允许服务器返回额外的资源。如果你请求主页面，服务器可以在主页面的请求中推送所需要的CSS文件内容。这种方式可以节省浏览器再次 发送CSS请求的时间，也能避免将critical CSS变为行内样式带来的复杂度。\n图2.17　自HTTP/2发布以来，SPDY的支持率下降\n2.5.2 HTTP/2 我想要强调的是，HTTP/2已经向你走来，请尽情使用它。它已经在实际应用中得到验证，可以显著提高性能，而且它解决了本章中描述的HTTP/1.1的问题。\n2.6 HTTP/2对Web性能的影响 2.6.1 展示HTTP/2能力的绝佳示例 作者的网站\n图2.18　HTTP、HTTPS、HTTP/2性能测试\n图2.19　HTTPS测试的瀑布图。忽略第18行，其是个302响应。\n图2.20　HTTP/2测试的瀑布图\n图2.21　HTTP/2下的延迟和瀑布图\n2.6.2 对HTTP/2提升性能的期望 如果网站还有其他性能问题，那么切换到HTTP/2后可能看不到任何性能提升，这也意味着HTTP/1.1的低效率对这些网站来说问题不大。\n对于一些网站，还有两个原因会导致使用HTTP/2没什么改善。\n第一个原因是这些网站已经优化得足够好了——使用2.2节中提到的变通办法，由HTTP/1带来的缓慢问题比较少。 其他的性能问题远超HTTP/1带来的影响。 让HTTP/2变慢的其他情况还是网络丢包\n表2.2　HTTP/2可能给Amazon带来的提升\n加载时间指页面发起onload事件的时间 —— 通常指所有的CSS和阻塞式JavaScript加载完成的时间。 首字节时间指从网站收到第一个字节的时间。通常，此响应是第一个真正的响应，不是重定向。 开始渲染时间指页面开始绘制的时间。此指标是一项关键性能指标，因为如果用户没有看到正在访问的页面有更新，他们可能会离开。 视觉完整时间指页面停止变化的时间，通常在初始加载时间之后很久，异步的JavaScript可能还在更新页面。 speed index为由WebPagetest计算的页面每部分加载的平均时间，以ms为单位。 图2.22　通过HTTP/1加载Amazon主页的一个副本\n图2.23　通过HTTP/2加载Amazon主页的一个副本\n2.6.3 HTTP/1.1的一些性能变通方法可能是反模式 例如，如果网站使用域名分片并强制使用多个连接，则无法享受使用单个TCP连接加载网站带来的性能提升。HTTP/2使得在默认情况下创建一个高性能网站变得更加 简单。\n然而，事实并非如此简单，，在HTTP/2的应用更加广泛之前，完全放弃这些技术可能为时尚早。在客户端，尽管有强大的浏览器支持，一些用户仍会使用HTTP/1.1。 他们可能正在使用较旧的浏览器，或通过尚不支持HTTP/2的代理（包括防病毒扫描程序和公司代理）进行连接。\n总结 HTTP/1.1存在一些根本的性能问题，特别是在获取多个资源时。 对于这些性能问题有多种变通的解决方法（使用多个连接、域名分片，以及使用精灵图等），但它们有其自身的缺点。 可以通过WebPageTest等工具生成瀑布图，从中很容易看到性能问题。 SPDY旨在解决这些性能问题。 HTTP/2是SPDY的标准化版本。 并非所有性能问题都可以通过HTTP/2解决。 ","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC1%E9%83%A8%E5%88%86-%E5%90%91http2%E9%9D%A0%E6%8B%A2/%E7%AC%AC2%E7%AB%A0-%E9%80%9A%E5%90%91http2%E4%B9%8B%E8%B7%AF/","summary":"2.1 HTTP/1.1和当前的万维网 图2.1 网站加载内容平均大小（2014年—2018年） 表2.1 美国访问量排名前10网站 2.1.1 HTTP/1.1根本","title":"第2章 通向http2之路"},{"content":"1.1 万维网的原理 HTTP是访问远程Web应用和资源的关键技术。\n1.1.1 因特网与万维网 因特网(Internet)和万维网(World Wide Web或Web)的区别\n因特网是使用IP（Internet Protocol，因特网协议）连接在一起实现消息传递的计算机构成的网络。因特网上有很多服务，包括万维网，以及电子邮件、 文件共享、因特网电话等。 因此万维网（注意，是World Wide Web，简称Web）只是因特网上的一种服务形式，但其却是人们最常看到的形式，因为人们经常会通过Web应用（如 Gmail、Hotmail和Yahoo!）来收发邮件。我们日常所说的上网，既可以理解为上万维网，也可以理解为上因特网。 Tim Berners-Lee当初发明万维网时，一共创造了三项核心技术\nHTTP URL HTML 1.1.2 打开网页时会发生什么 假设我们打开浏览器访问www.google.com。在接下来的几秒钟内，会发生下面这些事情\n图1.1　浏览器请求网页时的典型交互过程\n由于因特网是全球性的，所以大公司通常会把服务器部署在世界各地。我们在向DNS查询IP地址时，通常会得到一个距离你最近的服务器的IP地址，以便你能快 速访问。\n怎么没有IPv5? IP包的前4位表示版本，理论上限是15个版本。在被广泛使用的IPv4以前，出现过0～3共4个实验性版本。但是，直到第4版，这几个版本一直没有被标准化（参 见: https://tools.ietf.org/html/rfc760 , 这个协议后来被升级和替换了，见 https://tools.ietf.org/html/rfc791 )。此后，第5个版本被 指定为Internet Stream Protocol，其主要在实时音频和视频流应用中使用，与VoIP（Voice over IP，IP语音）后来的发展类似。可是，这个版本一直 没启用，原因之一就是存在与第4版一样的地址限制。后来第6版出来的时候，第5版的工作被叫停，于是IPv6就成了IPv4的后续版本。据说一开始由于人们以为 6也被占用了，所以IPv6最早被称为第7版(参见 https://archive.is/QqU73#selection-417.1-417.15 )。版本7、8、9同样也被占用，而且以后也不 会再使用了。假如IPv6还有后续版本，很可能会是IPv10或更高的版本。到时候，无疑还会导致与今天类似的疑惑。\n你的浏览器会自动将简短的网址（www.google.com）扩展为语法上更为准确的URL地址（http://www.google.com）。 而包含端口在内的完整URL应该是http://www.google.com:80，只不过在使用标准端口（80用于HTTP，443用于HTTPS）的情况下，浏览器会隐藏端口号。 如果使用的是非标准端口，端口就会被显示出来。比如在某些环境特别是开发环境下，HTTP可以使用8080端口，HTTPS则可以使用8443端口。\n1.2 什么是HTTP OSI模型（Open System Interconnection，开放式系统互联通信参考模型）\n图1.2　网络数据传输的分层\n1.3 HTTP的语法和历史 1.3.1 HTTP/0.9 HTTP的第一个规范是1991年发布的0.9版本。\n该规范指定\n通过TCP/IP（或类似的面向连接的服务）与服务器和端口（可选的，如果未指定端口，则使用80）建立连接。 客户端应发送一行ASCII文本，包括GET、文档地址（无空格）、回车符和换行符（回车是可选的）。 服务器使用HTML格式的消息进行响应，该消息被定义为“ASCII字符的字节流”。规范还指定，“通过服务器关闭连接来终止消息”，所以在每个请求之后 都关闭连接。 在处理错误时，规范声明：“错误响应以可读的文本显示，使用HTML语法。除了文本的内容，没有办法区分错误响应和正确响应。” 在文档结尾处，规范指出：“请求是幂等的。服务器不需要在断开连接后存储关于请求的任何信息。”本规范为我们提供了HTTP的无状态特性，这是一把双刃 剑，有利（这很简单）也有弊（因为必须附加HTTP cookies等技术以允许状态跟踪，这对于复杂的应用程序是必需的）。 HTTP/0.9可能仅有的指令\nGET /section/page.html↵ 1.3.2 HTTP/1.0 HTTP/1.0新增了一些关键特性\n更多的请求方法。除了先前定义的GET方法，新增了HEAD和POST方法。 为所有的消息添加HTTP版本号字段。此字段是可选的，为了向后兼容，默认情况下使用HTTP/0.9。 HTTP首部。它可以与请求和响应一起发送，以提供与正在执行的请求或发送的响应相关的更多信息。 一个三位整数的响应状态码，（例如）用来表示响应是否成功。此状态码还可以用来表示重定向请求、条件请求和错误状态 HTTP/1.0旨在记录现实世界中多数Web服务器上已经发生的事情，而不是定义新的功能/语法。\nHTTP/1.0的方法\nGET方法与HTTP/0.9中的基本相同，但是新增的首部允许客户端发送条件GET（仅当在客户端上次请求之后，资源发生变化时，才请求资源内容；否则，告诉 客户端资源没变化，继续使用旧的副本）。此外，用户可以使用GET方法获取更多的资源，而不仅仅是超文本文档，比如使用HTTP下载图像、视频或其他 类型的媒体内容。 HEAD方法允许客户端获取资源的所有元信息（例如HTTP头）而无须下载资源本身。 POST方法允许客户端发送数据到Web服务器。也就是说，POST方法允许将内容作为HTTP请求的一部分从客户端发送到服务器，这表示 HTTP请求终于和HTTP响应一样，拥有了正文部分。 GET方法允许将数据包含在URL尾部指定的查询参数中发送，通常放在?字符之后。 URL受到长度和内容方面的限制（例如，无法发送二进制数据），并且某些机密数据（密码、信用卡数据等）也不应出现在URL中，因为很容易就可以在屏幕和 浏览器历史记录中看到这些数据。 POST方法通常是一种更好的数据发送方式，其中的数据也不是那么显而易见（尽管在通过透明的HTTP而不是安全的HTTPS发送时仍应小心）。 是GET请求是幂等的，而POST请求不是。 HTTP请求首部\n没有首部的情况\n可以发送具有相同名称的多个首部\n等于\n一个经典的HTTP/1.0 GET请求\nHTTP响应状态码\n表1.1　HTTP/1.0响应码\nHTTP响应首部\n1.3.3 HTTP/1.1 HTTP/1.1更像是对HTTP/1.0的调整，它没有从根本上改变协议。从0.9到1.0是一个较大的变化，增加了HTTP首部。HTTP/1.1做了进一步的改进，以便充分 利用HTTP协议（例如，持久连接、强制响应首部、更好的缓存选项和分块编码）。更重要的是，它提供了一个正式标准，后来的万维网正是基于它构筑。虽然 HTTP的基础知识很容易理解，但是里面许多错综复杂的细节、实现方式的不同，以及正式标准的缺乏使得它难以扩展。\n强制添加Host首部\n如今，很多Web服务器上面有多个网站（虚拟主机托管），所以告诉服务器要访问哪个网站和访问哪个相对URL同样重要。此功能可以通过下面的方法实现：将 HTTP请求中的URL修改为完整的包含绝对路径的URL。但如果采用这种方法，则很多现有的Web服务器和客户端都不能正常运行。所以，我们在请求首部中添加 Host来实现该功能：\n指定强制Host首部字段，而不是将相对URL更改为绝对URL，带来了一些争论。HTTP/1.1引入的HTTP代理允许通过中间HTTP服务器连接到目标HTTP服务器。 代理的语法要求所有的请求使用完整的绝对URL，但实际的Web服务器（也称为源服务器）要求强制使用Host首部。\n持久连接（也就是KEEP-ALIVE）\nHTTP/1.0服务器是支持持久连接的, 但不在HTTP/1.0规范中\n服务器像往常一样响应，但如果它支持持久连接，它会在响应中包含一个Connection: Keep-Alive首部\nHTTP/1.1不仅将持久连接添加到文档标准中，还将其作为默认行为。即使响应中没有Connection:Keep-Alive首部，也可以假定任何HTTP/1.1连接都 使用持久连接。如果服务器确实想要关闭连接，无论出于何种原因，则它必须在响应中显式包含Connection:close HTTP首部\n在此基础上，HTTP/1.1增加了管道的概念，因此应该可以通过同一个持久连接发送多个请求并按顺序获取响应。\n由于某些原因，管道化并没有流行起来，并且客户端（浏览器）和服务器对管道化的支持都很差。因此，虽然持久连接允许在同一个TCP上顺序发出多个请 求，这也是一个很好的性能改进，但大多数HTTP/1.1的实现仍然是遵循请求响应再请求再响应的模式的。当一个请求被处理时，HTTP连接被阻塞，不能用于其 他请求。\n其他新功能\nHTTP/1.1又定义了新的方法，如PUT、OPTIONS和比较少见的CONNECT、TRACE及DELETE。 更好的缓存方法。这些方法允许服务器指示客户端将资源（例如CSS文件）存储在浏览器的缓存中，以便在以后需要时重复使用。在HTTP/1.1中引入的 Cache-Control HTTP首部比HTTP/1.0中的Expires首部的选项更多。 HTTP cookies，允许HTTP维护状态。 引入字符集（如本章的一些例子所示），在HTTP响应中新增语言选项。 支持代理。 支持权限验证。 新的状态码。 尾随首部 1.4 HTTPS简介 HTTPS是HTTP的安全版本，它使用TLS（Transport Layer Security，传输层加密）协议对传输中的消息进行加密，TLS的前身是我们熟知的SSL（Secure Sockets Layer，安全套接字层）\nHTTPS对HTTP消息添加了三个重要概念\n加密——传输过程中第三方无法读取消息。 完整性校验——消息在传输过程中未被更改，因为整个加密消息已经过数字签名，并且该签名在解密之前已通过加密验证。 身份验证——服务器不是伪装的。 SSL、TLS、HTTPS和HTTP\nHTTPS使用SSL或TLS加密。SSL是由Netscape发明的。SSLv1从未在Netscape之外发布，因此第一个生产版本是1995年发布的SSLv2。1996年发布的 SSLv3解决了一些安全漏洞。 由于SSL由Netscape拥有，因此它不是正式的互联网标准，尽管它随后由IETF作为历史文档发布。SSL被标准化为TLS（传输层加密）。 TLSv1.0与SSLv3类似，但它们不兼容。 TLSv1.1和TLSv1.2分别于2006年和2008年推出，并且它们更加安全。 TLSv1.3在2018年被批准为标准。虽然还需要一些时间它才能普及，但它更安全，更高效。 在2014年，在SSLv3中发现了重大漏洞，SSLv3因此被要求停止使用，并且浏览器也停止对它的支持。从这时人们才开始大量向TLS迁移。在TLSv1.0中发 现类似的漏洞后，安全专家强烈建议使用TLSv1.1或更高版本。 HTTPS使用公钥加密，服务器在用户首次连接时以数字证书的形式提供公钥。\nHTTPS的一个重大问题是，它只保证你正在连接到该服务器，而不能保证服务器值得信任。 HTTPS站点通常在Web浏览器中显示为绿色挂锁，许多用户认为这意味着安全，但其实它仅仅意味着加密。 OpenSSL提供了一个s_client命令，可使用该命令将HTTP命令发送到HTTPS服务器，和使用Telnet类似：\n1.5 查看、发送和接收HTTP消息的工具 1.5.1 浏览器开发者工具 1.5.2 发送HTTP请求 Advanced REST Client\n1.5.3 其他工具 curl, wget, httpie, SOAP-UI, Chrome的net-internals页面, Fiddler, Wireshark\n","permalink":"https://jdxj.github.io/posts/books/http2-in-action/%E7%AC%AC1%E9%83%A8%E5%88%86-%E5%90%91http2%E9%9D%A0%E6%8B%A2/%E7%AC%AC1%E7%AB%A0-%E4%B8%87%E7%BB%B4%E7%BD%91%E4%B8%8Ehttp/","summary":"1.1 万维网的原理 HTTP是访问远程Web应用和资源的关键技术。 1.1.1 因特网与万维网 因特网(Internet)和万维网(World Wide Web或Web)","title":"第1章 万维网与HTTP"},{"content":"谓词逻辑中的层级、集合论中的层级 对于EXISTS来说，层级的差别与EXISTS谓词及其参数有关，因此属于谓词逻辑中的阶。而GROUP BY中的阶与元素和集合的区别有关，因此属于集合论中的阶。\n为什么聚合后不能再引用原表中的列 Teams\n首先，我们还是以组为单位进行聚合查询。\n1 2 3 4 5 6 7 8 9 10 11 12 --以组为单位进行聚合查询 SELECT team, AVG(age) FROM Teams GROUP BY team; team AVG(age) ---- -------- A 23.3 B 34.5 C 30.0 D 25.5 那么如果我们把它改成下面这样，结果会怎么样呢？\n1 2 3 4 --以组为单位进行聚合查询？ SELECT team, AVG(age), age FROM Teams GROUP BY team; 标准SQL规定，在对表进行聚合查询的时候，只能在SELECT子句中写下面3种内容。\n通过GROUP BY子句指定的聚合键 聚合函数（SUM、AVG等） 常量 表Teams中的“age”列存储了每位成员的年龄信息。但是需要注意的是，这里的年龄只是每个人的属性，而不是小组的属性。所谓小组，指的是由多个人组成的 集合。因此，小组的属性只能是平均或者总和等统计性质的属性。\nGROUP BY的作用是将一个个元素划分成若干个子集。这样看的话，关系模型中“列”的正式名称叫作“属性”，其实也是有道理的。\n下面这条语句的错误也是相同的原因造成的。\n1 2 3 4 --错误 SELECT team, AVG(age), member FROM Teams GROUP BY team; 向小组询问姓名是不会得到回答的。如果非要在结果中包含“member”列的值，那么只能像下面这样使用聚合函数。\n1 2 3 4 --正确 SELECT team, AVG(age), MAX(member) FROM Teams GROUP BY team; MAX(member)会计算出小组成员中以字典序排序后最后一个人的姓名，因此这无疑是小组的属性。\n如果稍微扩展一下这条查询语句，我们还可以求出“小组中年龄最大的成员”，SQL语句如下所示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 SELECT team, MAX(age), (SELECT MAX(member) FROM Teams T2 WHERE T2.team = T1.team AND T2.age = MAX(T1.age)) AS oldest FROM Teams T1 GROUP BY team; team max(age) oldest ----- -------- ------ A 28 大木 B 40 山田 C 30 桥田 D 28 野野宫 这条语句的关键点有两个。\n第一个是，子查询中的WHERE子句里使用了MAX(T1.age)这样的聚合函数作为条件。我们在初学SQL时，会学到不可以在WHERE子句中使用聚合函数，但是在 本题中却是可以的。原因是，这里对外层的表T1也进行了聚合，这样一来我们就可以在SELECT子句中通过聚合函数来引用“age”列了（不能反过来在子查询 中直接引用“age”列）。 另一个是，当一个小组中年龄最大的成员有多人时，必须选出其中一个人作为代表。这个是通过子查询中SELECT子句里的MAX(member)来实现的。例如，D 小组中野野宫和鬼塚两人的年龄都是最大的，但是结果中只出现了野野宫一人。如果不使用MAX函数，那么子查询会返回多条数据，这样就会出现执行错误。 单元素集合也是集合 只有一个元素的集合，在集合论中叫作单元素集合（singleton）。一般来说，单元素集合的属性和其唯一元素的属性是一样的。\n现在的集合论认为单元素集合是一种正常的集合。单元素集合和空集一样，主要是为了保持理论的完整性而定义的。因此对于以集合论为基础的SQL来说，当然也 需要严格地区分元素和单元素集合。因此，元素a和集合{a}之间存在着非常醒目的层级差别。\n1 a ≠ {a} 这两个层级的区别分别对应着SQL中的WHERE子句和HAVING子句的区别。\nWHERE子句用于处理“行”这种0阶的对象 而HAVING子句用来处理“集合”这种1阶的对象。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-10-sql%E4%B8%AD%E7%9A%84%E5%B1%82%E7%BA%A7/","summary":"谓词逻辑中的层级、集合论中的层级 对于EXISTS来说，层级的差别与EXISTS谓词及其参数有关，因此属于谓词逻辑中的阶。而GROUP BY中的","title":"2-10 SQL中的层级"},{"content":"~告全体数据库工程师书~ NULL这个怪物最可怕的地方：一开始会让我们觉得很好用，于是在设计系统时，我们会非常自然地保留它，但当注意到问题的时候，系统已经变得非常复杂、低 效、不符合预期了，开发和维护也变得非常困难。\n为什么NULL如此惹人讨厌 在进行SQL编码时，必须考虑违反人类直觉的三值逻辑。 在指定IS NULL、IS NOT NULL的时候，不会用到索引，因而SQL语句执行起来性能低下。 如果四则运算以及SQL函数的参数中包含NULL，会引起“NULL的传播”。 在接收SQL查询结果的宿主语言中，NULL的处理方法没有统一标准。 与一般列的值不同，NULL是通过在数据行的某处加上多余的位（bit）来实现的。因此NULL会使程序占据更多的存储空间，使得检索性能变差。 对于第3个原因，我们来稍微解释一下。例如，如果四则运算中包含NULL，那么运算结果也肯定都是NULL。\n1 2 3 4 5 1 + NULL = NULL 2- NULL = NULL 3 ＊ NULL = NULL 4 / NULL = NULL NULL / 0 = NULL 并不能完全消除NULL 无法完全消除NULL的原因是它扎根于关系数据库的底层中。仅仅靠在表中所有列加上NOT NULL的约束是不够的。因为即使这样做，在使用外连接，或者SQL-99 中添加的带CUBE或ROLLUP的GROUP BY时，还是很容易引入NULL的。\n编号：使用异常编号 标志性编号, 例如性别\n使用varchar/char not null类型 1: 男性, 2: 女性, 0: 未知, 9: 不适用 名字：使用“无名氏” 一般来说，与编号相比，名字被用于聚合的频度很低，大多时候只作为冗余列使用。我们不用刻意地消除其中的NULL，但是最好还是让NULL从名字列中消失。\n数值：用0代替 转换为0。 如果一定要区分0和NULL，那么允许使用NULL。 日期：用最大值或最小值代替 当需要表示开始日期和结束日期这样的“期限”的时候，我们可以使用0000-01-01或者9999-12-31这样可能存在的最大值或最小值来处理。\n当默认值原本就不清楚的时候，例如历史事件发生的日期，或者某人的生日等，也就是当NULL的含义是“未知”的时候，这时可以允许使用NULL。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-9-%E6%B6%88%E7%81%ADnull%E5%A7%94%E5%91%98%E4%BC%9A/","summary":"~告全体数据库工程师书~ NULL这个怪物最可怕的地方：一开始会让我们觉得很好用，于是在设计系统时，我们会非常自然地保留它，但当注意到问题的时","title":"2-9 消灭NULL委员会"},{"content":"适当地抛开命题的真假吧 历史上最早提出三值逻辑（three-valued-logic）体系的是波兰的著名逻辑学家卢卡西维茨（Jan Lukasiewicz, 1878—1956）。\n卢卡西维茨考虑的“可能”这一真值的本质，其实是对未来不确定性的描述，丝毫没有Codd提出的“不适用”的含义。 第二个论点突破了一个命题只能有一个固定真值的观念，开拓出了新的思路，认为命题的真值可能会随时间发生“可能”→“真”，或者“可能”→“假”这样的变 化。 逻辑学的革命 除了三值逻辑，还有布劳威尔（Luitzen Egbertus Jan Brouwer）和海廷（Arend Heyting）等人创立的直觉主义逻辑学。三值逻辑通过导入第三个真值， 从语义学的角度对二值逻辑发起了挑战；而直觉主义逻辑从语法学的角度对二值逻辑发起了挑战。\n人类的逻辑学 在这种新的逻辑学中，命题的真值不仅有“真”和“假”，还可以有“无意义”“当前未知”“矛盾”等反映各种认知的值。于是诞生了三值逻辑，而且允许三个以上的真 值的多值逻辑学（many-valued logic）的研究也在进行中。没有神的逻辑学——人类的逻辑学诞生了。\n数据库的使用者当然是人类，而不是神。因此，数据的表达方式也应该基于有限而且不完善的人类的认知，而不是神的完美无缺的认知。这就是关系数据库采用 三值逻辑的原因。\n但是，这种面向人类的思维方式是一把双刃剑。确实，通过采用三值逻辑（主要是NULL和unknown），正如Codd所说，关系数据库变得非常接近人类的认知， 而且具有非常灵活的表达能力。但讽刺的是，人类又不得不引入许多不太直观的奇怪的逻辑运算。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-8-%E4%BA%BA%E7%B1%BB%E7%9A%84%E9%80%BB%E8%BE%91%E5%AD%A6/","summary":"适当地抛开命题的真假吧 历史上最早提出三值逻辑（three-valued-logic）体系的是波兰的著名逻辑学家卢卡西维茨（Jan Lukasiewicz, 1878—","title":"2-8 人类的逻辑学"},{"content":"实际工作中的递归集合 冯·诺依曼究竟是如何想到“用集合定义自然数”这样非同寻常的方法的呢？\n冯·诺依曼的前辈们 冯·诺依曼提出用递归集合定义自然数，是在1923年发表的论文《关于超限序数的引入》中。这是他发表的第二篇论文。从论文标题中的“序数”可以看出，实际 上冯·诺依曼提出的与其说是“自然数的定义”，还不如说是“序数的定义”。序数可以理解成自然数的别称，即在强调0的下一个是1,1的下一个是2,2的下一个是3 ……这种顺序时的名称（相反，在不强调顺序时，自然数有“基数”这样一个别称）。\n冯·诺依曼提出的自然数的递归定义\n各种自然数的递归定义\n按照冯·诺依曼方法，集合中的元素个数等于想要定义的数。\nSQL可以通过COUNT函数计算出元素个数，与冯·诺依曼方法的定义方式兼容性很好。\n相反，策梅洛方法不太适合在SQL中使用（SQL本来就不使用括号表示集合）。 数是什么 皮亚诺公理\n存在起到0的作用的东西 没有在0前面的自然数 每一个自然数a，都具有后继自然数（successor） 像这样得出某个自然数的后继自然数的函数叫作后继函数，写作suc(x)。于是有suc(5) ＝6、suc(17)＝18。因此，使用后继函数生成自然数时，可以像下面 这样嵌套使用。\n1 2 3 4 5 6 7 0 = 0 1 = suc(0) 2 = suc(suc(0)) 3 = suc(suc(suc(0))) · · · 这里需要着重理解的是，我们并没有指定该后继函数的内部实现。无论什么样的内部实现，只要能够生成下一个自然数就可以，这是一个比较宽松的条件。\n冯·诺依曼方法和弗雷格方法的后继函数：suc(a) = a∪{a} 策梅洛方法的后继函数：suc(a) = {a} 自然数的定义是由皮亚诺列举的5个条件给出的，冯·诺依曼等人只是根据皮亚诺公理生成了自然数而已。这样看来，冯·诺依曼等人的工作可以称为“构建”。\n构建自然数并不一定要使用集合。在计算机科学相关领域还有一种使用λ演算函数来构建自然数的方法。\n使用λ演算构建的自然数被阿隆佐·邱奇（Alonzo Church）以自己的姓氏命名为了“邱奇数”。不过，虽然取名叫“数”，其本质却是输入输出均为函数的高阶 函数。 0:=λ fx.x 1:=λ fx.fx 2:=λ fx.f(fx) 3:=λ fx.f(f(fx)) SQL的魔术与科学 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-7-sql%E5%92%8C%E9%80%92%E5%BD%92%E9%9B%86%E5%90%88/","summary":"实际工作中的递归集合 冯·诺依曼究竟是如何想到“用集合定义自然数”这样非同寻常的方法的呢？ 冯·诺依曼的前辈们 冯·诺依曼提出用递归集合定义自然数","title":"2-7 SQL和递归集合"},{"content":"不管是面向过程语言还是文件系统，都是将复杂的东西看成是由简单单元组合而成的——这是一种还原论的思维方式。\nSQL中没有赋值或者循环的处理，数据也不以记录为单位进行处理，而以集合为单位进行处理。SQL和关系数据库的思维方式更像是一种整体论的思维方式。\n1．用CASE表达式代替IF语句和CASE语句。SQL更像一种函数式语言 之所以叫它CASE“表达式”而不是CASE“语句”（statement），是因为CASE表达式与1+(2-4)或者(x＊y)/z一样，都是表达式，在执行时会被整体当作一个值 来处理。既然同样是表达式，那么能写1+1这样的表达式的地方就都能写CASE表达式，而且因为CASE表达式最终会作为一个确定的值来处理，所以我们也可以把 CASE表达式当作聚合函数的参数来使用。\n1 2 3 4 5 \u0026#39;Lisp中使用cond函数进行条件分支 cond( ((= x 1)\u0026#39;x是1\u0026#39;) ((= x 2)\u0026#39;x是2\u0026#39;) (t \u0026#39;x是1和2以外的数’)) 1 2 3 4 5 --SQL中使用CASE表达式进行条件分支 CASE WHEN x = 1 THEN\u0026#39;x是1\u0026#39; WHEN x = 2 THEN\u0026#39;x是2\u0026#39; ELSE \u0026#39;x是1和2以外的数’ END 参考→1-3节\n2．用GROUP BY和关联子查询代替循环 SQL中没有专门的循环语句。虽然可以使用游标实现循环，但是这样的话还是面向过程的做法，和纯粹的SQL没有关系。SQL在设计之初，就有意地避免了循环。\n参考→1-6节、 1-7节\n3．表中的行没有顺序 将表看成文件的最大问题是会误认为表中的行是有顺序的。\n在关系数据库中，从表中读取数据时的的确确会发生这样的情况。读出的数据不一定是按照INSERT的顺序排列的，因为SQL在处理数据时不需要它们这样。 SQL在处理数据时可以完全不依赖顺序。 在定义视图时指定ORDER BY子句（如果某种数据库支持这种写法，那么它本身就有问题），或者轻易地使用Oracle中的rownum这样依赖具体实现的 “行编号”列，都是典型的依赖顺序的不好的写法。 参考→1-4节、 1-9节、 1-10节\n4．将表看成集合 实际上，一张表并非对应一个文件，读取表时也并不是像读取文件一样一行一行地进行的。\n参考→1-2节\n5．理解EXISTS谓词和“量化”的概念 在SQL中，谓词逻辑的主要应用场景是“将多行数据作为整体”处理的时候。谓词逻辑中具有能将多个对象作为一个整体来处理的工具“量化符”。对于SQL来说， 量化符就是EXISTS谓词。\n参考→1-8节、 1-9节\n6．学习HAVING子句的真正价值 HAVING子句是集中体现了SQL之面向集合理念的功能。\n参考→1-4节、 1-10节\n7．不要画长方形，去画圆 传统的结构图(structure diagram), 数据流图(data flow diagram)用于描述动态数据, 而SQL只是用来描述所需数据的查询条件的，并不能描述动态的 处理过程。\n能够准确描述静态数据模型的标准工具是维恩图\n能否深刻理解并灵活使用嵌套子集（=递归集合），可以说是衡量SQL编程能力是否达到中级水平的关键。\n参考→1-4节、 1-7节\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-6-%E4%BB%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/","summary":"不管是面向过程语言还是文件系统，都是将复杂的东西看成是由简单单元组合而成的——这是一种还原论的思维方式。 SQL中没有赋值或者循环的处理，数据","title":"2-6 从面向过程思维向声明式思维, 面向集合思维转变的7个关键点"},{"content":"写在前面 关系数据库中不存在编程语言中一般被称为“指针”的物理性数据结构。但是严格来说，它其实是存在的，只不过被隐藏了，因而对用户不可见。\n不过，如果这么说，可能会有人列举出用户可以使用的指针，比如Oracle中的rowid或PostgreSQL中的oid来反对。确实，用户可以使用这些指针，但是它们 都是个别数据库厂商违反SQL标准而进行的扩展，而标准SQL一直在努力摆脱指针。\n关系模型是为摆脱地址而生 在关系模型中，我们通过完全关联的编址来代替位置编址。\n在关系数据库中，每个数据可以借助于关系名、主键的值以及属性名唯一地编址。这种形式的关联地址使用户（是的，也使得程序员）把以下两点留给系统来 完成： 确定要插入数据库的一块新信息的放置细节； 当检索数据时选择适当的存取通路。 这里说的“地址”不仅包括指针操作的地址，还包括数组下标等。 数据库中的关系无论如何都不能具有指针的那些属性。众所周知，关系数据库出现以前，数据库中充满了指针的概念，为了访问到想要的数据必须借助很多指 针。对这些数据库进行应用程序编程时很容易出现错误，而且数据不能由终端用户直接访问，这些问题都是指针导致的。 放弃地址的深刻意义是，通过放弃掉系统中没有意义的东西，创造出一个易于人类理解的有意义的世界。\n所以写代码也要偏向于易读而不是易写.\n编程中泛滥的地址 是的，变量——它正是编程语言中地址的化身。所有的变量都由没有实际意义的地址管理着。而且，要想在面向过程语言中处理数据，只能通过把数据赋值给变量。 只要使用变量，就无法逃出地址的魔咒。反过来说，之所以SQL能成为不依赖于地址的自由的语言，也是因为它不使用变量。\n不曾远去的老将——J.Backus的梦想 声明式语言SQL和函数式语言Lisp在当今的编程世界里都处于边缘，而且从来没有成为主流语言过。但是最近SQL中增加了许多丰富的功能，渐渐到了需要重新 评价SQL和函数式语言优点的时候了。“地址的解放战争”最终有怎样的归宿，现在还不好预测，但是笔者期待能够在不久的将来写一写它。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-4-%E5%9C%B0%E5%9D%80%E8%BF%99%E4%B8%80%E5%B7%A8%E5%A4%A7%E7%9A%84%E6%80%AA%E7%89%A9/","summary":"写在前面 关系数据库中不存在编程语言中一般被称为“指针”的物理性数据结构。但是严格来说，它其实是存在的，只不过被隐藏了，因而对用户不可见。 不过","title":"2-4 地址这一巨大的怪物"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/di/","summary":"原文","title":"Go工程化 - 手摸手带你理解依赖注入"},{"content":"了解啥是libcontainer、runc、containerd、CRI、OCI\n原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9Acontainerd%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"了解啥是libcontainer、runc、containerd、CRI、OCI 原文","title":"一文搞定Containerd的使用"},{"content":"从运算角度审视集合 “封闭性”（closure property）, 这个性质简单地说就是“运算的输入和输出都是关系”\n多亏了关系的封闭性，这些运算的输出才可以直接作为其他运算的输入。 与unix管道类比\n按照对四则运算是否封闭，我们可以把集合分为下面几类。\n群（group）：对加法和减法（或者乘法和除法）封闭 环（ring）：对加法、减法、乘法封闭 域（filed）：对加法、减法、乘法、除法封闭，即可以自由进行四则运算 如果要举个关于“群”的具体示例，那么最简单的就是整数集了，因为任何两个整数之间进行加法或者减法运算，结果一定还是整数。整数集也是环，但却不是域\n比如1÷2的结果是小数，不满足封闭性。 如果将整数集扩展成有理数集或者实数集的话，那么结果就满足域的条件了。 实践和原理 关系支持加法（UNION）运算和减法（EXCEPT）运算，因此满足群的条件。关系还支持相当于乘法运算的CROSS JOIN，所以也满足环的条件。关系中没有除法 运算符，所以不满足域的条件。\nSQL中没有除法运算符。但是我们在1-4节中说过，除法运算的定义是有的。因此，关系也满足域的条件。 Theory is practical.\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-3-%E5%BC%80%E5%A7%8B%E4%BA%8E%E5%85%B3%E7%B3%BB-%E7%BB%93%E6%9D%9F%E4%BA%8E%E5%85%B3%E7%B3%BB/","summary":"从运算角度审视集合 “封闭性”（closure property）, 这个性质简单地说就是“运算的输入和输出都是关系” 多亏了关系的封闭性，这些运算","title":"2-3 开始于关系, 结束于关系"},{"content":"为什么不叫“表”模型 Codd:\n当初思考关系模型的时候，从事数据处理工作的人们有一种普遍的观点，即认为多个对象之间的关系（或者关联）必须通过一种链接数据结构来表示。为了纠 正这个误解，我特意选择了“关系模型”这个词作为名字； 与关系相比，表的抽象度更低，容易给人可以像数组一样操作的印象，而n元关系就不会了。还有，数据库表中数据的内容和行的顺序没有关系，在这一点上表 更容易带来误解。尽管表有这样的小缺点，但依然是表达关系概念时最重要的手段。毕竟表的概念人们更熟悉一些。 关系的定义 数据库采用了关系模型，因此才被称为关系数据库。\n关系模型之父Codd本人也表示时不时地会收到这样的疑问，并给出了前文中的两个解释。\n其中(1)与现在的数据库工程师没有什么关系。“链接数据结构”指的是使用指针连接数据的链表结构，这是分层模型和网状模型数据结构流行的时期特有 的。 而(2)现在仍然有思考的价值，因为它触及了“关系”这一概念的本质。简单概括的话，关系和表看起来很相似，实质却不相同。 关系和表比较典型的区别。\n关系中不允许存在重复的元组（tuple），而表中可以存在。即，关系是通常说的不允许存在重复元素的集合，而表是多重集合（multiset） 关系中的元组没有从上往下的顺序，而表中的行有从上往下的顺序 关系中的属性没有从左往右的顺序，而表中的列有从左往右的顺序 关系中所有的属性的值都是不可分割的，而表中列的值是可以分割的。换句话说，关系中的属性满足第一范式，而表中的列不满足第一范式 元组和属性是关系模型中较为正式的术语，与非正式的日常用语有以下对应关系\n关系的定义可以用下面这样一个公式来给出。\n关系用符号R表示，属性用符号Ai表示，属性的定义域用符号Di表示 R ⊆（D1×D2×D3 · · · ×Dn） 这个公式读作“关系R是定义域D1, D2, …, Dn的笛卡儿积的子集”。\n我们假设属性a1可以取1种值，属性a2可以取2种值，属性a3可以取3种值。各属性对应的定义域分别叫作d1、d2、d3。\nd1 = { 1 } d2 = { 男 , 女 } d3 = { 红 , 绿 , 黄 } 使用这3个定义域生成关系时，最大的元组数是多少？答案是6。计算方法很简单，就是1×2×3＝6。\n关系就是定义域间的组合?\n定义域的忧虑 一段用Pascal语言写的代码\ntype Day = { Sun, Mon, Tue, Wed, Thu, Fri, Sat }; var Today : Day; 现在的DBMS是具备简单的定义域功能的，只不过比较初级. 这些定义域主要是字符型、数值型等叫作标量类型的数据类型。因为它们对属性的取值范围有约束， 所以尽管有局限性，但是标量类型也是定义域的一种。\n关系值和关系变量 值（value）和变量（variable）是很容易混淆的概念，在讨论和数据库相关的话题时，两者经常会被混用。一般提到“关系”这个词时，如果不加特殊说明， 指的都是“关系变量”。而关系值指的是关系变量在某一时刻取的值。实际上或许我们也可以说，值就是变量的时间切片（time-slice）。\n这与数学或者编程语言中变量和值之间的关系是一样的。在编程语言中，整数型变量存储整数值。同样，在关系模型中，关系型变量存储关系值。理解了这一点， 我们应该就不会像刚接触这些概念时那样觉得不可思议了。关键在于我们在学校中学到的变量和值基本上都是标量型的单一类型值，所以只是不习惯把关系 这样的复合型结构看成一个值。FROM子句中写的表名正是变量的名称\n存在“关系的关系”吗 这个问题可以替换成“存在递归的关系吗”或者“定义域中可以包含关系吗”。\n“关系的关系”在逻辑上是可能存在的。但是，为此必须定义能够使定义域包含关系的谓词，而且如果再考虑对关系的量化，就需要实现二阶谓词逻辑，因此实现 “关系的关系”非常困难。\n因此这里我们只简单地了解一下描述这种现实中还不存在的“关系的关系”的关系模型大概是什么样子。首先请看一个具体的表。\n如果接受了这种“关系的关系”，那么自然就能进一步扩展到“关系的关系的关系”或者“关系的关系的关系的关系”这样更高阶的关系。当然它们也都是嵌套式的递 归结构。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/","summary":"为什么不叫“表”模型 Codd: 当初思考关系模型的时候，从事数据处理工作的人们有一种普遍的观点，即认为多个对象之间的关系（或者关联）必须通过一种链接数","title":"2-2 为什么叫关系模型"},{"content":"8.1 为什么中国没有本土大型连锁便利店 电商改变了中国零售行业的发展路径 图8-1 2021年我国消费品零售渠道分布\n电商的出现改变了我国零售行业的发展路径。\n国外零售行业的发展路径从传统零售开始，发展出连锁零售（A\u0026amp;P等），进化到现代大型商超（沃尔玛等），再到仓储店（开市客等）与便利店（7-11等）， 最后发展出电商（亚马逊等）。 而国内零售行业的发展路径，是在连锁零售尚未发展完善时，就出现了电商；电商出现后不久就实现了极其迅速的增长，并且一定程度上挤压了传统线下零售 的生存空间。 图8-2 我国网民整体及手机网民规模\n图8-3 我国电商行业与全渠道消费品零售额增速\n图8-4 我国现代线下零售、传统线下零售和电商的市场份额变化\n图8-5 我国超市、便利店与消费品零售业整体增速对比\n电商改变渠道拓扑结构 电商的变革并不是单纯把交易场景从线下搬到线上、省去房租和人工费用、提升经营效率、把流通成本做到更低。以上变化都只是表象，电商改变的是整个交易 的思维和逻辑，并给商家集中度、品类结构等方面带来种种变化。\n商家的边界变得不同，线上商家的马太效应会越来越高 线下零售是区域竞争，每家店的辐射范围都不同。对于线下零售而言，门店的“点位”至关重要。 线上生意就不同了。网店的展现对于全国各地的消费者一视同仁，消费者距离某家网店的距离都是一样的。 适合线上、线下销售的品类会变得不同 电商适合的消费类型是标准化、重复消费的大众商品. 比如，数码、护肤品等产品就适合线上销售，因为它们是标准化且重复消费的产品； 线下渠道适合具备一定体验感、即时性需求的品类。生鲜、软饮、奢侈品就适合线下消费，因为生鲜、软饮对即时性有要求，奢侈品对消费过程中的体验 有要求。 图8-6 2020年各品类电商渗透率\n电商变革改变了中国零售的发展路径 电商难以解决“最后一公里”履约的成本和时效问题，其实并不太适合销售生鲜产品。所以在超市、便利店发展比较一般的情况下，生鲜就这样被留在了农贸市场。\n图8-7 2019年部分国家生鲜分销渠道\n8.2 为什么“美国的淘宝”eBay争不过亚马逊 图8-8 2020年中国电商平台市场份额\n美国的电商市场格局和我国很不一样\n美国电商的市场集中度远远低于我国。 品牌自营电商、连锁超市电商很难在我国占据一席之地，但在美国可以 头部平台的经营模式有所不同，我国排名第一的阿里巴巴是一个平台模式的电商，而美国排名第一的亚马逊是一个自营模式的电商。 图8-9 美国2020年电商前10名销售额\n中美电商在历史、环境上的差异，还导致了品牌和电商平台间话语权的不同。在渠道和品牌的博弈过程之中，中国电商平台的地位要比美国电商平台的地位更强。\n其一，流量高度集中于少数头部电商平台，这类平台的分发方式较为中心化，拥有较强的话语权。 其二，由于我国广阔的国土面积、多样的地域特色、复杂的城市层级，现阶段品牌方很难实现完全的渠道自主、数据自主，或多或少需要依附于头部电商平台。 因此，未来品牌与平台的博弈将始终存在。对于品牌来说，研究如何在电商平台上获取、转化、留存流量至关重要。 8.3 再论马太效应：社交电商、熟人经济、推荐算法使电商马太效应降低了吗 淘系平台转向信息流推荐之后，仍然由大商家主导；熟人电商发展势头一直比较一般；社交种草、直播带货主要还是肥了头部达人……这是为什么？\n电商平台转向信息流推荐并没有阻断马太效应形成的链条。推荐算法也会给头部商品较大的权重倾斜，使销量高的商品得到更多的曝光。 熟人经济很可能是一个伪命题。熟人之间互相推荐商品非常有效，但熟人关系可能不适合用来做电商。从熟人手上买东西，如果买贵了、买回来不好用，非常 不好处理，买家向卖家索要退款或其他售后的过程很可能损害朋友关系。 大多数直播带货实质上并非兴趣电商，而是折扣电商。这类电商显然与“去中心化”没有任何关系。主播成交额越高能拿到的折扣越高，拿到的折扣越高成交额 越高，这分明是另一个马太效应循环。 社交种草的直接收益通常并不明显，中腰部达人生态不佳。用户会对过于频繁的广告产生反感 现在的电商环境仍然呈现头部集中的态势。在一定程度上实现了“去中心化”的其实是抖音，但这个“去中心化”一定程度上建立在平台设法使用推荐算法抑制中心 化趋势的基础之上。\n8.4 结语 未来商家有可能持续加大在电商平台上的投入，使得部分品类在电商平台的费用率高于线下渠道。 对于电商平台来说，其未来的广告货币化率仍有可观的提升空间，并带动平台利润持续提升。 对于能够线上化的品类，我们可以投资线上渠道做得不错的品牌和商家；对于餐饮、旅游这类消费，继续押注线下消费的发展也是一个不错的选择。 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC8%E7%AB%A0-%E6%B8%A0%E9%81%93%E5%8F%98%E9%9D%A9%E7%9A%84%E7%9C%9F%E7%9B%B8/","summary":"8.1 为什么中国没有本土大型连锁便利店 电商改变了中国零售行业的发展路径 图8-1 2021年我国消费品零售渠道分布 电商的出现改变了我国零售行业的发展","title":"第8章 渠道变革的真相"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/mktindex/","summary":"主页","title":"魔镜市场情报"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/mobduos/","summary":"主页","title":"多多情报通"},{"content":"写在前面 关系模型的创始人E.F.Codd（1923—2003）。\n下面的内容主要依据C.J.Date的著作The Database Relation Model。\n两篇论文 Codd写了两篇与关系模型相关的论文。第一篇是写于1969年的《大型数据库中关系存储的可推导性、冗余与一致性》。遗憾的是，这篇论文发表在IBM公司内部 期刊IBM Research Report上了，因此并没有引起外界的注意。\n在接下来的1970年，Codd又在权威学术杂志Communications of ACM上，以《大型共享数据库的关系模型》为题发表了第二篇论文。至此，关系模型 真正地问世了。现在人们读到的论文基本上都是这一篇。\nCodd的贡献 Codd这两篇论文的主要贡献可以归纳为以下3点。\n定义了关系运算（relational calculus）。// todo 定义了关系代数（relational algebra）。选择、投影、并、交等8种运算 采用谓词逻辑作为数据库操作的基础。逻辑体系 1969年——一切从这里开始 1969年的论文不仅给出了关系的定义，还考虑到了主键的概念, Codd此时提出的“主键”这个词并非我们现在所说的“主键”，而更像是“超键”。因为Codd允许主 键存在冗余，而且一张表中可以存在多个主键。1970年的论文又追加了“外键”的概念。\n1969年的论文中有一句非常重要的话\n将数据看作关系后，有可能创造出以二阶谓词逻辑为基础的用于查询一般数据的子语言。 由于关系数据库以谓词逻辑作为基础，逻辑学的研究成果才可以直接应用于数据管理系统。\n“Codd最具决定性的重要思想就是把数据看成关系的集合，然后再把关系看成（真）命题的集合。这样，在创造出基于谓词逻辑的语言之后，就能直接使用这 种语言查询数据了”——C.J.Date的这句评论说到了关键点上。 1970年——远离地址 在Codd提出关系模型之前，数据库系统的主流模型是分层模型和网状模型。这两种模型在查找数据时都需要使用索引（指针），因此用户必须知道数据的存储位 置，抽象程度非常低。正因如此，Codd的首要目标就是将用户从这种毫无意义的烦恼中解放出来。于是“数据库中不再包含索引，字段间也没有顺序了”。\n范式 1970年的论文除了强调数据的独立性之外，还有一个重要的变化，那就是出现了范式的概念。\n“按照第一范式进行规范化的关系”其实就是“定义域只包含原子值（atomic value）的关系”（Codd）。这里所说的原子值，我们今天称为标量值。它指的是 不能再进行细分的最小单位的数据结构\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-1-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8E%86%E5%8F%B2/","summary":"写在前面 关系模型的创始人E.F.Codd（1923—2003）。 下面的内容主要依据C.J.Date的著作The Database Relation Model。 两篇论文 Cod","title":"2-1 关系数据库的历史"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/feigua/","summary":"主页","title":"飞瓜数据"},{"content":"","permalink":"https://jdxj.github.io/posts/data/coonav/","summary":"","title":"小葫芦大数据"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/bihukankan/","summary":"主页","title":"壁虎看看"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/qianzhan/","summary":"主页","title":"前瞻产业研究院"},{"content":"写在前面 下面两张卡片上各画了几个圆圈，哪个更容易数清楚呢？\n编程行为就像是一种沟通方式。因此，对编程风格的研究也可以看成是对提高系统开发中沟通效率的方法的研究（因此在只有一个人编程的项目中，很难注意到 代码风格的重要性）。\n表的设计 名字和意义 名称既包括用来指代具体东西的固有名称，也包括用来指代概念或者集合的一般名称。 地址没有指代任何具有实际意义的概念或者事物。 命名时允许的字符有以下3种\n英文字母 阿拉伯数字 下划线“_” 属性和列 在数据库中，列代表的是“属性”，因此应该具有一贯性。\n有些时候指代的是年龄，有些时候指代的是体重, 这种设计是不允许的 编程的方针 注释 就SQL而论，最好还是写注释。这样说主要有两个原因：\nSQL是声明式语言，即使表达同样的处理过程，逻辑仍然比面向过程语言凝练得多； SQL很难进行分步的执行调试。分析代码时主要需要进行桌面调试。 注释的写法有以下两种\n1 2 3 4 -- 单行注释 -- 从SomeTable中查询col_1 SELECT col_1 FROM SomeTable; 1 2 3 4 5 6 /＊ 多行注释 从SomeTable中查询col_1 ＊/ SELECT col_1 FROM SomeTable; SQL语句中不能有空行，却可以像下面这样加入注释。\n1 2 3 4 5 6 SELECT col_1 FROM SomeTable WHERE col_1 =\u0026#39;a\u0026#39; AND col_2 =\u0026#39;b\u0026#39; -- 下面的条件用于指定col_3的值是’c’或者’d\u0026#39; AND col_3 IN (\u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;); 注释也可以与代码在同一行\n1 2 SELECT col_1 -- 从SomeTable中查询col_1 FROM SomeTable; 缩进 1 2 3 4 5 6 7 8 9 10 11 12 13 14 --√好的示例 SELECT col_1, col_2, col_3, COUNT(＊) FROM tbl_A WHERE col_1 =\u0026#39;a\u0026#39; AND col_2 = ( SELECT MAX(col_2) FROM tbl_B WHERE col_3 = 100 ) GROUP BY col_1, col_2, col_3 1 2 3 4 5 6 7 8 9 --×坏的示例 SELECT col_1, col_2, col_3, COUNT(＊) FROM tbl_A WHERE col_1 =\u0026#39;a\u0026#39; AND col_2 = ( SELECT MAX(col_2) FROM tbl_B WHERE col_3 = 100 ) GROUP BY col_1, col_2, col_3 比起①这种所有关键字都顶格左齐的写法，②这种让关键字右齐的写法更好。\n①左齐\n1 2 3 4 5 6 SELECT FROM WHERE GROUP BY HAVING ORDER BY ②右齐\n1 2 3 4 5 6 7 SELECT FROM WHERE GROUP BY HAVING ORDER BY 空格 1 2 3 4 5 --√好的示例 SELECT col_1 FROM tbl_A A, tbl_B B WHERE ( A.col_1 \u0026gt;= 100 OR A.col_2 IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) ) AND A.col_3 = B.col_3; 1 2 3 4 5 --×坏的示例 SELECT col_1 FROM tbl_A A, tbl_B B WHERE (A.col_1\u0026gt;=100 OR A.col_2 IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;)) AND A.col_3=B.col_3; 大小写 在SQL里，关于应该如何区分使用大小写字母有着不成文的约定：关键字使用大写字母，列名和表名使用小写字母\n1 2 3 4 5 6 7 8 9 --√大小写有区分，易读 SELECT col_1, col_2, col_3, COUNT(＊) FROM tbl_A WHERE col_1 =\u0026#39;a\u0026#39; AND col_2 = ( SELECT MAX(col_2) FROM tbl_B WHERE col_3 = 100 ) GROUP BY col_1, col_2, col_3; 1 2 3 4 5 6 7 8 9 --×大小写没有区分，难读：全是小写 select col_1, col_2, col_3, count(＊) from tbl_a where col_1 =\u0026#39;a\u0026#39; and col_2 = ( select max(col_2) from tbl_b where col_3 = 100 ) group by col_1, col_2, col_3; 1 2 3 4 5 6 7 8 9 --×大小写没有区分，难读：全是大写 SELECT COL_1, COL_2, COL_3, COUNT(＊) FROM TBL_A WHERE COL_1 =\u0026#39;A\u0026#39; AND COL_2 = ( SELECT MAX(COL_2) FROM TBL_B WHERE COL_3 = 100 ) GROUP BY COL_1, COL_2, COL_3; 逗号 前置逗号\n1 2 3 4 5 SELECT col_1 , col_2 , col_3 , col_4 FROM tbl_A; 这种写法有优点有缺点, 这里列出仅供参考\n不使用通配符 写出所需的字段\n1 2 × SELECT ＊ FROM SomeTable; √ SELECT col_1, col2, col3 ... FROM SomeTable; ORDER BY中不使用列编号 前面讲过的通配符一样，一般来说会受列的顺序和位置影响的写法都应该避免\n1 2 × SELECT col_1, col2 FROM SomeTable ORDER BY 1, 2; √ SELECT col_1, col2 FROM SomeTable ORDER BY col_1, col2; SQL编程方法 请说普通话 SQL是一种有多种方言的语言，各种数据库实现都为我们做了各种扩展, 在日常开发中养成使用标准语法的习惯, 避免影响移植性\n不使用依赖各种数据库实现的函数和运算符 很多依赖数据库实现的函数都是转换函数或字符串处理函数。不要使用这些函数：DECODE(Oracle)、IF(MySQL)、NVL(Oracle)、STUFF(SQL Server)等。 请使用CASE表达式或者COALESCE、NULLIF等标准函数代替它们。此外，像SIGN或ABS、REPLACE这些，虽然标准SQL没有定义它们，但是几乎所有的数据库都 实现了它们，所以使用一下也没关系。\n连接操作使用标准语法 在很早的时候，连接条件和普通的查询条件一样，都是写在WHERE子句里的。\n1 2 3 4 SELECT ＊ FROM Foo F, Bar B WHERE F.state = B.state AND F.city =’东京’; 标准SQL使用INNER或CROSS等表明连接类型的关键字，连接条件可以使用ON子句分开写。\n1 2 3 4 5 --内连接，而且一眼就能看明白连接条件是F.state = B.state SELECT ＊ FROM Foo F INNER JOIN Bar B ON F.state = B.state WHERE F.city =’东京’; 外连接请使用LEFT OUTER JOIN、RIGHT OUTER JOIN或者FULL OUTER JOIN来写。使用(+)运算符(Oracle)、＊=运算符(SQL Server)等依赖数据库实 现的写法会降低代码的可移植性，而且表达能力也有限，所以还是尽量避免吧。标准SQL中允许省略关键字OUTER，但是这个关键字便于我们理解它是外连接而非 内连接，所以还是写上吧。\n“左派”和“右派” 外连接有左连接、右连接和全连接三种类型。其中，左连接和右连接的表达能力是一样的，理论上讲使用哪个都可以。\n在代码风格方面，左连接有一个优势：一般情况下表头都出现在左边。使用左边的表作为主表的话，SQL就能和执行结果在格式上保持一致。\n一般表头都在左边\n表头在右边的话看起来有点奇怪\n从FROM子句开始写 大家在写SQL语句时，是按照什么顺序写的呢？笔者想，大部分人都会说是从SELECT子句开始写的。他们可能会觉得“SELECT子句在开头，难道不该从它开始写 吗？”\n原因是SELECT子句是SQL语句中最后执行的部分，写的时候根本没有必要太在意。SQL中各部分的执行顺序是：FROM→WHERE→GROUP BY→HAVING→SELECT (→ORDER BY)。严格地说，ORDER BY并不是SQL语句的一部分，因此可以排除在外。这样一来，SELECT就是最后才被执行的部分了。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-12-sql%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95/","summary":"写在前面 下面两张卡片上各画了几个圆圈，哪个更容易数清楚呢？ 编程行为就像是一种沟通方式。因此，对编程风格的研究也可以看成是对提高系统开发中沟通","title":"1-12 SQL编程方法"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/tracing/","summary":"原文","title":"链路追踪（Tracing）的前世今生（上）"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/xuning/redis/","summary":"原文","title":"高可用Redis服务架构分析与搭建"},{"content":"边缘节点应该用以下方法来设置\nproxy_set_header X-Forwarded-For $remote_addr; 原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/ip/","summary":"边缘节点应该用以下方法来设置 proxy_set_header X-Forwarded-For $remote_addr; 原文","title":"如何获取客户端真实 IP？从 Gin 的一个 \"Bug\" 说起"},{"content":"使用高效的查询 参数是子查询时，使用EXISTS代替IN Class_A\nClass_B\n从Class_A表中查出同时存在于Class_B表中的员工, 使用EXISTS的SQL语句更快一些\n1 2 3 4 5 6 7 8 9 10 11 12 13 --慢 SELECT ＊ FROM Class_A WHERE id IN (SELECT id FROM Class_B); --快 SELECT ＊ FROM Class_A A WHERE EXISTS (SELECT ＊ FROM Class_B B WHERE A.id = B.id); 两个结果都如下所示\n1 2 3 4 id name -- ---- 1 田中 2 铃木 使用EXISTS时更快的原因有以下两个。\n如果连接列（id）上建立了索引，那么查询Class_B时不用查实际的表，只需查索引就可以了。 如果使用EXISTS，那么只要查到一行数据满足条件就会终止查询，不用像使用IN时一样扫描全表。在这一点上NOT EXISTS也一样。 其他\n使用in会生成临时表, exists不会 in的可读性更好 如果确信in也能很快, 就没必要改成exists 很多数据库改善了in的性能 参数是子查询时，使用连接代替IN 1 2 3 4 --使用连接代替IN SELECT A.id, A.name FROM Class_A A INNER JOIN Class_B B ON A.id = B.id; 至少用到了id上的索引\n避免排序 会排序的运算\nGROUP BY子句 ORDER BY子句 聚合函数（SUM、COUNT、AVG、MAX、MIN） DISTINCT 集合运算符（UNION、INTERSECT、EXCEPT） 窗口函数（RANK、ROW_NUMBER等） 灵活使用集合运算符的ALL可选项 SQL中有UNION、INTERSECT、EXCEPT三个集合运算符。在默认的使用方式下，这些运算符会为了排除掉重复数据而进行排序。\n1 2 3 SELECT ＊ FROM Class_A UNION SELECT ＊ FROM Class_B; 1 2 3 4 5 6 id name -- ----- 1 田中 2 铃木 3 伊集院 4 西园寺 如果不在乎结果中是否有重复数据，或者事先知道不会有重复数据，请使用UNION ALL代替UNION。这样就不会进行排序了。\n1 2 3 SELECT ＊ FROM Class_A UNION ALL SELECT ＊ FROM Class_B; 集合运算符ALL可选项的实现情况\nOracle使用MINUS代替EXCEPT MySQL连INTERSECT和EXCEPT运算本身还没有实现 mysql8 了, 应该再搜一下看有没有\n使用EXISTS代替DISTINCT 如果需要对两张表的连接结果进行去重，可以考虑使用EXISTS代替DISTINCT，以避免排序。\nItems\nSalesHistory\n使用distinct\n1 2 3 SELECT I.item_no FROM Items I INNER JOIN SalesHistory SH ON I. item_no = SH. item_no; 1 2 3 4 5 6 7 8 9 item_no ------- 10 10 20 20 30 30 30 为了排除重复数据，我们需要使用DISTINCT。\n1 2 3 4 5 6 7 8 9 SELECT DISTINCT I.item_no FROM Items I INNER JOIN SalesHistory SH ON I. item_no = SH. item_no; item_no ------- 10 20 30 使用exists\n1 2 3 4 5 6 SELECT item_no FROM Items I WHERE EXISTS (SELECT ＊ FROM SalesHistory SH WHERE I.item_no = SH.item_no); 在极值函数中使用索引（MAX/MIN） 使用这两个函数时都会进行排序。但是如果参数字段上建有索引，则只需要扫描索引，不需要扫描整张表。\n1 2 3 --这样写需要扫描全表 SELECT MAX(item) FROM Items; 1 2 3 --这样写能用到索引 SELECT MAX(item_no) FROM Items; 对于联合索引，只要查询条件是联合索引的第一个字段，索引就是有效的，所以也可以对表SalesHistory的sale_date字段使用极值函数。\n能写在WHERE子句里的条件不要写在HAVING子句里 下面两条SQL语句返回的结果是一样的。\n1 2 3 4 5 --聚合后使用HAVING子句过滤 SELECT sale_date, SUM(quantity) FROM SalesHistory GROUP BY sale_date HAVING sale_date = \u0026#39;2007-10-01\u0026#39;; 1 2 3 4 5 --聚合前使用WHERE子句过滤 SELECT sale_date, SUM(quantity) FROM SalesHistory WHERE sale_date = \u0026#39;2007-10-01\u0026#39; GROUP BY sale_date; 1 2 3 sale_date sum(quantity) -------------- -------------- \u0026#39;2007-10-01\u0026#39; 17 从性能上来看，第二条语句写法效率更高。原因通常有两个。\n第一个是在使用GROUP BY子句聚合时会进行排序，如果事先通过WHERE子句筛选出一部分行，就能够减轻排序的负担。 第二个是在WHERE子句的条件里可以使用索引。HAVING子句是针对聚合后生成的视图进行筛选的，但是很多时候聚合后的视图都没有继承原表的索引结构。 在GROUP BY子句和ORDER BY子句中使用索引 特别是，在一些数据库中，如果操作对象的列上建立的是唯一索引，那么排序过程本身都会被省略掉。\n真的用到索引了吗 假设我们在一个叫作col_1的列上建立了索引，然后来看一看下面这条SQL语句。这条SQL语句本来是想使用索引，但实际上执行时却进行了全表扫描。\n在索引字段上进行运算 1 2 3 SELECT ＊ FROM SomeTable WHERE col_1 ＊ 1.1 \u0026gt; 100; 把运算的表达式放到查询条件的右侧，就能用到索引了\n1 WHERE col_1 \u0026gt; 100 / 1.1 在查询条件的左侧使用函数时，也不能用到索引\n1 2 3 SELECT ＊ FROM SomeTable WHERE SUBSTR(col_1, 1, 1) = \u0026#39;a\u0026#39;; 使用IS NULL谓词 通常，索引字段是不存在NULL的，所以指定IS NULL和IS NOT NULL的话会使得索引无法使用，进而导致查询性能低下。\n1 2 3 SELECT ＊ FROM SomeTable WHERE col_1 IS NULL; 关于索引字段不存在NULL的原因，简单来说是NULL并不是值。非值不会被包含在值的集合中\n如果需要使用类似IS NOT NULL的功能，又想用到索引，那么可以使用下面的方法，假设“col_1”列的最小值是1。\n1 2 3 4 --IS NOT NULL的代替方案 SELECT ＊ FROM SomeTable WHERE col_1 \u0026gt; 0; 使用否定形式 下面这几种否定形式不能用到索引。\n\u0026lt;\u0026gt; != NOT IN 下面的SQL语句也会进行全表扫描。\n1 2 3 SELECT ＊ FROM SomeTable WHERE col_1 \u0026lt;\u0026gt; 100; 使用OR 在col_1和col_2上分别建立了不同的索引，或者建立了（col_1, col_2）这样的联合索引时，如果使用OR连接条件，那么要么用不到索引，要么用到了但是 效率比AND要差很多。\n1 2 3 4 SELECT ＊ FROM SomeTable WHERE col_1 \u0026gt; 100 OR col_2 = \u0026#39;abc\u0026#39;; 如果无论如何都要使用OR，那么有一种办法是位图索引。但是这种索引的话更新数据时的性能开销会增大，所以使用之前需要权衡一下利弊。\n使用联合索引时，列的顺序错误 假设存在这样顺序的一个联合索引“col_1, col_2, col_3”。\n1 2 3 4 5 ○ SELECT ＊ FROM SomeTable WHERE col_1 = 10 AND col_2 = 100 AND col_3 = 500; ○ SELECT ＊ FROM SomeTable WHERE col_1 = 10 AND col_2 = 100 ; × SELECT ＊ FROM SomeTable WHERE col_1 = 10 AND col_3 = 500 ; × SELECT ＊ FROM SomeTable WHERE col_2 = 100 AND col_3 = 500 ; × SELECT ＊ FROM SomeTable WHERE col_2 = 100 AND col_1 = 10 ; 联合索引中的第一列（col_1）必须写在查询条件的开头，而且索引中列的顺序不能颠倒。有些数据库里顺序颠倒后也能使用索引，但是性能还是比顺序正确时 差一些。\n如果无法保证查询条件里列的顺序与索引一致，可以考虑将联合索引拆分为多个索引。\n使用LIKE谓词进行后方一致或中间一致的匹配 使用LIKE谓词时，只有前方一致的匹配才能用到索引。\n1 2 3 × SELECT ＊ FROM SomeTable WHERE col_1 LIKE\u0026#39;%a\u0026#39;; × SELECT ＊ FROM SomeTable WHERE col_1 LIKE\u0026#39;%a%\u0026#39;; ○ SELECT ＊ FROM SomeTable WHERE col_1 LIKE\u0026#39;a%\u0026#39;; 进行默认的类型转换 对char类型的“col_1”列指定条件的示例\n1 2 3 × SELECT ＊ FROM SomeTable WHERE col_1 = 10; ○ SELECT ＊ FROM SomeTable WHERE col_1 =\u0026#39;10\u0026#39;; ○ SELECT ＊ FROM SomeTable WHERE col_1 = CAST(10, AS CHAR(2)); 默认的类型转换不仅会增加额外的性能开销，还会导致索引不可用 在需要类型转换时显式地进行类型转换吧（别忘了转换要写在条件表达式的右边）。 减少中间表 频繁使用中间表会带来两个问题，一是展开数据需要耗费内存资源，二是原始表中的索引不容易使用到\n灵活使用HAVING子句 不习惯使用HAVING子句的数据库工程师可能会倾向于像下面这样先生成一张中间表，然后在WHERE子句中指定筛选条件。\n1 2 3 4 5 sale_date tot_qty ------------ --------- 07-10-01 10 07-10-03 32 07-10-04 22 对聚合结果指定筛选条件时不需要专门生成中间表\n1 2 3 4 SELECT sale_date, MAX(quantity) FROM SalesHistory GROUP BY sale_date HAVING MAX(quantity) \u0026gt;= 10; HAVING子句和聚合操作是同时执行的，所以比起生成中间表后再执行的WHERE子句，效率会更高一些，而且代码看起来也更简洁。\n需要对多个字段使用IN谓词时，将它们汇总到一处 SQL-92中加入了行与行比较的功能。这样一来，比较谓词＝、＜、＞和IN谓词的参数就不能是标量值，而应是值列表了。\n这里对多个字段使用了IN谓词，“id”列是主键。\n1 2 3 4 5 6 7 8 SELECT id, state, city FROM Addresses1 A1 WHERE state IN (SELECT state FROM Addresses2 A2 WHERE A1.id = A2.id) AND city IN (SELECT city FROM Addresses2 A2 WHERE A1.id = A2.id); 如果像下面这样把字段连接在一起，那么就能把逻辑写在一处了。\n1 2 3 4 5 SELECT ＊ FROM Addresses1 A1 WHERE id || state || city IN (SELECT id || state|| city FROM Addresses2 A2); 这样一来，子查询不用考虑关联性，而且只执行一次就可以。此外，如果所用的数据库实现了行与行的比较，那么我们也可以像下面这样，在IN中写多个字段的 组合。\n1 2 3 4 5 SELECT ＊ FROM Addresses1 A1 WHERE (id, state, city) IN (SELECT id, state, city FROM Addresses2 A2); 这种方法与前面的连接字段的方法相比有两个优点。\n一是不用担心连接字段时出现的类型转换问题 二是这种方法不会对字段进行加工，因此可以使用索引。 先进行连接再进行聚合 连接和聚合同时使用时，先进行连接操作可以避免产生中间表。原因是，从集合运算的角度来看，连接做的是“乘法运算”。连接表双方是一对一、一对多的关系 时，连接运算后数据的行数不会增加。而且，因为在很多设计中多对多的关系都可以分解成两个一对多的关系，因此这个技巧在大部分情况下都可以使用。\n合理地使用视图 如果没有经过深入思考就定义复杂的视图，可能会带来巨大的性能问题。特别是视图的定义语句中包含以下运算的时候，SQL会非常低效，执行速度也会变得非常 慢。\n聚合函数（AVG、COUNT、SUM、MIN、MAX） 集合运算符（UNION、INTERSECT、EXCEPT等） 越来越多的数据库为了解决视图的这个缺点，实现了物化视图（materialized view）等技术。当视图的定义变得复杂时，可以考虑使用一下。\n本节小结 不管是减少排序还是使用索引，抑或是避免中间表的使用，都是为了减少对硬盘的访问。\n下面是本节要点。\n参数是子查询时，使用EXISTS或者连接代替IN。 使用索引时，条件表达式的左侧应该是原始字段。 在SQL中排序无法显式地指定，但是请注意很多运算都会暗中进行排序。 尽量减少没用的中间表。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-11-%E8%AE%A9sql%E9%A3%9E%E8%B5%B7%E6%9D%A5/","summary":"推荐看","title":"1-11 让SQL飞起来"},{"content":"各队，全体点名 你需要做的是查出现在可以出勤的队伍。可以出勤即队伍里所有队员都处于“待命”状态。\nTeams\n“所有队员都处于‘待命’状态”这个条件是全称量化命题，所以可以用NOT EXISTS来表达。\n1 2 3 4 5 6 7 8 -- 用谓词表达全称量化命题 SELECT team_id, member FROM Teams T1 WHERE NOT EXISTS (SELECT ＊ FROM Teams T2 WHERE T1.team_id = T2.team_id AND status \u0026lt;\u0026gt;’待命’); 执行结果\n1 2 3 4 5 6 team_id member ------- ------ 3 简 3 哈特 3 迪克 4 贝斯 使用HAVING子句\n1 2 3 4 5 6 7 -- 用集合表达全称量化命题(1) SELECT team_id FROM Teams GROUP BY team_id HAVING COUNT(＊) = SUM(CASE WHEN status =’待命’ THEN 1 ELSE 0 END); 执行结果\n1 2 3 4 team_id ------- 3 4 第一步还是使用GROUP BY子句将Teams集合以队伍为单位划分成几个子集。\nHAVING子句中的条件还可以像下面这样写。\n1 2 3 4 5 6 -- 用集合表达全称量化命题(2) SELECT team_id FROM Teams GROUP BY team_id HAVING MAX(status) =’待命’ AND MIN(status) =’待命’; 极值函数可以使用参数字段的索引，所以这种写法性能更好（当然本例中只有3种值，建立索引也并没有太大的意义）。\n也可以把条件放在SELECT子句里，以列表形式显示出各个队伍是否所有队员都在待命\n1 2 3 4 5 6 7 -- 列表显示各个队伍是否所有队员都在待命 SELECT team_id, CASE WHEN MAX(status) =’待命’AND MIN(status) =’待命’ THEN ’全都在待命’ ELSE’队长！人手不够’END AS status FROM Teams GROUP BY team_id; 1 2 3 4 5 6 7 team_id status ------- -------------------------- 1 队长！人手不够 2 队长！人手不够 3 全都在待命 4 全都在待命 5 队长！人手不够 单重集合与多重集合 关系数据库中的集合是允许重复数据存在的多重集合。与之相反，通常意义的集合论中的集合不允许数据重复，被称为“单重集合”（这是笔者自己造的词，并非 公认的术语）。\n生产地的材料库存的表\nMaterials\n为了在各生产地之间调整重复的材料，我们需要调查出存在重复材料的生产地。\n按生产地分组\n“排除掉重复元素后和排除掉重复元素前元素个数不相同”。如果不存在重复的元素，不管是否加上DISTINCT可选项，COUNT的结果都是相同的。\n1 2 3 4 5 -- 选中材料存在重复的生产地 SELECT center FROM Materials GROUP BY center HAVING COUNT(material) \u0026lt;\u0026gt; COUNT(DISTINCT material); 执行结果\n1 2 3 4 center ------ 东京 名古屋 显示哪种材料重复\n1 2 3 4 5 6 7 8 9 10 11 12 SELECT center, CASE WHEN COUNT(material) \u0026lt;\u0026gt; COUNT(DISTINCT material) THEN’存在重复’ ELSE’不存在重复’END AS status FROM Materials GROUP BY center; center status ---------- ---------- 大阪 不存在重复 东京 存在重复 福冈 不存在重复 名古屋 存在重复 这个问题也可以通过将HAVING改写成EXISTS的方式来解决。\n1 2 3 4 5 6 7 8 9 --存在重复的集合：使用EXISTS SELECT center, material FROM Materials M1 WHERE EXISTS (SELECT ＊ FROM Materials M2 WHERE M1.center = M2.center AND M1.receive_date \u0026lt;\u0026gt; M2.receive_date AND M1.material = M2.material); 1 2 3 4 5 6 7 8 center material ------- --------- 东京 锌 东京 锌 名古屋 钛 名古屋 钢 名古屋 钢 名古屋 钛 寻找缺失的编号：升级版 1-4节介绍过下面这样一条查询数列的缺失编号的查询语句\n1 2 3 4 -- 如果有查询结果，说明存在缺失的编号 SELECT’存在缺失的编号’AS gap FROM SeqTbl HAVING COUNT(＊) \u0026lt;\u0026gt; MAX(seq); 这条SQL语句有一个前提条件，即数列的起始值必须是1。\n放宽这个限制条件，思考一下不管数列的最小值是多少，都能用来判断该数列是否连续的SQL语句。\n(1)不存在缺失编号（起始值＝1）\n(2)存在缺失编号（起始值＝1）\n(3)不存在缺失编号（起始值\u0026lt;\u0026gt;1）\n(4)存在缺失编号（起始值\u0026lt;\u0026gt;1）\n如果数列的最小值和最大值之间没有缺失的编号，它们之间包含的元素的个数应该是“最大值－最小值+1”。\n1 2 3 4 -- 如果有查询结果，说明存在缺失的编号：只调查数列的连续性 SELECT’存在缺失的编号’ AS gap FROM SeqTbl HAVING COUNT(＊) \u0026lt;\u0026gt; MAX(seq) - MIN(seq) + 1 ; 不论是否存在缺失的编号，都想要返回结果\n1 2 3 4 5 6 7 -- 不论是否存在缺失的编号都返回一行结果 SELECT CASE WHEN COUNT(＊) = 0 THEN ’表为空’ WHEN COUNT(＊) \u0026lt;\u0026gt; MAX(seq) - MIN(seq) + 1 THEN ’存在缺失的编号’ ELSE’连续’END AS gap FROM SeqTbl; 改进一下查找最小的缺失编号的SQL语句，去掉起始值必须是1的限制。\n1 2 3 4 5 6 7 8 9 10 11 -- 查找最小的缺失编号：表中没有1时返回1 SELECT CASE WHEN COUNT(＊) = 0 OR MIN(seq) \u0026gt; 1 -- 最小值不是1时→返回1 THEN 1 ELSE (SELECT MIN(seq +1) -- 最小值是1时→返回最小的缺失编号 FROM SeqTbl S1 WHERE NOT EXISTS (SELECT ＊ FROM SeqTbl S2 WHERE S2.seq = S1.seq + 1)) END FROM SeqTbl; 这条SQL语句会返回下面这样的结果\n情况(1):6（没有缺失的编号，所以返回最大值5的下一个数） 情况(2):3（最小的缺失编号） 情况(3):1（因为表中没有1） 情况(4):1（因为表中没有1） 为集合设置详细的条件 学生考试成绩的表\nTestResults\n第1题：请查询出75%以上的学生分数都在80分以上的班级。\n1 2 3 4 5 6 7 SELECT class FROM TestResults GROUP BY class HAVING COUNT(＊) ＊ 0.75 \u0026lt;= SUM(CASE WHEN score \u0026gt;= 80 THEN 1 ELSE 0 END) ; 执行结果\n1 2 3 class ------- B 第2题：请查询出分数在50分以上的男生的人数比分数在50分以上的女生的人数多的班级。\n1 2 3 4 5 6 7 8 9 SELECT class FROM TestResults GROUP BY class HAVING SUM(CASE WHEN score \u0026gt;= 50 AND sex =’男’ THEN 1 ELSE 0 END) \u0026gt; SUM(CASE WHEN score \u0026gt;= 50 AND sex =’女’ THEN 1 ELSE 0 END) ; 执行结果\n1 2 3 4 class ------- B C 第3题：请查询出女生平均分比男生平均分高的班级。\n1 2 3 4 5 6 7 8 9 10 -- 比较男生和女生平均分的SQL语句(1)：对空集使用AVG后返回0 SELECT class FROM TestResults GROUP BY class HAVING AVG(CASE WHEN sex =’男’ THEN score ELSE 0 END) \u0026lt; AVG(CASE WHEN sex =’女’ THEN score ELSE 0 END) ; 执行结果\n1 2 3 4 class ------- A D 根据标准SQL的定义，对空集使用AVG函数时，结果会返回NULL\n1 2 3 4 5 6 7 8 9 10 -- 比较男生和女生平均分的SQL语句(2)：对空集求平均值后返回NULL SELECT class FROM TestResults GROUP BY class HAVING AVG(CASE WHEN sex =’男’ THEN score ELSE NULL END) \u0026lt; AVG(CASE WHEN sex =’女’ THEN score ELSE NULL END) ; 这回D班男生的平均分是NULL。因此不管女生的平均分多少，D班都会被排除在查询结果之外。\n本节小结 用于调查集合性质的常用条件及其用途\n在SQL中指定搜索条件时，最重要的是搞清楚搜索的实体是集合还是集合的元素。\n如果一个实体对应着一行数据→那么就是元素，所以使用WHERE子句。 如果一个实体对应着多行数据→那么就是集合，所以使用HAVING子句。 HAVING子句可以通过聚合函数（特别是极值函数）针对集合指定各种条件。 如果通过CASE表达式生成特征函数，那么无论多么复杂的条件都可以描述。 HAVING子句很强大。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-10-having%E5%AD%90%E5%8F%A5%E5%8F%88%E5%9B%9E%E6%9D%A5%E4%BA%86/","summary":"各队，全体点名 你需要做的是查出现在可以出勤的队伍。可以出勤即队伍里所有队员都处于“待命”状态。 Teams “所有队员都处于‘待命’状态”这个条件是全称","title":"1-10 HAVING子句又回来了"},{"content":"生成连续编号 谜题：00～99的100个数中，0, 1, 2, …, 9这10个数字分别出现了多少次？\n00～99的数中，数字0～9各出现了20次\n无论多大的数，都可以由这张表中的10个数字组合而成。\nDigits\n通过对两个Digits集合求笛卡儿积而得出0～99的数字\n1 2 3 4 --求连续编号(1)：求0~99的数 SELECT D1.digit + (D2.digit ＊ 10) AS seq FROM Digits D1 CROSS JOIN Digits D2 ORDER BY seq; 执行结果\n1 2 3 4 5 6 7 8 9 10 seq --- 0 1 2 ： ： ： 98 99 笛卡儿积：得到所有可能的组合\n如果只想生成从1开始，或者到542结束的数，只需在WHERE子句中加入过滤条件就可以了。\n1 2 3 4 5 6 7 --求连续编号(2)：求1~542的数 SELECT D1.digit + (D2.digit ＊ 10) + (D3.digit ＊ 100) AS seq FROM Digits D1 CROSS JOIN Digits D2 CROSS JOIN Digits D3 WHERE D1.digit + (D2.digit ＊ 10) + (D3.digit ＊ 100) BETWEEN 1 AND 542 ORDER BY seq; 通过将这个查询的结果存储在视图里，就可以在需要连续编号时通过简单的SELECT来获取需要的编号。\n1 2 3 4 5 6 7 8 9 10 11 --生成序列视图（包含0~999） CREATE VIEW Sequence (seq) AS SELECT D1.digit + (D2.digit ＊ 10) + (D3.digit ＊ 100) FROM Digits D1 CROSS JOIN Digits D2 CROSS JOIN Digits D3; --从序列视图中获取1~100 SELECT seq FROM Sequence WHERE seq BETWEEN 1 AND 100 ORDER BY seq; 求全部的缺失编号 假设存在下面这样一张编号有缺失的表。\nSeqtbl\n利用序列视图\n1 2 3 4 5 6 7 8 9 10 11 12 --EXCEPT版 SELECT seq FROM Sequence WHERE seq BETWEEN 1 AND 12 EXCEPT SELECT seq FROM SeqTbl; --NOT IN版 SELECT seq FROM Sequence WHERE seq BETWEEN 1 AND 12 AND seq NOT IN (SELECT seq FROM SeqTbl); 执行结果\n1 2 3 4 5 seq --- 3 9 10 可能像下面这么做性能会有所下降，但是通过扩展BETWEEN谓词的参数，我们可以动态地指定目标表的最大值和最小值。\n1 2 3 4 5 6 7 --动态地指定连续编号范围的SQL语句 SELECT seq FROM Sequence WHERE seq BETWEEN (SELECT MIN(seq) FROM SeqTbl) AND (SELECT MAX(seq) FROM SeqTbl) EXCEPT SELECT seq FROM SeqTbl; 这种写法在查询上限和下限未必固定的表时非常方便。两个自查询没有相关性，而且只会执行一次。 如果在“seq”列上建立索引，那么极值函数的运行可以变得更快速。 三个人能坐得下吗 火车座位预订情况的表\nSeats\n问题是，从1～15的座位编号中，找出连续3个空位的全部组合。\n希望得到的结果是\n3～5 7～9 8～10 9～11 假设所有的座位排成了一条直线。\n7～11的序列包含3个子序列\n借助上面的图表我们可以知道，需要满足的条件是，以n为起点、n+(3-1)为终点的座位全部都是未预订状态\n1 2 3 4 5 6 7 8 9 --找出需要的空位(1)：不考虑座位的换排 SELECT S1.seat AS start_seat, \u0026#39;~\u0026#39;, S2.seat AS end_seat FROM Seats S1, Seats S2 WHERE S2.seat = S1.seat + (:head_cnt -1) --决定起点和终点 AND NOT EXISTS (SELECT ＊ FROM Seats S3 WHERE S3.seat BETWEEN S1.seat AND S2.seat AND S3.status \u0026lt;\u0026gt;’未预订’); 发生换排的情况。假设这列火车每一排有5个座位。我们在表中加上表示行编号“row_id”列。\nSeats2\n因为发生换排，所以9~11的序列不符合条件\n1 2 3 4 5 6 7 8 9 10 --找出需要的空位(2)：考虑座位的换排 SELECT S1.seat AS start_seat, \u0026#39;~\u0026#39;, S2.seat AS end_seat FROM Seats2 S1, Seats2 S2 WHERE S2.seat = S1.seat + (:head_cnt -1) --决定起点和终点 AND NOT EXISTS (SELECT ＊ FROM Seats2 S3 WHERE S3.seat BETWEEN S1.seat AND S2.seat AND ( S3.status \u0026lt;\u0026gt;’未预订’ OR S3.row_id \u0026lt;\u0026gt; S1.row_id)); 执行结果\n1 2 3 4 5 start_seat \u0026#39;~\u0026#39; end_seat ---------- --- -------- 3 ~ 5 8 ~ 10 11 ~ 13 序列内的点需要满足的条件是，“所有座位的状态都是‘未预订’，且行编号相同”。这里新加的条件是“行编号相同”，等价于“与起点的行编号相同”（当然，与终 点的行编号相同也可以）。把这个条件直接写成SQL语句的话，就是像下面这样。\n1 S3.status =’未预订’AND S3.row_id = S1.row_id 由于SQL中不存在全称量词，所以我们必须使用这个条件的否定，即改成下面这样的否定形式。\n1 2 NOT (S3.status =’未预订’AND S3.row_id = S1.row_id) = S3.status \u0026lt;\u0026gt;’未预订’OR S3.row_id \u0026lt;\u0026gt; S1.row_id 最多能坐下多少人 这次要查询的是“按现在的空位状况，最多能坐下多少人”。换句话说，要求的是最长的序列。\nSeats3\n要想保证从座位A到另一个座位B是一个序列，则下面的3个条件必须全部都满足。\n条件1：起点到终点之间的所有座位状态都是“未预订”。 条件2：起点之前的座位状态不是“未预订”。 条件3：终点之后的座位状态不是“未预订”。 不符合条件1的情况\n不符合条件2的情况\n不符合条件3的情况\n先生成一张下面这样的视图。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --第一阶段：生成存储了所有序列的视图 CREATE VIEW Sequences (start_seat, end_seat, seat_cnt) AS SELECT S1.seat AS start_seat, S2.seat AS end_seat, S2.seat - S1.seat + 1 AS seat_cnt FROM Seats3 S1, Seats3 S2 WHERE S1.seat \u0026lt;= S2.seat --第一步：生成起点和终点的组合 AND NOT EXISTS --第二步：描述序列内所有点需要满足的条件 (SELECT ＊ FROM Seats3 S3 WHERE ( S3.seat BETWEEN S1.seat AND S2.seat AND S3.status \u0026lt;\u0026gt;’未预订’) --条件1的否定 OR (S3.seat = S2.seat + 1 AND S3.status =’未预订’) --条件3的否定 OR (S3.seat = S1.seat -1 AND S3.status =’未预订’)); --条件2的否定 这个视图包含以下的内容。\n1 2 3 4 5 start_seat end_seat seat_cnt ------------ ---------- ---------- 2 5 4 7 7 1 9 10 2 我们从这个视图中找出座位数（seat_cnt）最大的一行数据。\n1 2 3 4 --第二阶段：求最长的序列 SELECT start_seat, \u0026#39;~\u0026#39;, end_seat, seat_cnt FROM Sequences WHERE seat_cnt = (SELECT MAX(seat_cnt) FROM Sequences); 单调递增和单调递减 某公司股价动态的表\nMyStock\n求一下股价单调递增的时间区间。从上表来看，目标结果是下面两个。\n2007-01-06～2007-01-08 2007-01-14～2007-01-17 首先进行第一步——通过自连接生成起点和终点的组合。\n1 2 3 4 5 --生成起点和终点的组合的SQL语句 SELECT S1.deal_date AS start_date, S2.deal_date AS end_date FROM MyStock S1, MyStock S2 WHERE S1.deal_date \u0026lt; S2.deal_date; 第二步——描述起点和终点之间的所有点需要满足的条件。\n对于区间内的任意两个时间点，命题“较晚时间的股价高于较早时间的股价”都成立。 然后，我们将这个条件反过来，得到需要的条件——区间内不存在两个时间点使得较早时间的股价高于较晚时间的股价。 1 2 3 4 5 6 7 8 9 10 11 12 --求单调递增的区间的SQL语句：子集也输出 SELECT S1.deal_date AS start_date, S2.deal_date AS end_date FROM MyStock S1, MyStock S2 WHERE S1.deal_date \u0026lt; S2.deal_date --第一步：生成起点和终点的组合 AND NOT EXISTS ( SELECT ＊ --第二步：描述区间内所有日期需要满足的条件 FROM MyStock S3, MyStock S4 WHERE S3.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S4.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S3.deal_date \u0026lt; S4.deal_date AND S3.price \u0026gt;= S4.price); 执行结果\n1 2 3 4 5 6 start_date end_date ------------ ------------- 2007-01-06 2007-01-08 2007-01-14 2007-01-16 2007-01-14 2007-01-17 2007-01-16 2007-01-17 最后，我们要把这些不需要的子集排除掉。使用极值函数很容易就能实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --排除掉子集，只取最长的时间区间 SELECT MIN(start_date) AS start_date, --最大限度地向前延伸起点 end_date FROM (SELECT S1.deal_date AS start_date, MAX(S2.deal_date) AS end_date --最大限度地向后延伸终点 FROM MyStock S1, MyStock S2 WHERE S1.deal_date \u0026lt; S2.deal_date AND NOT EXISTS (SELECT ＊ FROM MyStock S3, MyStock S4 WHERE S3.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S4.deal_date BETWEEN S1.deal_date AND S2.deal_date AND S3.deal_date \u0026lt; S4.deal_date AND S3.price \u0026gt;= S4.price) GROUP BY S1.deal_date) TMP GROUP BY end_date; 执行结果\n1 2 3 4 start_date end_date ------------ ------------- 2007-01-06 2007-01-08 2007-01-14 2007-01-17 本节小结 SQL处理数据的方法有两种。\n第一种是把数据看成忽略了顺序的集合。 第二种是把数据看成有序的集合，此时的基本方法如下。 首先用自连接生成起点和终点的组合 其次在子查询中描述内部的各个元素之间必须满足的关系 要在SQL中表达全称量化时，需要将全称量化命题转换成存在量化命题的否定形式，并使用NOT EXISTS谓词。这是因为SQL只实现了谓词逻辑中的存在量词。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-9-%E7%94%A8sql%E5%A4%84%E7%90%86%E6%95%B0%E5%88%97/","summary":"生成连续编号 谜题：00～99的100个数中，0, 1, 2, …, 9这10个数字分别出现了多少次？ 00～99的数中，数字0～9各出现了20次 无论多大的","title":"1-9 用SQL处理数列"},{"content":"理论篇 什么是谓词 谓词是一种特殊的函数，返回值是真值。\ntrue false unknown 在关系数据库里，表中的一行数据可以看作是一个命题。\nTbl_A\n实体的阶层 同样是谓词，但是与=、BETWEEN等相比，EXISTS的用法还是大不相同的。概括来说，区别在于“谓词的参数可以取什么值”。\n1 2 3 4 5 6 SELECT id FROM Foo F WHERE EXISTS (SELECT ＊ FROM Bar B WHERE F.id=B.id ); 看一下EXISTS()的括号中的内容\n1 2 3 SELECT ＊ FROM Bar B WHERE A.id = T2.id 在EXISTS的子查询里，SELECT子句的列表可以有下面这三种写法。\n通配符：SELECT ＊ 常量：SELECT ‘这里的内容任意’ 列名：SELECT col 不管采用上面这三种写法中的哪一种，得到的结果都是一样的。\n=或者BETWEEEN等输入值为一行的谓词叫作“一阶谓词”，而像EXISTS这样输入值为行的集合的谓词叫作“二阶谓词”。阶（order）是用来区分集合或谓词的阶 数的概念。\n三阶谓词＝输入值为“集合的集合”的谓词 四阶谓词＝输入值为“集合的集合的集合”的谓词 …… 我们可以像上面这样无限地扩展阶数，但是SQL里并不会出现三阶以上的情况\nEXISTS因接受的参数是集合这样的一阶实体而被称为二阶谓词，但是谓词也是函数的一种，因此我们也可以说EXISTS是高阶函数。\n全称量化和存在量化 “所有的x都满足条件P”或者“存在（至少一个）满足条件P的x”。前者称为“全称量词”，后者称为“存在量词”，分别记作∀、∃。这两个符号看起来很奇怪。其 实，全称量词的符号其实是将字母A上下颠倒而形成的，存在量词则是将字母E左右颠倒而形成的。\nsql没有实现全称量词, 但是没有全称量词并不算是SQL的致命缺陷。因为全称量词和存在量词只要定义了一个，另一个就可以被推导出来。\n∀ xPx = ¬ ∃ x¬P（所有的x都满足条件P＝不存在不满足条件P的x） ∃ xPx = ¬ ∀ x¬Px（存在x满足条件P＝并非所有的x都不满足条件P） 实践篇 查询表中“不”存在的数据 在有些情况下，我们不得不从表中查找出“不存在的数据”。\nMeetings\n目标结果如下所示\n1 2 3 4 5 6 meeting person ---------- -------- 第1次 宫田 第2次 坂东 第2次 水岛 第3次 伊藤 思路是先假设所有人都参加了全部会议，并以此生成一个集合，然后从中减去实际参加会议的人。这样就能得到缺席会议的人。\n所有人都参加了全部会议的集合可以通过下面这样的交叉连接来求得。\n1 2 SELECT DISTINCT M1.meeting, M2.person FROM Meetings M1 CROSS JOIN Meetings M2; 所有人都参加了全部会议时\n然后我们从这张表中减掉实际参会者的集合\n1 2 3 4 5 6 7 8 --求出缺席者的SQL语句(1)：存在量化的应用 SELECT DISTINCT M1.meeting, M2.person FROM Meetings M1 CROSS JOIN Meetings M2 WHERE NOT EXISTS (SELECT ＊ FROM Meetings M3 WHERE M1.meeting = M3.meeting AND M2.person = M3.person); 这道例题还可以用集合论的方法来解答，即像下面这样使用差集运算。\n1 2 3 4 5 6 ----求出缺席者的SQL语句(2)：使用差集运算 SELECT M1.meeting, M2.person FROM Meetings M1, Meetings M2 EXCEPT SELECT meeting, person FROM Meetings; 全称量化(1)：习惯“肯定⇔双重否定”之间的转换 学生考试成绩的表\nTestScores\n请查询出“所有科目分数都在50分以上的学生”\n将查询条件“所有科目分数都在50分以上”转换成它的双重否定“没有一个科目分数不满50分”，然后用NOT EXISTS来表示转换后的命题。\n1 2 3 4 5 6 7 SELECT DISTINCT student_id FROM TestScores TS1 WHERE NOT EXISTS --不存在满足以下条件的行 (SELECT ＊ FROM TestScores TS2 WHERE TS2.student_id = TS1.student_id AND TS2.score \u0026lt; 50); --分数不满50分的科目 执行结果\n1 2 3 4 5 student_id ----------- 100 200 400 查询出满足下列条件的学生。\n数学的分数在80分以上。 语文的分数在50分以上。 针对同一个集合内的行数据进行了条件分支后的全称量化。\n“某个学生的所有行数据中，如果科目是数学，则分数在80分以上；如果科目是语文，则分数在50分以上。” 1 2 3 CASE WHEN subject =’数学’AND score \u0026gt;= 80 THEN 1 WHEN subject =’语文’AND score \u0026gt;= 50 THEN 1 ELSE 0 END 首先，数学和语文之外的科目不在我们考虑范围之内，所以通过IN条件进行一下过滤。然后，通过子查询来描述“数学80分以上，语文50分以上”这个条件。\n1 2 3 4 5 6 7 8 9 10 SELECT DISTINCT student_id FROM TestScores TS1 WHERE subject IN (’数学’, ’语文’) AND NOT EXISTS (SELECT ＊ FROM TestScores TS2 WHERE TS2.student_id = TS1.student_id AND 1 = CASE WHEN subject =’数学’AND score \u0026lt; 80 THEN 1 WHEN subject =’语文’AND score \u0026lt; 50 THEN 1 ELSE 0 END); 排除掉没有语文分数的学号为400的学生。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 SELECT student_id FROM TestScores TS1 WHERE subject IN (’数学’, ’语文’) AND NOT EXISTS (SELECT ＊ FROM TestScores TS2 WHERE TS2.student_id = TS1.student_id AND 1 = CASE WHEN subject =’数学’AND score \u0026lt; 80 THEN 1 WHEN subject =’语文’AND score \u0026lt; 50 THEN 1 ELSE 0 END) GROUP BY student_id HAVING COUNT(＊) = 2; --必须两门科目都有分数 student_id ---------- 100 200 全称量化(2)：集合VS谓词——哪个更强大？ 项目工程管理表\nProjects\n从这张表中查询出哪些项目已经完成到了工程1\nJoe Celko曾经借助HAVING子句用面向集合的方法进行过解答\n1 2 3 4 5 6 7 --查询完成到了工程1的项目：面向集合的解法 SELECT project_id FROM Projects GROUP BY project_id HAVING COUNT(＊) = SUM(CASE WHEN step_nbr \u0026lt;= 1 AND status =’完成’THEN 1 WHEN step_nbr \u0026gt; 1 AND status =’等待’THEN 1 ELSE 0 END); 执行结果\n1 2 3 project_id ----------- CS300 针对每个项目，将工程编号为1以下且状态为“完成”的行数，和工程编号大于1且状态为“等待”的行数加在一起，如果和等于该项目数据的总行数，则该项目符合 查询条件。\n用谓词逻辑\n1 2 3 4 5 6 7 8 9 10 --查询完成到了工程1的项目：谓词逻辑的解法 SELECT ＊ FROM Projects P1 WHERE NOT EXISTS (SELECT status FROM Projects P2 WHERE P1.project_id = P2. project_id --以项目为单位进行条件判断 AND status \u0026lt;\u0026gt; CASE WHEN step_nbr \u0026lt;= 1 --使用双重否定来表达全称量化命题 THEN ’完成’ ELSE ’等待’ END); 执行结果\n1 2 3 4 5 6 7 project_id step_nbr status ----------- -------- ------ CS300 0 完成 CS300 1 完成 CS300 2 等待 CS300 3 等待 对列进行量化：查询全是1的行 ArrayTbl\n在使用这种模拟数组的表时遇到的需求一般都是下面这两种形式。\n查询“都是1”的行。 查询“至少有一个9”的行。 1 2 3 4 5 6 7 8 9 --“列方向”的全称量化：不优雅的解答 SELECT ＊ FROM ArrayTbl WHERE col1 = 1 AND col2 = 1 · · · AND col10 = 1; SQL语言其实还准备了一个谓词，帮助我们进行“列方向”的量化。\n1 2 3 4 --“列方向”的全称量化：优雅的解答 SELECT ＊ FROM ArrayTbl WHERE 1 = ALL (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 1 2 3 key col1 col2 col3 col4 col5 col6 col7 col8 col9 col10 --- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----- C 1 1 1 1 1 1 1 1 1 1 如果想表达“至少有一个9”这样的存在量化命题，可以使用ALL的反义谓词ANY。\n1 2 3 4 --列方向的存在量化(1) SELECT ＊ FROM ArrayTbl WHERE 9 = ANY (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 1 2 3 4 key col1 col2 col3 col4 col5 col6 col7 col8 col9 col10 --- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----- D 9 E 3 1 9 9 或者也可以使用IN谓词代替ANY。\n1 2 3 4 --列方向的存在量化(2) SELECT ＊ FROM ArrayTbl WHERE 9 IN (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 如果左边不是具体值而是NULL，这种写法就不行了。\n1 2 3 4 --查询全是NULL的行：错误的解法 SELECT ＊ FROM ArrayTbl WHERE NULL = ALL (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10); 不管表里的数据是什么样的，这条SQL语句的查询结果都是空。这是因为，ALL谓词会被解释成col1 = NULL AND col2 = NULL AND ……col10 = NULL。 这种情况下，我们需要使用COALESCE函数。\n1 2 3 4 --查询全是NULL的行：正确的解法 SELECT ＊ FROM ArrayTbl WHERE COALESCE(col1, col2, col3, col4, col5, col6, col7, col8, col9, col10) IS NULL; 1 2 3 key col1 col2 col3 col4 col5 col6 col7 col8 col9 col10 --- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----- A 本节小结 SQL中的谓词指的是返回真值的函数。 EXISTS与其他谓词不同，接受的参数是集合。 因此EXISTS可以看成是一种高阶函数。 SQL中没有与全称量词相当的谓词，可以使用NOT EXISTS代替。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-8-exists%E8%B0%93%E8%AF%8D%E7%9A%84%E7%94%A8%E6%B3%95/","summary":"理论篇 什么是谓词 谓词是一种特殊的函数，返回值是真值。 true false unknown 在关系数据库里，表中的一行数据可以看作是一个命题。 Tbl_A 实体的阶层 同样是谓词，但是与=","title":"1-8 EXISTS谓词的用法"},{"content":"导入篇：集合运算的几个注意事项 注意事项1: SQL能操作具有重复行的集合，可以通过可选项ALL来支持\n一般的集合论不允许集合中存在重复元素 关系数据库允许存在重复行, 称为多重集合（multiset, bag） SQL的集合运算符也提供了允许重复和不允许重复的两种用法。如果直接使用UNION或INTERSECT，结果里就不会出现重复的行。如果想在结果里留下重复行， 可以加上可选项ALL，写作UNION ALL。 集合运算符为了排除掉重复行，默认地会发生排序，而加上可选项ALL之后，就不会再排序，所以性能会有提升。 注意事项2：集合运算符有优先级\n标准SQL规定，INTERSECT比UNION和EXCEPT优先级更高。 注意事项3：各个DBMS提供商在集合运算的实现程度上参差不齐\nSQL Server从2005版开始支持INTERSECT和EXCEPT，而MySQL还都不支持（包含在“中长期计划”里）。 还有像Oracle这样，实现了EXCEPT功能但却命名为MINUS的数据库。 注意事项4：除法运算没有标准定义\n四则运算里的和（UNION）、差（EXCEPT）、积（CROSS JOIN）都被引入了标准SQL。但是很遗憾，商（DIVIDE BY）因为各种原因迟迟没能标准化\n比较表和表：检查集合相等性之基础篇 “相等”指的是行数和列数以及内容都相同\n名字不同但内容相同的两张表\ntbl_A\ntbl_B\n如果这个查询的结果与tbl_A及tbl_B的行数一致，则两张表是相等的\n需要事先确认表tbl_A和表tbl_B的行数是一样的 1 2 3 4 5 6 SELECT COUNT(＊) AS row_cnt FROM ( SELECT ＊ FROM tbl_A UNION SELECT ＊ FROM tbl_B ) TMP; 执行结果\n1 2 3 row_cnt ------- 3 如果集合运算符里不加上可选项ALL，那么重复行就会被排除掉。因此，如果表tbl_A和表tbl_B是相等的，排除掉重复行后，两个集合是完全重合的。\nkey列为B的一行数据不同：结果会变为4\ntbl_A tbl_B\n前面的SQL语句可以用于包含NULL数据的表，而且不需要指定列数、列名和数据类型等就能使用\n对于任意的表S，都有下面的公式成立。\n1 S UNION S = S 同一个集合无论加多少次结果都相同\n1 S UNION S UNION S UNION S …… UNION S = S UNION的这个优雅而强大的幂等性只适用于数学意义上的集合，对SQL中有重复数据的多重集合是不适用的。\n比较表和表：检查集合相等性之进阶篇 在集合论里，判定两个集合是否相等时\n(A ∩ B )且(A ∩ B) ⇔ (A = B) 如果集合A包含集合B，且集合B包含集合A，则集合A和集合B相等 (A ∪ B ) = (A ∩ B) ⇔ (A = B) 除了UNION之外，另一个具有幂等性的运算符就是INTERSECT。\n如果A = B，则(A UNION B) EXCEPT (A INTERSECT B)的结果是空集\n1 2 3 4 5 6 7 8 9 10 11 --两张表相等时返回“相等”，否则返回“不相等” SELECT CASE WHEN COUNT(＊) = 0 THEN ’相等’ ELSE’不相等’END AS result FROM ((SELECT ＊ FROM tbl_A UNION SELECT ＊ FROM tbl_B) EXCEPT (SELECT ＊ FROM tbl_A INTERSECT SELECT ＊ FROM tbl_B)) TMP; 这条SQL语句与上一部分中的SQL语句具有同样的优点，也不需要知道列名和列数，还可以用于包含NULL的表，而且，这个改进版连事先查询两张表的行数这种 准备工作也不需要了。\n虽然功能改进了，却也带来了一些缺陷。由于这里需要进行4次排序（3次集合运算加上1次DISTINCT），所以性能会有所下降（不过这条SQL语句也不需要频繁 执行，所以这点缺陷也不是不能容忍）。\n因为这里使用了INTERSECT和EXCEPT，所以目前这条SQL语句不能在MySQL里执行。\n把不同的行输出\n1 2 3 4 5 6 7 8 --用于比较表与表的diff (SELECT ＊ FROM tbl_A EXCEPT SELECT ＊ FROM tbl_B) UNION ALL (SELECT ＊ FROM tbl_B EXCEPT SELECT ＊ FROM tbl_A); 执行结果\n1 2 3 4 key col_1 col_2 col_3 --- ----- ----- ----- B 0 7 9 B 0 7 8 因为A－B和B－A之间不可能有交集，所以合并这两个结果时使用UNION ALL也没有关系。 在A和B一方包含另一方时，这条SQL语句也是成立的（这时A－B或者B－A有一个会是空集）。 需要注意的是，在SQL中，括号决定了运算的先后顺序，非常重要，如果去掉括号，结果就会不正确。 用差集实现关系除法运算 实现除法的方法\n嵌套使用NOT EXISTS。 使用HAVING子句转换成一对一关系。 把除法变成减法。 本节将介绍一下第三种方法。\n两张员工技术信息管理表\nSkills\nEmpSkills\n问题是，从表EmpSkills中找出精通表Skills中所有技术的员工。也就是说，答案是相田和神崎。\n1 2 3 4 5 6 7 8 9 10 --用求差集的方法进行关系除法运算（有余数） SELECT DISTINCT emp FROM EmpSkills ES1 WHERE NOT EXISTS (SELECT skill FROM Skills EXCEPT SELECT skill FROM EmpSkills ES2 WHERE ES1.emp = ES2.emp); 执行结果\n1 2 3 4 emp --- 相田 神崎 从需求的技术的集合中减去每个员工自己的技术的集合，如果结果是空集，则说明该员工具备所有的需求的技术，否则说明该员工不具备某些需求的技术。\n相田\n平井\n寻找相等的子集 供应商及其经营的零件的表\nSupParts\n我们需要求的是，经营的零件在种类数和种类上都完全相同的供应商组合。\nSQL并没有提供任何用于检查集合的包含关系或者相等性的谓词。IN谓词只能用来检查元素是否属于某个集合（∈），而不能检查集合是否是某个集合的子集 （∪）。\n首先，我们来生成供应商的全部组合。\n1 2 3 4 5 --生成供应商的全部组合 SELECT SP1.sup AS s1, SP2.sup AS s2 FROM SupParts SP1, SupParts SP2 WHERE SP1.sup \u0026lt; SP2.sup GROUP BY SP1.sup, SP2.sup; 执行结果\n1 2 3 4 5 6 7 8 9 10 s1 s2 ---- ---- A B A C A D ： ： ： D E E F 接下来，我们检查一下这些供应组合是否满足以下公式：[插图]且[插图]。这个公式等价于下面两个条件。\n条件1：两个供应商都经营同种类型的零件 条件2：两个供应商经营的零件种类数相同（即存在一一映射） 条件1只需要简单地按照“零件”列进行连接，而条件2需要用COUNT函数来描述。\n1 2 3 4 5 6 7 8 9 10 11 SELECT SP1.sup AS s1, SP2.sup AS s2 FROM SupParts SP1, SupParts SP2 WHERE SP1.sup \u0026lt; SP2.sup --生成供应商的全部组合 AND SP1.part = SP2.part --条件1：经营同种类型的零件 GROUP BY SP1.sup, SP2.sup HAVING COUNT(＊) = (SELECT COUNT(＊) --条件2：经营的零件种类数相同 FROM SupParts SP3 WHERE SP3.sup = SP1.sup) AND COUNT(＊) = (SELECT COUNT(＊) FROM SupParts SP4 WHERE SP4.sup = SP2.sup); 因为要比较任意两个供应商的零件, 所以用笛卡儿积\n执行结果\n1 2 3 4 s1 s2 ---- ---- A C B D 用于删除重复行的高效SQL 1-2节介绍的解法是使用关联子查询\n1 2 3 4 5 6 --删除重复行：使用关联子查询 DELETE FROM Products WHERE rowid \u0026lt; ( SELECT MAX(P2.rowid) FROM Products P2 WHERE Products.name = P2. name AND Products.price = P2.price ) ; 上面这条语句的思路是，按照“商品名，价格”的组合汇总后，求出每个组合的最大rowid，然后把其余的行都删除掉。\n假设表中加上了“rowid”列\n1 2 3 4 5 6 7 8 --用于删除重复行的高效SQL语句(1)：通过EXCEPT求补集 DELETE FROM Products WHERE rowid IN ( SELECT rowid --全部rowid FROM Products EXCEPT --减去 SELECT MAX(rowid) --要留下的rowid FROM Products GROUP BY name, price) ; 使用EXCEPT求补集的逻辑如下面的图表所示。\n把EXCEPT改写成NOT IN也是可以实现的。\n1 2 3 4 5 --删除重复行的高效SQL语句(2)：通过NOT IN求补集 DELETE FROM Products WHERE rowid NOT IN ( SELECT MAX(rowid) FROM Products GROUP BY name, price); ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-7-%E7%94%A8sql%E8%BF%9B%E8%A1%8C%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97/","summary":"导入篇：集合运算的几个注意事项 注意事项1: SQL能操作具有重复行的集合，可以通过可选项ALL来支持 一般的集合论不允许集合中存在重复元素 关系数","title":"1-7 用SQL进行集合运算"},{"content":"使用SQL进行行间比较时，发挥主要作用的技术是关联子查询，特别是与自连接相结合的“自关联子查询”\n增长、减少、维持现状 Sales\n年营业额的趋势\n使用SQL输出与上一年相比营业额是增加了还是减少了，抑或是没有变化。\n先试试求出“不变”这种情况\n1993 1995 用面向过程语言来解决，应该是下面这样的思路\n按年份递增的顺序排序。 循环地将每一行与前一行的“sale”列进行比较。 使用SQL时的解题思路需要用面向集合的方式进行思考\n在表Sales的基础上，再加一个存储了上一年数据的集合（S2） 1 2 3 4 5 6 7 --求与上一年营业额一样的年份(1)：使用关联子查询 SELECT year, sale FROM Sales S1 WHERE sale = (SELECT sale FROM Sales S2 WHERE S2.year = S1.year -1) ORDER BY year; 今年的sale==去年的sale\n执行结果\n1 2 3 4 year sale ----- ---- 1993 52 1995 50 使用自连接\n1 2 3 4 5 6 7 --求与上一年营业额一样的年份(2)：使用自连接 SELECT S1.year, S1.sale FROM Sales S1, Sales S2 WHERE S2.sale = S1.sale AND S2.year = S1.year -1 ORDER BY year; 接下来请将这个例子扩展一下，求出每一年相比上一年营业额是增加了还是减少了，抑或是没有变化。\n用列表展示与上一年的比较结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --求出是增长了还是减少了，抑或是维持现状(1)：使用关联子查询 SELECT S1.year, S1.sale, CASE WHEN sale = (SELECT sale FROM Sales S2 WHERE S2.year = S1.year -1) THEN\u0026#39;→\u0026#39;--持平 WHEN sale \u0026gt; (SELECT sale FROM Sales S2 WHERE S2.year = S1.year -1) THEN\u0026#39;↑\u0026#39;--增长 WHEN sale \u0026lt; (SELECT sale FROM Sales S2 WHERE S2.year = S1.year -1) THEN\u0026#39;↓\u0026#39;--减少 ELSE\u0026#39;—\u0026#39;END AS var FROM Sales S1 ORDER BY year; 执行结果\n1 2 3 4 5 6 7 8 9 10 year sale var ------ ---- --- 1990 50 — 1991 51 ↑ 1992 52 ↑ 1993 52 → 1994 50 ↓ 1995 50 → 1996 49 ↓ 1997 55 ↑ 用自连接来实现\n1 2 3 4 5 6 7 8 9 --求出是增长了还是减少了，抑或是维持现状(2)：使用自连接查询（最早的年份不会出现在结果里） SELECT S1.year, S1.sale, CASE WHEN S1.sale = S2.sale THEN\u0026#39;→\u0026#39; WHEN S1.sale \u0026gt; S2.sale THEN\u0026#39;↑\u0026#39; WHEN S1.sale \u0026lt; S2.sale THEN\u0026#39;↓\u0026#39; ELSE\u0026#39;—\u0026#39;END AS var FROM Sales S1, Sales S2 WHERE S2.year = S1.year -1 ORDER BY year; 结果没有1990年之前的数据\n时间轴有间断时：和过去最临近的时间进行比较 Sales2：有年份缺失\n“过去最临近的年份”需要满足下面两个条件\n与该年份相比是过去的年份。 在满足条件1的年份中，年份最早的一个。 1 2 3 4 5 6 7 8 9 10 11 --查询与过去最临近的年份营业额相同的年份 SELECT year, sale FROM Sales2 S1 WHERE sale = (SELECT sale FROM Sales2 S2 WHERE S2.year = (SELECT MAX(year) --条件2：在满足条件1的年份中，年份最早的一个 FROM Sales2 S3 WHERE S1.year \u0026gt; S3.year)) --条件1：与该年份相比是过去的年份 ORDER BY year; 执行结果\n1 2 3 4 year sale ----- ---- 1992 50 1997 55 查询与过去最临近的年份营业额相同的年份：同时使用自连接\n1 2 3 4 5 6 7 8 SELECT S1.year AS year, S1.year AS year FROM Sales2 S1, Sales2 S2 WHERE S1.sale = S2.sale AND S2.year = (SELECT MAX(year) FROM Sales2 S3 WHERE S1.year \u0026gt; S3.year) ORDER BY year; 查询每一年与过去最临近的年份之间的营业额之差\n1 2 3 4 5 6 7 8 9 10 11 --求每一年与过去最临近的年份之间的营业额之差(1)：结果里不包含最早的年份 SELECT S2.year AS pre_year, S1.year AS now_year, S2.sale AS pre_sale, S1.sale AS now_sale, S1.sale - S2.sale AS diff FROM Sales2 S1, Sales2 S2 WHERE S2.year = (SELECT MAX(year) FROM Sales2 S3 WHERE S1.year \u0026gt; S3.year) ORDER BY now_year; 执行结果\n1 2 3 4 5 6 pre_year now_year pre_sale now_sale diff -------- -------- -------- -------- ---- 1990 1992 50 50 0 --50-50 = 0 1992 1993 50 52 2 --52-50 = 2 1993 1994 52 55 3 --55-52 = 3 1994 1997 55 55 0 --55-55 = 0 如果想让结果里出现1990年的数据，可以使用“自外连接”来实现。\n1 2 3 4 5 6 7 8 9 --求每一年与过去最临近的年份之间的营业额之差(2)：使用自外连接。结果里包含最早的年份 SELECT S2.year AS pre_year, S1.year AS now_year, S2.sale AS pre_sale, S1.sale AS now_sale, S1.sale - S2.sale AS diff FROM Sales2 S1 LEFT OUTER JOIN Sales2 S2 ON S2.year = (SELECT MAX(year) FROM Sales2 S3 WHERE S1.year \u0026gt; S3.year) ORDER BY now_year; 执行结果\n1 2 3 4 5 6 7 pre_year now_year pre_sale now_sale diff -------- -------- -------- -------- ----- 1990 50 --1990年也会出现 1990 1992 50 50 0 1992 1993 50 52 2 1993 1994 52 55 3 1994 1997 55 55 0 移动累计值和移动平均值 Accounts\n求截止到那个时间点的账户余额。我们首先可以使用窗口函数来实现。\n1 2 3 4 --求累计值：使用窗口函数 SELECT prc_date, prc_amt, SUM(prc_amt) OVER (ORDER BY prc_date) AS onhand_amt FROM Accounts; 如果使用标准SQL-92，我们可以像下面这样写SQL语句。\n1 2 3 4 5 6 7 --求累计值：使用冯·诺依曼型递归集合 SELECT prc_date, A1.prc_amt, (SELECT SUM(prc_amt) FROM Accounts A2 WHERE A1.prc_date \u0026gt;= A2.prc_date ) AS onhand_amt FROM Accounts A1 ORDER BY prc_date; 执行结果\n1 2 3 4 5 6 7 8 9 prc_date prc_amt onhand_amt ---------- ------- ---------- 2006-10-26 12000 12000 --12000 2006-10-28 2500 14500 --12000 + 2500 2006-10-31 -15000 -500 --12000 + 2500 + (-15000) 2006-11-03 34000 33500 --12000 + 2500 + (-15000) + 34000 2006-11-04 -5000 28500 -- 下同 2006-11-06 7200 35700 -- ： 2006-11-11 11000 46700 -- ： 移动累计值。所谓移动，指的是将累计的数据行数固定（本例中为3行），一行一行地偏移，如下表所示。\n滑动窗口, 窗口大小为3行\n目标区间一行一行地偏移\n如果使用窗口函数，可以像下面这样通过指定ROWS关键字来指定数据行数。\n1 2 3 4 5 --求移动累计值(1)：使用窗口函数 SELECT prc_date, prc_amt, SUM(prc_amt) OVER (ORDER BY prc_date ROWS 2 PRECEDING) AS onhand_amt FROM Accounts; 如果使用关联子查询，我们还可以像下面这样用标量子查询来计算行数。\n1 2 3 4 5 6 7 8 9 10 11 12 --求移动累计值(2)：不满3行的时间区间也输出 SELECT prc_date, A1.prc_amt, (SELECT SUM(prc_amt) FROM Accounts A2 WHERE A1.prc_date \u0026gt;= A2.prc_date AND (SELECT COUNT(＊) FROM Accounts A3 WHERE A3.prc_date BETWEEN A2.prc_date AND A1.prc_date ) \u0026lt;= 3 ) AS mvg_sum FROM Accounts A1 ORDER BY prc_date; 执行结果\n1 2 3 4 5 6 7 8 9 prc_date prc_amt mvg_sum ---------- ------- ------- 2006-10-26 12000 12000 --12000 2006-10-28 2500 14500 --12000 + 2500 2006-10-31 -15000 -500 --12000 + 2500 + (-15000) 2006-11-03 34000 21500 --2500 + (-15000) + 34000 2006-11-04 -5000 14000 --下同 2006-11-06 7200 36200 -- ： 2006-11-11 11000 13200 -- ： 使用HAVING子句找出元素数刚好为3行的集合\n1 2 3 4 5 6 7 8 9 10 11 12 --移动累计值(3)：不满3行的区间按无效处理 SELECT prc_date, A1.prc_amt, (SELECT SUM(prc_amt) FROM Accounts A2 WHERE A1.prc_date \u0026gt;= A2.prc_date AND (SELECT COUNT(＊) FROM Accounts A3 WHERE A3.prc_date BETWEEN A2.prc_date AND A1.prc_date ) \u0026lt;= 3 HAVING COUNT(＊) =3) AS mvg_sum --不满3行数据的不显示 FROM Accounts A1 ORDER BY prc_date; 执行结果\n1 2 3 4 5 6 7 8 9 prc_date prc_amt mvg_sum ---------- ------- ------- 2006-10-26 12000 --不满3行数据，所以不显示 2006-10-28 2500 --不满3行数据，所以不显示 2006-10-31 -15000 -500 --凑够了3行，所以输出 2006-11-03 34000 21500 2006-11-04 -5000 14000 2006-11-06 7200 36200 2006-11-11 11000 13200 去掉聚合后的明细数据\n1 2 3 4 5 6 7 8 9 10 --去掉聚合并输出 SELECT A1.prc_date AS A1_date, A2.prc_date AS A2_date, A2.prc_amt AS amt FROM Accounts A1, Accounts A2 WHERE A1.prc_date \u0026gt;= A2.prc_date AND (SELECT COUNT(＊) FROM Accounts A3 WHERE A3.prc_date BETWEEN A2.prc_date AND A1.prc_date ) \u0026lt;= 3 ORDER BY A1_date, A2_date; 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 A1_date A2_date amt ---------- ---------- ------- 2006-10-26 2006-10-26 12000 2006-10-28 2006-10-26 12000 2006-10-28 2006-10-28 2500 2006-10-31 2006-10-26 12000 2006-10-31 2006-10-28 2500 …S1:-500 2006-10-31 2006-10-31 -15000 2006-11-03 2006-10-28 2500 2006-11-03 2006-10-31 -15000 …S2:21500 2006-11-03 2006-11-03 34000 2006-11-04 2006-10-31 -15000 2006-11-04 2006-11-03 34000 …S3:14000 2006-11-04 2006-11-04 -5000 2006-11-06 2006-11-03 34000 2006-11-06 2006-11-04 -5000 …S4:36200 2006-11-06 2006-11-06 7200 2006-11-11 2006-11-04 -5000 2006-11-11 2006-11-06 7200 …S5:13200 2006-11-11 2006-11-11 11000 存在部分交集的集合簇\n到目前为止，我们主要思考了累计值的求法，所以使用的是SUM函数。如果求移动平均值（moving average），那么将SUM函数改写成AVG函数就可以了。\n查询重叠的时间区间 Reservations\n日期的重叠类型\n1 2 3 4 5 6 7 8 9 10 11 12 --求重叠的住宿期间 SELECT reserver, start_date, end_date FROM Reservations R1 WHERE EXISTS (SELECT ＊ FROM Reservations R2 WHERE R1.reserver \u0026lt;\u0026gt; R2.reserver --与自己以外的客人进行比较 AND ( R1.start_date BETWEEN R2.start_date AND R2.end_date --条件(1)：自己的入住日期在他人的住宿期间内 OR R1.end_date BETWEEN R2.start_date AND R2.end_date)); --条件(2)：自己的离店日期在他人的住宿期间内 执行结果\n1 2 3 4 5 6 reserver start_date end_date -------- ---------- ---------- 荒木 2006-10-28 2006-10-31 堀 2006-10-31 2006-11-01 山本 2006-11-03 2006-11-04 内田 2006-11-03 2006-11-05 如果想求“与任何住宿期间都不重叠的日期”，我们只需要把EXISTS谓词改写成NOT EXISTS谓词就可以了。\n如果山本的入住日期不是11月3号，而是推迟了一天，即11月4号，那么查询结果里将不会出现内田。这是因为，内田的入住日期和离店日期都不再与任何人重叠， 于是条件(1)和条件(2)就都不满足了。换句话说，像内田这种自己的住宿期间完全包含了他人的住宿期间的情况，会被这条SQL语句排除掉。如果想把这样的住 宿期间也输出，我们需要追加条件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --升级版：把完全包含别人的住宿期间的情况也输出 SELECT reserver, start_date, end_date FROM Reservations R1 WHERE EXISTS (SELECT ＊ FROM Reservations R2 WHERE R1.reserver \u0026lt;\u0026gt; R2.reserver AND ( ( R1.start_date BETWEEN R2.start_date AND R2.end_date OR R1.end_date BETWEEN R2.start_date AND R2.end_date) OR ( R2.start_date BETWEEN R1.start_date AND R1.end_date AND R2.end_date BETWEEN R1.start_date AND R1.end_date))); ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-6-%E7%94%A8%E5%85%B3%E8%81%94%E5%AD%90%E6%9F%A5%E8%AF%A2%E6%AF%94%E8%BE%83%E8%A1%8C%E4%B8%8E%E8%A1%8C/","summary":"使用SQL进行行间比较时，发挥主要作用的技术是关联子查询，特别是与自连接相结合的“自关联子查询” 增长、减少、维持现状 Sales 年营业额的趋势 使用SQ","title":"1-6 用关联子查询比较行与行"},{"content":"本节将以集合论和群论中的“类”这一重要概念为核心，阐明GROUP BY和PARTITION BY的意义。\nSQL的语句中具有分组功能的是GROUP BY和PARTITION BY，它们都可以根据指定的列为表分组。区别仅仅在于，GROUP BY在分组之后会把每个分组聚合成一 行数据。\nTeams\n1 2 3 4 5 6 SELECT member, team, age , RANK() OVER(PARTITION BY team ORDER BY age DESC) rn, DENSE_RANK() OVER(PARTITION BY team ORDER BY age DESC) dense_rn, ROW_NUMBER() OVER(PARTITION BY team ORDER BY age DESC) row_num FROM Members ORDER BY team, rn; 执行结果\n分割后的子集\n重点关注一下划分出的子集\n它们全都是非空集合。 所有子集的并集等于划分之前的集合。 任何两个子集之间都没有交集。 对3取余给自然数集合N分类\n余0的类：M1 = {0, 3, 6, 9, …} 余1的类：M2 = {1, 4, 7, 10, …} 余2的类：M2 = {2, 5, 8, 11, …} 从类的第2个性质我们知道，这3个类涵盖了全部自然数。\nM1 + M2 + M3 = N MOD函数\n1 2 3 4 5 --对从1到10的整数以3为模求剩余类 SELECT MOD(num, 3) AS modulo, num FROM Natural ORDER BY modulo, num; 执行结果\n随机地将数据减为原来的五分之一\n1 2 3 4 5 6 7 8 9 10 11 12 --从原来的表中抽出（大约）五分之一行的数据 SELECT ＊ FROM SomeTbl WHERE MOD(seq, 5) = 0; --表中没有连续编号的列时，使用ROW_NUMBER函数就可以了 SELECT ＊ FROM (SELECT col, ROW_NUMBER() OVER(ORDER BY col) AS seq FROM SomeTbl) WHERE MOD(seq, 5) = 0; ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%96%E7%95%8C/2-5-group-by%E5%92%8Cpartition-by/","summary":"本节将以集合论和群论中的“类”这一重要概念为核心，阐明GROUP BY和PARTITION BY的意义。 SQL的语句中具有分组功能的是GROUP","title":"2-5 GROUP BY和PARTITION BY.md"},{"content":"用外连接进行行列转换(1)（行→列）：制作交叉表 员工学习过的培训课程的表Courses\n课程学习记录一览表（表头：课程；侧栏：员工姓名）\n用外连接的思路来思考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --水平展开求交叉表(1)：使用外连接 SELECT C0.name, CASE WHEN C1.name IS NOT NULL THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;SQL入门\u0026#34;, CASE WHEN C2.name IS NOT NULL THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;UNIX基础\u0026#34;, CASE WHEN C3.name IS NOT NULL THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;Java中级\u0026#34; FROM (SELECT DISTINCT name FROM Courses) C0 --这里的C0是侧栏 LEFT OUTER JOIN (SELECT name FROM Courses WHERE course = \u0026#39;SQL入门’) C1 ON C0.name = C1.name LEFT OUTER JOIN (SELECT name FROM Courses WHERE course = \u0026#39;UNIX基础’) C2 ON C0.name = C2.name LEFT OUTER JOIN (SELECT name FROM Courses WHERE course = \u0026#39;Java中级’) C3 ON C0.name = C3.name; C0：主表\nC1:SQL\nC2:UNIX\nC3:Java\n一般情况下，外连接都可以用标量子查询替代\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --水平展开(2)：使用标量子查询 SELECT C0.name, (SELECT \u0026#39;○\u0026#39; FROM Courses C1 WHERE course = \u0026#39;SQL入门’ AND C1.name = C0.name) AS \u0026#34;SQL入门\u0026#34;, (SELECT \u0026#39;○\u0026#39; FROM Courses C2 WHERE course = \u0026#39;UNIX基础’ AND C2.name = C0.name) AS \u0026#34;UNIX基础\u0026#34;, (SELECT \u0026#39;○\u0026#39; FROM Courses C3 WHERE course = \u0026#39;Java中级’ AND C3.name = C0.name) AS \u0026#34;Java中级\u0026#34; FROM (SELECT DISTINCT name FROM Courses) C0; --这里的C0是表侧栏 例如想加入第4列“PHP入门”时，只需要在SELECT子句的最后加上下面这条语句就可以了（如果采用前面的写法，则必需修改SELECT子句和FROM子句两个地方）。\n1 2 3 4 (SELECT \u0026#39;○\u0026#39; FROM Courses C4 WHERE course = \u0026#39;PHP入门’ AND C4.name = C0.name ) AS \u0026#34;PHP入门\u0026#34; 这种做法不仅利于应对需求变更，对于需要动态生成SQL的系统也是很有好处的。缺点是性能不太好，目前在SELECT子句中使用标量子查询（或者关联子查询） 的话，性能开销还是相当大的。\n嵌套使用CASE表达式\n1 2 3 4 5 6 7 8 9 10 --水平展开(3)：嵌套使用CASE表达式 SELECT name, CASE WHEN SUM(CASE WHEN course = \u0026#39;SQL入门’THEN 1 ELSE NULL END) = 1 THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;SQL入门\u0026#34;, CASE WHEN SUM(CASE WHEN course = \u0026#39;UNIX基础’THEN 1 ELSE NULL END) = 1 THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;UNIX基础\u0026#34;, CASE WHEN SUM(CASE WHEN course = \u0026#39;Java中级’THEN 1 ELSE NULL END) = 1 THEN\u0026#39;○\u0026#39;ELSE NULL END AS \u0026#34;Java中级\u0026#34; FROM Courses GROUP BY name; 用外连接进行行列转换(2)（列→行）：汇总重复项于一列 一张让数据库工程师想哭的表Personnel：员工子女信息\n使用UNION ALL来实现。\n1 2 3 4 5 6 --列数据转换成行数据：使用UNION ALL SELECT employee, child_1 AS child FROM Personnel UNION ALL SELECT employee, child_2 AS child FROM Personnel UNION ALL SELECT employee, child_3 AS child FROM Personnel; 执行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 employee child ---------- ------- 赤井 一郎 赤井 二郎 赤井 三郎 工藤 春子 工藤 夏子 工藤 铃木 夏子 铃木 铃木 吉田 吉田 吉田 希望得到员工子女列表\n来生成一个存储子女列表的视图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 CREATE VIEW Children(child) AS SELECT child_1 FROM Personnel UNION SELECT child_2 FROM Personnel UNION SELECT child_3 FROM Personnel; child ----- 一郎 二郎 三郎 春子 夏子 员工列表为主表进行外连接操作\n1 2 3 4 5 --获取员工子女列表的SQL语句（没有孩子的员工也要输出） SELECT EMP.employee, CHILDREN.child FROM Personnel EMP LEFT OUTER JOIN Children ON CHILDREN.child IN (EMP.child_1, EMP.child_2, EMP.child_3); 在交叉表里制作嵌套式表侧栏 年龄层级主表：TblAge\n性别主表：TblSex\n人口分布表：TblPop\n包含嵌套式表侧栏的统计表\n目标表的侧栏是年龄层级和性别，所以我们需要使用表TblAge和表TblSex作为主表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --使用外连接生成嵌套式表侧栏：错误的SQL语句 SELECT MASTER1.age_class AS age_class, MASTER2.sex_cd AS sex_cd, DATA.pop_tohoku AS pop_tohoku, DATA.pop_kanto AS pop_kanto FROM (SELECT age_class, sex_cd, SUM(CASE WHEN pref_name IN (’青森’, ’秋田’) THEN population ELSE NULL END) AS pop_tohoku, SUM(CASE WHEN pref_name IN (’东京’, ’千叶’) THEN population ELSE NULL END) AS pop_kanto FROM TblPop GROUP BY age_class, sex_cd) DATA RIGHT OUTER JOIN TblAge MASTER1--外连接1：和年龄层级主表进行外连接 ON MASTER1.age_class = DATA.age_class RIGHT OUTER JOIN TblSex MASTER2--外连接2：和性别主表进行外连接 ON MASTER2.sex_cd = DATA.sex_cd; 内部的sql先生成age_class, sex_cd, pop_tohoku, pop_kanto, 之后再关联名称\n执行结果\n1 2 3 4 5 6 age_class sex_cd pop_tohoku pop_kanto --------- ------ ---------- --------- 1 m 1100 1800 1 f 1300 2500 3 m 1000 3 f 1800 2100 结果里没有年龄层为2的原因是TblPop没有数据.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --停在第1个外连接处时：结果里包含年龄层级为2的数据 SELECT MASTER1.age_class AS age_class, DATA.sex_cd AS sex_cd, DATA.pop_tohoku AS pop_tohoku, DATA.pop_kanto AS pop_kanto FROM (SELECT age_class, sex_cd, SUM(CASE WHEN pref_name IN (’青森’, ’秋田’) THEN population ELSE NULL END) AS pop_tohoku, SUM(CASE WHEN pref_name IN (’东京’, ’千叶’) THEN population ELSE NULL END) AS pop_kanto FROM TblPop GROUP BY age_class, sex_cd) DATA RIGHT OUTER JOIN TblAge MASTER1 ON MASTER1.age_class = DATA.age_class; 执行结果\n1 2 3 4 5 6 7 age_class sex_cd pop_tohoku pop_kanto --------- ------ ---------- --------- 1 m 1100 1800 1 f 1300 2500 2 --存在年龄层级为2的数据 3 m 1000 3 f 1800 2100 原因也不难理解。表TblPop里本来就没有年龄层级为2的数据，自然也没有相应的性别信息m或f，于是“性别编号”列只能是NULL。因此与性别主表进行外连接时， 连接条件会变成ON MASTER2.sex_cd =NULL，结果是unknown\n如果不允许进行两次外连接，那么调整成一次就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --使用外连接生成嵌套式表侧栏：正确的SQL语句 SELECT MASTER.age_class AS age_class, MASTER.sex_cd AS sex_cd, DATA.pop_tohoku AS pop_tohoku, DATA.pop_kanto AS pop_kanto FROM (SELECT age_class, sex_cd FROM TblAge CROSS JOIN TblSex ) MASTER --使用交叉连接生成两张主表的笛卡儿积 LEFT OUTER JOIN (SELECT age_class, sex_cd, SUM(CASE WHEN pref_name IN (’青森’, ’秋田’) THEN population ELSE NULL END) AS pop_tohoku, SUM(CASE WHEN pref_name IN (’东京’, ’千叶’) THEN population ELSE NULL END) AS pop_kanto FROM TblPop GROUP BY age_class, sex_cd) DATA ON MASTER.age_class = DATA.age_class AND MASTER.sex_cd = DATA.sex_cd; 执行结果\n1 2 3 4 5 6 7 8 age_class sex_cd pop_tohoku pop_kanto --------- ------ ---------- --------- 1 m 1100 1800 1 f 1300 2500 2 m 2 f 3 m 1000 3 f 1800 2100 作为乘法运算的连接 交叉连接相当于乘法运算\nItems\nSalesHistory\n先使用这两张表生成一张统计表，以商品为单位汇总出各自的销量。我们期望的结果是像下面这样的。\n1 2 3 4 5 6 item_no total_qty ------- --------- 10 36 20 32 30 22 40 恐怕很多人会想到下面这种做法。\n1 2 3 4 5 6 7 --解答(1)：通过在连接前聚合来创建一对一的关系 SELECT I.item_no, SH.total_qty FROM Items I LEFT OUTER JOIN (SELECT item_no, SUM(quantity) AS total_qty FROM SalesHistory GROUP BY item_no) SH ON I.item_no = SH.item_no; 以商品编号为主键的临时视图（SH）\n1 2 3 4 5 --解答(2)：先进行一对多的连接再聚合 SELECT I.item_no, SUM(SH.quantity) AS total_qty FROM Items I LEFT OUTER JOIN SalesHistory SH ON I.item_no = SH.item_no 一对多的连接 GROUP BY I.item_no; 一对一或一对多关系的两个集合，在进行连接操作后行数不会（异常地）增加。\n全外连接 标准SQL里定义了外连接的三种类型\n左外连接（LEFT OUTER JOIN） 右外连接（RIGHT OUTER JOIN） 全外连接（FULL OUTER JOIN） 左外连接和右外连接没有功能上的区别。用作主表的表写在运算符左边时用左外连接，写在运算符右边时用右外连接。\n全外连接\nClass_A\nClass_B\n可以理解成“把两张表都当作主表来使用”的连接。\n1 2 3 4 5 6 --全外连接保留全部信息 SELECT COALESCE(A.id, B.id) AS id, A.name AS A_name, B.name AS B_name FROM Class_A A FULL OUTER JOIN Class_B B ON A.id = B.id; 执行结果\n1 2 3 4 5 6 id A_name B_name ---- ------ ------ 1 田中 田中 2 铃木 铃木 3 伊集院 4 西园寺 COALESCE是SQL的标准函数，可以接受多个参数，功能是返回第一个非NULL的参数。\n如果所用的数据库不支持全外连接，可以分别进行左外连接和右外连接，再把两个结果通过UNION合并起来，也能达到同样的目的\n1 2 3 4 5 6 7 8 9 --数据库不支持全外连接时的替代方案 SELECT A.id AS id, A.name, B.name FROM Class_A A LEFT OUTER JOIN Class_B B ON A.id = B.id UNION SELECT B.id AS id, A.name, B.name FROM Class_A A RIGHT OUTER JOIN Class_B B ON A.id = B.id; 我们还可以换个角度，把表连接看成集合运算。内连接相当于求集合的积（INTERSECT，也称交集），全外连接相当于求集合的和（UNION，也称并集）。\n内连接相当于求集合的积（INTERSECT）\n全外连接相当于求集合的和（UNION）\n用外连接进行集合运算 用外连接求差集：A－B 1 2 3 4 SELECT A.id AS id, A.name AS A_name FROM Class_A A LEFT OUTER JOIN Class_B B ON A.id = B.id WHERE B.name IS NULL; 执行结果\n1 2 3 id A_name ---- ------ 3 伊集院 用外连接求差集（A-B）\n用外连接求差集：B－A 1 2 3 4 SELECT B.id AS id, B.name AS B_name FROM Class_A A RIGHT OUTER JOIN Class_B B ON A.id = B.id WHERE A.name IS NULL; 执行结果\n1 2 3 id B_name ---- ------ 4 西园寺 用外连接求差集（B-A）\n用全外连接求异或集 SQL没有定义求异或集的运算符，如果用集合运算符，可以有两种方法。\n一种是(A UNION B) EXCEPT (A INTERSECT B) 另一种是(A EXCEPT B) UNION (B EXCEPT A)。两种方法都比较麻烦，性能开销也会增大。 1 2 3 4 5 6 SELECT COALESCE(A.id, B.id) AS id, COALESCE(A.name , B.name ) AS name FROM Class_A A FULL OUTER JOIN Class_B B ON A.id = B.id WHERE A.name IS NULL OR B.name IS NULL; 执行结果\n1 2 3 4 id name ---- ----- 3 伊集院 4 西园寺 用全外连接求异或集\n关系除法运算也可以通过外连接来实现。使用1-4节里的表Items和表ShopItems\n1 2 3 4 5 6 7 8 9 --用外连接进行关系除法运算：差集的应用 SELECT DISTINCT shop FROM ShopItems SI1 WHERE NOT EXISTS (SELECT I.item FROM Items I LEFT OUTER JOIN ShopItems SI2 ON I.item = SI2.item AND SI1.shop = SI2.shop WHERE SI2.item IS NULL) ; 执行结果\n1 2 3 4 shop ---- 仙台 东京 本节小结 SQL不是用来生成报表的语言，所以不建议用它来进行格式转换。 必要时考虑用外连接或CASE表达式来解决问题。 生成嵌套式表侧栏时，如果先生成主表的笛卡儿积再进行连接，很容易就可以完成。 从行数来看，表连接可以看成乘法。因此，当表之间是一对多的关系时，连接后行数不会增加。 外连接的思想和集合运算很像，使用外连接可以实现各种集合运算。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-5-%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%94%A8%E6%B3%95/","summary":"用外连接进行行列转换(1)（行→列）：制作交叉表 员工学习过的培训课程的表Courses 课程学习记录一览表（表头：课程；侧栏：员工姓名） 用外连","title":"1-5 外连接的用法"},{"content":"sql是面向集合的语言\n寻找缺失的编号 SeqTbl\n用面向过程语言查询缺失的编号的过程\n对“连续编号”列按升序或者降序进行排序。 循环比较每一行和下一行的编号。 将表整体看作一个集合\n1 2 3 4 -- 如果有查询结果，说明存在缺失的编号 SELECT’存在缺失的编号’AS gap FROM SeqTbl HAVING COUNT(＊) \u0026lt;\u0026gt; MAX(seq); 执行结果\n1 2 3 gap ---------- \u0026#39;存在缺失的编号’ 上面的SQL语句里没有GROUP BY子句，此时整张表会被聚合为一行。这种情况下HAVING子句也是可以使用的。\n再来查询一下缺失编号的最小值。\n1 2 3 4 -- 查询缺失编号的最小值 SELECT MIN(seq + 1) AS gap FROM SeqTbl WHERE (seq+ 1) NOT IN ( SELECT seq FROM SeqTbl); 执行结果\n1 2 3 gap --- 4 上面展示了通过SQL语句查询缺失编号的最基本的思路，然而这个查询还不够周全，并不能涵盖所有情况。例如，如果表SeqTbl里没有编号1，那么缺失编号的 最小值应该是1，但是这两条SQL语句都不能得出正确的结果\n用HAVING子句进行子查询：求众数 Graduates（毕业生表）\n从这个例子可以看出，简单地求平均值有一个缺点，那就是很容易受到离群值（outlier）的影响。这种时候就必须使用更能准确反映出群体趋势的指标—— 众数（mode）就是其中之一。\n1 2 3 4 5 6 7 --求众数的SQL语句(1)：使用谓词 SELECT income, COUNT(＊) AS cnt FROM Graduates GROUP BY income HAVING COUNT(＊) \u0026gt;= ALL ( SELECT COUNT(＊) FROM Graduates GROUP BY income); 执行结果\n1 2 3 4 income cnt ------ --- 10000 3 20000 3 1-3节提到过ALL谓 词用于NULL或空集时会出现问题，可以用极值函数来代替。\n1 2 3 4 5 6 7 8 --求众数的SQL语句(2)：使用极值函数 SELECT income, COUNT(＊) AS cnt FROM Graduates GROUP BY income HAVING COUNT(＊) \u0026gt;= ( SELECT MAX(cnt) FROM ( SELECT COUNT(＊) AS cnt FROM Graduates GROUP BY income) TMP ) ; 用HAVING子句进行自连接：求中位数 用面向集合的方式，来查询位于集合正中间的元素。\n将集合里的元素按照大小分为上半部分和下半部分两个子集，同时让这2个子集共同拥有集合正中间的元素。 中位数求法的思路\n1 2 3 4 5 6 7 8 9 10 11 12 --求中位数的SQL语句：在HAVING子句中使用非等值自连接 SELECT AVG(DISTINCT income) FROM (SELECT T1.income FROM Graduates T1, Graduates T2 GROUP BY T1.income --S1的条件 HAVING SUM(CASE WHEN T2.income \u0026gt;= T1.income THEN 1 ELSE 0 END) \u0026gt;= COUNT(＊) / 2 --S2的条件 AND SUM(CASE WHEN T2.income \u0026lt;= T1.income THEN 1 ELSE 0 END) \u0026gt;= COUNT(＊) / 2 ) TMP; 查询不包含NULL的集合 count(*)和count(column)的区别\n第一个是性能上的区别；第二个是COUNT（＊）可以用于NULL，而COUNT（列名）与其他聚合函数一样，要先排除掉NULL的行再进行统计。 第二个区别也可以这么理解：COUNT（＊）查询的是所有行的数目，而COUNT（列名）查询的则不一定是。 一张全是NULL的表NullTbl\n1 2 3 --在对包含NULL的列使用时，COUNT（＊）和COUNT（列名）的查询结果是不同的 SELECT COUNT(＊), COUNT(col_1) FROM NullTbl; 执行结果\n1 2 3 count(＊) count(col_1) -------- ------------ 3 0 Students\n所有学生都提交了报告的学院有哪些\n1 2 3 4 5 --查询“提交日期”列内不包含NULL的学院(1)：使用COUNT函数 SELECT dpt FROM Students GROUP BY dpt HAVING COUNT(＊) = COUNT(sbmt_date); 执行结果\n1 2 3 4 dpt -------- 理学院 经济学院 使用CASE表达式也可以实现同样的功能\n1 2 3 4 5 6 7 --查询“提交日期”列内不包含NULL的学院(2)：使用CASE表达式 SELECT dpt FROM Students GROUP BY dpt HAVING COUNT(＊) = SUM(CASE WHEN sbmt_date IS NOT NULL THEN 1 ELSE 0 END); 用关系除法运算进行购物篮分析 我们假设有这样两张表：全国连锁折扣店的商品表Items，以及各个店铺的库存管理表ShopItems。\nItems\nShopItems\n查询囊括了表Items中所有商品的店铺\n1 2 3 4 --查询啤酒、纸尿裤和自行车同时在库的店铺：错误的SQL语句 SELECT DISTINCT shop FROM ShopItems WHERE item IN (SELECT item FROM Items); 执行结果\n1 2 3 4 5 shop ---- 仙台 东京 大阪 1 2 3 4 5 6 --查询啤酒、纸尿裤和自行车同时在库的店铺：正确的SQL语句 SELECT SI.shop FROM ShopItems SI, Items I WHERE SI.item = I.item GROUP BY SI.shop HAVING COUNT(SI.item) = (SELECT COUNT(item) FROM Items); 执行结果\n1 2 3 4 shop ---- 仙台 东京 请注意，如果把HAVING子句改成HAVING COUNT(SI.item)=COUNT(I.item)，结果就不对了。\n1 2 3 4 5 -- COUNT(I.item)的值已经不一定是3了 SELECT SI.shop, COUNT(SI.item), COUNT(I.item) FROM ShopItems SI, Items I WHERE SI.item = I.item GROUP BY SI.shop; 执行结果\n1 2 3 4 5 shop COUNT(SI.item) COUNT(I.item) ----- --------------- -------------- 仙台 3 3 东京 3 3 大阪 2 2 如何排除掉仙台店（仙台店的仓库中存在“窗帘”，但商品表里没有“窗帘”），让结果里只出现东京店。\n这类问题被称为“精确关系除法”（exact relational division），即只选择没有剩余商品的店铺 与此相对，前一个问题被称为“带余除法”（division with a remainder）。 1 2 3 4 5 6 7 --精确关系除法运算：使用外连接和COUNT函数 SELECT SI.shop FROM ShopItems SI LEFT OUTER JOIN Items I ON SI.item=I.item GROUP BY SI.shop HAVING COUNT(SI.item) = (SELECT COUNT(item) FROM Items) --条件1 AND COUNT(I.item) = (SELECT COUNT(item) FROM Items); --条件2 执行结果\n1 2 3 shop ---- 东京 表ShopItems和表Items外连接后的结果\n一般来说，使用外连接时，大多会用商品表Items作为主表进行外连接操作，而这里颠倒了一下主从关系，表使用ShopItems作为了主表，这一点比较有趣。\n本节小结 表不是文件，记录也没有顺序，所以SQL不进行排序。 SQL不是面向过程语言，没有循环、条件分支、赋值操作。 SQL通过不断生成子集来求得目标集合。SQL不像面向过程语言那样通过画流程图来思考问题，而是通过画集合的关系图来思考。 GROUP BY子句可以用来生成子集。 WHERE子句用来调查集合元素的性质，而HAVING子句用来调查集合本身的性质。 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-4-having%E5%AD%90%E5%8F%A5%E7%9A%84%E5%8A%9B%E9%87%8F/","summary":"sql是面向集合的语言 寻找缺失的编号 SeqTbl 用面向过程语言查询缺失的编号的过程 对“连续编号”列按升序或者降序进行排序。 循环比较每一行和下一行的编号","title":"1-4 HAVING子句的力量"},{"content":"7.1 定价能力是衡量品牌力的重要标准 既然不赚钱，为何商家要花大力气宣传、促销、做销售额、发战报呢？\n答案是：“卖货”和“卖价格带”是品牌经营的两大目标。卖货即提高销量获取利润，卖价格带即维持知名度和品牌价格带。品牌商家在大促中行动的主要目的是提 升知名度和价格带，更多是营销维度的考量，而非获利行为。\n卖货赚钱关乎品牌的生存和短期业绩表现，保持一定的销量和规模是品牌的生存基础。 品牌认知建立在销售规模之上，若商家达不到一定的规模，就很难被称为“品牌”。 而卖价格带则关乎品牌商长期的定位、形象与价值。 比如我们常见的许多消费品品牌，毛利率可高达40%以上，它们为什么不降价20%～30%，在保证毛利为正的前提下薄利多销、抢占更多市场？\n因为价格带一旦降下去，就很难重新抬起来了。降价在短期能带来丰厚的业绩，但长期来看，却是一种毁灭品牌价值的行为。 这也是为何有一部分大品牌会抵制新兴渠道。部分新兴渠道（如拼多多、早期的淘宝等）以低价位为核心竞争力，并没有渠道管控、帮助大品牌稳住价格带的 能力。 品牌的定价能力有时体现在产品售价的稳定性上\n定价能力强的品牌，其产品的价格一般比较稳定，很少打折，打折幅度也不大； 反之，若产品上市一段时间后总通过大幅打折出货，则体现出产品定价能力不足。 图7-1 部分国内外美妆护肤品牌大单品2020年11～12月天猫旗舰店价格\n任何一个优秀的品牌，都应该具备定价能力（不打折）、溢价能力、涨价能力。我们可以通过品牌对于价格的掌控能力找到品牌力出众的优秀企业。\n7.2 品牌分级体系：从1.0到4.0，提价能力逐级增强 不同消费品品牌的经营壁垒和品牌价值天差地别。其中，溢价能力是一个非常重要的指标，它能够直接反映品牌的质地以及未来发展潜力。\n根据定价能力的不同，消费品品牌可分为1.0到4.0四个阶段：\n品牌1.0是“品牌即认知”，代表品牌提供了基础的质量保障，并做到了规模化生产； 品牌2.0是“品牌即优选”，代表品牌具备基础的溢价能力； 品牌3.0是“品牌即品类”，行业大部分自然流量导向少数品牌； 品牌4.0是“品牌即身份”，这类品牌拥有极高的溢价，其定价几乎完全脱离成本。 品牌1.0对应第4章中提到的省心型品牌，品牌2.0到品牌4.0对应悦己型品牌。省心型品牌面向只想快速找到具备基础质量保障且价格公道的商品的消费者，而 悦己型品牌则面向以购物为乐趣，期望买到高品质商品，或期望彰显身份与格调的消费者。\n品牌1.0：品牌即认知 我们生活中接触的大多数大众消费品品牌，属于品牌1.0的范畴。这类品牌的核心价值是组织生产，实现规模化降本增效，并且保证产品质量合格。这些品牌的存 在大幅提升了消费品产业的运转效率，并提供了质量背书，降低了消费者的搜索成本。\n怡宝 优衣库 从如此多的工厂中采购商品，同时保证各个型号和尺码的产品的质量与库存，这体现了优衣库作为一个省心型品牌所起到的组织生产功能。\n表7-1 优衣库部分核心代工厂\n优衣库在国内市场取得成功的原因包括：\n拥有领先的分销渠道 一方面是门店数量, 767家 另一方面是线上线下渠道的协同优衣库提供无缝的购物体验，其天猫旗舰店支持下单后到附近门店自提，这极大满足了顾客对即时性的需求。 品质稳定、性价比高 接地气，快反（快速反应），对本土文化理解度高 能做到快反的原因则是强大的供应链管理和库存管控能力。 品牌2.0：品牌即优选 这个层级以上的品牌，都具备较为突出的溢价能力。换句话说，“是否具备溢价能力”这一要素决定了品牌能否进入2.0以上的层级。当然，品牌在具备一定销量 和认知的基础上产生的溢价才有意义。如果一个品牌没有达到一定的规模，那就连品牌1.0都算不上。\n品牌溢价不会凭空产生，大多数产品产生溢价的原因可归结为：①文化属性认同感；②功能性区隔差异性。\n文化属性认同感来自品牌，每个品牌背后都代表一种精神，比如“Just do it”“Nothing is impossible”“一切皆有可能”“永不止步”等，对于精神文化 的认可会转为对于品牌的忠诚度。 功能性区隔差异性来自产品本身，运动鞋可以分成篮球鞋、跑步鞋等多个品种，每个品种下又有多种细分，比如跑步鞋分成缓冲、支撑、控制等条线。这样的 细分带来了功能性区隔差异性，不同的人、不同的用途，适用不同的产品。 图7-2 溢价来自文化属性认同感和功能性区隔差异性\n跻身2.0阶段的一个国货品牌是安踏旗下的FILA。\n图7-3 FILA、耐克、阿迪达斯运动产品价格带对比（2021年7月）\n品牌3.0：品牌即品类 如何简单地理解“品牌即品类”？\n一想到某些细分品类、特定功能，就自然而然地想到某个品牌。比如很多消费者提起羽绒服就想到波司登，提起智能手机就想到苹果和华为，提起电动车就想到 特斯拉，这都是品牌3.0的体现。这类品牌的特点是与品类强绑定，并且具备较高的溢价。\n有一些品牌有很高的市占率，却没有涨价空间，它们并不属于3.0品牌，可以称其为“伪3.0品牌”。事实上，这类品牌很容易陷入“价格涨不动、市占率已经饱和、 行业规模没有扩张空间”的增长瓶颈。区分伪3.0品牌和真3.0品牌的核心要素，是品牌的涨价能力。\n2020年，我国功能性护肤品龙头品牌薇诺娜牢牢占据国内功能性护肤品市场份额第一的地位，其品牌在一定程度上代表了针对敏感肌的功能性护肤品品类。\n图7-4 薇诺娜在功能性护肤品中的市占率逐年提升\n薇诺娜的一部分产品是先由合作医院的医生提出临床需求，之后联合当地高校共同研发的。新品诞生后，由合作医院用于临床辅助治疗，结合临床的良好反馈将 产品推向市场。\n图7-5 薇诺娜的“产学研”合作机制\n总而言之，品牌3.0的核心在于通过与品类实现强绑定，得到较高的溢价能力。我们可以在日常生活中留意这类“提起品类想到品牌”的现象，在这类品牌里不乏 具备独特壁垒和较强涨价能力的重要标的。\n品牌4.0：品牌即身份 “品牌即身份”指的是拥有或使用某个品牌的商品，就能够拥有某种身份。此类现象常见于奢侈品品牌以及某些品牌的限量产品\n品牌要达到4.0阶段，文化属性认同感可能会比功能性区隔差异性更为重要。\n拥有极高溢价的品类往往集合了社交属性和彰显格调两个因素，因为具备这两个因素的产品更容易形成文化属性认同感。 当然大多数4.0品牌仍然拥有功能性区隔差异性。如很多奢侈品品牌都有其精通的领域： 爱马仕之于皮具，劳力士之于手表，巴宝莉之于大衣，等等。 功能性区隔差异性一定程度上也是品牌打造文化属性认同感的一个基础条件。 4.0品牌的产品通常会形成稳定交易的二级市场。\n对于一般的消费品，二手商品的价格相比原价会有明显折让，且流动性不佳； 但某些强势品牌的产品却能够产生广泛流通的二级市场（即玩家间相互交易），甚至产生做市商（比如二手奢侈品专卖店）。这意味着这些产品已经具备 “通货”属性，具备极强的价格认知。随着时间的推移，一部分产品在二级市场上的流通价格甚至可能超过产品的原始定价。我们将这类现象称为“品牌4.0+”。 7.3 案例一：直播电商带来了什么 直播电商的规模有多大？根据艾瑞咨询的预测，2021年我国直播电商市场规模约为2.27万亿元（见图7-7），在整个线上消费市场中的渗透率约为15.5%。这意 味着每6～7个包裹中，可能就有一个来自直播电商渠道。\n图7-7 中国直播电商市场规模\n很多人会认为直播电商的火热仅仅是因为直播平台的流量大，这是一个非常典型的误解。在分析直播电商的时候，我们要放下“销售量=流量×转化率”的思路。这 个思路过于简单，会让我们忽略很多重要的问题，进而得到错误的结论。在商品销售的商业模型中，曝光次数、转化率、价格、毛利率、复购次数都是关键的指 标，只关注流量（曝光次数）而忽略了价格和复购，是常见的误区。定价格带、通过品牌宣传带来自然流量乃至复购，都是品牌经营中的重要环节。商家对价格 带和复购的追求，会在相当大的程度上影响其商业行为。事实上，很多直播电商的商家不赚钱（甚至亏本），他们参与直播电商的原因是希望提升知名度，并最 终通过复购和自然流量赚钱。\n图7-8 2020～2021年各大主要直播电商品平台GMV\n淘宝直播的特点是头部主播占据极高的话语权，品牌商家几乎难以通过头部主播赚钱。 快手主播的头部化也比较明显，主播通过私域流量销售亲民品牌或产业带品牌； 抖音的特色则在于品牌自播，品牌通过自播实现营销和变现是相对比较容易的，没有特别突出的头部主播。 淘宝头部主播带货：商家核心诉求是品宣而非盈利 为什么这些主播能够拥有如此之强的议价能力？\n播之间“强者愈强”的马太效应循环就此形成：主播成交额高—议价能力强—品牌给的折扣低—成交额更高。 图7-9 2021年9月淘宝直播平台前10名主播带货GMV\n商家请淘宝头部主播带货很难直接盈利，一方面是因为头部主播要求的折扣力度大，另一方面是这些头部主播通常会向品牌方收取高额的佣金。\n头部主播通常通过“坑位费+佣金”的形式向品牌商家收费。\n坑位费是只要开播上架了商品就会收取的费用，而不论实际成交额的多少； 佣金则按实际成交额的百分比来收取。 那么品牌商家为何还要让主播来帮他们带货？主要还是品宣的考量。\n淘宝店铺自播：主要作用是转化而非引流 图7-10 在截至2021年9月的12个月内，淘宝直播的商家自播占比达60%\n引流和转化有什么区别？核心在于是否能够让用户产生计划以外的选择。\n比如某消费者计划在A和B两个品牌的产品中购买其一，最终不论买了A还是B，都属于这两个品牌的“转化”。但若是发现并购买了C，就相当于品牌C做了一次 成功的“引流”。 一个渠道是否有这样的引流功能，会直接决定渠道的获利空间，引流功能越强的渠道，通常盈利能力也越强。 淘宝的店铺自播如何促进转化？\n第一，直播能比图文带来更好的展示效果，从而促进用户下单。 第二，直播互动能起到一部分“客服”的职能，效果也优于传统的客服。 第三，有的店家会在直播间中发放专属的直播优惠，这也能起到促进转化的效果。 淘宝店铺自播和抖音、快手自播的最大区别在于引流的能力。\n大多数用户点进自播间之前就应进入了相应品牌或店铺的首页，这意味着其实淘宝的店铺自播引流能力并不强。 而抖音、快手的店铺自播则是用户“刷”出来的，用户在进入直播间之前可能并不认识这些品牌或店家，这类店铺自播能帮助商家起到较强的引流效果。 快手直播：头部主播帮助亲民品牌和产业带品牌卖货 在前文中，我们就提到了消费产业链有三个主要环节：供应链（提供商品）、品牌（提供认知和信任）、渠道（提供流通和触达）。\n快手直播的特殊之处在于：快手头部主播充当的是品牌环节 而淘宝、抖音等平台上的主播主要属于渠道环节。 首先，快手是一个以主播带货为主、主播头部化程度较高的平台。\n快手的调性和文化是比较独特的，对比过快手、抖音、淘宝直播的人会很容易发现，快手直播的内容给人的感觉是很不一样的。很多商家难以把握快手的口味 和调性，很难做好自播，他们只能依靠达人带货来进驻快手。 快手的主播集中程度似乎远低于淘宝平台，但我们要注意，其中很多大主播都属于“辛巴家族”, 如果把“辛巴家族”所有主播的成交额都算到一起，那么快手带 货主播的集中程度非常之高。 图7-11 2021年9月快手直播平台前10名主播带货GMV\n其次，快手直播下单用户的流量来源主要是私域流量，这和淘宝、抖音等平台有很大不同。如果消费者下单之前就已经是主播的粉丝了，那就将其归为私域流量， 否则是公域流量。\n快手直播达人的下单客户大多是其粉丝，这是由：\n①快手主播充当了“品牌”这件事情导致的，消费者一般都会是其信任的主播的粉丝； ②快手平台的页面设计导致的，在快手App里通过“关注”页面进入直播间是最方便的方法，而在用户离开某个直播间时，系统也会弹出窗口提醒用户关注主播， 这样的设计增加了用户关注他们感兴趣的主播的概率。 最后，快手头部主播销售的很多商品是亲民品牌的商品，或产业带品牌的商品。\n对于很多产业带品牌而言，其在品牌认知上是有所欠缺的。这些品牌的产品可能拥有不错的质量，但由于缺乏品牌认知，很多消费者没有足够的信心去购买这 些商品。快手的主播在直播过程中充当了“品牌”，用其自身的名誉为这些产品提供了背书。 这个环境并不适合大多数品牌\n一是因为其去品牌化的平台调性 二是因为品牌自身也很难在这样的生态中展开自播带货（公域流量池小，难以和主播私域流量竞争）。 抖音直播：品牌化+去中心化的直播平台，是品牌崛起的好土壤 抖音是三大直播电商平台中中心化程度最低的。平衡的主播生态使得每个主播相对品牌的议价权都比较适中，因此品牌商家找抖音主播带货的费用率显著低于淘 宝电商的头部主播，这样就有了更好的盈利能力。\n图7-12 2021年9月抖音直播平台前10名主播带货GMV\n店铺自播是抖音平台的亮点所在，也是抖音平台的重点发展方向。\n对于平台而言，直接向商家收费、绕开达人这个中间环节有利于提升盈利能力； 对于商家而言，摆脱达人意味着其将能够完全拥有直播带来的流量，并可以随心所欲地定制直播内容，甚至可起到提升品牌形象的效果。 未来抖音平台内的自播不会完全取代达人播，达人播的趣味性一般强于自播，达人播的存在有助于平衡平台的内容生态和商业生态，是连接内容与商业的一座桥 梁。\n图7-13 抖音自播与达人播的市场份额（以GMV计）\n抖音直播的环境使其成为上佳的品牌化舞台。\n第一，品牌有直接盈利的可能，这一方面源于达人播较为平衡的费率，另一方面源于自播生态的完善。 第二，在抖音开设自播间并实现冷启动并不难，抖音有公平高效的付费推广系统，同时拥有较为完善的代运营体系（品牌商家很难独自完成直播的相关事务， 很多工作需要在代运营商的帮助之下完成）。 第三，抖音具备品牌化的心智，平台的调性和主要受众适合大多数的知名品牌。 同样作为品牌化的直播电商平台，抖音和淘宝的区别在何处？本质上在于用户的目的性。\n淘宝的用户通常带有较强的购物目的，他们上淘宝的目的就是买东西，所以能够接受头部主播“报价格”的直播方式； 抖音更注重内容，很多用户上抖音的最初目的是找乐子，因此若想要获得成交，销售的内容就要足够吸引人。 直播电商的增长驱动力之一：用户数量的增长 直播电商用户数还有很大的提升空间\n图7-14 2021年6月中国网民、直播电商用户数结构\n直播电商的增长驱动力之二：核心品类渗透率提升 直播电商聚焦的品类有如下特点：①毛利润高；②需要一定的展示效果。这些品类包括服装、化妆品、珠宝、零食酒水等。只有毛利润足够高的产品，才能支撑 得起直播带来的相关费用。而需要展示效果的产品，更能够发挥视频直播在商品展示效果上的优势。\n图7-15 2021年四季度抖音品类结构（按成交额）\n总之，从品类的视角看，直播电商的增长逻辑在于提升了线上购物的体验感，从而拿到了一些本来属于线下渠道的市场份额。从这个角度看，随着人们对直播电 商接受程度的提升和用户习惯的养成，未来直播电商的市场还有很大的增长空间。\n拆解各方诉求，分析渠道影响，发掘投资机会 对新渠道的分析，最重要的是对各个参与方的分析。了解各个参与方之间的联系与诉求，是理解渠道、发现投资机会的关键所在。\n红人环节：很难产生明显的机会 主播环节主要包括红人本身、MCN机构、相关中介机构等。\nMCN机构真的能成为好的长期投资标的吗？恐怕很难。\n直播电商行业主播的马太效应是很强的，主播的体量和议价权呈两极分化的态势。 MCN机构基本可以分为两类：\n一类是绑定了头部主播的MCN机构，另一类是服务中腰部主播的MCN机构。 前者在头部主播之下，基本上没有像样的话语权；而后者手中的主播在行业中的地位不强，因此也不具备显著的投资价值，且如果后者手中的中小主播长成了 头部主播，MCN机构将很可能失去话语权，沦为头部主播的依附。 平台与产业工厂环节：选择有限 平台有可能成为非常好的投资方向，但主要问题在于选择有限。\n2021年直播电商行业的三巨头是淘宝、快手、抖音。\n对于阿里巴巴，看好淘宝直播的发展不构成投资阿里巴巴的直接理由，淘宝直播在阿里巴巴集团中占据的体量比较小，远不如天猫的分量大。此外，淘宝头部 主播话语权过强、经营生态一般的事实，也给淘宝直播的投资价值打了折扣。 对于快手而言，中国强大的消费品供应链是其稳定发展的坚实后盾，而足够接地气的平台氛围也使其成为足够独特的资产。但商业化内容与平台体验之间的天 然冲突如何处理，以及头部主播群体如何提高抽佣率，都会是未来的重要问题。 字节跳动的抖音各方面都非常优秀，可惜并没有上市。 快手直播电商的崛起给优秀的产业带工厂带来了重要的发展机遇，不过这里也很难产生投资机会。一般而言，找主播带货的企业大多为中小型的产业工厂，绝大 部分没有上市；而成功上市的头部代工企业（如申洲国际、华利集团等）都绑定了稳定的大客户，它们一般不会把自己的产品放到快手上销售，因此不构成直播 电商的直接受益对象。\n品牌：重要的投资机会所在 总之，国产品牌通过各方面竞争实力的逐渐释放逐渐蚕食国外传统大牌的份额，将会是未来数年服装、化妆品等消费品领域的发展大趋势，而像直播电商这样的 新兴渠道，将会成为这一趋势的重要加速器。未来，我们不但要关注国产品牌在各个渠道，尤其是直播电商这样的新兴渠道中的发展情况，也要关注其他重要渠 道变革带来的品牌投资机会。\n7.4 案例二：为何拼多多难跑出新品牌 拼多多还是一个社交电商吗 从商业模式、运营模式、流量分发、营销工具、品类结构等方面来看，拼多多都在向淘系电商靠近。可以认为，拼多多并没有成为多年前人们想象的“社交电商”， 而是逐渐变成了另一个“货架电商”。\n什么是社交电商，什么是货架电商 零售生意可以简单划归为流量获取和转化、成交履约、形成复购三个环节\n社交电商中的“社交”二字主要体现在流量获取和转化上，即通过熟人之间的分享介绍促成交易。 货架电商会把商品摆在各种展示位, 在购物决策的过程中，货架电商的消费者一般较少依赖他们的社交关系。 淘宝、天猫、京东显然不属于社交电商，我们一般称之为“货架电商”或“搜索电商”。 拼多多平台内的流量结构与淘宝越来越相似，以搜索为主导 一般判断电商平台流量来源的方式是看用户如何进入“商品详情”页面。\n与其说拼多多是个社交电商，不如说它也是一个搜索电商。\n图7-18 2020年拼多多流量结构\n拼多多的流量结构与淘宝已经非常相似，两个平台自然流量的前两大来源都是搜索和推荐。\n图7-19 2018～2020年淘宝流量结构\n从流量结构上看，拼多多和淘宝相比，最大的差异在于活动流量。\n淘宝和拼多多拥有相似的运营逻辑 淘宝和拼多多在运营上的相似之处在于：\n第一，二者都看重商品的展现排位，都采用通过付费流量提权重、通过免费流量以及复购盈利的模式； 第二，二者的投放工具大体上比较相似； 第三，付费流量投放的计价方式比较相似。 在中心化的电商平台里，商品在搜索和推荐结果中的排位越靠前，曝光量就越高。\n图7-20 电商平台中的商品展现排位影响其点击率\n自然流量（免费展位）的排位主要由“期望展现收益”决定。\n期望收益可以是GMV、广告收入（针对付费流量），也可以是顾客停留时间、访问深度、购物体验等。 在不同的阶段，平台会根据自身需求动态调整各项指标的权重，并把“期望展现收益”高的商品放在前排增加展示，从而实现平台综合效用的最大化。 图7-21 做投放是在淘宝、拼多多这类平台上经营的必选项\n投放的核心目的是改善权重，进而使自然流量占比提升，最终通过免费的自然流量获利。\n以手机搜索为例，在淘宝和拼多多搜索结果中，一般每5～7个会有一个广告，这意味着投放流量占比最高仅为20%，可见自然流量带来的销售额总量是远远高 于付费流量的。 因此，对于淘宝和拼多多而言，其运营投放的共性是：通过付费投放积攒数据，提升商品在自然展位中的排位，最后通过自然流量的提升赚钱。\n拼多多和淘宝的投放工具比较类似 拼多多主要的底层投放工具包括多多搜索、多多场景、多多进宝、明星店铺、合约推广等。\n多多搜索提供付费搜索信息服务，和淘系的直通车较为相似； 多多场景相当于淘系的超级推荐，对应信息流推荐位中的流量； 多多进宝相当于淘宝客，是达人使用平台外链分享带来的流量； 淘宝和拼多多都有明星店铺，用于在搜索结果的上方展示店铺及热销商品。 这些主要的投放工具在两大平台上的收费方式也基本相同：\n搜索和信息流广告的收费方式都按用户点击次数收费（CPC） 淘宝客和多多进宝都按照成交额百分比收费（CPS） 明星店铺都按千次展示收费（CPM）。 两个平台CPC类投放（搜索、信息流）的定价方式是相似的，都是竞价\n图7-22 淘宝直通车计费方式\n在这套竞价体系下：\n①流量的价格在商家之间的博弈中产生，取决于商家的付费意愿，而非由平台直接掌控，流量价格将随着商家之间竞争的激烈程度而水涨船高； ②不是出价高就一定能获得展现，平台通过质量分把控投放商品的质量，保证用户体验，质量分体系使得积淀较少的新商品、新商家的投放费用更高，加剧了 马太效应； ③CPC广告是点击了才扣费，质量分能确保较稳定的广告点击率，维持平台广告消耗的平稳。 两个平台主要的不同在于一些级别更高的自动投放工具。拼多多的OCPX工具有自动投放的功能，会自动帮助商家调整投放的参数，尝试出比较好的投放方案。\n淘宝、拼多多的商品构成大同小异 二者的核心差异点在于，淘系电商（尤其是天猫平台）拥有极强的品牌化能力，而拼多多几乎没有品牌化能力。因此，品牌认知较为重要的品类（如化妆品等） 在天猫上占比更高，而品牌认知不那么重要的品类（比如家纺、日用品等）在拼多多上的占比较高。\n数码电器在拼多多上占比较高的原因，在于拼多多“百亿补贴”重点补贴大牌数码类产品\n图7-23 2021年四季度拼多多品类结构\n我们知道化妆品是一个非常看重品牌的品类，中高端化妆品的出厂价可能只有售价的10%，溢价主要来自品牌。化妆品占比的差异，一定程度上反映了两个平台品 牌化能力的差异。\n图7-24 天猫2020年“双11”大促品类结构\n在分析这两大电商平台的时候，我们基本上可以套用同样的分析框架，即把分析的重心放在对成交额、用户数、货币化率等关键指标，以及平台整体生态和活力 等重要的经营细节的跟踪上。\n平台排名机制解析：为何拼多多的商品看上去比淘宝的便宜 主要原因在于：\n①我国拥有强大的商品供应链，能提供大量物美价廉的消费品； ②拼多多的排序机制使得低价爆款商品更容易获得前排展示； ③拼多多的补贴和商家的主动让利进一步拉低了价格。 其中最核心的一条在于，拼多多和淘系电商在排位权重的分配上有所不同，拼多多更看重“品”，而淘系电商更看重“店”，因此拼多多上的高性价比爆品有更大的 机会拿到高排位。\n淘宝上不是没有便宜的商品，但是有些低价商品在平台中得不到前排展示。在一些“埋得更深”的地方，常常会出现更具性价比的商品。 图7-25 在淘宝上排名靠后的商品也有好价格\n造成天猫品牌化能力强、拼多多难跑出新品牌这个差异的直接原因，在于平台的排序机制。\n拼多多上的便宜商品能够很快得到前排展现，而淘系电商的头部商家在平台上的展现排序更为稳固。 拼多多上的头部商家如果失去了价格优势，就有可能很快被新的商家挤下去； 而淘宝上的头部商家就算涨价，也能维持其在平台中的展现排位。 这不但使拼多多前排展示的商品看起来比淘宝的更便宜，也使两个平台的用户心智出现较大差异。 这对我们的消费品投资分析有何影响？\n首先，要判断一个品牌在电商上经营得是否成功，我们会更重视其在天猫、抖音等品牌化平台上的表现，而不怎么关注其在拼多多、社区团购乃至快手这类非 品牌化平台上的表现。 其次，在分析拼多多等这类平台上的大品牌时，我们更关注其在组织效率、基础质量保障等方面的实力，而非溢价能力。 最后，拼多多品牌化能力弱并不意味着平台变现能力差，向产业带品牌和经销商收费，也可实现较高的货币化率。 7.5 案例三：波司登的品牌升级之路 波司登是如何成功实现品牌升级的？\n第一，国货崛起的核心是“国”崛起，其次才是“货”崛起，我国国力日趋强盛，这使消费者对国产品牌的倾向性持续提升； 第二，羽绒服这类功能性服饰是一个天然的好赛道，容易出现市占率高、品牌溢价高的品牌； 第三，Moncler、加拿大鹅等品牌进驻中国，成功提升了消费者对于羽绒服的价格认知，这为波司登的品牌跃升打开了空间； 第四，波司登本身具备超凡的品牌运营能力，在适当的时机通过明星代言、登山队科考队背书等宣传，配合完成度高、实力强的产品，成功实现品牌跃迁。 国牌崛起的两条典型路径是功能性路径和效率性路径，波司登很明显走的是功能性路径。\n功能性路径专注于细分领域，给产品打上的标签，让消费者感受到品牌的专业度，从而抢占消费者的心智。 效率性路径则强调高周转、高性价比、快速反映用户需求、良好的终端触达等，让消费者能够省力放心地买到中意的商品。 波司登所在的功能性服饰赛道，是一个容易走出好品牌的优质赛道。所谓功能性服饰就是有特殊用途、特殊要求的服饰，比如羽绒服、运动服等。羽绒服赛道兼 具功能性和社交属性两个优质特性，容易诞生大品牌。\n2016～2017年，国际羽绒服大品牌Moncler、加拿大鹅在中国市场吸引了众多的消费者认购，中高端羽绒服消费开始崛起，波司登适时完成提价。\n图7-27 波司登在国内中高端羽绒服市场中一枝独秀\n波司登成功实现品牌升级和其自身的品牌实力也有脱不开的关系。\n第一，波司登有自己的羽绒服工厂，可从源头上把控生产工艺的每一个细节，实现精益求精。依托领先的制造工艺，波司登的产品在用料和做工上无可挑剔。 第二，波司登多年深耕羽绒服，其服装面料和工艺经历了多轮迭代，技术专业程度处于业内领先水平，产品质量的优异性久经考验。 第三，波司登的设计做得非常到位。 一是与迪士尼、漫威等大IP联名推出时尚羽绒服，获得年轻消费者的青睐； 二是与国际知名设计师合作，推出“高定羽绒服”“新一代羽绒服”系列，合作的设计师包括爱马仕黄金时代的缔造者让·保罗·戈尔捷。 第四，波司登在品牌宣传上也下了大功夫。一方面邀请杨幂等头部明星代言，另一方面积极赞助登山、科考等专业团队。 7.6 结语 品牌力就是品牌对其价格带的控制能力，包括定价能力、溢价能力、涨价能力。价格带就是品牌的生命线，降价容易提价难，品牌在保证一定销售规模的前提下， 保持价格带稳定要远远比多卖些货重要。历史上成功实现品牌升级、价格带提升的案例非常少，而能够持续实现价格提升的消费品更为稀缺，这些具备提价能力 的公司，都是消费行业中一等一的优秀公司。\n","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC7%E7%AB%A0-%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%81%E7%89%8C%E5%8A%9B/","summary":"7.1 定价能力是衡量品牌力的重要标准 既然不赚钱，为何商家要花大力气宣传、促销、做销售额、发战报呢？ 答案是：“卖货”和“卖价格带”是品牌经营的两大","title":"第7章 什么是品牌力"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/commerce/","summary":"主页","title":"U.S. Department of Commerce"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/iresearch/","summary":"主页","title":"艾瑞咨询"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/zhiyan/","summary":"主页","title":"智研咨询"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/swsresearch/","summary":"主页","title":"申万宏源研究"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/frost/","summary":"主页","title":"FROST \u0026 SULLIVAN"},{"content":"SQL是三值逻辑(three-valued logic)\n理论篇 两种NULL、三值逻辑还是四值逻辑\n未知(unknown). 以“不知道戴墨镜的人眼睛是什么颜色”这种情况为例，这个人的眼睛肯定是有颜色的，但是如果他不摘掉眼镜，别人就不知道他的眼睛是什 么颜色。 不适用(not applicable, inapplicable). 而“不知道冰箱的眼睛是什么颜色”则属于“不适用”。因为冰箱根本就没有眼睛 关系数据库中“丢失的信息”的分类\n四值逻辑真值表\n为什么必须写成“IS NULL”，而不是“＝NULL”\n对NULL使用比较谓词后得到的结果总是unknown。 1 2 3 4 5 6 --以下的式子都会被判为 unknown 1 = NULL 2 \u0026gt; NULL 3 \u0026lt; NULL 4 \u0026lt;\u0026gt; NULL NULL = NULL 为什么对NULL使用比较谓词后得到的结果永远不可能为真呢？\n因为NULL既不是值也不是变量。NULL只是一个表示“没有值”的标记，而比较谓词只适用于值。因此，对并非值的NULL使用比较谓词本来就是没有意义的 unknown、第三个真值\n书中用unknown表示三值逻辑的第三个值 书中用UNKNOWN表示NULL 1 2 3 4 5 --这个是明确的真值的比较 unknown = unknown → true --这个相当于NULL = NULL UNKNOWN = UNKNOWN → unknown 三值逻辑的真值表（NOT）\n三值逻辑的真值表（AND）\n三值逻辑的真值表（OR）\n记忆方法\nAND的情况： false ＞ unknown ＞ true OR的情况： true ＞ unknown ＞ false 优先级高的真值会决定计算结果。例如true AND unknown，因为unknown的优先级更高，所以结果是unknown。而true OR unknown的话，因为true优 先级更高，所以结果是true。 特别需要记住的是，当AND运算中包含unknown时，结果肯定不会是true（反之，如果AND运算结果为true，则参与运算的双方必须都为true）。 实践篇 1. 比较谓词和NULL(1)：排中律不成立 “把命题和它的否命题通过‘或者’连接而成的命题全都是真命题”这个命题在二值逻辑中被称为排中律（Law of Excluded Middle）。顾名思义，排中律就是 指不认可中间状态，对命题真伪的判定黑白分明，是古典逻辑学的重要原理。“是否承认这一原理”被认为是古典逻辑学和非古典逻辑学的分界线。\n如果排中律在SQL里也成立，那么下面的查询应该能选中表里的所有行。\n1 2 3 4 5 --查询年龄是20岁或者不是20岁的学生 SELECT ＊ FROM Students WHERE age = 20 OR age \u0026lt;\u0026gt; 20; 遗憾的是，在SQL的世界里，排中律是不成立的。假设表Students里的数据如下所示。\nStudents\n这条SQL语句无法查询到约翰，因为约翰年龄不详。\nSQL语句的查询结果里只有判断结果为true的行。要想让约翰出现在结果里，需要添加下面这样的“第3个条件”。\n1 2 3 4 5 6 --添加第3个条件：年龄是20岁，或者不是20岁，或者年龄未知 SELECT ＊ FROM Students WHERE age = 20 OR age \u0026lt;\u0026gt; 20 OR age IS NULL; 2. 比较谓词和NULL(2):CASE表达式和NULL 1 2 3 4 5 --col_1为1时返回○、为NULL时返回×的CASE表达式？ CASE col_1 WHEN 1 THEN\u0026#39;○\u0026#39; WHEN NULL THEN\u0026#39;×\u0026#39; END 这个CASE表达式一定不会返回×。这是因为，第二个WHEN子句是col_1 = NULL的缩写形式。这个式子的真值永远是unknown。\n正确写法\n1 2 3 CASE WHEN col_1 = 1 THEN\u0026#39;○\u0026#39; WHEN col_1 IS NULL THEN\u0026#39;×\u0026#39; END 3. NOT IN和NOT EXISTS不是等价的 Class_A\nClass_B\n考虑一下如何根据这两张表查询“与B班住在东京的学生年龄不同的A班学生”。\n希望查询到的是拉里和伯杰。因为布朗与齐藤年龄相同，所以不是我们想要的结果。 如果单纯地按照这个条件去实现，则SQL语句如下所示。 1 2 3 4 5 6 --查询与B班住在东京的学生年龄不同的A班学生的SQL语句？ SELECT ＊ FROM Class_A WHERE age NOT IN ( SELECT age FROM Class_B WHERE city =’东京’); 上面的sql查不到任何数据\n分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 --1．执行子查询，获取年龄列表 SELECT ＊ FROM Class_A WHERE age NOT IN (22, 23, NULL); --2．用NOT和IN等价改写NOT IN SELECT ＊ FROM Class_A WHERE NOT age IN (22, 23, NULL); --3．用OR等价改写谓词IN SELECT ＊ FROM Class_A WHERE NOT ( (age = 22) OR (age = 23) OR (age = NULL) ); --4．使用德·摩根定律等价改写 SELECT ＊ FROM Class_A WHERE NOT (age = 22) AND NOT(age = 23) AND NOT (age = NULL); --5．用\u0026lt;\u0026gt;等价改写NOT和= SELECT ＊ FROM Class_A WHERE (age \u0026lt;\u0026gt; 22) AND (age \u0026lt;\u0026gt; 23) AND (age \u0026lt;\u0026gt; NULL); --6．对NULL使用\u0026lt;\u0026gt;后，结果为unknown SELECT ＊ FROM Class_A WHERE (age \u0026lt;\u0026gt; 22) AND (age \u0026lt;\u0026gt; 23) AND unknown; --7．如果AND运算里包含unknown，则结果不为true（参考“理论篇”中的矩阵） SELECT ＊ FROM Class_A WHERE false或unknown; 如果NOT IN子查询中用到的表里被选择的列中存在NULL，则SQL语句整体的查询结果永远是空。\n为了得到正确的结果，我们需要使用EXISTS谓词。\n1 2 3 4 5 6 7 --正确的SQL语句：拉里和伯杰将被查询到 SELECT ＊ FROM Class_A A WHERE NOT EXISTS ( SELECT ＊ FROM Class_B B WHERE A.age = B.age AND B.city = ’东京’); 执行结果\n1 2 3 4 name age city ----- ---- ---- 拉里 19 埼玉 伯杰 21 千叶 分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 --1．在子查询里和NULL进行比较运算 SELECT ＊ FROM Class_A A WHERE NOT EXISTS ( SELECT ＊ FROM Class_B B WHERE A.age = NULL AND B.city =’东京’); --2．对NULL使用“=”后，结果为 unknown SELECT ＊ FROM Class_A A WHERE NOT EXISTS ( SELECT ＊ FROM Class_B B WHERE unknown AND B.city =’东京’); --3．如果AND运算里包含unknown，结果不会是true SELECT ＊ FROM Class_A A WHERE NOT EXISTS ( SELECT ＊ FROM Class_B B WHERE false或unknown); --4．子查询没有返回结果，因此相反地，NOT EXISTS为true SELECT ＊ FROM Class_A A WHERE true; 4. 限定谓词和NULL any与in等价\nClass_A\nClass_B\n思考一下用于查询“比B班住在东京的所有学生年龄都小的A班学生”的SQL语句。\n1 2 3 4 5 6 --查询比B班住在东京的所有学生年龄都小的A班学生 SELECT ＊ FROM Class_A WHERE age \u0026lt; ALL ( SELECT age FROM Class_B WHERE city =’东京’); 执行结果\n1 2 3 name age city ----- ---- ---- 拉里 19 埼玉 如果山田的年龄仍是NULL时的分析\nALL谓词其实是多个以AND连接的逻辑表达式的省略写法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --1．执行子查询获取年龄列表 SELECT ＊ FROM Class_A WHERE age \u0026lt; ALL ( 22, 23, NULL ); --2．将ALL谓词等价改写为AND SELECT ＊ FROM Class_A WHERE (age \u0026lt; 22) AND (age \u0026lt; 23) AND (age \u0026lt; NULL); --3．对NULL使用“\u0026lt;”后，结果变为 unknown SELECT ＊ FROM Class_A WHERE (age \u0026lt; 22) AND (age \u0026lt; 23) AND unknown; --4. 如果AND运算里包含unknown，则结果不为true SELECT ＊ FROM Class_A WHERE false 或 unknown; 5. 限定谓词和极值函数不是等价的 如果用极值函数重写刚才的SQL\n1 2 3 4 5 6 --查询比B班住在东京的年龄最小的学生还要小的A班学生 SELECT ＊ FROM Class_A WHERE age \u0026lt; ( SELECT MIN(age) FROM Class_B WHERE city =’东京’); 执行结果\n1 2 3 4 name age city ----- ---- ---- 拉里 19 埼玉 伯杰 21 千叶 没有问题。即使山田的年龄无法确定，这段代码也能查询到拉里和伯杰两人。这是因为，极值函数在统计时会把为NULL的数据排除掉。\nALL谓词和极值函数表达的命题含义\nALL谓词：他的年龄比在东京住的所有学生都小——Q1 极值函数：他的年龄比在东京住的年龄最小的学生还要小——Q2 还有一种情况下它们也是不等价的\n谓词（或者函数）的输入为空集的情况 Class_B没有住在东京的学生！\n使用ALL谓词的SQL语句会查询到A班的所有学生 然而用极值函数查询时一行数据都查询不到。 1 2 3 4 5 6 7 8 9 --1．极值函数返回NULL SELECT ＊ FROM Class_A WHERE age \u0026lt; NULL; --2．对NULL使用“\u0026lt;”后结果为 unknown SELECT ＊ FROM Class_A WHERE unknown; 6. 聚合函数和NULL COUNT以外的聚合函数在输入为空表时都返回NULL\n1 2 3 4 5 6 --查询比住在东京的学生的平均年龄还要小的A班学生的SQL语句？ SELECT ＊ FROM Class_A WHERE age \u0026lt; ( SELECT AVG(age) FROM Class_B WHERE city =’东京’); 本节小结 ","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-3-%E4%B8%89%E5%80%BC%E9%80%BB%E8%BE%91%E5%92%8Cnull/","summary":"SQL是三值逻辑(three-valued logic) 理论篇 两种NULL、三值逻辑还是四值逻辑 未知(unknown). 以“不知道戴墨镜的人眼睛是什么颜","title":"1-3 三值逻辑和NULL"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/moffatt/sql-joins/","summary":"原文","title":"Visual Representation of SQL Joins"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/codinghorror/sql-joins/","summary":"原文","title":"A Visual Explanation of SQL Joins"},{"content":"可重排列、排列、组合 Products\n有序对(排列)\n\u0026lt;1, 2\u0026gt; != \u0026lt;2, 1\u0026gt; 无序对(组合)\n{1, 2} == {2, 1} 通过交叉连接生成笛卡儿积（直积）生成有序对\n1 2 3 --用于获取可重排列的SQL语句 SELECT P1.name AS name_1, P2.name AS name_2 FROM Products P1, Products P2; 执行结果\n1 2 3 4 5 6 7 8 9 10 11 name_1 name_2 ------ ------ 苹果 苹果 苹果 橘子 苹果 香蕉 橘子 苹果 橘子 橘子 橘子 香蕉 香蕉 苹果 香蕉 橘子 香蕉 香蕉 去掉\u0026lt;苹果, 苹果\u0026gt;这种\n1 2 3 4 --用于获取排列的SQL语句 SELECT P1.name AS name_1, P2.name AS name_2 FROM Products P1, Products P2 WHERE P1.name \u0026lt;\u0026gt; P2.name; 执行结果\n1 2 3 4 5 6 7 8 name_1 name_2 ------ ------ 苹果 橘子 苹果 香蕉 橘子 苹果 橘子 香蕉 香蕉 苹果 香蕉 橘子 不能有（苹果，苹果）这样的组合\n去掉\u0026lt;苹果, 橘子\u0026gt;, \u0026lt;橘子, 苹果\u0026gt;这种\n1 2 3 4 --用于获取组合的SQL语句 SELECT P1.name AS name_1, P2.name AS name_2 FROM Products P1, Products P2 WHERE P1.name \u0026gt; P2.name; 执行结果\n1 2 3 4 5 name_1 name_2 ------ ------ 苹果 橘子 香蕉 橘子 香蕉 苹果 获取3个以上元素的组合\n1 2 3 4 5 --用于获取组合的SQL语句：扩展成3列 SELECT P1.name AS name_1, P2.name AS name_2, P3.name AS name_3 FROM Products P1, Products P2, Products P3 WHERE P1.name \u0026gt; P2.name AND P2.name \u0026gt; P3.name; 执行结果\n1 2 3 name_1 name_2 name_3 ------- -------- -------- 香蕉 苹果 橘子 删除重复行 删除重复行\n使用由数据库独自实现的行ID\n只有Oracle(rowid)和PostgreSQL(oid)才能使用, 其他数据库需要自己创建主键 1 2 3 4 5 6 --用于删除重复行的SQL语句(1)：使用极值函数 DELETE FROM Products P1 WHERE rowid \u0026lt; ( SELECT MAX(P2.rowid) FROM Products P2 WHERE P1.name = P2. name AND P1.price = P2.price ) ; 1 2 3 4 5 6 7 --用于删除重复行的SQL语句(2)：使用非等值连接 DELETE FROM Products P1 WHERE EXISTS ( SELECT ＊ FROM Products P2 WHERE P1.name = P2.name AND P1.price = P2.price AND P1.rowid \u0026lt; P2.rowid ); 查找局部不一致的列 假设有下面这样一张住址表，主键是人名\nAddresses\n前田夫妇。这两个人并没有分居，只是夫人的住址写错了而已, 需要修改一下\n所以这个表结构设计的不对\n找出像前田夫妇这样的“是同一家人但住址却不同的记录”, 用非等值自连接来实现，代码会非常简洁\n1 2 3 4 5 --用于查找是同一家人但住址却不同的记录的SQL语句 SELECT DISTINCT A1.name, A1.address FROM Addresses A1, Addresses A2 WHERE A1.family_id = A2.family_id AND A1.address \u0026lt;\u0026gt; A2.address ; 感觉这里的DISTINCT没什么用.\n从下面这张商品表里找出价格相等的商品的组合。\nProducts\n1 2 3 4 5 --用于查找价格相等但商品名称不同的记录的SQL语句 SELECT DISTINCT P1.name, P1.price FROM Products P1, Products P2 WHERE P1.price = P2.price AND P1.name \u0026lt;\u0026gt; P2.name; 执行结果\n1 2 3 4 5 6 7 name price ------ ------ 苹果 50 葡萄 50 草莓 100 橘子 100 香蕉 100 这里确实应该用DISTINCT.\n排序 按照价格从高到低的顺序, 让价格相同的商品位次也一样\nProducts\n使用窗口函数\n1 2 3 4 5 --排序：使用窗口函数 SELECT name, price, RANK() OVER (ORDER BY price DESC) AS rank_1, DENSE_RANK() OVER (ORDER BY price DESC) AS rank_2 FROM Products; 商品则有两种排序方法，一种是跳过之后的位次，另一种是不跳过之后的位次。\nrank_1跳过了之后的位次，rank_2没有跳过 MySQL8支持窗口函数 执行结果\n1 2 3 4 5 6 7 8 name price rank_1 rank_2 ------- ------ ------- ------- 橘子 100 1 1 西瓜 80 2 2 苹果 50 3 3 香蕉 50 3 3 葡萄 50 3 3 柠檬 30 6 4 不依赖于具体数据库来实现的方法\n1 2 3 4 5 6 7 8 --排序从1开始。如果已出现相同位次，则跳过之后的位次 SELECT P1.name, P1.price, (SELECT COUNT(P2.price) FROM Products P2 WHERE P2.price \u0026gt; P1.price) + 1 AS rank_1 FROM Products P1 ORDER BY rank_1; 查询比当前水果价格还要大的水果数n, n+1就是rank\n执行结果\n1 2 3 4 5 6 7 8 name price rank ----- ------ ------ 橘子 100 1 西瓜 80 2 苹果 50 3 葡萄 50 3 香蕉 50 3 柠檬 30 6 如果使用COUNT(DISTINCT P2.price)可以实现不跳过之后的位次\n自连接的写法\n1 2 3 4 5 6 7 8 --排序：使用自连接 SELECT P1.name, MAX(P1.price) AS price, COUNT(P2.name) +1 AS rank_1 FROM Products P1 LEFT OUTER JOIN Products P2 ON P1.price \u0026lt; P2.price GROUP BY P1.name ORDER BY rank_1; 查询当前水果价格能连接多少个n(p1.price\u0026lt;p2.price), n+1就是排名.\n本节小结 与多表之间进行的普通连接相比，自连接的性能开销更大（特别是与非等值连接结合使用的时候），因此用于自连接的列推荐使用主键或者在相关列上建立索引。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-2-%E8%87%AA%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%94%A8%E6%B3%95/","summary":"可重排列、排列、组合 Products 有序对(排列) \u0026lt;1, 2\u0026gt; != \u0026lt;2, 1\u0026gt; 无序对(组合) {1, 2} == {2, 1} 通过交叉连接生成笛卡儿积（直积）生成有序对 1 2 3 --用于获取可重排列的","title":"1-2 自连接的用法"},{"content":"CASE表达式概述 CASE表达式的写法\n1 2 3 4 5 6 7 8 9 10 --简单CASE表达式 CASE sex WHEN \u0026#39;1\u0026#39; THEN ’男’ WHEN \u0026#39;2\u0026#39; THEN ’女’ ELSE ’其他’ END --搜索CASE表达式 CASE WHEN sex =\u0026#39;1\u0026#39;THEN’男’ WHEN sex =\u0026#39;2\u0026#39;THEN’女’ ELSE ’其他’ END 剩余的WHEN子句被忽略的写法示例\n1 2 3 4 --例如，这样写的话，结果里不会出现“第二” CASE WHEN col_1 IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) THEN’第一’ WHEN col_1 IN (\u0026#39;a\u0026#39;) THEN’第二’ ELSE ’其他’ END 注意\n注意事项1：各分支返回的数据类型要一致, 否则报错 注意事项2：不要忘了写END 注意事项3：养成写ELSE子句的习惯 不写可能会造成“语法没有错误，结果却不对”这种不易追查原因的麻烦 养成这样的习惯后，我们从代码上就可以清楚地看到这种条件下会生成NULL，而且将来代码有修改时也能减少失误。 将已有编号方式转换为新的方式并统计 统计数据源表PopTbl\n统计结果\n用县名（pref_name）代替编号作为GROUP BY的列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 --把县编号转换成地区编号(1) SELECT CASE pref_name WHEN ’德岛’ THEN ’四国’ WHEN ’香川’ THEN ’四国’ WHEN ’爱媛’ THEN ’四国’ WHEN ’高知’ THEN ’四国’ WHEN ’福冈’ THEN ’九州’ WHEN ’佐贺’ THEN ’九州’ WHEN ’长崎’ THEN ’九州’ ELSE’其他’END AS district, SUM(population) FROM PopTbl GROUP BY CASE pref_name WHEN ’德岛’ THEN ’四国’ WHEN ’香川’ THEN ’四国’ WHEN ’爱媛’ THEN ’四国’ WHEN ’高知’ THEN ’四国’ WHEN ’福冈’ THEN ’九州’ WHEN ’佐贺’ THEN ’九州’ WHEN ’长崎’ THEN ’九州’ ELSE ’其他’ END; 将数值按照适当的级别进行分类统计\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 --按人口数量等级划分都道府县 SELECT CASE WHEN population \u0026lt; 100 THEN\u0026#39;01\u0026#39; WHEN population \u0026gt;= 100 AND population \u0026lt; 200 THEN\u0026#39;02\u0026#39; WHEN population \u0026gt;= 200 AND population \u0026lt; 300 THEN\u0026#39;03\u0026#39; WHEN population \u0026gt;= 300 THEN\u0026#39;04\u0026#39; ELSE NULL END AS pop_class, COUNT(＊) AS cnt FROM PopTbl GROUP BY CASE WHEN population \u0026lt; 100 THEN\u0026#39;01\u0026#39; WHEN population \u0026gt;= 100 AND population \u0026lt; 200 THEN\u0026#39;02\u0026#39; WHEN population \u0026gt;= 200 AND population \u0026lt; 300 THEN\u0026#39;03\u0026#39; WHEN population \u0026gt;= 300 THEN\u0026#39;04\u0026#39; ELSE NULL END; pop_class cnt --------- ---- 01 1 02 3 03 3 04 2 上面两种方式都要在select和group by中写相同的case, 在变更时可能会忘记同步, 下面的写法更方便\n严格来说，这种写法是违反标准SQL的规则的。因为GROUP BY子句比SELECT语句先执行，所以在GROUP BY子句中引用在SELECT子句里定义的别称是不被允 许的。事实上，在Oracle、DB2、SQL Server等数据库里采用这种写法时就会出错。 不过也有支持这种SQL语句的数据库，例如在PostgreSQL和MySQL中，这个查询语句就可以顺利执行。这是因为，这些数据库在执行查询语句时，会先对 SELECT子句里的列表进行扫描，并对列进行计算。 用一条SQL语句进行不同条件的统计 统计源表PopTbl2\n统计结果\n通常的做法是写两个sql, 可能然后再用union合并\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 男性人口 SELECT pref_name, SUM(population) FROM PopTbl2 WHERE sex =\u0026#39;1\u0026#39; GROUP BY pref_name; -- 女性人口 SELECT pref_name, SUM(population) FROM PopTbl2 WHERE sex =\u0026#39;2\u0026#39; GROUP BY pref_name; 用一条sql实现\n1 2 3 4 5 6 7 SELECT pref_name, --男性人口 SUM( CASE WHEN sex =\u0026#39;1\u0026#39;THEN population ELSE 0 END) AS cnt_m, --女性人口 SUM( CASE WHEN sex =\u0026#39;2\u0026#39;THEN population ELSE 0 END) AS cnt_f FROM PopTbl2 GROUP BY pref_name; 用CHECK约束定义多个列的条件关系 假设某公司规定“女性员工的工资必须在20万日元以下”，而在这个公司的人事表中，这条无理的规定是使用CHECK约束来描述的\n1 2 3 4 5 6 7 8 9 CONSTRAINT check_salary CHECK ( CASE WHEN sex =\u0026#39;2\u0026#39; THEN CASE WHEN salary \u0026lt;= 200000 THEN 1 ELSE 0 END ELSE 1 END = 1 ) 用逻辑与改写的CHECK约束如下所示。\n1 2 CONSTRAINT check_salary CHECK ( sex =\u0026#39;2\u0026#39;AND salary \u0026lt;= 200000 ) 这两个约束的程序行为不一样(第二个如果是男雇员也返回false了, 不符合命题)\n逻辑与和蕴含式的真值表\nU表示unknown 在UPDATE语句里进行条件分支 Salaries\n假设现在需要根据以下条件对该表的数据进行更新。\n对当前工资为30万日元以上的员工，降薪10%。 对当前工资为25万日元以上且不满28万日元的员工，加薪20%。 按照这些要求更新完的数据应该如下表所示。\n乍一看，分别执行下面两个UPDATE操作好像就可以做到，但这样的结果却是不正确的。\n1 2 3 4 5 6 7 8 9 --条件1 UPDATE Salaries SET salary = salary ＊ 0.9 WHERE salary \u0026gt;= 300000; --条件2 UPDATE Salaries SET salary = salary ＊ 1.2 WHERE salary \u0026gt;= 250000 AND salary \u0026lt; 280000; 正确的写法\n注意最后的else必须写, 否则返回null 1 2 3 4 5 6 7 --用CASE表达式写正确的更新操作 UPDATE Salaries SET salary = CASE WHEN salary \u0026gt;= 300000 THEN salary ＊ 0.9 WHEN salary \u0026gt;= 250000 AND salary \u0026lt; 280000 THEN salary ＊ 1.2 ELSE salary END; 调换主键值的方便写法\nSomeTable\n不使用case\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --1．将a转换为中间值d UPDATE SomeTable SET p_key =\u0026#39;d\u0026#39; WHERE p_key =\u0026#39;a\u0026#39;; --2．将b调换为a UPDATE SomeTable SET p_key =\u0026#39;a\u0026#39; WHERE p_key =\u0026#39;b\u0026#39;; --3．将d调换为b UPDATE SomeTable SET p_key =\u0026#39;b\u0026#39; WHERE p_key =\u0026#39;d\u0026#39;; 使用case\n适用于Oracle, DB2, SQL Server 不适用于PostgreSQL, MySQWL 1 2 3 4 5 6 7 8 --用CASE表达式调换主键值 UPDATE SomeTable SET p_key = CASE WHEN p_key =\u0026#39;a\u0026#39; THEN \u0026#39;b\u0026#39; WHEN p_key =\u0026#39;b\u0026#39; THEN \u0026#39;a\u0026#39; ELSE p_key END WHERE p_key IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;); 表之间的数据匹配 课程一览 CourseMaster\n开设的课程 OpenCourses\n我们要用这两张表来生成下面这样的交叉表\ncourse_name 6月 7月 8月 ----------- ---- ---- ---- 会计入门 ○ × × 财务知识 × × ○ 簿记考试 ○ × × 税务师 ○ ○ ○ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 --表的匹配：使用IN谓词 SELECT course_name, CASE WHEN course_id IN (SELECT course_id FROM OpenCourses WHERE month = 200706) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;6月\u0026#34;, CASE WHEN course_id IN (SELECT course_id FROM OpenCourses WHERE month = 200707) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;7月\u0026#34;, CASE WHEN course_id IN (SELECT course_id FROM OpenCourses WHERE month = 200708) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;8月\u0026#34; FROM CourseMaster; --表的匹配：使用EXISTS谓词 SELECT CM.course_name, CASE WHEN EXISTS (SELECT course_id FROM OpenCourses OC WHERE month = 200706 AND OC.course_id = CM.course_id) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;6月\u0026#34;, CASE WHEN EXISTS (SELECT course_id FROM OpenCourses OC WHERE month = 200707 AND OC.course_id = CM.course_id) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;7月\u0026#34;, CASE WHEN EXISTS (SELECT course_id FROM OpenCourses OC WHERE month = 200708 AND OC.course_id = CM.course_id) THEN\u0026#39;○\u0026#39; ELSE\u0026#39;×\u0026#39;END AS \u0026#34;8月\u0026#34; FROM CourseMaster CM; 无论使用IN还是EXISTS，得到的结果是一样的，但从性能方面来说，EXISTS更好。通过EXISTS进行的子查询能够用到“month, course_id”这样的主键索引， 因此尤其是当表OpenCourses里数据比较多的时候更有优势。\n在CASE表达式中使用聚合函数 假设这里有一张显示了学生及其加入的社团的一览表。如表StudentClub所示，这张表的主键是“学号、社团ID”，存储了学生和社团之间多对多的关系。\nStudentClub\n我们按照下面的条件查询这张表里的数据。\n获取只加入了一个社团的学生的社团ID。 获取加入了多个社团的学生的主社团ID。 条件1的SQL\n1 2 3 4 5 --条件1：选择只加入了一个社团的学生 SELECT std_id, MAX(club_id) AS main_club FROM StudentClub GROUP BY std_id HAVING COUNT(＊) = 1; 执行结果1\n1 2 3 4 5 std_id main_club ------ ---------- 300 4 400 5 500 6 条件2的SQL\n1 2 3 4 --条件2：选择加入了多个社团的学生 SELECT std_id, club_id AS main_club FROM StudentClub WHERE main_club_flg =\u0026#39;Y\u0026#39;; 执行结果2\n1 2 3 4 std_id main_club ------ ---------- 100 1 200 3 如果使用CASE表达式，下面这一条SQL语句就可以了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 SELECT std_id, CASE WHEN COUNT(＊) = 1 --只加入了一个社团的学生 THEN MAX(club_id) ELSE MAX(CASE WHEN main_club_flg =\u0026#39;Y\u0026#39; THEN club_id ELSE NULL END) END AS main_club FROM StudentClub GROUP BY std_id; std_id main_club ------ ---------- 100 1 200 3 300 4 400 5 500 6 本节小结 最后说一点细节的东西。CASE表达式经常会因为同VB和C语言里的CASE“语句”混淆而被叫作CASE语句。但是准确来说，它并不是语句，而是和1+1或者a/b一样 属于表达式的范畴。结束符END确实看起来像是在标记一连串处理过程的终结，所以初次接触CASE表达式的人容易对这一点感到困惑。“表达式”和“语句”的名称 区别恰恰反映了两者在功能处理方面的差异。\n作为表达式，CASE表达式在执行时会被判定为一个固定值，因此它可以写在聚合函数内部；也正因为它是表达式，所以还可以写在SELECE子句、GROUP BY 子句、WHERE子句、ORDER BY子句里。简单点说，在能写列名和常量的地方，通常都可以写CASE表达式。从这个意义上来说，与CASE表达式最接近的不是面向 过程语言里的CASE语句，而是Lisp和Scheme等函数式语言里的case和cond这样的条件表达式。\n","permalink":"https://jdxj.github.io/posts/books/sql%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/%E7%AC%AC1%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84sql/1-1-case%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"CASE表达式概述 CASE表达式的写法 1 2 3 4 5 6 7 8 9 10 --简单CASE表达式 CASE sex WHEN \u0026#39;1\u0026#39; THEN ’男’ WHEN \u0026#39;2\u0026#39; THEN ’女’ ELSE ’其他’ END --搜索CASE表达","title":"1-1 CASE表达式"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/smantic/","summary":"主页","title":"Smantic"},{"content":"8.1 内存分配 在Go的runtime中，有一系列函数被用来分配内存。\n例如与new语义相对应的有newobject()函数和newarray()函数，分别负责单个对象的分配和数组的分配。 与make语义相对应的有makeslice()函数、makemap()函数及makechan()函数及一些变种，分别负责分配和初始化切片、map和channel。 无论是new系列还是make系列，这些函数的内部无一例外都会调用runtime.mallocgc()函数，它就是Go语言堆分配的关键函数。\n8.1.1 sizeclasses Go的堆分配采用了与tcmalloc内存分配器类似的算法，tcmalloc是谷歌公司开发的一款针对C/C++的内存分配器，在对抗内存碎片化和多核性能方面非常优秀\n参考tcmalloc实现的内存分配器，内部针对小块内存的分配进行了优化。这类分配器会按照一组预置的大小规格把内存页划分成块，然后把不同规格的内存块放 入对应的空闲链表中\n图8-1 tcmalloc内存分配器预置不同规格的链表\n在Go源代码runtime包的sizeclasses.go文件中，给出了一组预置的大小规格。\n表8-1 sizeclasses预置的大小规格\n续表\nsizeclasses.go\n第一列是所谓的sizeclass，实际上就是所有规格按空间大小升序排列的序号。 第二列是规格的空间大小，单位是字节。 第三列表示需要申请多少字节的连续内存，目的是保证划分成目标大小的内存块以后，尾端因不能整除而剩余的空间要小于12.5%。Go使用8192字节作为页面 大小，底层内存分配的时候都是以整页面为单位的，所以第三列都是8192的整数倍。 第四列是第三列与第二列做整数除法得到的商 第五列则是余数，分别表示申请的连续内存能划分成多少个目标大小的内存块，以及尾端因不能整除而剩余的空间，也就是在内存块划分的过程中浪费掉的空 间。 最后一列表示的是最大浪费百分比，结合了内存块划分时造成的尾端浪费和内存分配时向上对齐到最接近的块大小造成的块内浪费。 sizeclasses.go文件是被程序生成出来的，源码就在 mksizeclasses.go文件中\n8.1.2 heapArena Go语言的runtime将堆地址空间划分成多个arena，在amd64架构的Linux环境下，每个arena的大小是64MB，起始地址也是对齐到64MB的。每个arena都有一 个与之对应的heapArena结构，用来存储arena的元数据\n图8-2 area与heapArena的关系\nheapArena是在Go的堆之外分配和管理的\nbitmap字段是个位图\n它用两个二进制位来对应arena中一个指针大小的内存单元，所以对于64MB大小的arena来讲，heapArenaBitmapBytes的值是 64MB/8/8×2＝2MB(64MB/8B=8M, 8M*2b/8=2MB)，这个位图在GC扫描阶段会被用到。 bitmap第一字节中的8个二进制位，对应的就是arena起始地址往后32字节的内存空间。 用来描述一个内存单元的两个二进制位当中，低位用来区分内存单元中存储的是指针还是标量，1表示指针，0表示标量，所以也被称为指针／标量位。 高位用来表示当前分配的这块内存空间的后续单元中是否包含指针，例如在堆上分配了一个结构体，可以知道后续字段中是否包含指针，如果没有指针就不需 要继续扫描了，所以也被称为扫描／终止位。 为了便于操作，一个位图字节中的指针／标量位和扫描／终止位被分开存储，高4位存储4个扫描／终止位，低4位存储4个指针／标量位。 图8-3 arena起始处分配一个slice对应的bitmap标记\nspans数组用来把当前arena中的页面映射到对应的mspan，暂时先认为一个mspan管理一组连续的内存页面\npagesPerArena表示arena中共有多少个页面，用arena大小(64MB)除以页面大小(8KB)得到的结果是8192\n图8-4 arena中的页面到mspan的映射\npageInUse是个长度为1024的uint8数组，实际上被用作一个8192位的位图\n通过它和spans可以快速地找到那些处于mSpanInUse状态的mspan。 虽然pageInUse位图为arena中的每个页面都提供了一个二进制位，但是对于那些包含多个页面的mspan，只有第1个页面对应的二进制位会被用到，标记的 是整个span。 图8-5 pageInUse位图标记使用中的span\npageMarks表示哪些span中存在被标记的对象\n与pageInUse一样用与起始页面对应的一个二进制位来标记整个span。 在GC的标记阶段会原子性地修改这个位图，标记结束之后就不会再进行改动了。 清扫阶段如果发现某个span中不存在任何被标记的对象，就可以释放整个span了。 不是被标记的才释放吗?\npageSpecials又是一个与pageInUse类似的位图，只不过标记的是哪些span包含特殊设置，目前主要指的是包含finalizers，或者runtime内部用来存储 heap profile数据的bucket。\ncheckmarks是一个大小为1MB的位图，其中每个二进制位对应arena中一个指针大小的内存单元。当开启调试debug.gccheckmark的时候，checkmarks位图 用来存储GC标记的数据。该调试模式会在STW的状态下遍历对象图，用来校验并发回收器能够正确地标记所有存活的对象。\nzeroedBase记录的是当前arena中下个还未被使用的页面的位置，相对于arena起始地址的偏移量。页面分配器会按照地址顺序分配页面，所以zeroedBase之 后的页面都还没有被用到，因此还都保持着清零的状态。通过它可以快速判断分配的内存是否还需要进行清零。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC8%E7%AB%A0-%E5%A0%86/","summary":"8.1 内存分配 在Go的runtime中，有一系列函数被用来分配内存。 例如与new语义相对应的有newobject()函数和newarray()函","title":"第8章 堆"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/docs/keepachangelog/","summary":"原文","title":"如何维护更新日志"},{"content":"代码地址\n","permalink":"https://jdxj.github.io/posts/docs/syslist/","summary":"代码地址","title":"Go交叉编译支持的系统与架构"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/karllhughes/the-best-golang-blogs/","summary":"原文","title":"The Best Golang Blogs"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/cch123/plan9/","summary":"原文","title":"Plan9 Assembly"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/docs/conventionalcommits/","summary":"原文","title":"约定式提交"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/fillmem/intellij-ideavim-repeat-key/","summary":"ideavim中没法长按按键重复字符解决办法","title":"Intellij Ideavim Repeat Key"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/alikhll/golang-developer-roadmap/","summary":"原文","title":"Golang Developer Roadmap"},{"content":"7.1 Happens Before 多核情况下避免并发读写的条件\nw happens before r。 没有其他针对v的写操作happens after w且before r。 图7-1 多线程并发事件示意图\n7.1.1 并发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 第7章 package main import ( \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { var data int var ok bool someValue := rand.Int() // 第7章 code_7_1 go func() { for { if !ok { data = someValue ok = true } } }() var sum int // 第7章 code_7_2 go func() { for { if ok { sum += data ok = false } } }() time.Sleep(time.Second * 10) } 如果编译器生成的指令与源码中语句的顺序严格一致，上述生产者协程和消费者协程在单核CPU上并发执行是可以保证结果正确的。一旦编译器对生成指令的顺序 进行优化调整，或者程序在多核CPU上执行，就不能保证结果正确了\n7.1.2 并行 抽象地解释并发，指的是多个事件在宏观上是同时发生的，但是并不一定要在同一时刻发生，而并行就不一样了，从微观角度来看，并行的两个事件至少有某一 时刻是同时发生的，所以在单核CPU上的多线程只存在并发，不存在并行。只有在多核CPU上，线程才有可能并行执行。\n7.2 内存乱序 处理器普遍具有乱序执行的特性，目的都是为了更优的性能。 编译器和CPU都会考虑指令间的依赖关系，在不会改变当前线程行为的前提下进行顺序调整，因此在单个线程内依然是逻辑有序的，语句间原本满足的 happens before条件不会被破坏，但这种有序性只是在单个线程内，并不会保证线程间的有序性。 7.2.1 编译期乱序 指的是编译器对最终生成的机器指令进行了顺序调整\n7.2.2 执行期乱序 CPU在执行期间也可能会对指令的顺序进行调整\n协程一和协程二中的两条赋值语句形式相似，对应到x86汇编就是三条内存操作指令，按照顺序及分类分别是Store、Load、Store\n图7-2 协程一和协程二的赋值语句对应的汇编指令\n一般的内存属于write-back cacheable内存，简称WB内存。对于WB内存而言，Store和Load指令并不是直接操作内存中的数据的，而是先把指定的内存单元 填充到高速缓存中，然后读写高速缓存中的数据。\nLoad指令的大致流程是，先尝试从高速缓存中读取，如果缓存命中，则读操作就完成了。如果缓存未命中，则先填充对应的Cache Line， 然后从Cache Line中读取\n图7-3 Load指令的执行流程\nStore指令的大致流程类似，先尝试写高速缓存，如果缓存命中，则写操作就完成了。如果缓存未命中，则先填充对应的Cache Line，然后写到Cache Line中\n图7-4 Store指令执行流程\n在多核心的CPU上，Store操作会变得更复杂一些。\n每个CPU核心都拥有自己的高速缓存，例如x86的L1 Cache。写操作会修改当前核心的高速缓存, 被修改的数据可能存在于多个核心的高速缓存中，CPU需要 保证各个核心间的缓存一致性。 目前主流的缓存一致性协议是MESI协议，MESI这个名字取自缓存单元可能的4种状态，分别是已修改的Modified，独占的Exclusive，共享的Shared和无 效的Invalid。 当一个CPU核心要对自身高速缓存的某个单元进行修改时，它需要先通知其他CPU核心把各自高速缓存中对应的单元置为Invalid，再把自己的这个单元置为 Exclusive，然后就可以进行修改了。\n图7-5 一个CPU核心修改高速缓存数据单元的过程\n这个过程涉及多核间的内部通信，是一个相对较慢的过程，为了避免当前核心因为等待而阻塞，CPU在设计上又引入了Store Buffer。当前核心向其他核心发出 通知以后，可以先把要写的值放在Store Buffer中，然后继续执行后面的指令，等到其他核心完成响应以后，当前核心再把Store Buffer中的值合并到高速 缓存中\n图7-6 引入Store Buffer后CPU修改高速缓存数据单元的过程\n虽然高速缓存会保证多核一致性，但是Store Buffer却是各个核心私有的，因此对其他核心不可见。在Store-Load乱序中，从微观时序上，Load指令可能是 在另一个线程的Store之后执行，但此时多核间通信尚未完成，对应的缓存单元还没有被置为Invalid，Store Buffer也没有被合并到高速缓存中，所以Load 读到的是修改前的值。\n图7-7 写入Store Buffer后合并到高速缓存前Load数据\n当协程一执行最后一条Store指令时，b就被赋值为0。同样地，协程二会将a赋值为0。即使Store Buffer合并到高速缓存，x和y都被修改为新值，也已经晚了\n图7-8 合并到高速缓存后的数据状态\n理论上可能出现的乱序有4种\nLoad-Load，相邻的两条Load指令，后面的比前面的先读到数据。 Load-Store，Load指令在前，Store指令在后，但是Store操作先变成全局可见，Load指令在此之后才读到数据。 Store-Load，Store指令在前，Load指令在后，但是Load指令先读到了数据，Store操作在此之后才变成全局可见。这个我们已经在x86平台见证过了。 Store-Store，相邻的两条Store指令，后面的比前面的先变成全局可见。 所谓的全局可见，指的是在多核CPU上对所有核心可见。\n7.2.3 内存排序指令 执行期乱序会给结果带来很大的不确定性，这对于应用程序来讲是不能接受的，完全按照指令顺序执行又会使性能变差。为了解决这一问题，CPU提供了内存排序 指令，应用程序在必要的时候能够通过这些指令来避免发生乱序。以目前的Intel x86处理器为例，提供了LFENCE、SFENCE和MFENCE这3条内存排序指令\n难以理解\n7.3 常见的锁 锁需要将所有线程（或协程）对临界区的访问进行串行化处理，需要同时保证两点要求：\n同时只能有一个线程获得锁，持有锁才能进入临界区。 当线程离开临界区释放锁后，线程在临界区内做的所有操作都要全局可见。 7.3.1 原子指令 如果CMP, JNE, MOV不在一条指令中执行, 那么加锁会出问题\n图7-9 同步问题\nx86就提供了CMPXCHG指令, 是Compare and Exchange的缩写，该指令有两个操作数，用于实现锁的时候，第一操作数通常是个内存地址，也称为目的操作 数，第二操作数是个通用寄存器。CMPXCHG会将AX寄存器和第一操作数进行比较，如果相等就把第二操作数复制到目的操作数中，若不相等就把目的操作数复制 到AX寄存器中。\n在多核环境下，运行在不同CPU核心上的线程可能会并行加锁，不同核心同时执行CMPXCHG又会造成多个线程同时获得锁。\n如何解决这个问题呢？\n一种思路是，在当前核心执行CMPXCHG时，阻止其他核心执行CMPXCHG，x86汇编中的LOCK前缀用于实现这一目的。\nLOCK前缀能够应用于部分内存操作指令，最简单的解释就是LOCK前缀会让当前CPU核心在当前指令执行期间独占总线，这样其他的CPU核心就不能同时操作内 存了。 事实上，只有对于不在高速缓存中的数据才会这样，对于高速缓存中的数据，LOCK前缀会通过MESI协议处理多核间缓存一致性。 在多核环境下，这种带有LOCK前缀的指令也被称为原子指令。 在x86CPU上，LOCK前缀同时具有内存排序的作用，相当于在应用LOCK前缀的指令之后紧接着执行了一条MFENCE指令。综上所述，原子指令既能保证只允许一个 线程进入临界区，又具有内存排序的作用，能够保证在锁的状态发生变化时，临界区中所有的修改随锁的状态一起变成全局可见。\n7.3.2 自旋锁 自旋锁得以实现的基础是原子性的CAS操作，CAS即Compare And Swap，在x86平台上对应带有LOCK前缀的CMPXCHG指令。之所以称作自旋锁，是因为它会一 直循环尝试CAS操作直到成功，看起来就像是一直在自旋等待。\n尝试一下用汇编语言基于CMPXCHG指令实现一把自旋锁\nlock()和unlock()这两个函数用汇编实现\nlock()函数把锁的地址放在了BX寄存器中，把用来比较的旧值old放到了DX寄存器中，把要写入的新值new放到了CX寄存器中。 从标签again处开始是一个循环，每次循环开始前，把DX寄存器的值复制给AX寄存器，因为CMPXCHG隐含使用AX寄存器中的值作为比较用的旧值，并且可能会 修改AX寄存器，所以每次循环需要重新赋值 这个循环不断尝试通过CMPXCHG进行加锁，成功后会通过JE指令跳出循环。能够通过JE跳出循环，这是因为CMP操作会影响标志寄存器。 unlock()函数通过XCHG指令将锁清零，实现了解锁操作。细心的读者可能会注意到这里没有LOCK前缀，根据Intel开发者手册所讲，XCHG指令隐含了LOCK 前缀，所以代码中不用写，依然能够起到独占总线和内存排序的作用。 事实上，atomic包中的CompareAndSwapInt32()函数和StoreInt32()函数是基于CMPXCHG和XCHG这两条汇编指令实现的，所以上述的自旋锁可以改成完全 用Go实现\n在锁竞争比较激烈的场景下，这种自旋会造成CPU使用率很高，所以还要进行优化。x86专门为此提供了PAUSE指令，它一方面能够提示处理器当前正处于自旋循 环中，从而在退出循环的时候避免因检测到内存乱序而造成性能损失。另一方面，PAUSE能够大幅度减小自旋造成的CPU功率消耗，从而达到节能和减少发热的效 果。\n可以把PAUSE指令加入我们汇编版本的lock()函数实现中\n可以把PAUSE指令单独放在一个函数中，这样就能够跟atomic包中的函数结合使用了\n自旋锁的适用场景\n不适用于单核, 因为单核系统上任一时刻只能有一个线程在运行，当前线程一直在自旋等待，而持有锁的线程得不到运行，锁就不可能被释放 即使是在多核环境下, 在持有锁的时间占比很小，并且活跃线程数接近CPU核心数量时，自旋锁比较高效，也就是自旋的代价小于线程切换的代价。 7.3.3 调度器对象 指操作系统提供的线程间同步原语\n这些调度器对象与自旋锁的不同主要是有一个等待队列。 当线程获取锁失败时不会一直在那里自旋，而是挂起后进入等待队列中等待，然后系统调度器会切换到下一个可运行的线程。 等到持有锁的线程释放锁的时候，会按照一定的算法从等待队列中取出一个线程并唤醒它，被唤醒的线程会获得所有权，然后继续执行。 这些同步原语是由内核提供的，直接与系统的调度器交互，能够挂起和唤醒线程，这一点是自旋锁做不到的。 等待队列可以实现支持FIFO、FILO，甚至支持某种优先级策略，但是也正是由于是在内核中实现的，所以应用程序需要以系统调用的方式来使用它，这就造 成了一定的开销。在获取锁失败的情况下还会发生线程切换，进一步增大开销。 7.3.4 优化的锁 将自旋锁和调度器对象结合，理论上就可以得到一把优化的锁了。加锁时首先经过自旋锁，但是需限制最大自旋次数，如果在有限次数内加锁成功也就成功了， 否则就进一步通过调度器对象将当前线程挂起。等到持有锁的线程释放锁的时候，会通过调度器对象将挂起的线程唤醒。这样就结合了二者的优点，既避免了加 锁失败立即挂起线程造成过多的上下文切换，又避免了无限制地自旋而空耗CPU，这也是如今主流的锁实现思路。\n7.4 Go语言的同步 推荐看极客时间的Go并发编程实战课\n7.5 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC7%E7%AB%A0-%E5%90%8C%E6%AD%A5/","summary":"7.1 Happens Before 多核情况下避免并发读写的条件 w happens before r。 没有其他针对v的写操作happens after w且before r。 图7-1 多线程并发事件示意图 7.1.1 并发 1 2","title":"第7章 同步"},{"content":"COUNT函数用于统计在符合搜索条件的记录中，指定的表达式expr不为NULL的行数有多少。\n对于COUNT(*)、COUNT(常数)、COUNT(主键)形式的COUNT函数来说，优化器可以选择最小的索引执行查询，从而提升效率，它们的执行过程是一样的，只不 过在判断表达式是否为NULL时选择不同的判断方式，这个判断为NULL的过程的代价可以忽略不计，所以我们可以认为COUNT(*)、COUNT(常数)、COUNT(主键) 所需要的代价是相同的。\n而对于COUNT(非主键列)来说，server层必须要从InnoDB中读到包含非主键列的记录，所以优化器并不能随心所欲的选择最小的索引去执行。\n原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/mysql%E7%9A%84count%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/","summary":"COUNT函数用于统计在符合搜索条件的记录中，指定的表达式expr不为NULL的行数有多少。 对于COUNT(*)、COUNT(常数)、COU","title":"MySQL的COUNT是怎么执行的"},{"content":"6.1 数解中国供应链 在我国强大的商品供应链之下，质量过硬的商品能以低廉的成本大量产出。\n图6-1 拼多多、1688上有许多高性价比的消费品\n图6-2 2010年全球奢侈品皮具代工市场份额（以销售额计）\n在效率方面，我国供应链工厂“小单快反”的响应能力领先世界。\n我国制造业具备较高的完善程度，形成了多个发达的产业集群，大部分原料都能在国内完成采购。\n图6-3 2016年各国制造业海外增加值占总出口之比\n图6-4 2016年中外制造业上游原材料能在国内购买的比重对比\n国内完备的制造业体系和稳定的经营环境，使得我国制造业具备无与伦比的韧性和抗打击能力。\n图6-5 疫情期间中外制造业PMI对比（以50%作为经济强弱的分界点，越高越好）\n我国拥有多个成型的产业集群，多个细分产品的产量世界领先。\n图6-6 2019年世界鞋类产量份额前10的国家\n图6-7 2019年全球家电出口额占比前六的国家\n6.2 亲临中国制造一线：南通家纺调研实录 叠石桥简介 叠石桥的支柱产业是制造与销售家纺产品，即大家通常所说的“床上四件套”，主要包括枕头和抱枕、床单、被单、被芯等。整个地方几乎就是一个家纺产业链集 群，差不多所有人都围着家纺产业链上下游工作，从各类原材料的供给、成品加工，到展示招商、快递收发，乃至线上店铺的经营培训，一应俱全。\n图6-8 叠石桥地理位置\n全球大约60%的家纺产品产自这个地方。可以认为，在全球家纺领域，“中国制造”几乎等价为“叠石桥制造”。\n叠石桥具备完整的家纺产业链 几乎整个叠石桥都围绕着家纺产业。从上游原料，到整件制造批发，再到与家纺制造销售有关的配套服务，五脏俱全。\n比“制造”更难的事情是“销售”，销售所需要的“品牌”具备护城河 能制造、缺品牌、卖不掉，是叠石桥最常见的问题。\n在叠石桥，我们能看到很多“贴牌加工、一件代发”的牌子。\n什么是贴牌加工？是我能设计，能制造，但是没有品牌，没有销路。谁如果有品牌、有渠道，那可以直接在我的产品上贴牌销售。 什么是一件代发？这是一个电商术语，如果你能够在电商平台上开店找到买家，你就不用进货，不用备库存，而是和我签协议，在你收到订单之后，我直接帮 你发货，这类似于线下零售的“代销”模式。 做品牌是一件风险相对较高的事情，品牌商品的库存会占用大量的现金流，也有失败的风险。因此对于很多工厂主而言，做一个新品牌是一件吃力不讨好的事情。\n总之，家纺产业链的难点不在于造，而在于卖。拥有好的品牌和销售渠道，比制造更重要。这也说明，在服装等产业中，销路往往比生产能力更值钱。\n6.3 如何兑现中国消费品供应链的真正价值 优质供应链品牌化或是未来消费行业的重要机会 产业链里的大多数工厂主，对于自己做品牌这件事热情并不大，他们一方面垂涎大品牌丰厚的利润，另一方面希望能够安安心心地搞生产，希望能够得到大品牌 的垂青。做出一个大品牌比生产出质量过硬的商品更难，因为品牌的经营涉及品牌营销、渠道管理、供应链管理等多方面的细节，对于中小企业主而言是一件比 较难的事情，同时也会占用较大的资金，带来较高的经营风险。\n成为大品牌的核心供应商，是供应链企业的重要成长方向 大品牌对其供应商的要求更高\n第一，代工厂要保证稳定的质量和足够的合格率，因为质量低下的产品有可能会一夜之间毁掉大品牌多年以来积累的口碑。 第二，代工厂要保证出货的效率，天下武功唯快不破，在互联网时代，品牌方也需要快速响应市场动态以保持竞争力。 第三，代工厂也要保证其经营的正规性，因为品牌方一定不会希望因为代工厂的经营和管理问题而使得自己的口碑受到影响。 管理能力是供应商的一个核心壁垒。\n供应商通常需要聘用大量的员工作为制造人员，而为了保证成本，大部分制造人员的学历并不高。 考虑到工人的熟练度会随着生产逐渐提升，企业不但要打造完善的员工培训体系，还要尽可能保证工人的留存率。如果工人流动太快，熟练度不高，生产效率 和质量将会受到影响。 品牌方构建的合作关系也是一个重要壁垒。\n为了保障质量的稳定和管理的便利，大品牌的供应商构成会相对比较稳定。有时候品牌方甚至会主动向供应商输出管理方法和制造工艺，以提升产品的总体质 量。 因此，在没有出现重大问题的情况下，品牌方通常较少更换其核心供应商。这样一来，与品牌方建立的合作关系就成了供应商的重要经营壁垒：稳定的合作关 系意味着稳定的订单，同时这种关系也为供应商挡住了部分潜在竞争对手。 跨境电商是我国优质供应链突围的另一个重要方向 图6-10 中国跨境电商市场规模与增长率\n为什么是电商，而非传统的线下渠道？第一，海外的电商渠道尚未成型，存在弯道超车的空间；第二，线上渠道的开店成本低，且我国商家在电商渠道上具备更 强大的竞争优势。\n国内商家在对互联网和电商的理解上具备领先优势。我国的电商规模和电商渗透率在世界范围内处于领先地位，也拥有大量经过激烈竞争后沉淀下来的电商从 业人员，他们在剖析平台规则的方法论、对电商消费者心理的把控、对互联网的理解等方面，都展现出一定的优势。 国外电商渠道里的机会更大。它们的线下渠道发展已经基本进入成熟期，而线上渠道仍在发展过程中。 图6-11 美国电商渗透率\n跨境电商大致分为三类，从出现的先后顺序上来说：第一类是只做渠道的“大卖家”，这是跨境电商初期的形式；第二类是做跨境品牌的“品牌商”；第三类是同时 做品牌和线上渠道的“独立站”。品牌商和独立站是现阶段的主流形式\n表6-1 跨境电商的主要形式\n海外电商行业的市场格局和我国的最大不同，在于独立站的份额比较大。在美国，除了亚马逊之外，其他平台的份额都不高，用户也习惯于在各个品牌的官 方网站上购买产品，因此在国外，独立站有较大发展空间。\n做独立站还有一个好处，就是可以做出更加精美的展示页面，这对于服饰类商家来说是比较重要的。亚马逊、eBay的展现页面总体上比较简约，展现服饰类商品 时有所不足，而海外用户2021年也暂时没有养成在社交媒体上下单的购物习惯（事实上他们非常在意购物的隐私，因此海外用户是否会像我国用户一样在抖音上 下单，需要多久养成这个习惯，都需要时间观察）。因此，独立站对于服装等一些品类而言，是一个非常好的选择。\n独立站的启动难度和经营风险都是最高的。\n第一，海外网购的主要支付方式是信用卡的安全码，用户由于害怕卡片被盗刷，因此很少在自己不信任的平台上下单。 第二，亚马逊等平台上的大卖家和品牌商可以直接使用平台提供的仓储服务，但独立站通常需要自建海外仓库，所有的东西都从国内跨境发货，时效性和用户 体验都会很差。由于难度大、风险高，独立站在最近几年才逐渐发展起来。 6.4 结语 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC6%E7%AB%A0-%E4%BE%9B%E5%BA%94%E9%93%BE-%E4%B8%AD%E5%9B%BD%E6%B6%88%E8%B4%B9%E7%9A%84%E5%BA%95%E6%B0%94/","summary":"6.1 数解中国供应链 在我国强大的商品供应链之下，质量过硬的商品能以低廉的成本大量产出。 图6-1 拼多多、1688上有许多高性价比的消费品 图6-2 2","title":"第6章 供应链 中国消费的底气"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/cnnic/","summary":"主页","title":"中国互联网络信息中心"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/euromonitor/","summary":"主页","title":"Euromonitor"},{"content":"6.1 进程、线程与协程 6.1.1 进程 现代操作系统利用硬件提供的页表机制，通过为不同进程分配独立的页表，实现进程间地址空间的隔离。\n图6-1 进程间地址空间的隔离\nLinux通过clone系统调用来创建新的进程。\n6.1.2 线程 为什么要有一个用户栈和一个内核栈呢？\n因为我们的线程在执行过程中经常需要在用户态和内核态之间切换，通过系统调用进入内核态使用系统资源。 对于内核来讲，任何的用户代码都被视为不安全的，可能有Bug或者带有恶意的代码，所以操作系统不允许用户态的代码访问内核数据。 图6-2 线程的用户栈和内核栈\n调度系统切换线程时，如果两个线程属于同一个进程，开销要比属于不同进程时小得多\n因为不需要切换页表，相应地，TLB缓存也就不会失效。 同一个进程中的多个线程，因为共享同一个虚拟地址空间，所以线程间数据共享变得十分简单高效 图6-3 同进程间线程切换\n在线程切换频繁时，调度本身的开销会占用大量CPU资源，造成系统吞吐量严重下降。\n6.1.3 协程 从具体实现来看，纤程就是一个由入口函数地址、参数和独立的用户栈组成的任务，相当于让线程可以有多个用户栈\n图6-4 纤程概念示意图\n6.2 IO多路复用 6.2.1 3种网络IO模型 把一个常见的TCP socket的recv请求分成两个阶段：一是等待数据阶段，等待网络数据就绪；二是数据复制阶段，把数据从内核空间复制到用户空间。\n对于阻塞式IO来讲，整个IO过程是一直阻塞的，直至这两个阶段都完成。\n图6-5 经典的阻塞式网络IO模型\n如果想要启用非阻塞式IO，需要在代码中使用fcntl()函数将对应socket的描述符设置成O_NONBLOCK模式。\n在非阻塞模式下，线程等待数据的时候不会阻塞，从编程角度来看就是recv()函数会立即返回，并返回错误代码EWOULDBLOCK（某些平台的SDK也可能是 EAGAIN），表明此时数据尚未就绪，可以先去执行别的任务。 程序一般会以合适的频率重复调用recv()函数，也就是进行轮询操作。在数据就绪之前，recv()函数会一直返回错误代码EWOULDBLOCK。 等到数据就绪后，再进入复制数据阶段，从内核空间到用户空间。 因为非阻塞模式下的数据复制也是同步进行的，所以可以认为第二阶段也是阻塞的。 图6-6 非阻塞式网络IO模型\n有了非阻塞式IO是不是就万事大吉了呢？\n虽然第一阶段不会阻塞，但是需要频繁地进行轮询。一次轮询就是一次系统调用，如果轮询的频率过高就会空耗CPU，造成大量的额外开销 如果轮询频率过低，就会造成数据处理不及时，进而使任务的整体耗时增加。 IO多路复用技术就是为解决上述问题而诞生的\n与非阻塞式IO相似，从socket读写数据不会造成线程挂起。 在此基础之上把针对单个socket的轮询改造成了批量的poll操作，可以通过设置超时时间选择是否阻塞等待。 只要批量socket中有一个就绪了，阻塞挂起的线程就会被唤醒，进而去执行后续的数据复制操作。 图6-7 IO多路复用\n6.2.2 示例对比 6.3 巧妙结合 把每个网络请求放到一个单独的协程中去处理，底层的IO事件循环在处理不同的socket时直接切换到与之关联的协程栈\n图6-10 协程与IO多路复用的结合\n这样一来，就把IO事件循环隐藏到了runtime内部，开发者可以像阻塞式IO那样平铺直叙地书写代码逻辑，尽情地把数据存放在栈帧上的局部变量中，代码执行 网络IO时直接触发协程切换，切换到下一个网络数据已经就绪的协程。当底层的IO事件循环完成本轮所有协程的处理后，再次执行netpoll，如此循环往复，开 发者不会有任何感知，程序却得以高效执行。\n6.4 GMP模型 6.4.1 基本概念 G指的就是goroutine；M是Machine的缩写，指的是工作线程；P则是指处理器Processor，代表了一组资源，M要想执行G的代码，必须持有一个P才行。\n6.4.2 从GM到GMP 在早期版本的Go实现中（1.1版本之前），是没有P的，只有G和M\n图6-11 GM调度模型\nGM调度模型有几个明显的问题\n用一个全局的mutex保护着一个全局的runq（就绪队列），所有goroutine的创建、结束，以及调度等操作都要先获得锁，造成对锁的争用异常严重。 G的每次执行都会被分发到随机的M上，造成在不同M之间频繁切换，破坏了程序的局部性 每个M都会关联一个内存分配缓存mcache，造成了大量的内存开销，进一步使数据的局部性变差。 在存在系统调用的情况下，工作线程经常被阻塞和解除阻塞，从而增加了很多开销。 为了解决上述这些问题，新的调度器被设计出来。\n总体的优化思路就是将处理器P的概念引入runtime，并在P之上实现工作窃取调度程序。 M仍旧是工作线程，P表示执行Go代码所需的资源。当一个M在执行Go代码时，它需要有一个关联的P，当M执行系统调用或者空闲时，则不需要P。 图6-12 GMP调度模型\n本地runq和全局runq 当一个G从等待状态变成就绪状态后，或者新创建了一个G的时候，这个G会被添加到当前P的本地runq。 当M执行完一个G后，它会先尝试从关联的P的本地runq中取下一个，如果本地runq为空，则到全局runq中去取 如果全局runq也为空，就会去其他的P那里窃取一半的G过来。 图6-13 本地runq为空到全局runq获取G\n图6-14 全局runq也为空窃取其他P的G\nM的自旋 当一个M进入系统调用时，它必须确保有其他的M来执行Go代码。新的调度器设计引入了一定程度的自旋，就不用再像之前那样过于频繁地挂起和恢复M了，这 会多消耗一些CPU周期，但是对整体性能的影响是正向的。 自旋分两种：第一种是一个有关联P的M，自旋寻找可执行的G；第二种是一个没有P的M，自旋寻找可用的P。这两种自旋的M的个数之和不超过GOMAXPROCS， 当存在第二种自旋的M时，第一种自旋的M不会被挂起(因为P不够)。 当一个新的G被创建出来或者M即将进行系统调用，或者M从空闲状态变成忙碌状态时，它会确保至少有一个处于自旋状态的M（除非所有的P都忙碌），这样保 证了处于可执行状态的G都可以得到调度，同时还不会频繁地挂起、恢复M。 6.5 GMP主要数据结构 6.5.1 runtime.g runtime.g部分字段\n表6-1 runtime.g部分字段的用途\nstack是个结构体类型, 用来描述goroutine的栈空间的，对应的内存区间是一个左闭右开区间[lo，hi]。\n1 2 3 4 type stack struct { lo uintptr hi uintptr } sched用来存储goroutine执行上下文, 它与goroutine协程切换的底层实现直接相关，其对应的gobuf结构代码如下\nsp字段存储的是栈指针 pc字段存储的是指令指针 g用来反向关联到对应的G ctxt指向闭包对象，也就是说用go关键字创建协程的时候传递的是一个闭包，这里会存储闭包对象的地址 ret用来存储返回值，实际上是利用AX寄存器实现类似C函数的返回值，目前只发现panic-recover机制用到了该字段。lr在arm等架构上用来存储返回地址， x86没有用到该字段 bp用来存储栈帧基址。 atomicstatus描述了当前G的状态\n表6-2 atomicstatus的取值及其含义\nwaiting对应的sudog结构\n6.5.2 runtime.m runtime.m部分字段\n表6-3 runtime.m部分字段的用途\n6.5.3 runtime.p runtime.p部分字段\n表6-4 runtime.p各个字段的主要用途\nstatus字段有5种不同的取值，分别表示P所处的不同状态\n表6-5 P的不同状态\n6.5.4 schedt Go 1.16版源代码中的schedt结构定义\n表6-6 schedt部分字段的主要用途\n","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC6%E7%AB%A0-goroutine/","summary":"6.2 IO多路复用写的不是特别详细","title":"第6章 Goroutine"},{"content":" ","permalink":"https://jdxj.github.io/posts/hello/","summary":"用于测试hugo特性.","title":"Hello Hugo!"},{"content":"5.1 中国零售渠道概览 我国的零售渠道分布情况在世界范围内都很独特，其独特性主要归为两点。\n我国电商渠道无比发达。 我国传统零售渠道的占比仍然很高。 图5-1 2021年我国零售渠道份额分布, 注：由于四舍五入，相加不为100%\n电商已经成为我国零售商业的一个重要成长来源。\n我国零售商业与西方国家非常大的一个差异在于线下零售的发达程度\n西方国家在线下发展完善之后才出现了电商，因此电商的推进速度并不快 我国线下零售在发展到一半的时候就受到了电商崛起的冲击，在电商逐渐趋于成熟之后，线下零售的发展遭受到了一定的压制。 图5-2 我国各零售渠道规模增速\n目前我国零售商业的形态是比较割裂的。\n一边是先进高效、已经具备世界领先水平的电商渠道，另一边则是仍然占据较大市场份额的传统零售渠道 我国拥有复杂的城市层级结构，这些传统零售渠道遍布在广大的市井之中。这种割裂的环境未来可能仍将伴随中国消费行业不断前行。 思考零售渠道，就是思考“人”“货”“场”之间的关系。\n“人-货-场”是零售商业中一个经典的分析模型。零售生意的本质，就是把“人”和“货”通过“场”连接起来。\n具体来说，“人”指的就是消费者，对应的是消费者的画像和其消费诉求； “货”指的选品，对应的是商场中的品类结构、产品价格带、品牌阶层等； “场”指的是消费者购物的场所，场所的位置在哪儿、商品如何陈列、要放多少个SKU，都是这个环节的核心问题。 渠道需求分析框架：多快好省\n对人的分析，其实就是对消费者需求的分析。人物画像、用户层级等数据，其实最后都要归到多、快、好、省这四个维度中来。\n其中，“多”代表可选择的商品多，消费者能够找到所需要的所有商品； “快”代表方便快捷，包括购物所需时间短、门店离消费者近，以及网购时配送速度快； “好”不但代表商品的质量又好又稳定，也代表购物体验的优势； “省”则是价格便宜。 图5-3 不同渠道在多、快、好、省上有不同侧重点\n处于不同位置的渠道，分析时有不同的侧重点。\n比如，对于超市这种品类“多”的渠道，我们要考量其动销情况，并且要重点关注其经营效率； 对于便利店这种注重“快”的渠道，要密切关注门店的数量和密度； 对于京东这样通过自营物流做到“快”和“好”的渠道，则要密切关注物流的覆盖面和经营效率。 货：不同的渠道适合不同的品类，区分盈利品类和引流品类\n在渠道商业中，品类的聚集效应是一个非常重要的规律。同一类商品的门店聚集在一起，能够汇聚更多的人流量，实现相互引流，使得彼此的生意都变得更好。\n从线下线上渠道的对比上看，线上渠道适合标准化、重复消费的商品，线下渠道则适合注重体验感和即时性的品类。\n图5-4 2021年各大消费品品类的线上渗透率\n我们在分析渠道品类结构的时候，也要注意区分引流品类和利润品类。\n有的品类能够吸引很多的人流量，但不一定能够产生太高的利润； 另外一些品类不具备引流的能力，却是渠道的利润中心。 场：经销、代销、联营、租赁的商业模式解析\n租赁就是把自己的地盘租给别人经营，并收取一定的租金，业主基本不会介入太多日常经营。 经销就是自己选品，以自有资金大批量进货，赚取批发和零售之间的差价，并承担商品滞销、贬值等风险。总的来说，租赁是风险最低、介入经营程度最低的 模式，而经销是风险最高、介入经营程度最高的模式。 代销和联营是比较难以理解的两个模式，处于经销和租赁的中间。代销是指把商品放在他人的店铺中，由他人代为销售，存货风险由自己承担。 联营是指与他人联合经营，比如由他人负责提供场地，并负责装修和固定资产的购置，而己方负责进货、生产、销售等环节，并按照事先约定进行利润分成。 具体的例子, 假设小明同学要卖面包，他有如下经营方式可选\n①租下一个门店，自己装修开业，成为面包店店主，这是经销模式，而出租这家门店的业主，则以租赁模式参与了零售商业； ②把自己手中的面包放在由他人运营的超市货架上，由超市帮忙出售，每卖出一个面包就与超市分成结算，所有卖不出去的都算在小明头上，这是代销； ③盘下楼下超市的一个面包柜台，自己站在柜台前销售自己的面包，并以固定租金或扣点的形式与超市分账，这是联营。 有时我们也会简化以上分类，而用“1P”和“3P”来区分零售商业公司的经营业态。1P指的是自营，3P指的是平台。\n1P就是“1st-Party”，指的是销售商品的货值会呈现在企业报表的收入和营业成本之中；京东 3P是“3rd-Party”，指的是企业销售商品的货值不会呈现在报表的收入和成本项中。天猫 5.2 中国电商，世界第一 图5-5 2019年各国零售电商销售额\n电商也已经渗入我国居民生活的方方面面。\n图5-6 中国历年电商渗透率\n发达便利的快递网络、扎实的移动网络建设，使得身处中小城镇乃至乡村的居民，也能享受到网购带来的实惠与便利。\n图5-7 中国网购用户已突破8亿人, 注：2021H1表示2021年上半年\n新冠肺炎疫情期间，电商是国民经济的压舱石，是居民日常消费的诺亚舟。\n图5-8 电商是我国社会零售额增长的重要引擎\n我们在分析消费品品牌时，必须重点关注其互联网运营能力以及在电商渠道上的表现。\n线上营销能力强、线上渠道建设较好的商家通常具备更好的发展前景； 而不重视线上化趋势的商家则有被时代淘汰的可能。 5.3 阿里巴巴、京东、拼多多：卖货还是卖流量 阿里巴巴、京东、拼多多是我国市场份额前三的电商平台。尽管它们都被消费者称为“平台”，但盈利方式和商业实质却存在着根本上的不同。\n图5-9 2020年中国电商平台市场份额\n线下零售生意分为买卖和收租，前者卖货，后者卖流量\n平台电商≈购物中心或小商品城，自营电商≈百货商超\n简单对比平台电商和自营电商：\n平台电商更轻，自营电商更重。平台电商的核心资产在于流量本身，重点是要做好流量的聚合与分发。这些平台的实物资产可能只是一些服务器，但平台自有 流量的价值远远高于这些服务器的价值。 自营电商的核心资产是履约体系，通常包括大量的仓库、运输车辆、配送人员等。履约体系是其保证大规模、高效率、好体验的根基所在。 平台电商：更应关注GMV和货币化率\nGMV指用户下单的总金额 货币化率等于平台收入除以GMV，这是反映平台盈利能力的重要指标。 自营电商：关注收入、利润率、周转率\n一般而言，我们需要关注毛利率、履约毛利率、营业利润率等指标：\n①毛利率直接反映了平台进销差价及其变化幅度。 ②履约毛利率是毛利率减去仓储、物流的费用率，这个指标直接反映了平台的边际利润率，即每一笔订单能够赚到的钱。对于一个健康的平台而言，履约毛利 率最好为正数，否则将“做一单亏一单”。 ③营业利润率是在履约毛利率的基础上，进一步扣减营销、管理、研发费用率得来的，反映了平台的整体盈利水平。 5.4 淘宝、天猫、拼多多的利润实质是广告收入 阿里巴巴本质上是一家以广告费和佣金为主要收入来源的“线上商业地产公司”\n佣金是如何产生的？\n在交易环节，淘宝平台的商家是免佣金的；天猫平台的商家需要向阿里巴巴支付固定金额的年费，以及占成交额一定比例的佣金。佣金率主要根据品类而定，平 时很少调整，大多数品类的佣金率介于0.3%～5%之间。其中，服装、化妆品的佣金率较高，充值、3C数码产品的佣金率较低。\n表5-1 天猫平台2020年各经营类目佣金率及年费\n淘系电商有着多种多样的广告投放工具\n阿里巴巴佣金货币化率的小幅提升主要来自\n①天猫平台成交额占比的提升，淘宝平台不收取佣金，天猫占比越高，佣金货币化率越高； ②天猫高佣金货币化率品类的成交额占比提升。广告费货币化率的提升是平台货币化率增长的核心驱动力。 图5-10 阿里巴巴货币化率及构成\n为何阿里巴巴的广告费货币化率能够连续多年实现增长？\n阿里巴巴推出了B2C平台“天猫”，直接与品牌商合作。 增加移动端广告库存。广告库存可以直接理解为广告位的数量，这个指标与广告收入、货币化率都有较强的相关性。 上线“千人千面”的推荐机制。个性化算法 拼多多也是一个“卖流量”的平台\n从平台经营实质上来看，如今的拼多多与阿里巴巴差异不大，都是通过商家的投放来盈利。拼多多和阿里巴巴的主要区别在于平台上的商家构成不同，以及用户 对于这两个平台的心智定位不同，即淘宝天猫代表品牌商品，而拼多多代表非品牌商品或折扣商品。\n拼多多如果不能实现品牌化，那未来的潜在盈利能力还高吗？\n高。去品牌化不意味着没有盈利能力，拼多多的货币化率已经接近阿里巴巴了。我国的消费品制造业世界领先，在多个地区拥有多类消费品产业集群，如浙 江小商品、江苏家纺等，这些集群的产品物美价廉却缺乏销路，而拼多多是一个好的去处。\n5.5 结语 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC5%E7%AB%A0-%E6%B8%A0%E9%81%93-%E4%BA%92%E8%81%94%E7%BD%91%E5%92%8C%E7%94%B5%E5%95%86%E6%98%AF%E4%B8%AD%E5%9B%BD%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%98%E9%87%8F/","summary":"5.1 中国零售渠道概览 我国的零售渠道分布情况在世界范围内都很独特，其独特性主要归为两点。 我国电商渠道无比发达。 我国传统零售渠道的占比仍然很高。 图","title":"第5章 渠道 互联网和电商是中国消费行业的核心变量"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/news/bloomberg/","summary":"主页","title":"Bloomberg"},{"content":"多线程并发读/写同一个TCP socket是线程安全的，因为TCP socket的读/写操作都上锁了。虽然线程安全，但依然不建议你这么做，因为TCP本身是基于数据流的协 议，一份完整的消息数据可能会分开多次去写/读，内核的锁只保证单次读/写socket是线程安全，锁的粒度并不覆盖整个完整消息。因此建议用一个线程去 读/写TCP socket。\n多线程并发读/写同一个UDP socket也是线程安全的，因为UDP socket的读/写操作也都上锁了。UDP写数据报的行为是\u0026quot;原子\u0026quot;的，不存在发一半包或收一半包的问题， 要么整个包成功，要么整个包失败。因此多个线程同时读写，也就不会有TCP的问题。虽然如此，但还是建议用一个线程去读/写UDP socket。\n原文\n","permalink":"https://jdxj.github.io/posts/articles/weixin/socket%E6%98%AF%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97/","summary":"多线程并发读/写同一个TCP socket是线程安全的，因为TCP socket的读/写操作都上锁了。虽然线程安全，但依然不建议你这么做，因为T","title":"Socket是并发安全的吗"},{"content":"主要看下模型对比.\n原文\n","permalink":"https://jdxj.github.io/posts/articles/skychen1218/rabbitmq%E4%B8%8Ekafka%E9%80%89%E5%9E%8B%E5%AF%B9%E6%AF%94/","summary":"主要看下模型对比. 原文","title":"RabbitMQ与Kafka选型对比"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/rude3knife/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/","summary":"原文","title":"缓存与数据库一致性问题深度剖析"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/duck-and-duck/%E8%80%81%E6%9D%BF%E8%A6%81%E6%88%91%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%BC%95%E6%93%8E/","summary":"原文","title":"老板要我开发一个简单的工作流引擎"},{"content":"DDD 是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。\n原文\n","permalink":"https://jdxj.github.io/posts/articles/courage129/ddd%E5%85%B4%E8%B5%B7%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB/","summary":"DDD 是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。 原文","title":"DDD兴起的原因以及与微服务的关系"},{"content":"5.1 空接口 是指不包含任何方法的接口interface{}\n5.1.1 一个更好的void∗ 如果用unsafe.Sizeof()函数获取一个interface{}类型变量的大小，在64位平台上是16字节，在32位平台上是8字节。interface{}类型本质上是个 struct，由两个指针类型的成员组成，在runtime中可以找到对应的struct定义\n1 2 3 4 type eface struct { _type *_type data unsafe.Pointer } 还有一个专门的类型转换函数efaceOf()，该函数接受的参数是一个interface{}类型的指针，返回值是一个eface类型的指针，内部实际只进行了一下指针类 型的转换，也就说明interface{}类型在内存布局层面与eface类型完全等价。\n1 2 3 func efaceOf(ep *interface{}) *eface { return (*eface)(unsafe.Pointer(ep)) } data字段是一个unsafe.Pointer类型的指针，用来存储实际数据的地址。 unsafe.Pointer在含义上和C语言中的void∗有些类似，只用来表明这是一个指针，并不限定指向的目标数据的类型，可以接受任意类型的地址。 _type字段用来描述data的类型元数据 1 2 3 // 第5章 code_5_1.go var n int var e interface{} = \u0026amp;n 图5-1 空接口变量e与赋值变量n的关系\n就变量n本身而言，它的类型信息只会被编译器使用，编译阶段参考这种类型信息来分配存储空间、生成机器指令，但是并不会把这种类型信息写入最终生成的 可执行文件中。从内存布局的角度来讲，变量n在64位和32位平台分别占用8字节和4字节，占用的这些空间全部用来存放整型的值，没有任何空间被用来存放整 型类型信息。\n把变量n的地址赋值给interface{}类型的变量e的这个操作，意味着编译器要把∗int的类型元数据生成出来，并把其地址赋给变量e的_type字段，这些类型元 数据会被写入最终的可执行文件\n1 2 3 4 5 // 第5章 code_5_2.go func p2e(p *int) (e interface{}) { e = p return } 反编译p2e()\n等价伪代码\n对于interface{}类型的变量e，它的声明类型是interface{}, _type会随着变量e装载不同类型的数据而发生改变，所以后文中将它称为变量e的动态类型， 并相应地把变量e的声明类型称为静态类型。\n5.1.2 类型元数据 在C语言中类型信息主要存在于编译阶段，编译器从源码中得到具体的类型定义，并记录到相应的内存数据结构中，然后根据这些类型信息进行语法检查、生成 机器指令等。例如x86整数加法和浮点数加法采用完全不同的指令集，编译器根据数据的类型来选择。这些类型信息并不会被写入可执行文件，即使作为符号数 据被写入，也是为了方便调试工具，并不会被语言本身所使用。\nGo与C语言不同的是，在设计之初就支持面向对象编程，还有其他一些动态语言特征，这些都要求运行阶段能够获得类型信息，所以语言的设计者就把类型信息 用统一的数据结构来描述，并写入可执行文件中供运行阶段使用，这就是所谓的类型元数据。\nGo 1.15版本的runtime源码\n表5-1 _type各字段的含义及主要用途\n_type提供了适用于所有类型的最基本的描述，对于一些更复杂的类型，例如复合类型slice和map等，runtime中分别定义了maptype、slicetype等对应的 结构。\n1 2 3 4 type slicetype struct { typ _type elem *_type } Go语言允许为自定义类型实现方法，这些方法的相关信息也会被记录到自定义类型的元数据中，一般称为类型的方法集信息。\n1 type Integer int 图5-2 自定义类型Integer的类型元数据结构\n_type结构的tflag字段是几个标志位，当tflagUncommon这一位为1时，表示类型为自定义类型。从runtime的源码可以发现，_type类型有一个 uncommon()方法，对于自定义类型可以通过此方法得到一个指向uncommontype结构的指针\nuncommontype结构的定义代码如下：\n通过pkgpath可以知道定义该类型的包名称 mcount表示该类型共有多少个方法 xcount表示有多少个方法被导出 moff是个偏移值，那里就是方法集的元数据，也就是一组method结构构成的数组。 例如，若为自定义类型Integer定义两个方法，它的类型元数据及其method数组的内存布局如图5-3所示。\n图5-3 Integer类型元数据及其method数组的内存布局\n可以将type method struct理解为tcp封包中的header.\n图5-4 method数组排序\n通过name偏移能够找到方法的名称字符串 mtyp偏移处是方法的类型元数据，进一步可以找到参数和返回值相关的类型元数据。 ifn是供接口调用的方法地址 tfn是正常的方法地址，这两个方法地址有什么不同呢？ifn的接收者类型一定是指针，而tfn的接收者类型跟源代码中的实现一致 以上这些类型元数据都是在编译阶段生成的，经过链接器的处理后被写入可执行文件中，runtime中的类型断言、反射和内存管理等都依赖于这些元数据.\n5.1.3 逃逸与装箱 data字段是个指针，那么它是如何接收来自一个值类型的赋值的呢？\n1 2 3 // 第5章 code_5_3.go n := 10 var e interface{} = n 图5-5 interface{}类型的变量e的数据结构\n把第5章/code_5_3.go放到一个函数中\n1 2 3 4 5 // 第5章 code_5_4.go func v2e(n int) (e interface{}) { e = n return } 反汇编\n等价的伪代码\nruntime.convT64()函数的源代码\nstaticuint64s是个长度为256的uint64数组，每个元素的值都跟下标一致，存储了0～255这256个值，主要用来避免常用数字频繁地进行堆分配。\n图5-6 staticuint64s数组\n图5-7 变量e的数据结构\n值类型装箱就一定会进行堆分配吗？\n1 2 3 4 5 6 7 8 // 第5章 code_5_5.go func fn(n int) bool { return notNil(n) } func notNil(a interface{}) bool { return a != nil } 编译时需要禁止内联优化，编译器还能够通过notNil()函数的代码实现判定有没有发生逃逸，反编译fn()函数得到的汇编代码如下\n转换为等价的伪代码\n图5-8 fn()函数的调用栈\n注意局部变量v，它实际上是被编译器采用隐式方式分配的，被用作变量n的值的副本，却并没有分配到堆上。\ninterface{}在装载值的时候必须单独复制一份，而不能直接让data存储原始变量的地址，因为原始变量的值后续可能会发生改变，这就会造成逻辑错误。\n5.2 非空接口 5.2.1 动态派发 多态\n方法地址静态绑定 要进行方法（函数）调用，有两点需要确定：\n一是方法的地址，也就是在代码段中的指令序列的起始地址； 二是参数及调用约定，也就是要传递什么参数及如何传递的问题（通过栈或者寄存器），返回值的读取也包含在调用约定范畴内。 不使用接口而直接通过自定义类型的对象实例调用其方法的例子\n1 2 3 4 //go:noinline func ReadFile(f *os.File, b[]byte) (n int, err error) { return f.Read(b) } 反编译\n伪代码\n从汇编语言的角度来看，上述方法的调用是通过CALL指令＋相对地址实现的，方法地址在可执行文件构建阶段就确定了，一般将这种情况称为 方法地址的静态绑定。\n对于动态派发来讲，编译阶段能够确定的是要调用的方法的名字，以及方法的原型（参数与返回值列表）。\n动态查询类型元数据 让我门设计动态派发\n例子代码\n1 2 var r io.Reader = f n, err := r.Read(buf) 首先，可以通过变量r得到∗os.File的类型元数据 然后根据方法名称Read以二分法查找匹配的method结构 找到后再根据method.mtyp得到方法本身的类型元数据 最后对比方法原型是否一致（参数和返回值的类型、顺序是否一致）。 如果原型一致，就找到了目标方法，通过method.ifn字段得到方法的地址，然后就像调用普通函数一样调用就可以了。 图5-9 ∗os.File的类型元数据\n单就动态派发而言，这种方式确实可以实现，但是有一个明显的问题，那就是效率低，或者说性能差。\n跟地址静态绑定的方法调用比起来，原本一条CALL指令完成的事情，这里又多出了一次二分查找加方法原型匹配，增加的开销不容小觑，可能会造成动态派发 的方法比静态绑定的方法多一倍开销甚至更多，所以必须进行优化。 不能在每次方法调用前都到元数据中去查找，尽量做到一次查找、多次使用，这里可以一定程度上参考C++的虚函数表实现。 C++虚函数机制 C++中的虚函数机制跟接口的思想很相似，编程语言允许父类指针指向子类对象，当通过父类的指针来调用虚函数时，就能实现动态派发。\n具体实现原理就是\n编译器为每个包含虚函数的类都生成一张虚函数表，实际上是个地址数组，按照虚函数声明的顺序存储了各个虚函数的地址。 此外还会在类对象的头部安插一个虚指针（GCC安插在头部，其他编译器或有不同），指向类型对应的虚函数表。 运行阶段通过类对象指针调用虚函数时，会先取得对象中的虚指针，进一步找到对象类型对应的虚函数表，然后基于虚函数声明的顺序，以数组下标的方式从 表中取得对应函数的地址，这样整个动态派发过程就完成了。 测试代码\n输出\nA,8 B,16 图5-10 C++虚函数动态派发示例\n参考C++的虚函数表思想，再回过头来看Go语言中接口的设计，如果把这种基于数组的函数地址表应用在接口的实现中，基本就能消除每次查询地址造成的性能 开销。显然这里需要对eface结构进行扩展，加入函数地址表相关字段，经过扩展的eface姑且称作efacex\n怪不得叫tab (table)\n图5-11 参照C++虚函数机制修改后的非空接口数据结构\n什么时候为fun数组赋值呢？当然是在为整个efacex结构赋值的时候最合适\n1 2 3 4 // 第5章 code_5_9.go f, _ := os.Open(\u0026#34;gom.go\u0026#34;) var rw io.ReadWriter rw = f 从f到rw这个看似简单的赋值，至少要展开成如下几步操作：\n①根据rw接口中方法的个数动态分配tab结构，这里有两个方法，fun数组的长度是2。 ②从∗os.File的方法集中找到Read()方法和Write()方法，把地址写入fun数组对应下标。 ③把∗os.File的元数据地址赋值给tab._type。 ④把f赋值给data，也就是数据指针。 图5-12 基于efacex设计的非空接口变量rw赋值后的数据结构\n实际上，fun数组也不用每次都重新分配和初始化，从指定具体类型到指定接口类型变量的赋值，运行阶段无论发生多少次，每次生成的fun数组都是相同的。例 如从∗os.File到io.ReadWriter的赋值，每次都会生成一个长度为2的fun数组，数组的两个元素分别用于存储(∗os.File).Read和(∗os.File).Write的 地址。也就是说通过一个确定的接口类型和一个确定的具体类型，就能够唯一确定一个fun数组，因此可以通过一个全局的map将fun数组进行缓存，这样就能进 一步减少方法集的查询，从而优化性能。\n5.2.2 具体实现 实际上在Go语言的runtime中与非空接口对应的结构类型是iface\n因为也是通过数据指针data来装载数据的，所以也会有逃逸和装箱发生。其中的itab结构就包含了具体类型的元数据地址_type，以及等价于虚函数表的方法地 址数组fun，除此之外还包含了接口本身的类型元数据地址inter\n接口类型元数据 除去最基本的typ字段，pkgpath表示接口类型被定义在哪个包中，mhdr是接口声明的方法列表。\n比自定义类型的method结构少了方法地址，只包含方法名和类型元数据的偏移。\n这些偏移的实际类型为int32，与指针的作用一样，但是64位平台上比使用指针节省一半空间。 以ityp为起点，可以找到方法的参数（包括返回值）列表，以及每个参数的类型信息，也就是说这个ityp是方法的原型信息。 图5-13 io.ReadWriter类型的变量rw的数据结构\n如何获得itab 运行阶段可通过runtime.getitab函数来获得相应的itab，该函数被定义在runtime包中的iface.go文件中\n1 func getitab(inter *interfacetype, typ *_type, canfail bool) *itab 前两个参数inter和typ分别是接口类型和具体类型的元数据，canfail表示是否允许失败。如果typ没有实现inter要求的所有方法，则canfail为true时函 数返回nil，canfail为false时就会造成panic。对应到具体的语法就是comma ok风格的类型断言和普通的类型断言\n1 2 r, ok := a.(io.Reader) // comma ok r := a.(io.Reader) //有可能造成panic getitab()函数的代码摘抄自Go语言runtime源码\n函数的主要逻辑如下：\n①校验inter的方法列表长度不为0，为没有方法的接口生成itab是没有意义的。 ②通过typ.tflag标志位来校验typ为自定义类型，因为只有自定义类型才能有方法集。 ③在不加锁的前提下，以inter和typ作为key查找itab缓存itabTable，找到后就跳转到⑤。 ④加锁后再次查找缓存，如果没有就通过persistentalloc()函数进行持久化分配，然后初始化itab并调用itabAdd添加到缓存中，最后解锁。 ⑤通过itab的fun[0]是否为0来判断typ是否实现了inter接口，如果没实现，则根据canfail决定是否造成panic，若实现了，则返回itab地址。 判断itab.fun[0]是否为零，也就是判断第一个方法的地址是否有效，因为Go语言会把无效的itab也缓存起来，主要是为了避免缓存穿透。缓存中查不到对应 的itab，就会每次都查询元数据的方法列表，从而显著影响性能，所以Go语言会把有效、无效的itab都缓存起来，通过fun[0]加以区分。\nfun[0] 相当于标记.\n图5-14 interfacetype和_type与itab的对应关系\nitab缓存 itabTable就是runtime中itab的全局缓存，它本身是个itabTableType类型的指针\nentries是实际的缓存空间 size字段表示缓存的容量，也就是entries数组的大小 count表示实际已经缓存了多少个itab。 entries的初始大小是通过itabInitSize指定的，这个常量的值为512。当缓存存满以后，runtime会重新分配整个struct，entries数组是 itabTableType的最后一个字段，可以无限增大它的下标来使用超出容量大小的内存，只要在struct之后分配足够的空间就够了，这也是C语言里常用的手法。\nitabTableType被实现成一个散列表。查找和插入操作使用的key是由接口类型元数据与动态类型元数据组合而成的，哈希值计算方式为接口类型元数据哈希值 inter.typ.hash与动态类型元数据哈希值typ.hash进行异或运算。\n图5-15 itabTableType哈希表\n方法find()和add()分别负责实现itabTableType的查找和插入操作，方法add()操作内部不会扩容存储空间，重新分配操作是在外层实现的，因此 对于find()方法而言，已经插入的内容不会再被修改，所以查找时不需要加锁。方法add()操作需要在加锁的前提下进行，getitab()函数是通过调用 itabAdd()函数来完成添加缓存的，itabAdd()函数内部会按需对缓存进行扩容，然后调用add()方法。因为缓存扩容需要重新分配itabTableType结构，为 了并发安全，使用原子操作更新itabTable指针。加锁后立刻再次查询也是出于并发的考虑，避免其他协程已经将同样的itab添加至缓存。\n通过persistentalloc()函数分配的内存不会被回收\nitab类型的init方法\ninit()函数内部就是遍历接口的方法列表和具体类型的方法集，来寻找匹配的方法的地址。 虽然遍历操作使用了两层嵌套循环，但是方法列表和方法集都是有序的，两层循环实际上都只需执行一次。 匹配方法时还会考虑方法是否导出，以及接口和具体类型所在的包。如果是导出的方法则直接匹配成功，如果方法未导出，则接口和具体类型需要定义在同一 个包中，方可匹配成功。 最后需要再次强调的是，对于匹配成功的方法，地址取的是method结构中的ifn字段 5.2.3 接收者类型 具体类型方法元数据中的ifn字段，该字段存储的是专门供接口使用的方法地址。所谓专门供接口使用的方法，实际上就是个接收者类型为指针的方法。\n还记不记得第4章中分析OBJ文件时，发现编译器总是会为每个值接收者方法包装一个指针接收者方法？这也就说明，接口是不能直接使用值接收者方法的， 这是为什么呢？\n5.2.2节已经看过了接口的数据结构iface，它包含一个itab指针和一个data指针，data指针存储的就是数据的地址。对于接口来讲，在调用指针接收者方法 时，传递地址是非常方便的，也不用关心数据的具体类型，地址的大小总是一致的。假如通过接口调用值接收者方法，就需要通过接口中的data指针把数据的值 复制到栈上，由于编译阶段不能确定接口背后的具体类型，所以编译器不能生成相关的指令来完成复制，进而无法调用值接收者方法。\n如果基于reflectcall()函数，能不能实现通过接口调用值接收者方法呢？\n肯定是可以实现的，接口的itab中有具体类型的元数据，确实能够应用reflectcall()函数 但是有个明显的问题，那就是性能太差。跟几条用于传参的MOV指令加一条普通的CALL指令相比，reflectcall()函数的开销太大了，所以Go语言选择为值 接收者方法生成包装方法。 对于代码中的值接收者方法，类型元数据method结构中的ifn和tfn的值是不一样的，指针接收者方法的ifn和tfn是一样的。 从类型元数据来看，T和∗T是不同的两种类型。\n接收者类型为T的所有方法，属于T的方法集。 因为编译器自动包装指针接收者方法的关系，∗T的方法集包含所有方法，也就是所有接收者类型为T的方法加上所有接收者类型为∗T的方法。 第1行输出打印出了Integer类型的方法集，String()和Value()这两个方法各自的IFn和TFn都不相等，这是因为IFn指向接收者为指针类型的方法代码， 而TFn指向接收者为值类型的方法代码。 第2行输出打印出了∗Integer类型的方法集，这两个方法各自的IFn和TFn是相等的，都与第1条指令中同名方法的IFn的值相等。 第3行输出打印出了Number接口itab中fun数组中的两个方法地址，与第1行输出Integer方法集中对应方法的IFn的值一致。 图5-16 Integer和∗Integer类型的方法集\n5.2.4 组合式继承 从方法集的角度进行分析\n看一下B、C、∗B和∗C会继承哪些方法\n表5-2 示例程序中各自定义类型包含的方法的情况\nGo语言不允许为T和∗T定义同名方法，实际上并不是因为不支持函数重载，前面已经看到了A.Value()方法和(∗A).Value()方法是可以区分的。其根本原因就 是编译器要为值接收者方法生成指针接收者包装方法，要保证两者的逻辑一致，所以不允许用户同时实现，用户可能会实现成不同的逻辑。\n5.3 类型断言 5.3.1 E To具体类型 1 2 3 func normal(a interface{}) int { return a.(int) } 反编译\n等价的伪代码\ncomma ok风格的断言\n1 2 3 4 func commaOk(a interface{}) (n int, ok bool) { n, ok = a.(int) return } 反编译\n等价的伪代码\n从interface{}到具体类型的断言基本上就是一个指针比较操作加上一个具体类型相关的复制操作\n图5-17 从interface{}到具体类型的断言\n5.3.2 E To I 1 2 3 func normal(a interface{}) io.ReadWriter { return a.(io.ReadWriter) } 反编译\n伪代码\nruntime.assertE2I()函数代码\n函数先校验了E的具体类型元数据指针不可为空，没有具体类型的元数据是无法进行断言的 然后通过调用getitab()函数来得到对应的itab，data字段直接复制。 注意调用getitab()函数时最后一个参数为false，根据之前的源码分析已知这个参数是canfail。canfail为false时，如果t没有实现inter要求的所有 方法，getitab()函数就会造成panic。 comma ok风格的断言\n1 2 3 4 func commaOk(a interface{}) (i io.ReadWriter, ok bool) { i, ok = a.(io.ReadWriter) return } 反编译\n伪代码\nruntime.assertE2I2()函数代码\nE To I形式的类型断言，主要通过runtime中的assertE2I()和assertE2I2()这两个函数实现，底层的主要任务如图5-18所示，都是通过getitab()函数 完成的方法集遍历及itab分配和初始化。因为getitab()函数中用到了全局的itab缓存，所以性能方面应该也是很高效的。\n图5-18 从interface{}到非空接口的类型断言\n5.3.3 I To具体类型 1 2 3 func normal(i io.ReadWriter) *os.File { return i.(*os.File) } 反汇编\n伪代码\n其中的go.itab.∗os.File，io.ReadWriter指的就是全局itab缓存中与∗os.File和io.ReadWriter这一对类型对应的itab。这个itab是在编译阶段就 被编译器生成的，所以代码中可以直接链接到它的地址。 这个断言的核心逻辑就是比较iface中tab字段的地址是否与目标itab地址相等。如果不相等就调用panicdottypeI，如果相等就把iface的data字段返回。 注意这里因为∗os.File是指针类型，所以不涉及自动拆箱，也就没有与具体类型相关的复制操作，如果具体类型为值类型就不然了。 comma ok风格的断言\n1 2 3 4 func commaOk(i io.ReadWriter) (f *os.File, ok bool) { f, ok = i.(*os.File) return } 反编译\n伪代码\nI To具体类型的断言与E To具体类型的断言在实现上极其相似，核心逻辑如图5-19所示，都是一个指针的相等判断。\n图5-19 从非空接口到具体类型的类型断言\n5.3.4 I To I 1 2 3 func normal(rw io.ReadWriter) io.Reader { return rw.(io.ReadWriter) } 反编译\n伪代码\nruntime.assertI2I()函数代码\n先校验i.tab不为nil，否则就意味着没有类型元数据，类型断言也就无从谈起 然后检测i.tab.inter是否等于inter，相等就意味着源接口和目标接口类型相同，直接复制就可以了。 最后才调用getitab()函数，根据inter和i.tab._type获取对应的itab。canfail参数为false，所以如果getitab()函数失败就会造成panic。 comma ok风格的断言\n1 2 3 4 func commaOk(rw io.ReadWriter) (r io.Reader, ok bool) { r, ok = rw.(io.Reader) return } 反编译\n伪代码\nruntime.assertI2I2()函数代码\n如果i.tab为nil，则直接返回false。 只有在i.tab.inter与inter不相等时才调用getitab()函数，而且canfail为true，如果getitab()函数失败，则不会造成panic，而是返回nil。 I To I的类型断言，实际上是通过runtime.assertI2I()函数和runtime.assertI2I2()函数实现的，底层也都是基于getitab()函数实现的。\n图5-20 从非空接口到非空接口的类型断言\n5.4 反射 5.4.1 类型系统 1. 类型信息的萃取 TypeOf()函数所做的事情如图5-21所示，就是找到传入参数的类型元数据，并以reflect.Type形式返回。\n图5-21 由一个∗_type和一个∗itab组建一个iface\nTypeOf()函数的代码\nemptyInterface类型和5.1节介绍过的eface类型在内存布局上等价，emptyInterface类型定义\n其中的rtype类型与runtime._type类型在内存布局方面也是等价的，只不过因为无法使用其他包中未导出的类型定义，所以需要在reflect包中重新定义一下。 代码中的eface.typ实际上就是从interface{}变量中提取出的类型元数据地址\n先判断了一下传入的rtype指针是否为nil，如果不为nil就把它作为Type类型返回，否则返回nil。 从这里可以知道∗rtype类型肯定实现了Type接口，之所以要加上这个nil判断，需要考虑到Go的接口类型是个双指针结构，一个指向itab，另一个指向实际 的数据对象。只有在两个指针都为nil的时候，接口变量才等于nil。 图5-22 萃取前判断非空\n通过代码说明接口何时为空\n在上述代码中第1个if处判断结果为真，所以会打印出1。第2个if处rw不再为nil，所以不会打印2。\ninterface{}中的类型元数据地址是从哪里来的呢？\n当然是在编译阶段由编译器赋值的，实际的地址可能是由链接器填写的，也就是说源头还是要追溯到最初的源码中。 2.类型系统的初始化 5.5 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC5%E7%AB%A0-%E6%8E%A5%E5%8F%A3/","summary":"5.1 空接口 是指不包含任何方法的接口interface{} 5.1.1 一个更好的void∗ 如果用unsafe.Sizeof()函数获取一个interfac","title":"第5章 接口"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 第4章 code_4_1.go package gom type Point struct { x float64 } func (p Point) X() float64 { return p.x } func (p *Point) SetX(x float64) { p.x = x } 4.1 接收者类型 为了排除编译器内联优化造成的干扰，下面采用只编译不链接的方式来得到OBJ文件，然后对编译得到的OBJ文件进行反编译分析\n1 $ go tool compile -trimpath=\u0026#34;`pwd`=\u0026gt;\u0026#34; -l -p gom point.go 通过go tool nm可以查看该文件中实现了哪些函数，nm会输出OBJ文件中定义或使用到的符号信息\npoint.o中一共实现了3个方法\n第1个是Point的SetX()方法，它的接收者类型是∗Point 第3个是Point的X()方法，它的接收者类型是Point 第二个方法是一个接收者类型为∗Point的X()方法 4.1.1 值类型 反编译Point.X()\n第4行代码用SP作为基址并加上8字节偏移，把该地址处的一个float64复制到X0寄存器中。 第5行代码用SP作为基址并加上16字节偏移，把X0中的float64复制到该地址处。 第6行代码就是普通的返回指令。 图4-1 调用Point.X()方法后的栈帧布局\n值类型的接收者实际上是作为第1个参数通过栈来传递的，与普通的函数调用并没有什么不同。\nGo语言允许通过方法的完全限定名称(Full Qualified Name)把方法当成一个普通函数那样调用，只不过需要把接收者作为第1个参数显式地传递\n1 2 p := Point{x: 10} Point.X(p) 可以认为p.X()这种写法只是编译器提供的语法糖，本质上会被转换为Point.X(p)这种普通的函数调用，而接收者就是隐含的第1个参数。\n4.1.2 指针类型 反编译SetX()\n第4行代码用SP作为基址加上16字节偏移，把该地址处的一个float64复制到X0寄存器中。 第5行代码用SP作为基址加上8字节偏移，把该地址处的一个64位数值复制到AX寄存器中。 第6行代码用AX作为基址，把X0寄存器中的float64复制到该地址处。 第8行是返回指令 图4-2 调用Point.SetX()方法后的栈帧布局\n跟值类型接收者类似，指针类型的接收者也是作为第1个参数来传递的，只不过传递的是一个地址。\n可以通过完全限定名称把指针接收者方法作为一个普通函数那样调用\n1 2 p := \u0026amp;Point{} (*Point).SetX(p, 10) 4.1.3 包装方法 查看自动生成的(*Point).X方法的汇编\n有autogenerated字样\n汇编(*Point).X的伪代码\n第1个if语句块通过比较栈指针SP和gp.stackguard0来判断是否需要栈增长。 第2个if用于检测是否正处于panic流程中，这种情况下当前方法应该是被某个defer直接或间接地调用了，要按需修改gp._panic.argp的值，因为当前方 法是编译器自动包装的，通过修改argp来跳过包装方法的栈帧，使后面调用的原始方法中的recover能够生效。 第3个if用于检测p是否为nil，因为包装方法需要根据p的地址得到∗p的值，如果地址为nil就调用runtime.panicwrap。 最后一步才是调用原始的Point.X()方法并传递∗p的值作为参数。 编译器会为代码中定义的值接收者方法生成指针接收者的包装方法，这在语义上是可行的，但反过来却不可以，因为通过传递的值是无法得到原始变量的地址的。\n看一下实际调用的是不是包装方法, 先添加一个函数\n1 2 3 func PointX(p *Point) float64 { return p.X() } 反编译\n可以看到p.X()实际上会在调用端对指针解引用，然后调用值接收者方法，并没有调用编译器生成的包装方法。\n栈分析\n28 return value of PointX (float64) 20 arg of PointX (address of p) 18 return address of PointX 10 bp -| 08 return value of X (float64) | stack of PointX 00 arg of X (p) -| 4.2 Method Value 把一个函数存储在一个变量中，这个变量就是一个Function Value。相应地，把一个方法存储在一个变量中，这个变量就是个Method Value。\n4.2.1 基于类型 1 x := Point.X 方法其实就是个普通的函数，接收者是隐含的第1个参数，所以这里可以推断，基于类型的Method Value就是个普通的Function Value，本质上是个两级指 针，而且第二级的指针是在编译阶段静态分配的。\n1 2 3 func GetX() func(Point) float64 { return Point.X } 上述代码可以成功编译，说明Point.X()函数可以被赋值给func(Point)float64类型的Function Value。接下来反编译GetX()函数\n第4行代码用IP作为基址加上一个偏移0来得到一个地址，这个0只作为预留的一个32位整数，等到链接阶段，链接器会填写上实际的偏移值。第4行代码得到的 地址被用作返回值，也就是最终的Function Value，而该地址处就是第二级指针\n4.2.2 基于对象 可以把一个对象的某个方法赋值给一个变量，这样就会得到一个基于对象的Method Value\n1 2 p := Point{x: 10} x := p.X 从语义角度来看，与基于类型的Method Value不同，基于对象的Method Value隐式地包含了对象的数据，所以在上述代码中调用x时不需要再显式地传递接 收者参数。第3章中已经了解了闭包的实现原理，所以这里推断x是个指向闭包对象的指针，通过闭包的捕获列表捕获了对象p。\n示例函数\n1 2 3 func X(p Point) func() float64 { return p.X } 反编译\n伪代码\n编译器为返回值自动定义了一个struct，第1个成员是一个函数指针，第2个成员是一个Point对象。对应到闭包对象的结构，捕获列表中是Point类型的对象， 闭包函数是gom.Point.X-fm()函数，也是由编译器自动生成的。反编译这个闭包函数\n伪代码\n主要逻辑就是通过DX寄存器得到闭包对象的地址，再以捕获列表里的Point对象的值作为参数调用Point.X()方法，并把Point.X()方法的返回值作为自己的 返回值。\n进一步探索会发现，闭包是捕获对象的值还是捕获地址，跟Method Value对应的方法接收者类型一致。上述示例中Point.X()方法的接收者为值类型，所以闭 包捕获的也是值类型，如果换成接收者为指针类型的∗Point.SetX()方法，闭包捕获列表中就会相应地变成指针类型。\n至此可以进行一下总结，基于类型的Method Value和基于对象的Method Value本质上都是Function Value，只不过前者是简单的两级指针，而后者通常是 个闭包（考虑编译器优化）。\n4.3 组合式继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 第4章 code_4_2.go package gom type Point2dV struct { Point y float64 } func (p Point2d) Y() float64 { return p.y } func (p *Point2d) SetY(y float64) { p.y = y } 4.3.1 嵌入值 图4-3 Point2d内存布局示意图\n再次用nm命令查看一下OBJ文件中为Point2d类型实现了哪些函数和方法\n最后一个函数是由编译器自动生成的，用于判断两个Point2d对象是否相等\n反编译Point2d.X()后的伪代码\n以p.Point为参数来调用Point.X()方法的代码，也就说明这是个包装方法，因此可以推测，编译器对于继承来的方法都是通过生成相应的包装方法来调用原始 方法的方式实现的。\n反编译(∗Point2d).SetX()\n第1条指令把接收者的值复制到AX寄存器中。 第2条指令尝试访问AX存储的地址处的数据，如果接收者为空指针就会触发空指针异常。 第3条指令把AX的值复制到栈上接收者参数的位置，这一行其实可以优化掉。 第4条指令用于跳转到(∗Point).SetX()方法的起始地址。 反编译一下(∗Point2d).X()方法，对照汇编整理出的伪代码如下：\n可以看到除了接收者为指针类型外，代码逻辑与Point2d.X()方法基本一致\n4.3.2 嵌入指针 1 2 3 4 5 6 7 // 第4章 code_4_3.go package gom type Point2dP struct { *Point y float64 } 图4-4 Point2d与Point的内存布局关系\n再用nm命令查看一下OBJ文件中为Point2d类型实现了哪些函数和方法\n这里值得注意的是Point2d.SetX()方法，它的存在意味着虽然接收者Point2d是通过值的形式传递的，但是通过Point2d的值可以得到原始Point对象的地址， 所以依然可以对原始Point对象进行修改。\n看一下在嵌入指针的情况下(∗Point2d).SetX()方法还会不会被优化处理\n编译器还进行了优化处理，第1行指令把栈上的接收者参数复制到AX寄存器中，其实也就是Point2d对象的地址。 第2行指令把Point2d的第1个字段的值复制到AX寄存器中，也就是Point对象的地址。 第3行指令把AX的值复制回栈上的接收者参数处。 第4行指令用于跳转到(∗Point).SetX()方法的起始地址。 至于其他3种方法，编译器都会生成相应的包装方法, 伪代码\n因为在嵌入指针的情况下总是能够得到基类对象的地址，所以子类中的值接收者方法可以调用基类中的指针接收者方法，编译器会尽可能把符合逻辑的包装方法 都生成出来。\n4.3.3 多重继承 首先定义两种类型A和B\n定义一种类型C，将A和B以值的形式嵌入\n通过nm命令查看编译生成的OBJ文件中都实现了哪些方法\n发现只有A和B的方法，编译器没有为C生成任何方法。结合Go语言官方文档的说明，因为同时嵌入A和B而且嵌套的层次相同，所以编译器不知道应该让包装方法 继承自谁，这种情况只能由程序员手工实现。\n定义一种类型D，把A以嵌入值的形式嵌入D中，然后把C中的A改成D\n再次通过nm命令查看\n这次类型C成功地继承了这一组方法，对这些方法进行反编译就能确定是继承自类型B，因为B的嵌套层次比A要浅，编译器优先选择短路径。\n4.4 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC4%E7%AB%A0-%E6%96%B9%E6%B3%95/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 第4章 code_4_1.go package gom type Point struct { x float64 } func (p Point) X() float64 { return p.x } func (p *Point) SetX(x float64) { p.x = x } 4.1 接收者类型 为了排除编译器内联优化造成的干扰，","title":"第4章 方法"},{"content":"2.1 车身规格 Body Specification 车宽尺寸包括后视镜吗？\n现在，全世界各汽车厂商在汽车车身规格的标注方面基本上都统一了，尤其是车身总长、轴距、轮距、前悬和后悬等规格上都完全一样。但是，在车身总宽和总 高上稍有区别\n车身尺寸标注示意图\n什么是汽车的通过性？\n指汽车通过各种坏路和无路地带以及克服各种障碍的能力。汽车的外形尺寸甚至直接决定了汽车的通过性能，如最小离地间隙、接近角和离去角、纵向通过角等。\n最大爬坡度\n一种是百分比坡度，它是指坡道的垂直高度与坡道的水平距离之比值，如30%，即表示此坡度为每前进100米，坡度便升高30米； 另一种表述方法是坡道的倾角度。 2.2 车身构造 Body Structure 为什么车身要由面板和骨架组成？\n车身面板只是汽车的“皮肤”，其实它的厚薄甚至强度如何，对汽车的安全性没有太大影响。 骨架的形状，基本决定了车身的造型。为了使车身更加安全，分散来自各方向的撞击力，现在的汽车厂商在设计汽车时往往都要把车身做成像一个鸟笼子那样， 也称为“网状交叉式设计”。 奥迪R8车身构造\n大众高尔夫汽车鸟笼车身骨架图\n什么是承载式车身和非承载式车身？\n承载式车身的汽车没有刚性车架，发动机、前后悬架、传动系统的一部分总成部件都装配在车身上，车身负载通过悬架装置传给车轮。\n承载式车身的优点是：公路行驶非常平稳，整个车身为一体，固有频率振动低，噪声小，重量轻，比较省油。 缺点：底盘强度远不如有大梁结构的非承载式车身；当四个车轮受力不均匀时，车身易发生变形。 承载式车身示意图\n非承载式车身的汽车有一刚性车架，又称底盘大梁，发动机、传动系统、车身等总成部件都固定在车架上，车架通过前后悬架与车轮连接。\n非承载式车身的优点是：底盘强度较高，抗颠簸性能好；四个车轮受力即使再不均匀，也是由车架承担，而不会传递到车身上去，因此车身不易扭曲变形。 缺点是：车身比较笨重。非承载式车身多用在货车、客车和越野车上，但也有部分高级轿车使用，这是因为非承载式车身具有较好的平稳性和安全性。 非承载式车身示意图\n为什么说车门防撞杠非常重要？\n当汽车受到侧面撞击时，可减轻车门的变形程度，从而起到对驾乘人员的保护作用。\n车门防撞杠示意图\n车身安全设计\n车身结构示意图\n奥迪TT车身结构\n什么是NVH特性？\nNVH是Noise（噪声）、Vibration（振动）和Harshness（声振粗糙度，通俗地称为不舒适性或不平顺性）的缩写。噪声是由振动引起的，通过振动波来传递， 因此噪声、振动和声振粗糙度三者在汽车等机械振动中是同时出现且密不可分的\n车辆在行驶时的振动源主要有三个：发动机、传动系统和不平的路面。 车辆在行驶时的噪声主要有四个：发动机产生的噪声、空气流过车身时的噪声、轮胎滚动和振动时的噪声，以及车身和底盘结构振动时产生的噪声。 汽车NVH设计示意图\n发动机噪声主要包括燃烧噪声、机械噪声和排气噪声。\n燃烧噪声是指气缸燃烧压力通过活塞、连杆、曲轴、缸体等途径向外辐射产生的噪声； 机械噪声是指活塞、齿轮、配气机构等运动件之间机械撞击产生的振动噪声； 排气噪声是指发动机排气产生的声音。一般情况下，低转速时燃烧噪声占主要地位，高转速时机械噪声占主要地位。 轮胎噪声主要来自泵气效应和轮胎振动。\n泵气效应是指轮胎高速滚动时引起轮胎变形，使得轮胎花纹与路面之间的空气受压挤，随着轮胎滚动，空气又在轮胎离开接触面时被释放，这样连续的“压挤 释放”，空气就迸发出噪声。 轮胎运行时的振动也会产生噪声，而且刚性越大或阻尼越小的轮胎，其振动噪声越大。 汽车上的空气噪声主要包括风阻噪声和风笛噪声。\n风阻噪声是指空气流过车身时与车身之间的摩擦声，而且风阻越大的汽车，其风阻噪声越大，因此现在轿车都要设计成流线形，以减少空气噪声； 风笛噪声是指空气进入或流出车身钣金缝隙时产生的噪声。车门、车窗等密封性越好的汽车，其风笛噪声越小。 车身和底盘结构噪声\n汽车在运动时，尤其是行驶在不平路面时，车身会产生一定的扭曲，此时车身钣金件在各种力的作用下就会产生一定的扭曲和振动，从而产生一定的噪声。 底盘中的部件，尤其是传动和悬架结构等运动部件，在运行时也会因转动、扭动或振动而产生一定的噪声，尤其是汽车行驶在不平路面或高速行驶时，底盘噪 声可能更大。这些噪声可能会通过底盘而传入车内。 2.3 车身材料 Body Material 什么是车身刚性？\n刚性是指物体受力后抗变形的能力。车身刚性则是指在施加不至毁坏车身的普通外力时车身不容易变形的能力。高刚性车身具有极高的抗扭曲和抗弯曲的能力， 反之亦然。当汽车行驶在凹凸不平的地面时，刚性差的汽车车身会发出“嘎吱嘎吱”的响声，因为这样的车身此时扭曲较严重，从而使一些装配部位产生摩擦。\n2018款奥迪A8车身结构\n在汽车高速转弯时，车身的刚性优劣也会暴露无遗。车身刚性好的车辆在过弯时，其行驶稳定性会比较好，反之亦然。\n为了保证车身具有较高的刚性，最可靠的手段就是采用高强度钢材来打造车身的关键部位，而在对刚性没有影响或影响较小的部位，则采用普通钢材或材质来制 作。\n奔驰CL双门轿车轻量化车身设计构造图\n怎样减轻车身重量？\n车身越重，其制动能力和操控能力可能受到的影响越大。 对车身轻量化起作用最大的还是广泛采用铝质材料。 保时捷车身用材料强度示意图\n奥迪TT铝质车身构造图\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC2%E7%AB%A0-%E8%BD%A6%E8%BA%AB/","summary":"2.1 车身规格 Body Specification 车宽尺寸包括后视镜吗？ 现在，全世界各汽车厂商在汽车车身规格的标注方面基本上都统一了，尤其是车身总长、轴距、轮距、前悬和后悬等规","title":"第2章 车身 Body"},{"content":"4.1 品牌是一种什么样的资产 图4-1 时代集团控股的手袋及小皮具平均出厂价\n总之，奢侈品包的制造成本，与其定价相去甚远。\n奢侈品皮具代工行业相对分散，中国是全球最大的供应地\n图4-2 全球奢侈品皮具代工市场份额（以销售额计）\n奢侈品溢价的来源是设计吗，设计的重要性有多高？\n奢侈品包的高价并非来自物料成本：售价上万元的奢侈品包，平均出厂价仅约200元。 奢侈品包的高价并非来自特殊制造工艺：皮具的生产以代工为主，代工费用已计入出厂价；中国是全球的奢侈品皮具主要代工地。 奢侈品的高价并非来自设计：有一部分奢侈品包是由代工厂设计、品牌“贴牌”生产的，主流消费者显然无法轻易分辨奢侈品包的设计方（否则“贴牌”奢侈品的 相关信息早就传遍网络，而不会被深埋在招股说明书中）。 品牌溢价来自品牌认知，即品牌过去的所有动作给消费者留下的整体印象\n品牌本质上还是认知。认知一方面是动态反馈形成的，另一方面是要靠时间积淀的。 品牌认知的形成，是品牌的各种动作在不同环境下，不断和周围环境相互反馈，并形成动态认知的过程。 譬如，品牌标识、品牌设计特色、品牌销售渠道、品牌营销广告、品牌粉丝互动等，都属于品牌动作，并不断产生动态变化。而在这个动态变化的过程中，消 费者对品牌产生各种各样的印象，长时间积累下来形成的动态认知的集合，就是品牌认知，也是品牌溢价的来源。 品牌溢价=品牌认知=品牌所有的动作反馈在时间上的积分\n图4-3 “品牌计分板”理论下的品牌溢价公式\n“品牌计分板”具备三重含义：\n品牌认知并非由单一因素形成，而由各种因素综合构成。 品牌认知是有时间维度的，需要经过时间积淀。 在对的时候做对的事情，方能得分，切忌刻舟求剑。 4.2 我们为何会为品牌溢价买单 消费者为品牌商品额外支付的溢价，就是在购买品牌背后的信用契约。\n信用契约的作用可以从两个方面理解：降低搜索成本、赋予文化认同\n图4-4 品牌（信用契约）的作用\n文化认同常见于奢侈品，也是奢侈品溢价的主要来源。\n赋予文化价值和降低搜索成本这两种作用，大致对应了两种行为模式的消费者。前者我们称之为悦己型消费者，后者为省心型消费者\n图4-5 悦己型消费者和省心型消费者\n悦己型消费者和省心型消费者并不是完全割裂的，二者之间没有严格界限。\n所以消费升级并不意味着省心型品牌会被淘汰；同样，消费降级也不意味着悦己型品牌的消亡。消费升级的大趋势并不会使得高端品牌取代大众品牌，因为格调 需要通过对比来体现，所以只属于少部分人；反之，若经济持续低迷，高端品牌也不见得会全部消失，因为对于炫耀、身份展示和自我满足的追求，不见得会随 着经济低迷而退散。\n对于悦己型公司，我们更应关注其品牌形象的维持，以及定价能力的不断提升；对于省心型公司，我们更应关注其经营规模的增长，以及渠道覆盖范围的演进。\n4.3 品牌化或是未来中国消费品投资最重要的机会之一 品牌是消费品产业链中利润空间最大的一环\n图4-6 品牌、供应链、渠道的毛利率（2019年）\n图4-7 品牌、供应链、渠道的净利率（2019年）\n国牌崛起的必要条件：发达的消费品供应链，特殊的渠道环境\n我国拥有强大的供应链，能够产出物美价廉高质量的产品。国产品牌使用本土供应链，就能生产出品质不亚于（甚至超过）海外大牌的产品。 2010年全世界有42%的奢侈品手袋产自中国（以代工市场份额计） 大多数苹果数码产品也是由位于中国本土的代工厂组装生产的。 我国已经形成多个优质的产业链集群。 广东有服装、化妆品、3C电子的产业链集群； 浙江有箱包、小商品的产业链集群； 江苏有家纺等商品的产业链集群； 福建有服装、鞋的产业链集群。 在渠道方面，独特的电商和互联网文化造就了国产品牌成长的沃土。 中国整体社零电商渗透率已达20%以上，且仍在高速增长（而美国只有大约10%的电商渗透率）。 国牌崛起的核心逻辑首先是“国崛起”，其次才是“货崛起”\n表4-1 “70后”“80后”与“Z世代”的生长环境对比\n国产品牌崛起是我们研究消费行业时必须重点关注的一个行业趋势性投资机会。\n从何处找到这类正在崛起的国产品牌标的呢？\n第一，它们的产品在国内有成体系的供应链，大多数消费品都在此范围之内； 第二，这些品牌经营的品类适合线上渠道销售，或能够通过互联网营销实现快速传播，因为对线上渠道和互联网文化的理解，是国产品牌的核心领先之处。 4.4 结语 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC4%E7%AB%A0-%E5%93%81%E7%89%8C-%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A%E7%9A%84%E7%9A%87%E5%86%A0%E6%98%8E%E7%8F%A0/","summary":"4.1 品牌是一种什么样的资产 图4-1 时代集团控股的手袋及小皮具平均出厂价 总之，奢侈品包的制造成本，与其定价相去甚远。 奢侈品皮具代工行业相对分散，","title":"第4章 品牌 消费行业的皇冠明珠"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/cninfo/","summary":"主页","title":"巨潮资讯"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/wind/","summary":"主页","title":"Win.d"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/insiderintelligence/","summary":"主页","title":"eMarketer"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/data/stats/","summary":"主页","title":"国家统计局"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/zhangdetalk/%E8%B6%85%E5%85%A8%E9%9D%A2-mysql%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/","summary":"原文","title":"超全面 MySQL语句加锁分析"},{"content":"图3-1 函数调用发生前\nCALL指令会先把下一条指令的地址(返回地址)压入栈中, IP寄存器存储f1的地址 图3-2 CALL指令执行后\n执行f1() f1()最后有条RET指令, 弹出栈顶的返回地址(应该弹到IP中), 跳到返回地址处继续执行 图3-3 RET指令执行后\n3.1 栈帧 3.1.1 栈帧布局 函数栈帧是由编译器管理的。\n图3-4 Go语言函数栈帧布局示意图\n猜测代码逻辑在其他地方, 这里只保存函数状态.\nreturn address：函数返回地址，占用一个指针大小的空间。实际上是在函数被调用时由CALL指令自动压栈的，并非由被调用函数分配。 caller’s BP：调用者的栈帧基址，占用一个指针大小的空间。用来将调用路径上所有的栈帧连成一个链表，方便栈回溯之类的操作， 只在部分平台架构上存在。函数通过将栈指针SP直接向下移动指定大小，一次性分配caller’s BP、locals和args to callee所占用的空间， 在x86架构上就是使用SUB指令将SP减去指定大小的。 locals：局部变量区间，占用若干机器字。用来存放函数的局部变量，根据函数的局部变量占用空间大小来分配，没有局部变量的函数不分配。 args to callee：调用传参区域，占用若干机器字。这一区域所占空间大小，会按照当前函数调用的所有函数中返回值加上参数所占用的最大空 间来分配。当没有调用任何函数时，不需要分配该区间。callee视角的args from caller区间包含在caller视角的args to callee区间内，占用空间 大小是小于或等于的关系。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 第3章 code_3_1.go package main func main() { var v1, v2 int v3, v4 := f1(v1, v2) println(\u0026amp;v1, \u0026amp;v2, \u0026amp;v3, \u0026amp;v4) f2(v3) } //go:noinline func f1(a1, a2 int) (r1, r2 int) { var l1, l2 int println(\u0026amp;r2, \u0026amp;r1, \u0026amp;a2, \u0026amp;a1, \u0026amp;l1, \u0026amp;l2) return } //go:noinline func f2(a1 int) { println(\u0026amp;a1) } 实际上，代码中的println()函数会被编译器转换为多次调用runtime包中的printlock()、printunlock()、printpointer()、printsp()、 printnl()等函数。前两个函数用来进行并发同步，后3个函数用来打印指针、空格和换行。这5个函数均无返回值， 只有printpointer()函数有一个参数，会在调用者的args to callee区间占用一个机器字。\n输出结果\n表3-1 3个函数栈帧上各区间的大小\n(1+4+4)*8 = 72B = 0x48B 依次类推 图3-5 main调用f1()函数和f2()函数的栈帧布局图\n调用f2()函数时的栈，在a1和v4之间空了3个机器字。这是因为Go语言的函数是固定栈帧大小的，args to callee是按照所需的最大空间来分配的。\n3.1.2 寻址方式 图3-6 SUB指令分配整个栈帧\n如果把图3-6中整个函数栈帧视为一个struct，SP存储着这个struct的起始地址，然后就可以通过基址＋位移的方式来寻址struct的各个字段，也就是栈帧上 的局部变量、参数和返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 第3章 code_3_3.go package main func main() { fa(0) } //go:noinline func fa(n int) (r int) { r = fb(n) return } //go:noinline func fb(n int) int { return n } 图3-7 函数fa的栈帧布局\n4～7行和最后两行汇编代码主要用来检测和执行动态栈增长 倒数第4行的RET指令用于在函数执行完成后跳转回返回地址。 第8行的SUBQ指令向下移动栈指针SP，完成当前函数栈帧的分配。倒数第5行的ADDQ指令在函数返回前向上移动栈指针SP，释放当前函数的栈帧。释放与分 配时的大小一致，均为0x18，即24字节，其中BP of main占用了8字节，args to fb占用了16字节。 第9行代码把BP寄存器的值存到栈帧上的BP of main中，第10行把当前栈帧上BP of main的地址存入BP寄存器中。倒数第6行指令在当前栈帧释放前用 BP of main的值还原BP寄存器。 第12行和第13行代码，通过AX寄存器中转，把参数n的值从args to fa区间复制到args to fb区间，也就是在fa中把main()函数传递过来的参数n，复 制到调用fb()函数的参数区间。 第14行代码通过CALL指令调用fb()函数。 Go语言中函数的返回值可以是匿名的，也可以是命名的。对于匿名返回值而言，只能通过return语句为返回值赋值。对于命名返回值，可以在代码中通过其名称 直接操作，与参数和局部变量类似。无论返回值命名与否，都不会影响函数的栈帧布局。\n3.1.3 又见内存对齐 Go语言函数栈帧中返回值和参数的对齐方式与struct类似，对于有返回值和参数的函数，可以把所有返回值和所有参数等价成两个struct，一个返回值 struct和一个参数struct。因为内存对齐方式更加紧凑，所以在支持大量参数和返回值时能够做到较高的栈空间利用率。\n验证函数参数和返回值的对齐方式与struct成员的对齐方式是一致的\n栈帧上的参数和返回值到底是分开后作为两个struct，还是按照一个struct来对齐的？\n1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_5.go package main //go:noinline func f1(a int8) (b int8) { println(\u0026amp;b, \u0026amp;a) return } func main() { f1(0) } f1()函数有一个返回值和一个参数，而且都是int8类型，如果返回值和参数作为同一个struct进行内存对齐，则a和b应该是紧邻的，中间不会插入padding。 可以看到参数a和返回值b并没有紧邻，而是分别按照8字节的边界进行对齐的，也就说明返回值和参数是分别对齐的，不是合并在一起作为单个struct。 局部变量的对齐\n1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_6.go package main //go:inline func fn() { var a int8 var b int64 var c int32 var d int16 var e int8 println(\u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d, \u0026amp;e) } 1 2 3 4 5 6 7 struct { e int8 a int8 d int16 c int32 b int64 } 局部变量的顺序被重排的, 布局更紧凑\n为什么编译器会对栈帧上局部变量的顺序进行调整以优化内存利用率，但是并不会调整参数和返回值呢？\n因为函数本身就是对代码单元的封装，参数和返回值属于对外暴露的接口，编译器必须按照函数原型来呈现 局部变量属于封装在内部的数据，不会对外暴露，所以编译器按需调整局部变量布局不会对函数以外造成影响。 3.1.4 调用约定 对Go语言普通函数的调用约定进行如下总结：\n返回值和参数都通过栈传递，对应的栈空间由调用者负责分配和释放。 返回值和参数在栈上的布局等价于两个struct，struct的起始地址按照平台机器字长对齐。 验证编译器能够参照函数声明来生成传参相关指令\n1 2 3 4 5 6 7 8 9 10 11 // 第3章 code_3_7.go package main import _ \u0026#34;unsafe\u0026#34; func main() { Add(1, 2) } // 只有声明 func Add(a, b int) 编译\n反编译\n与Add()函数调用相关的几行汇编代码\n可以看到两条MOVQ指令分别复制了参数1和2，证明编译阶段参照函数声明生成了正确的传参指令，也就是调用约定在发挥作用。 CALL指令处，十六进制编码e800000000预留了32位的偏移量空间，在链接阶段会被链接器填写为实际的偏移值。 3.1.5 Go 1.17的变化 1.16版及以前的版本中都是通过栈来传递参数的，这样实现简单且能支持海量的参数传递，缺点就是与寄存器传参相比性能方面会差一些。 在1.17版本中就实现了基于寄存器的参数传递，当然只是在部分硬件架构上实现了。 结合Go自带的反编译工具，在汇编代码层面看一下1.17版本的函数调用是如何通过寄存器传递参数的。\n1. 函数入参的传递方式\n第1～9个参数是依次用AX、BX、CX、DI、SI、R8、R9、R10和R11这9个通用寄存器来传递的 从第10个参数开始使用栈来传递 (注意MOVW $0xb0a, 0(SP)直接复制了两个数字10, 11) 图3-8 Go 1.17中in12()函数入参的传递方式\n2. 函数返回值的传递方式\n反编译out12()函数\n3.2 逃逸分析 3.2.1 什么是逃逸分析 1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_10.go package main func main() { println(*newInt()) } //go:noinline func newInt() *int { var a int return \u0026amp;a } 如果局部变量a仍分配在栈中, 那么返回的地址会变成一个悬挂指针\n反编译newInt()函数\n重点关注上述汇编代码中runtime.newobject()函数调用，该函数是Go语言内置函数new()的具体实现，用来在运行阶段分配单个对象。 CALL指令之后的两条MOVQ指令通过AX寄存器中转，把runtime.newobject()函数的返回值复制给了newInt()函数的返回值，这个返回值就是动态分配的 int型变量的地址。 3.2.2 不逃逸分析 验证new()函数与堆分配是否有必然关系\n1 2 3 4 5 6 // 第3章 code_3_11.go //go:noinline func New() int { p := new(int) return *p } 反编译New()函数\nMOVQ指令直接把返回值赋值为0，其他的逻辑全都被优化掉了，所以即便是代码中使用了new()函数，只要变量的生命周期没有超过当前函数栈帧的生命周期， 编译器就不会进行堆分配。\n3.2.3 不逃逸判断 如果把局部变量的地址赋值给包级别的指针变量，应该也会造成变量逃逸\n1 2 3 4 5 6 7 8 // 第3章 code_3_12.go var pt *int //go:noinline func setNew() { var a int pt = \u0026amp;a } 反编译setNew()函数\n验证逃逸分析的依赖传递性\n1 2 3 4 5 6 7 8 9 var pp **int //go:noinline func dep() { var a int var p *int p = \u0026amp;a pp = \u0026amp;p } 反编译dep()函数\n跨包测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 第3章 code_3_14.go package inner //go:noinline func RetAry(p *int) *int { return p } // 第3章 code_3_15.go package main //go:noinline func arg() int { var a int return *inner.RetAry(\u0026amp;a) } 反编译\n阻止编译器参考函数实现的测试\n反编译arg()函数\n变量a依旧是栈分配，变量b已经逃逸了。 在上述代码中的retArg()函数只是个函数声明，没有给出具体实现，通过linkname机制让链接器在链接阶段链接到inner.RetArg()函数。 retArg()函数只有声明没有实现，而且编译器不会跟踪linkname，所以无法根据代码逻辑判定变量b到底有没有逃逸。 3.3 Function Value 3.3.1 函数指针 函数指针存储的也是地址, 该地址指向代码段中某个函数的第一条指令\n3.3.2 Function Value分析 1 2 3 4 5 6 7 8 9 10 11 // 第3章 code_3_18.go package main func main() { println(helper(nil, 0, 0)) } //go:noinline func helper(fn func(int, int) int, a, b int) int { return fn(a, b) } 反编译\n4～7行和最后两行用于栈增长，暂不需要关心。 第8～10行分配栈帧并赋值caller’s BP，RET之前的两行还原BP寄存器并释放栈帧。 CALL后面的两行用来复制返回值。 CALL连同之前的6条MOVQ指令，实现了Function Value的传参和过程调用。 MOVQ 0x30(SP)，AX和MOVQ AX，0(SP)用于把helper()函数的第2个参数a的值复制给fn()函数的第1个参数。 MOVQ 0x38(SP)，AX和MOVQ AX，0x8(SP)同理，把helper()函数第3个参数b的值复制给fn()函数的第2个参数。 MOVQ 0x28(SP)，DX把helper()函数第1个参数fn的值复制到DX寄存器，MOVQ 0(DX)，AX把DX用作基址，加上位移0，也就是从DX存储的地址处读 取出一个64位的值，存入了AX寄存器中。 CALL AX说明，上一步中AX寄存器最终存储的是实际函数的地址。 栈分析\n40(SP) return value -| 38(SP) b | stack of main 30(SP) a | 28(SP) fn -| 20(SP) return addr 18(SP) bp -| 10(SP) return value | stack of helper 8(SP) b | 0(SP) a -| 3.3.3 闭包 1 2 3 4 5 6 // 第3章 code_3_19.go func mc(n int) func() int { return func() int { return n } } 闭包的状态保存在哪里呢？\n闭包对象 反编译\n栈分析\n... | 28(SP) main arg (mc-func()int) | stack of main 20(SP) main arg (mc-n) -| 18(SP) return address of mc 10(SP) bp -| 8(SP) newobject ret | stack of mc 0(SP) newobject arg -| 推测newobject所创建的对象的结构\n1 2 3 4 5 6 7 // 闭包对象 struct { // 闭包函数 F uintptr // 捕获列表 n int } 看到闭包 newobject的原型\n1 func newobject(typ *_type) unsafe.Pointer 使用自定义的newobject实现来查看_type的布局\n运行结果\n因为start++导致start变量逃逸, 所以调用了两次newobject\nint struct { F uintptr; start *int } 图3-12 Function Value和闭包对象\n调用闭包 闭包函数在被调用的时候，必须得到当前闭包对象的地址才能访问其中的捕获列表，这个地址是如何传递的呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 第3章 code_3_22.go package main func main() { a := mc(2) a() } func mc(n int) func() int { return func() int { return n } } 反编译\n将DX寄存器用作基址，再加上位移8，把该地址处的值复制到AX寄存器中。 把AX寄存器的值复制给闭包函数的返回值。 闭包函数返回。 书中说把AX的值给闭包函数的返回值, 不太理解为啥0x8(SP)是返回值地址.\n闭包与变量逃逸 1 2 3 4 5 6 7 // 第3章 code_3_23.go func sc(n int) int { f := func() int { return n } return f() } 禁用内联优化\n1 $ go build -gcflags=\u0026#39;-l\u0026#39; 反编译\nreturn f()之前的6行汇编代码\nXORPS和MOVUPS这两行利用128位的寄存器X0，把栈帧上从位移8字节开始的16字节清零，这段区间就是sc()函数的局部变量区，正好符合捕获了一个int变 量的闭包对象大小。 LEAQ和MOVQ把闭包函数的地址复制到栈帧上位移8字节处，正是闭包对象中的函数指针。 接下来的两个MOVQ把sc()函数的参数n的值复制到栈帧上位移16字节处，也就是闭包捕获列表中的int变量。 图3-13 sc()函数中构造的闭包对象f\nreturn之后的5行汇编代码\nMOVQ把闭包函数的地址复制到AX寄存器中，LEAQ把闭包对象的地址存储到DX寄存器中。 CALL指令调用闭包函数，接下来的两条MOVQ把闭包函数的返回值复制到sc()函数的返回值。 图3-14 调用闭包函数f()\n闭包对象的捕获列表，捕获的是变量的值还是地址？\n只有在变量的值不会再改变的前提下，才可以复制变量的值，否则就会出现不一致错误。 示例, 需要禁用内联优化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 第3章 code_3_24.go // 捕获地址 func sc(n int) int { f := func() int { n++ return n } return f() } // 第3章 code_3_25.go // 捕获值 func sc(n int) int { n++ f := func() int { return n } return f() } // 第3章 code_3_26.go // 捕获地址 func sc(n int) int { f := func() int { return n } n++ return f() } 3.4 defer 3.4.1 最初的链表 使用go1.12\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 第3章 code_3_28.go package main func main() { println(df(10)) } func df(n int) int { defer func(i *int) { *i *= 2 }(\u0026amp;n) return n } 反编译df()\ndeferproc Go语言中，每个goroutine都有自己的一个defer链表，而runtime.deferproc()函数做的事情就是把defer函数及其参数添加到链表中。 编译器还会在当前函数结尾处插入调用runtime.deferreturn()函数的代码，该函数会按照FILO的顺序调用当前函数注册的所有defer函数。 如果当前goroutine发生了panic（宕机），或者调用了runtime.Goexit()函数，runtime的panic处理逻辑会按照FILO的顺序遍历当前goroutine的整 个defer链表，并逐一调用defer函数，直到某个defer函数执行了recover，或者所有defer函数执行完毕后程序结束运行。 runtime.deferproc()函数原型\n1 func deferproc(size int32, fun *funcval) Go语言用两级指针结构统一了函数指针和闭包，这个funcval结构就是用来支持两级指针的。 funcval结构中只定义了uintptr 图3-15 funcval对Function Value两级指针的支持\n参数siz表示defer函数的参数占用空间的大小，这部分参数也是通过栈传递的，虽然没有出现在deferproc()函数的参数列表里，但实际上会被编译器追加 到fn的后面 注意defer函数的参数在栈上的fn后面，而不是在funcval结构的后面。这点不符合正常的Go语言函数调用约定，属于编译器的特殊处理。 图3-16 df()函数调用deferproc时的栈帧\n基于第3章/code_3_28.go反编译得到的汇编代码，整理出等价的伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func df(n int) (v int) { r := runtime.deferproc(8, df.func1, \u0026amp;n) if r \u0026gt; 0 { goto ret } v = n runtime.deferreturn() return ret: runtime.deferreturn() return } func df.func1(i *int) { *i *= 2 } deferproc()函数的返回值为0或非0时代表不同的含义\n0代表正常流程，也就是已经把需要延迟执行的函数注册到了链表中，这种情况下程序可正常执行后续逻辑。 返回值为1则表示发生了panic，并且当前defer函数执行了recover，这种情况会跳过当前函数后续的代码，直接执行返回逻辑。 deferproc()函数的具体实现, 摘抄自runtime包的panic.go\n通过getcallersp()函数获取调用者的SP，也就是调用deferproc()函数之前SP寄存器的值。这个值有两个用途\n一是在deferreturn()函数执行defer函数时用来判断该defer是不是被当前函数注册的 二是在执行recover的时候用来还原栈指针。 基于unsafe指针运算得到编译器追加在fn之后的参数列表的起始地址，存储在argp中。\n通过getcallerpc()函数获取调用者指令指针的位置，在amd64上实际就是deferproc()函数的返回地址，从调用者df()函数的视角来看就是CALL runtime.deferproc后面的那条指令的地址。这个地址主要用来在执行recover的时候还原指令指针。\n调用newdefer()函数分配一个runtime._defer结构，newdefer()函数内部使用了两级缓冲池来避免频繁的堆分配，并且会自动把新分配的_defer结构添加 到链表的头部。\nruntime._defer的定义\nsiz表示defer参数占用的空间大小，与deferproc()函数的第1个参数一样。 started表示有个panic或者runtime.Goexit()函数已经开始执行该defer函数。 _panic的值是在当前goroutine发生panic后，runtime在执行defer函数时，将该指针指向当前的_panic结构。 link指针用来指向下一个_defer结构，从而形成链表。 _defer中没有发现用来存储defer函数参数的空间，参数应该被存储到哪里？\n实际上runtime.newdefer()函数用了和编译器一样的手段，在分配_defer结构的时候，后面额外追加了siz大小的空间，如图3-17所示，所以deferproc() 函数接下来会将fn、callerpc、sp都复制到_defer结构中相应的字段，然后根据siz大小来复制参数，最后通过return0()函数来把返回值0写入AX寄存器中。\n图3-17 deferproc执行中为_defer赋值\n通过deferproc()函数注册完一个defer函数后，deferproc()函数的返回值是0。后面如果发生了panic，又通过该defer函数成功recover，那么指令指针 和栈指针就会恢复到这里设置的pc、sp处，看起来就像刚从runtime.deferproc()函数返回，只不过返回值为1，编译器插入的if语句继而会跳过函数体，仅 执行末尾的deferreturn()函数。\ndeferreturn 在正常情况下，注册过的defer函数是由runtime.deferreturn()函数负责执行的，正常情况指的就是没有panic或runtime.Goexit()函数，即当前函数完 成执行并正常返回时。\ndeferreturn()函数的代码如下：\n值得注意的是参数arg0的值没有任何含义，实际上编译器并不会传递这个参数，deferreturn()函数内部通过它获取调用者栈帧上args to callee区间的起 始地址，从而可以将defer函数所需参数复制到该区间。defer函数的参数个数要比编译器传给deferproc()函数的参数还少两个，所以调用者的 args to callee区间大小肯定足够，不必担心复制参数会覆盖掉栈帧上的其他数据。\ndeferreturn()函数的主要逻辑如下：\n若defer链表为空，则直接返回，否则获得第1个_defer的指针d，但并不从链表中移除。 判断d.sp是否等于调用者的SP，即判断d是否由当前函数注册，如果不是，则直接返回。 如果defer函数有参数，d.siz会大于0，就将参数复制到栈上\u0026amp;arg0处。 将d从defer链表移除，链表头指向d.link，通过runtime.freedefer()函数释放d。和runtime.newdefer()函数对应，runtime.freedefer()函数 会把d放回缓冲池中，缓冲池内部按照defer函数参数占用空间的多少分成了5个列表，对于参数太多且占用空间太大的d，超出了缓冲池的处理范围则不会被 缓存，后续会被GC回收。 通过runtime.jmpdefer()函数跳转到defer函数去执行。 runtime.jmpdefer()函数是用汇编语言实现的，amd64平台下的实现代码如下：\n第2行把fn赋值给DX寄存器，3.3节中已经讲过Function Value调用时用DX寄存器传递闭包对象地址。接下来的3行代码通过设置SP和BP来还原 deferreturn()函数的栈帧，结合最后一条指令是跳转到defer函数而不是通过CALL指令来调用，这样从调用栈来看就像是deferreturn()函数的调用者直接 调用了defer函数。\njmpdefer()函数会调整返回地址，在amd64平台下会将返回地址减5，即一条CALL指令的大小，然后才会跳转到defer函数去执行。这样一来，等到defer函数 执行完毕返回的时候，刚好会返回编译器插入的runtime.deferreturn()函数调用之前，从而实现无循环、无递归地重复调用deferreturn()函数。直到当 前函数的所有defer都执行完毕，deferreturn()函数会在第1、第2步判断时返回，不经过jmpdefer()函数调整栈帧和返回地址，从而结束重复调用。\n使用deferproc()函数实现defer的好处是通用性比较强，能够适应各种不同的代码逻辑。\n因为defer函数的注册是运行阶段才进行的，可以跟代码逻辑很好地整合在一起，所以像if这种条件分支不用完成额外工作就能支持。由于每个 runtime._defer结构都是基于缓冲池和堆动态分配的，所以即使不定次数的循环也不用额外处理，多次注册互不干扰。\n但是链表与堆分配组合的最大缺点就是慢，即使用了两级缓冲池来优化runtime._defer结构的分配，性能方面依然不太乐观，所以在后续的版本中就开始了对 defer的优化之旅。\n3.4.2 栈上分配 在1.13版本中对defer做了一点小的优化，即把runtime._defer结构分配到当前函数的栈帧上。很明显这不适用于循环中的defer，循环中的defer仍然需要 通过deferproc()函数实现，这种优化只适用于只会执行一次的defer。\n编译器通过runtime.deferprocStack()函数来执行这类defer的注册，相比于runtime.deferproc()函数，少了通过缓冲池或堆分配_defer结构的步骤， 性能方面还是稍有提升的。\nruntime._defer结构中新增了一个bool型的字段heap来表示是否为堆上分配，对于这种栈上分配的_defer结构，deferreturn()函数就不会用 freedefer()函数进行释放了。因为编译器在栈帧上已经把_defer结构的某些字段包括后面追加的fn的参数都准备好了，所以deferprocStack()函数这里只 需为剩余的几个字段赋值，与deferproc()函数的逻辑基本一致。最后几行中通过unsafe.Pointer做类型转换再赋值，源码注释中解释为避免写屏障，暂时理 解成为提升性能就行了\n同样使用第3章/code_3_28.go，经过Go 1.13编译器转换后的伪代码如下：\n图3-18 df()函数调用deferprocStack()时的栈帧\n栈上分配_defer这种优化只是节省了_defer结构的分配、释放时间，仍然需要将defer函数添加到链表中，在调用的时候也还要复制栈上的参数，整体提升比 较有限。\n3.4.3 高效的open coded defer 在Go 1.14版本中又进行了一次优化，这次优化也是针对那些只会执行一次的defer。编译器不再基于链表实现这类defer，而是将这类defer直接展开为代码中 的函数调用，按照倒序放在函数返回前去执行，这就是所谓的open coded defer。\n使用第3章/code_3_28.go，在1.14版本中经编译器转换后的伪代码如下：\n1 2 3 4 5 6 7 func df(n int) (v int) { v = n func(i *int) { *i *= 2 }(\u0026amp;n) return } 两个问题：\n如何支持嵌套在if语句块中的defer？ 当发生panic时，如何保证这些defer得以执行呢？ 第1个问题其实并不难解决，可以在栈帧上分配一个变量，用每个二进制位来记录一个对应的defer函数是否需要被调用。Go语言实际上用了一字节作为标 志，可以最多支持8个defer，为什么不支持更多呢？笔者是这样理解的，open coded defer本来就是为了提高性能而设计的，一个函数中写太多defer，应该 是不太在意这种层面上的性能了。\n还需要考虑的一个问题是，deferproc()函数在注册的时候会存储defer函数的参数副本，defer函数的参数经常是当前函数的局部变量，即使它们后来被修改 了，deferproc()函数存储的副本也是不会变的，副本是注册那一时刻的状态，所以在open coded defer中编译器需要在当前函数栈帧上分配额外的空间来存 储defer函数的参数。\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 // 第3章 code_3_30.go package main func fn(n int) (r int) { if n \u0026gt; 0 { defer func(i int) { r \u0026lt;\u0026lt;= i }(n) } n++ return n } 经编译器转换后的等价代码如下：\n其中局部变量f就是专门用来支持if这类条件逻辑的标志位，局部变量i用作n在defer注册那一刻的副本，函数返回前根据标志位判断是否调用defer函数。\n图3-19 fn()函数通过open coded defer的方式调用defer函数\n3.5 panic 3.5.1 gopanic()函数 1.12版本的gopanic()函数的源码\n从函数原型来看，与内置函数panic()完全一致，有一个interface{}类型的参数，这使gopanic()函数可以接受任意类型的参数。函数首先通过getg()函数 得到当前goroutine的g对象指针gp，然后会进行一些校验工作，主要目的是确保处在系统栈、内存分配过程中、禁止抢占或持有锁的情况下不允许发生panic。 接下来gopanic()函数在栈上分配了一个_panic类型的对象p，把参数e赋值给p的arg字段，并把p安放到当前goroutine的_panic链表的头部，特意使用 noescape()函数来避免p逃逸，因为panic本身就是与栈的状态强相关的。\nruntime._panic结构的定义代码如下：\nargp字段用来在defer函数执行阶段指向其args from caller区间的起始地址。 arg字段保存的就是传递给gopanic()函数的参数。 link字段用来指向链表中的下一个_panic结构。 recovered字段表示当前panic已经被某个defer函数通过recover恢复。 aborted字段表示发生了嵌套的panic，旧的panic被新的panic流程标记为aborted。 gopanic()中的for循环\n每次循环开始都会从gp的_defer链表头部取一项赋值给d，直到链表为空时结束循环。 接下来判断若d.started为真则表明当前是一个嵌套的panic，也就是在原有panic或Goexit()函数执行defer函数的时候又触发了panic，因为触发 panic的defer函数还没有执行完，所以还没有从链表中移除。这里会把d关联的旧的_panic设置为aborted，然后把d从链表中移除，并通过freedefer() 函数释放。 后续的3大块逻辑就是：调用defer函数、释放_defer结构和检测recover。 调用defer函数 调用defer函数的代码如下：\n首先将d.started设置为true，这样如果defer函数又触发了panic，新的panic遍历defer链表时，就能通过started的值确定该defer函数已经被调用 过了，避免重复调用。 然后为d._panic赋值，将d关联到当前panic对象p，并使用noescape()函数避免p逃逸，这一步是为了后续嵌套的panic能够通过d._panic找到上一个 panic。 接下来，p.argp被设置为当前gopanic()函数栈帧上args to callee区间的起始地址，recover()函数通过这个值来判断自身是否直接被defer函数调用 reflectcall()函数\n1 func reflectcall(argtype *_type, fn, arg unsafe.Pointer, argsize uint32, retoffset uint32) reflectcall()函数的主要逻辑是根据argsize的大小在栈上分配足够的空间，然后把arg处的参数复制到栈上，复制的大小为argsize字节，然后调用fn() 函数，再把返回值复制回arg＋retoffset处，复制的大小为argsize-retoffset字节，如果argtype不为nil，则根据argtype来应用写屏障。\n在编译阶段，编译器无法知道gopanic()函数在运行阶段会调用哪些defer函数，所以也无法预分配足够大的args to callee区间，只能通过 reflectcall()函数在运行阶段进行栈增长。defer函数的返回值虽然也会被复制回调用者的栈帧上，但是Go语言会将其忽略，所以这里不必应用写屏障。\n释放_defer结构 调用完d.fn()函数后，不应该出现gp._defer不等于d这种情况。假如在d.fn()函数执行的过程中没有造成新的panic，那么所有新注册的defer都应该在 d.fn()函数返回的时候被deferreturn()函数移出链表。假如d.fn()函数执行过程中造成了新的panic，若没有recover，则不会再回到这里，若经 recover之后再回到这里，则所有在d.fn()函数执行过程中注册的defer也都应该在d.fn()函数返回之前被移出链表。\n检测recover 检测recover的代码如下：\n如果d.fn()函数成功地执行了recover，则当前_panic对象p的recovered字段就会被设置为true，此处通过检测后就会执行recover逻辑。\n首先把p从gp的_panic链表中移除，然后循环移除链表头部所有已经标为aborted的_panic对象。如果没有发生嵌套的panic，则此时gp._panic应该是nil， 不为nil就表明发生了嵌套的panic，而且只是内层的panic被recover。代码的最后把局部变量sp和pc赋值给gp的sigcode0和sigcode1字段，然后通过 mcall()函数执行recovery()函数。mcall()函数会切换到系统栈，然后把gp作为参数来调用recovery()函数。\nrecovery()函数负责用存储在sigcode0和sigcode1中的sp和pc恢复gp的执行状态。recovery()函数的主要逻辑代码如下：\n首先确保栈指针sp的值不能为0，并且还要在gp栈空间的上界与下界之间，然后把sp和pc赋值给gp.sched中对应的字段，并且把返回值设置为1。\n调用gogo()函数之后，gp的栈指针和指令指针就会被恢复到sp和pc的位置，而这个位置是deferproc()函数通过getcallersp()函数和getcallerpc()函 数获得的，即deferproc()函数正常返回后的位置，所以经过某个defer函数执行recover()函数后，当前goroutine的栈指针和指令指针会被恢复到deferproc()函数刚刚注册完该defer函数后返回的位置，只不过返回值是1而不是0。\n3.5.2 gorecover()函数 defer函数中调用了内置函数recover()，实际上只会设置_panic的一种状态。内置函数recover()对应runtime中的gorecover()函数，代码如下：\n编译器会把调用者的args from caller区间的起始地址作为参数传递给gorecover()函数。\n1 2 3 4 5 6 7 // 第3章 code_3_31.go func fn() { defer func(a int) { recover() println }(0) } 经编译器转换后的等价代码如下：\n1 2 3 4 5 func fn() { defer func(a int) { gorecover(uintptr(unsafe.Pointer(\u0026amp;a))) }(0) } 图3-20 p.argp和gorecover()函数参数argp的关系\n3.5.3 嵌套的panic Go语言的panic是支持嵌套的，第1个panic在执行defer函数的时候可能会注册新的defer函数，也可能会触发新的panic。如果新的panic被新注册的defer 函数中的recover恢复，则旧的panic就会继续执行，否则新的panic就会把旧的panic置为aborted。\n1 2 3 4 5 6 7 // 第3章 code_3_32.go func fn() { defer func() { panic(\u0026#34;2\u0026#34;) }() panic(\u0026#34;1\u0026#34;) } fn()函数首先将一个defer函数注册到当前goroutine的defer链表头部，记为defer1，然后当panic(＂1＂)执行时，会在当前goroutine的_panic链表中 新增一个_panic结构，记为panic1，panic1触发defer执行，defer1中started字段会被标记为true，_panic字段会指向panic1\n图3-21 panic2执行前的_defer链表和_panic链表\n然后执行到panic(＂2＂)这里，也会在当前goroutine的_panic链表中新增一项，记为panic2。panic2同样会去执行defer链表，通过defer1记录的 _panic字段找到panic1，并将其标记为aborted，然后移除defer1，处理defer链表中的后续节点。\n图3-22 panic2执行后的_defer链表和_panic链表\n在defer函数中嵌套一个带有recover的defer函数\n1 2 3 4 5 6 7 8 9 10 // 第3章 code_3_35.go func fu() { defer func() { defer func() { recover() }() panic(\u0026#34;2\u0026#34;) }() panic(\u0026#34;1\u0026#34;) } 依然把fn()函数首先注册的defer函数记为defer1，把接下来执行的panic记为panic1，此时goroutine的_defer链表和_panic链表与图3-21中的链表并 无不同。只不过当panic1触发defer1执行时，会再次注册一个defer函数，记为defer2，然后才会执行到panic(＂2＂)，这里触发第二次panic，在_panic 链表中新增一项，记为panic2。\n图3-23 defer2执行前的_defer链表和_panic链表\n然后panic2去执行_defer链表，首先执行defer2，将其started字段置为true，_panic字段指向panic2。待到defer2执行recover()函数时，只会把 panic2的recovered字段置为true，defer2结束后，从_defer链表中移除\n图3-24 defer2结束后的_defer链表和_panic链表\n接下来，panic处理逻辑检测到panic2已经被刚刚执行的defer2恢复了，所以会把panic2从_panic链表中移除，如图3-25所示，然后进入recovery()函数 的逻辑中。\n图3-25 panic2恢复后的_defer链表和_panic链表\n结合3.5.1节中的recovery()函数的介绍，panic2被recover后，当前协程会恢复到defer1中注册完defer2刚刚返回时的状态，只不过返回值被置为1，直 接跳转到最后的deferreturn()函数处，而此时defer链表中已经没有defer1注册的defer函数了，所以defer1结束返回，返回panic1执行defer链表的逻 辑中继续执行。\n3.5.4 支持open coded defer 1.14版本中runtime._defer结构的定义\n3.6 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC3%E7%AB%A0-%E5%87%BD%E6%95%B0/","summary":"本章建议最多读到3.4, 到这里已经看不太懂了","title":"第3章 函数"},{"content":"原文\nRC/RU+条件列非索引 RC/RU+条件列是聚簇索引 RC/RU+条件列是非聚簇索引 RR/Serializable+条件列非索引 RR/Serializable+条件列是聚簇索引 RR/Serializable+条件列是非聚簇索引 ","permalink":"https://jdxj.github.io/posts/articles/rjzheng/%E6%83%8A-%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E7%9A%84select%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90-mysql/","summary":"该文章展示了事务隔离级别与锁的关系, 推荐阅读","title":"惊! 史上最全的select加锁分析(Mysql)"},{"content":"1.1 整车构造组成 Vehicle Structure 四大组成\n车身部分包括车身骨架、车身钣金件以及座椅、仪表、天窗、车外后视镜等车身附件。 动力系统由发动机和变速器组成。 底盘由传动系统、悬架系统、转向系统、制动系统和车轮轮胎组成。 电气电子系统包括蓄电池、发电机、空调、照明系统、行车电脑、音响以及电子控制单元、驾驶辅助系统、电信号传输系统等。 轿车车身骨架和钣金件构造示意图\n宾利汽车整车构造\n汽车主要部件构造图\n双门轿车构造示意图\n动力系统和传动系统构造示意图\n底盘组成\n传动系统包括离合器、传动轴、半轴和差速器等； 行驶系统由悬架系统、转向系统、制动系统、车轮和轮胎等组成。 轿车底盘构造示意图\n1.2 整车布局形式 Vehicle Layout 什么是前置发动机、前轮驱动车型？\n将发动机放置在前部，而且一般都是横置，并采用前轮驱动，就是前置前驱车型（简称F F）。这种传动方式简单，紧凑，传动效率高，制造和维修成本低。\n前横置发动机前轮驱动车型构造图\n前横置发动机前轮驱动\n什么是前置发动机、四轮驱动车型？\n在原来前驱车的基础上再塞进四轮驱动系统, 这样要将发动机输出的动力方向转90°才能向后传递\n前横置发动机四轮驱动车型构造图\n前横置发动机四轮驱动\n什么是前置发动机、后轮驱动车型？\n发动机放置在前部，两个后轮为驱动轮，这种布局方式称为前置后驱车型（简称FR）。豪华汽车一般采用这种前置后驱方式，因为它们通常采用大排量发动机， 发动机体积较大。如果把发动机和传动系统都放置在汽车前部，不仅布置困难，而且还会造成“一头沉”，影响汽车的操控性和安全性。\n前置后驱车型构造图\n前纵置发动机\n什么是后置发动机、后轮驱动车型？\n将发动机放置在后轴后方并采用后轮驱动，称为后置后驱车型（简称RR）。现在，这种布局方式只有保时捷汽车采用。\n后置后驱车型构造图\n保时捷GT3\n什么是前纵置发动机、四轮驱动车型？\n大排量发动机的四驱车型，一般都是从前纵置发动机、后驱车型改造来的。它的发动机采用前纵置方式，动力经变速器后由分动器一分为二，分别传递给后轴和 前轴。\n前纵置发动机、四轮驱动车型（奔驰GL）构造图\n怎样判断发动机是横置还是纵置？\n站在车头前，面向发动机，打开发动机舱盖，如果看到发动机的气缸排列方向是左右方向，则此车发动机为“横置”；如果看到发动机的气缸排列方向为前后方向， 则此车发动机为“纵置”。\n什么是后中置发动机、四轮驱动车型？\n将发动机放置在后轴前端并采用四轮驱动，称为后中置发动机、四轮驱动方式。现在，大多数超级跑车都采用这种驱动方式。\n后中置发动机、四轮驱动车型（奥迪R8）构造图\n奥迪R8超级跑车\n什么是前中置发动机、后轮驱动车型？\n将发动机放置在前轴后方、采用后轮驱动，称为前中置发动机后轮驱动布局方式（简称M R）。跑车喜欢采用这种驱动方式，因为这样可以将整车重心尽量靠近车 身中间，使车辆拥有较高的操控性能。\n奔驰SLR McLaren Roadster构造图\n出气孔\n汽车制动时，前制动盘要比后制动盘承受更大的制动力，它需要更快速地散热，尤其对于车速较快的超级跑车而言，前制动盘的散热效果更为重要。因此，多数 超级跑车上都设计有专为前制动盘散热的出气孔，以利于提高制动性能。\n","permalink":"https://jdxj.github.io/posts/books/%E6%B1%BD%E8%BD%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%B7%91-%E5%9B%BE%E8%A7%A3%E6%B1%BD%E8%BD%A6%E6%9E%84%E9%80%A0%E4%B8%8E%E5%8E%9F%E7%90%86-%E7%B2%BE%E8%A3%85%E5%85%B8%E8%97%8F%E7%89%88/%E7%AC%AC1%E7%AB%A0-%E6%95%B4%E8%BD%A6/","summary":"1.1 整车构造组成 Vehicle Structure 四大组成 车身部分包括车身骨架、车身钣金件以及座椅、仪表、天窗、车外后视镜等车身附件。 动力系统由发动机和变速器组成。 底盘由传","title":"第1章 整车 Automobile"},{"content":"3.1 如何发现好赛道 必选消费中有食品饮料、日用品、卫生用品、烟酒等，可选消费有珠宝首饰、房地产、汽车\n如何从种类繁多的领域中找到成长性强、模式优秀、值得投资的赛道？\n明白行业处于其生命周期中的哪一个环节 图3-1 行业生命周期理论\n表3-1 四个阶段的行业在股票市场中的体现\n某个消费品可能会衰退，但消费行业本身不会衰退。\n表3-2 消费品三条成长逻辑与行业生命周期的关系\n我们可以参考海外成熟市场的发展历程，来寻找消费行业的投资机会 站在2022年，我们是否还能通过对标海外的方式，来提前发现消费行业的发展方向呢？答案是肯定的。比较显而易见的方向是医美和餐饮 我们可以借助统计局的统计数字，来判断各个行业的景气程度 国家统计局披露的宏观消费数据主要有三个：\n社会消费品零售（简称社零）总额 “住户调查”下的人均居民消费支出 GDP支出法口径下的最终消费支出。 一般来说，我们主要关注社零总额，这个数据反映社会企业销售非生产、非经营的实物商品以及提供餐饮服务所获得的收入。关注社零数据的原因在于：\n第一，社零数据的更新频率较快，每个月更新一次（除1～2月春节期间只更新一次以外），能够迅速地反映消费趋势的变化； 第二，它的口径更为详细，每个月都会披露不同类目下限额以上企业的零售总额及同比增速，可以帮助我们具体判断消费行业每个细分赛道的景气程度； 第三，它的统计结果准确程度相对较高，因为限额以上口径的数字是由各地的大型企业填表报送而来的，是相对直接的一手统计数据。 “限额以上企业”是指主营业务收入超过一定数额的企业，这类企业的零售额由填表报送而来，而非推算得来，具有较高的准确度。\n表3-3 各品类限额以上企业零售额增速\n在消费领域中，什么样的行业值得我们投资？\n其实这取决于我们想找什么样的投资品。\n喜欢进攻、风格犀利的投资者可以关注医美、新能源汽车等处于渗透率提升阶段的消费品； 风格稳妥的投资者可以选择成熟期的价值股（如大家电）进行投资； 均衡的消费者可以选择功能性服饰、功能性护肤品品牌这类处于市占率提升阶段的标的来投资，其具备优异的持续成长能力，也正在不断地创造利润； 而行业格局稳定、拥有持续提价能力的白酒等品类，能够跑赢通胀，也具备明显的壁垒和稀缺性，几乎适合绝大多数的投资者。 3.2 消费品公司分类体系：品牌、渠道、供应链 我们的消费研究框架：供应商-品牌商-渠道商\n按照在消费产业链上所处的环节，企业由上到下可分为供应商、品牌商、渠道商。三者分别对应产品、品牌、渠道三要素。其中， 品牌是消费者和商家间的信用契约，渠道是消费者和商家间的反馈机制，产品是商家对于消费者需求的解读。\n国内知名的渠道商包括京东集团、永辉超市等。 品牌商通常扮演着渠道和供应链的组织者，一方面要设计产品，寻找代工厂，另一方面也要管理其库存与销售渠道，此外还要负责品牌营销等，并给消费者提 供质量背书。国内知名品牌包括服装品牌李宁和安踏、白酒品牌茅台等。 对于长期投资而言，重点是看清投资标的的壁垒和护城河。 壁垒通常是企业具备的难以被复制，并能够持续创造超额利润的资产。\n供应商的壁垒包括规模化生产能力、管理与成本控制能力、研发能力、工艺改善能力等。 渠道商的壁垒包括网络效应、渠道效率、覆盖面、组织管理能力等。 品牌商的壁垒主要在于品牌认知，它的形成需要时间积淀，不可复制，是品牌溢价的基础，能够持续为企业带来利润和成长；此外也在于销售渠道的建设和管 理，这对于即时性消费品类（比如瓶装饮料）而言非常重要。 供应链：中国拥有世界上首屈一指的消费品制造业 供应链主要包括各种原材料供应商和代工厂，它们负责产品的生产环节。比如服装供应链主要包括桐昆股份、百宏实业等原料供应商，以及申洲国际、晶苑国际 等成衣制造商。消费品供应链涉及的范围很广，很多科技企业本质上都属于消费品供应链环节。\n消费行业的定价权通常由品牌和渠道环节掌控，供应链环节的议价能力比较一般，产品出厂价主要依据成本而定。因此，供应链企业的毛利率通常较低，盈利能 力短期受到上游价格波动的影响，长期受制于人工成本提升的挤压。想要持续实现盈利，需持续优化生产过程中的每个细节，并保证充足的产能利用率。\n供应链企业的核心壁垒包括规模化生产能力、管理能力、成本控制能力、研发能力和工艺改善能力等。 研发能力、工艺改善能力近年来变得越来越重要，品牌方会把一部分设计工作（如打样等）交给供应链企业负责，有时也会购买代工厂的方案，未来研发能力 或将成为供应链企业之间决出胜负的关键要素。 我国本土的消费行业在品牌环节整体较为薄弱，其一大原因是形成品牌需要时间积淀。没有品牌、没有销路是国内优质制造商遇到的最大的问题，大量工厂只能 帮海外品牌干苦力活，而拿不到品牌订单的工厂只能艰难度日，这甚至一度催生了“山寨”这种畸形业态。\n渠道：电商是中国消费行业中的核心变量 渠道包括商超、百货、经销商、电商平台等。渠道的核心作用是将终端消费者与品牌和厂家对接起来，将批量生产的商品零售给消费者。\n商超（如永辉超市等）、百货（如百联股份等）、经销商（如滔博体育等）、电商平台（如天猫、京东等）、在电商平台上开店的店家和服务商（如壹网壹创等），都属于渠道商的范畴。 渠道可分为线上渠道和线下渠道，按照经营模式又可分为自营（经销）模式和平台（租赁）模式。对于不同类型的渠道，我们的关注重点有所不同。\n对于线上渠道，我们关注规模、流量和变现能力。线上渠道的壁垒在于网络效应、变现能力、反馈效率、用户习惯等。 网络效应非常关键，用户越多，商家越多；商家越多，用户越多。在线上渠道中，消费者获得的效用与使用该平台的其他用户人数具备相关性，因此线上渠 道的规模（主要用GMV衡量）和流量（主要用活跃用户数衡量）是核心指标。 变现能力反映渠道的利润率和货币化率，直接决定了企业的盈利能力。 反馈效率指渠道把信息传递给商家、供应商的速度，这将影响渠道的整体经营效率。 用户习惯反映了消费者对渠道的倾向性，这将显著影响渠道的流量。 线下渠道的壁垒在于经营模式、规模、渠道覆盖面、经营效率、组织管理能力、用户习惯等。 我们首先要弄清楚渠道是自营的还是加盟的：自营投入高、经营杠杆大，但企业对门店的把控可以做得更到位；加盟相当于自带财务杠杆，扩店所需投入小， 但需要关注加盟协议的细节，以及企业对加盟商的管理能力。 关注门店数量的多寡以及分布情况，门店的扩张需要时间，覆盖面大是线下消费业态的重要壁垒，此外扩店是线下消费最直接的增长方式。 我们要关注门店的经营效率，核心指标包括坪效、店效等，以此考量门店经营的健康程度。 组织管理能力可通过横向对比相似企业的费用率来衡量； 用户习惯主要基于大家在日常生活中对各个渠道的理解，比如“超市的菜没有菜市场的新鲜，所以尽量去菜市场”就是一个用户习惯。 自营渠道的壁垒在于经营效率、规模、渠道覆盖面、用户体验等。所谓自营，就是企业通过低买高卖的形式获利，同时承担存货风险。 通常这个买卖价差并不会很大，因此经营效率上的微小差异，最终可能给利润带来大变化。经营效率是企业长年累月抠细节抠出来的，难以复制。 规模与渠道覆盖面之间存在联系，通常渠道覆盖面大了，规模才能上来。渠道覆盖面决定有多少消费者能前来购物；规模一方面决定了渠道议价能力，影响 进货价，另一方面对于摊薄固定成本意义重大（自营渠道的经营杠杆通常比较高）。 用户体验的好坏、用户习惯的形成与改变，是决定渠道长期存亡的重要变量。 平台模式的壁垒主要在于流量及规模（网络效应）、变现能力。 线上平台和线下商铺租赁是同一种商业模式，都在为经营者提供流量，并向其收取流量费用。收费的多少很大程度上取决于平台提供流量的价值，而平台所 具备的流量在一定程度上取决于网络效应。 线下商铺也类似，租金多少由商铺人流量而定，而人流量通常取决于聚集效应。 对于平台模式的渠道而言，运营组织能力也很重要，它将在更长的周期里决定渠道的人气，并关系到渠道的价值。 总的来说，我们要关注的指标是GMV（反映规模）、活跃用户数（反映流量）、货币化率（反映变现能力）。 表3-4 消费渠道分类\n我国的零售渠道最为特殊之处在于电商。\n图3-4 2019年各国零售电商销售额\n渠道变革永不停歇，每次渠道变革都蕴藏着巨大的机会。\n图3-5 拼多多与开市客涨幅\n品牌：品牌认知带来溢价 消费者根据品牌来评价和挑选商品，制造商在品牌的组织下完成生产，经销商在品牌的管理下销售商品，可以说品牌是消费产业链的枢纽。\n品牌的壁垒，很多时候就是品牌本身。\n图3-6 “品牌计分板”理论\n“品牌计分板”理论告诉我们：\n品牌溢价的形成并非单纯由用料成本、设计、营销中的某个单一因素造成，而是通过所有品牌动作（包括设计、制造、宣传、销售等所有环节）不断和市场交 互反馈，长年累月积淀而成的。 品牌认知具备时间维度。可以把品牌认知想象成一个计分板，有的动作得分，有的动作减分。品牌认知是品牌动作反馈的最终得分，包含动作和时间两个维度。 只有在对的时候做对的事才能得分，品牌资产难以复制。比如，商家在2000年前投放央视广告，在2010年前投放淘宝直通车（买搜索排名），大概率是高分 动作，但放在此时此刻就未必了。 品牌资产的核心在于品牌认知，主要体现在品牌的规模和溢价能力上。一个优秀的品牌不但要具备足够的规模及相应的规模增速，也要有领先的定价能力、溢价 能力、涨价能力。\n具备一定的规模是一个品牌存在的必要条件，不成规模，难言品牌。品牌的销售规模是消费者用真金白银买出来的，是品牌认可度的一个直接体现。 定价能力即“说一不二”的能力，只要定了10元的建议零售价，就不会以9元卖出去，体现为打折少、力度小。 溢价能力强是指毛利率高，比如出厂价为5元的东西，可以凭借品牌力以10元甚至20元的高价卖出。 涨价能力是指能让消费者接受持续涨价，这是最为稀缺的能力，只有部分高端白酒和传统奢侈品等极少数品牌具备这样的能力。 品牌作为一个能够持续创造利润的资产，却不被计入报表之中。ROE=净利润÷净资产，由品牌资产带来的那部分利润会抬高ROE。优秀的品牌企业通常具备较高的 ROE。品牌企业中浮现了大量的“现金牛”，因为品牌的持续经营通常并不需要持续的资本性投入，经营产生的利润基本上都是自由现金流。\n表3-5 部分品牌、渠道、供应链公司的核心优势\n3.3 读懂数字，看清公司 上市公司的数据主要包括财务数据和经营数据。\n财务数据指三张合并报表（利润表、资产负债表、现金流量表）披露的数据，比如收入、利润、存货、现金流等，以及根据报表上的数据算出来的比率，比如 毛利率、净利率、营运周期、ROE等。 经营数据指三张表之外的重要数据，如门店数量、员工数量、坪效、店效等，主要来自上市公司财报的业务概要或经营情况分析等章节，也可来自上市公司官 网、官方微信公众号等渠道。 一份财报通常包括重要提示、释义、公司简介和主要财务指标、公司业务概要、经营情况讨论与分析、重要事项、股份变动及股东情况、优先股情况、 员工情况、公司治理、债券相关情况、财务报告、备查文件目录等。\n以贵州茅台2020年年度报告为例\n标准无保留意见代表对报表的质量满意，如果未获得标准无保留意见，则说明财报中的某些地方是有问题的。 重要提示之后是目录 图3-7 贵州茅台2020年年度报告目录\n公司简介和主要财务指标关注主要会计数据，可清楚看到营业收入、归属于上市公司股东的净利润、经营活动产生的现金流量净额、总资产及它们的同比变动 情况. 我们还可以在公司简介中找到公司的联系方式，若对公司的经营情况有疑问，投资者可拨打相应的电话，或在投资者交流平台上与公司互动。 图3-8 贵州茅台2020年主要会计数据\n公司业务概要主要包含公司对其主要业务的介绍。如果公司业务没有发生重大变化，那么这一段的内容可能会连续很多年没有大变化。当然，在初次分析一家 公司的时候，可以从此处入手来了解公司的主要业务。 经营情况讨论与分析是非常重要的一节，其中最重要的当数管理层对经营情况的文字分析。本节亦会披露大量的经营数据，包括重要的收入和成本的构成， 这有助于我们厘清公司的业务条线，以及各个条线的经营情况和增长情况 主要客户、主要供应商情况也很关键，一方面看采购和销售的集中程度，另一方面也可以通过前五大供应商的构成情况来辅助判断公司主要业务的经营实质 （当然大多数时候企业只会在招股书中披露前五大客户具体是谁）。 前五大供应商、客户的成交额数据有时也可以用来做交叉验证，比如若上游企业前五大客户和下游企业前五大供应商有重合，可以对比双方报表中的数据， 这可以用来大致判断双方报表的数据质量。 图3-9 贵州茅台2020年主营业务分行业、分产品情况\n重要事项统计了公司的历史股利分配方案、承诺履行、会计师事务所聘任情况、关联交易、收并购事项等内容，这部分的很多内容在此前的公告中披露过了， 投资者可利用本节查漏补缺，同时也需关注在本节中是否有可能给经营、股价带来风险的事件。 普通股股份变动及股东情况展示了公司前十大股东、前十大流通股东的变动情况，我们一般关注实控人背景、新增大股东情况、原有大股东股份变动或质押等 信息。 董事、监事、高级管理人员和员工情况是相对比较重要但分析起来有难度的一节。所谓“事在人为”，公司经营情况的好坏很大程度上取决于员工的能力及动力。 在这部分中我们可以看到公司高管的简介、变动情况，以及员工人数及构成。人数和构成都是重点，通常一家业务不断扩张的公司，员工数量会不断增多，尤 其是业务部门的员工。 关注财报中的文字信息 财报中的文字包含了大量的经营信息，有时候能领先于统计数据，折射出企业经营环境的变化。我们在阅读各类财务经营数据之前，可以先看公司管理层对公司 自身经营的分析。这部分内容一般在第四节“经营情况讨论与分析”，当然也在各种“致股东的信”中。\n阅读经营情况讨论与分析的方法：竖着读、横着读。\n竖着读指依次阅读公司历史上各个年度的经营情况讨论与分析，弄清楚公司经营和业务发生变化的脉络，并尽量和各个时期的经济大环境对应起来，找到决定 行业、公司经营的关键变量。 横着读指阅读同一个时期行业同业企业的经营情况讨论与分析，了解彼此之间的竞争情况，并对每个时期的行业景气度进行全景扫描。 利润表：主要关注收入规模及增速、利润规模及增速、毛利率、净利率和费用率等 在利润表中，最重要的两个原始数字是营业收入和归属于母公司股东的净利润（简称归母净利润）的数字。除了关注这两个数字本身，更要关注它们的同比增速。\n利润表中其余的项目，我们主要关注其占营业收入的比率，以及比率的变动趋势。\n图3-10所示为一个基本的消费品利润表分析框架。\n收入反映企业的整体经营规模，企业的成长首先要体现在收入规模的增长上。\n对于消费品企业而言，收入上升通常意味着卖出了更多的产品，有时收入规模就是企业的壁垒所在。 于品牌企业，收入规模增长通常意味着消费者对其总体认可程度提升； 于线上渠道，收入规模增长意味着流量的增长和网络效应的扩大； 于线下渠道，收入规模增长通常来自门店数量增长、覆盖面提升，或坪效、店效的增长； 于供应链企业，收入规模增长则意味着得到更多的下游订单，并有望带来规模效应。 毛利率是非常重要的指标，具备一定的前瞻性。\n一般来说，渠道和品牌企业的利润率是比较稳定的，收入增速会与利润增速相匹配。当两个增速不匹配时，除了非经常性费用、财务费用发生改变的少数情况 外，利润率会发生变化。此时我们要去溯源，看是哪一个环节的成本、费用率发生了变化。 在行业转好时，需求会率先增长起来，但企业的产能扩充难以快速跟上，此时产品价格上涨，毛利率率先提高，此后企业扩产，兑现利润；反之，毛利率将率 先下降。 对于供应链企业而言，通常影响毛利率的因素从大到小分别是：①销售情况，当行业需求变好的时候，价格提升，体现为毛利率增长；②原材料价格，当原材 料降价幅度大于产品降价幅度时，毛利率将会增长；③规模效应降低生产成本。 对于渠道企业而言，平台模式、租赁模式、联营模式的毛利率高于自营，而自建门店的毛利率大于加盟门店。很多公司同时采用多种模式经营，且不同的品类 毛利率通常不一样。当毛利率发生变化时，要先弄清楚这是由结构变化导致的，还是因为经营基本面重大变化而产生的。 费用率反映企业综合管理水平，同类企业中管理水平高的企业，费用率通常更低。这些企业通过费用率的优势，获取了高于行业的利润率。\n费用会包含一部分固定成本，因此规模效应的提升通常将在一定程度上摊薄费用率。 品牌和渠道类消费品公司的销售费用率比较高，品牌公司的销售费用主要来自营销投放等，线下渠道公司的销售费用来自门店租金和折旧、店内员工的工资等。 在分析销售费用的时候，我们要特别注意物流费用的处理方法，在2020年1月1日开始执行的新准则中，物流相关费用从销售费用转移到了营业成本，而一部分 海外公司仍然记在销售费用中，这一点我们在做横向、纵向对比的时候要特别注意。 销售费用率有时候有前瞻指导意义 我们还要将收入和成本拆分到每个业务或每个渠道，并对其逐一分析。\n首先，按业务（产品）拆分。在这一步我们要弄清楚：① 公司的主要收入来源，每个业务的收入及收入占比；② 主要的增长点，即每个业务的增速；③ 哪个业 务利润率高，即每个业务的毛利率；④ 公司的主要利润来源，一般通过毛利构成来判断。\n表3-6 申洲国际各业务收入拆分\n其次，按渠道拆分，即按照不同的渠道进行逐一拆分，弄清楚每个渠道的收入、增速、毛利率，以及相应的收入占比和毛利占比。不同的渠道会有不同的成本和 费用结构，如果不拆清楚，分析就没有意义。\n表3-7 周大生各渠道收入拆分\n以上两个拆分步骤进行完毕之后，我们可以进一步按照“量×价”对收入进行拆分，即拆出销量和单价。有时候财报只披露了销量，这时候我们可以用销售额除以 销量来估算单价。我们可以纵向观察每个产品的销量、单价、毛利率在历史上的变动关系，以及相互之间的关联性。“量×价”也可以按其他方式来进行展开，比如 “店铺数量×单店收入”，或者“经营面积×坪效”等。这里的关键在于找出公司的增长驱动力，发掘不同经营指标之间的关系，并找出决定公司业绩的核心变量。\n资产负债表：关注营运能力指标 观察资产负债表，第一个项目是现金及现金等价物。这是一个相对重要的指标，是否有足够的现金关系到企业能否持续正常运转。\n资产负债表中的营运能力指标会耗费我们大量的分析时间，这些指标主要包括：存货、应收账款、应收票据、应付账款、应付票据、预收款项、预付款项等。对 于这些指标，除了关注其绝对值之外，更重要的是关注其周转速度指标（如周转率、周转天数，二者的区别仅为展现方式不同，乘积为365）。\n存货是一个需要特别小心的科目，其金额和周转天数都要关注。\n第一，一部分消费品存在保质期或时间价值，老库存过多将有可能导致存货减值损失，而如果清仓甩卖，则有可能带来直接亏损，并影响品牌价格带。 第二，存货过高会占用企业的运营资金，影响运营效率。 存货一般可以分为三类：原材料、在产品或半成品、产成品（包括库存商品和发出商品）。\n应收应付款项、预收预付款项代表着企业的行业地位。在产业链中地位越高，就越能够占用上下游资金，体现为预收款项和应付款项高，而预付款项和应收款项 少。\n现金流量表：消费赛道频出“现金牛” 在国内现行管理下，我们更多地关注现金流量表中的经营活动净现金流量。经营活动净现金流量的数值通常会高于净利润，因为净利润不会包括企业的折旧摊销 费用。\n如何看待消费行业的ROE ROE是一个非常重要的财务指标，由净利润除以账面净资产得来，其含义是“股东每投入1元钱，每年能够产生多少净利润”。ROE还表征企业自然增速的天花板： 假设企业新业务的ROE等于原有业务，那么如果企业将每年的利润都投入到再生产中，所能带来的业绩增速就等于该ROE，而我们知道新业务的ROE通常不会高于 原有业务，因此ROE通常被认为是企业自然增速的天花板。\n我们一般会比较看重供应链企业的ROE，而不会太关注消费品牌和加盟类、平台类渠道的ROE。\n对于供应链企业，ROE能很好地反映“每投1元钱能赚多少”，但对于品牌和渠道则不行。 品牌是在企业与消费者长年累月的不断交互中产生的，花钱并不一定能买来品牌认知； 而不同渠道企业如果采取不同的经营模式，会直接对ROE造成较大的扰动； 此外，像阿里巴巴这类电商平台的核心资产其实是平台上的用户和供应商，这些资产不会被计价放入报表中，因此也会使ROE失去意义。 数据的作用仅仅是帮助我们理解行业的景气度和企业的经营情况。在实践中，我们应当站在企业家的角度，思考整个生意的运转，这样才能够得到真实的、对投 资有意义的结论。\n3.4 探寻消费牛股的上涨驱动力 股价=P/E×EPS，股价的上涨可以由利润驱动（EPS驱动），也可以由估值驱动（P/E驱动）。从历史上看，大多数消费牛股都是由利润驱动的。\n表3-8 A股消费行业牛股股价增长拆解（2011-12-31～2021-12-31）\n论消费品估值：为何消费品企业的PEG常大于1\n消费品企业的增长持续性、确定性强。品牌力的形成、产品不断提价、用户消费习惯的转变、新消费渗透率的提升、渠道网络效应的形成，都是消费品企业增长 的根本来源。历史多次证明这些转变是缓慢但具备趋势性的，很多时候企业增速虽然不太高，但能够持续很多年，且增长具有惯性，确定性较强，因此市场乐于 给予使PEG\u0026gt;1的估值。\n再论消费品估值：什么样的企业能够实现长期估值增长\n为什么这些白酒、调味品标的能够在长周期内实现估值的增长？\n答案是：涨价逻辑。头部白酒品牌的涨价逻辑类似于奢侈品。\n首先，白酒是有社交和分享属性的商品，饮酒的场合通常是各种聚会，在这类场合下人们有溢价购买品牌商品的动力，对价格相对不敏感。 其次，在白酒品牌中，口碑最佳、最具品牌力的就是这些A股龙头白酒上市公司，市面上能够买到的最好的白酒，就出自这些品牌。 最后，白酒保质期长，越放越醇，越值钱。 图3-13 飞天茅台（53度）的经销商调货均价持续上升\n调味品在一盘菜中所占的成本比重极低，几乎可以忽略不计，但存在感高，在相当大的程度上决定了一盘菜的风味。仅几滴酱油，就能决定菜品的色香味，而如 果换了一个品牌，可能就完全不一样了。这使得用户对酱油的品种存在较强的黏性，同时对涨价相对不敏感。因此，酱油这类调味品拥有很高的涨价能力。\n为什么涨价能力如此重要？因为其代表永续增长和跑赢通胀的能力。有涨价能力意味着企业可以以超过通胀的速度逐渐提升其产品的售价，以实现实际意义上的 永续增长当然，这个永续增长的速度并不会很快。这类资产在经济增速放缓、无风险利率下降的经济环境下，将迎来估值提升。提升的本质逻辑可以用戈登模型 解释，戈登模型告诉我们，股票的P/E=1/（r-g）。如表3-9所示，永续增长率g更高的资产，在贴现率r下降时，估值的增长幅度更大。\n表3-9 在不同贴现率、永续增长率下，戈登模型预示的P/E\n3.5 结语 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC3%E7%AB%A0-%E6%B6%88%E8%B4%B9%E5%93%81%E6%8A%95%E8%B5%84%E5%89%91%E6%8B%9B/","summary":"3.1 如何发现好赛道 必选消费中有食品饮料、日用品、卫生用品、烟酒等，可选消费有珠宝首饰、房地产、汽车 如何从种类繁多的领域中找到成长性强、模式优秀","title":"第3章 消费品投资剑招"},{"content":"品牌投资的三条主要逻辑 行业规模、渗透率提升：行业增长可由消费人群的增长或人均消费的增长驱动，渗透率指的是现有消费群体在潜在消费群体中的占比，渗透率提升是品类市场 规模增长的重要驱动力。 市占率提升：如果行业原本较为分散，没有成规模、成体系的供应，这时出现了品牌公司整合资源实现规模化，就有品牌化程度提升；如果行业的龙头公司不 断扩大市场份额，品牌增速大于行业增速，就有品牌集中度提升。 价格带提升：一部分消费品具备持续提升价格带的能力，比如茅台、爱马仕等；另一些消费品公司则通过不断提升产品定位，做高端迭代来提升产品价格带， 如华为等。 2.1 消费品品牌增长逻辑之一：行业规模、渗透率提升 行业规模增长可以拆分成用户基数增长和人均消费增长\n图2-1 行业规模增长可拆分成用户基数（渗透率）增长和人均消费增长\n现阶段大多数的消费品品类已经进入了成熟期，拥有渗透率提升逻辑的并不多。这类行业通常代表新兴需求，如2021年的新能源汽车、医美、扫地机器人等行业， 都拥有渗透率提升的增长逻辑。\n医美就是一个典型的渗透率增长的行业。\n图2-2 每千人医美诊疗次数（2019年）\n图2-3 中国大众对医美的接受度调查（2018年）\n图2-4 我国不同城市层级的医美渗透率（2020年）\n图2-5 我国医美消费者年龄分布（2020年）\n2.2 消费品品牌增长逻辑之二：市占率提升 市占率提升包括品牌化程度提升和品牌集中度提升。\n品牌化程度提升指的是，把原本并不集中的行业通过品牌整合起来，如连锁餐饮行业； 品牌市占率提升指的是，行业内具备优势的品牌蚕食对手份额，提升市占率的过程 图2-6 中日美餐饮连锁化率\n海底捞崛起的逻辑是品牌化程度提升\n图2-7 2020年中国连锁餐饮市占率\n龙头企业市占率提升背后的原因包括：\n规模生产降低成本，从而提供了质量更好、更具性价比的产品； 知名度高，具备更强的消费者认知； 拥有分布更广的销售和售后服务渠道等。 通常而言，具备功能性的消费品细分赛道更容易出现市占率较高的大品牌，因为细分赛道中的龙头品牌更加容易被贴上标签，与某些特殊功能、功效形成强绑定。\n图2-8 皮肤学级护肤品行业龙头品牌市占率高于整个化妆品行业\n2.3 消费品品牌增长逻辑之三：价格带提升 在具备彰显个性和社交属性特征的消费品赛道，通常更容易出现具备持续提价能力的品牌。\n茅台 爱马仕 图2-9 飞天茅台（53度）的经销商调货价格持续上升\n根据戈登模型P/E=1/（r-g），在投资者要求的回报率r（即贴现率）保持不变的情况下，永续增长率g越高的标的，其合理P/E越高。\n表2-1 在不同贴现率、永续增长率下，戈登模型预示的P/E\n类似茅台、爱马仕这样具备直接提价能力的品牌毕竟是极少数。对于大部分消费品品牌而言，提价主要通过产品迭代完成。\n图2-10 波司登2017～2018年各价格带产品销售量分布\n图2-11 我国高端美妆个护品的市占率逐年提升\n总的来说，渗透率提升阶段的资产进攻性最强、涨得最快、风险最大，投资时要充分小心，要充分摸清公司质地，并保持对公司基本面的紧密跟踪，当增速不及 预期时要及时防范回撤风险。投资于市占率不断提升的龙头公司是一种平衡了风险和收益的好做法，关键在于对行业的景气度以及公司的成长速度保持跟踪。而 投资于具备持续涨价能力的品牌企业是一种相对稳妥的做法，理论上这类资产在当前经济增长放缓、无风险利率下行的经济环境之下，会有让人眼前一亮的表现。\n2.4 结语 行业规模与渗透率提升是稀缺逻辑。大多数消费品品类已经进入成熟期，行业规模与渗透率提升逻辑主要出现在新兴需求领域。拥有这类逻辑的消费品容易实现 持续高增长。\n市占率提升即品牌化程度提升、品牌集中度提升。品牌化程度提升指品牌把分散的行业整合起来，品牌集中度提升指龙头企业市占率提升。\n拥有持续提价能力的品牌容易成为核心资产。大多数品牌通过产品高端化迭代来提升价格带，只有极少数品牌拥有让产品直接涨价的能力。\n","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC2%E7%AB%A0-%E6%B6%88%E8%B4%B9%E5%93%81%E6%8A%95%E8%B5%84%E5%BF%83%E6%B3%95/","summary":"品牌投资的三条主要逻辑 行业规模、渗透率提升：行业增长可由消费人群的增长或人均消费的增长驱动，渗透率指的是现有消费群体在潜在消费群体中的占比，","title":"第2章 消费品投资心法"},{"content":"2.1 指针构成 1 var p *int 无论指针的元素类型是什么，指针变量本身的格式都是一致的，即一个无符号整型，变量大小能够容纳当前平台的地址。例如在386架构上是一个32位无符号整 型，在amd64架构上是一个64位无符号整型。\n有着不同元素类型的指针被视为不同类型，这是语言设计层面强加的一层安全限制，因为不同的元素类型会使编译器对同一个内存地址进行不同的解释。\n2.1.1 地址 2.1.2 元素类型 后两条指令由MOVQ变为MOVL\n2.2 相关操作 2.2.1 取地址 LEAQ指令的作用就是取得main.n的地址并装入AX寄存器中。后面的MOVQ指令则把AX的值复制到返回值p。\n这里获取的是一个包级别变量n的地址，等价于C语言的全局变量，变量n的地址是在编译阶段静态分配的，所以LEAQ指令通过位移寻址的方式得到了main.n 的地址。 LEAQ同样也支持基于基址和索引获取地址 Go语言通过逃逸分析机制避免返回局部变量地址所引发的问题, 实际上在堆上分配\n2.2.2 解引用 空指针异常 所谓空指针，就是地址值为0的指针。按照操作系统的内存管理设计，进程地址空间中地址为0的内存页面不会被分配和映射，保留地址0在程序代码中用作无效 指针判断，所以对空指针进行解引用操作就会造成程序异常崩溃 遭遇空指针异常并非语言设计方面的缺陷，而是程序逻辑上的Bug。 野指针问题 在C语言中, 未初始化的指针变量是随机值, 会绕过代码中的空指针判断逻辑，从而造成内存访问错误。 Go语言中声明的变量默认都会初始化为对应类型的零值，指针类型变量都会初始化为nil 悬挂指针问题 指程序过早地释放了内存，而后续代码又对已经释放的内存进行访问，从而造成程序出现错误或异常。 Go语言实现了自动内存管理，由GC负责释放堆内存对象。GC基于标记清除算法进行对象的存活分析，只有明确不可达的对象才会被释放 2.2.3 强制类型转换 2.2.4 指针运算 假如有一个元素类型为int的指针p，要把p移动到下一个int的位置，在C语言中可以通过指针的自增运算实现，代码如下：\n1 ++p; 在Go语言中等价的代码如下：\n1 p = (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(p))+unsafe.Sizeof(*p))) 2.3 unsafe包 经典的类型转换\n图2-1 String Header和Slice Header的结构\n如果不经意修改了slice就可能会造成程序逻辑错误。\n2.3.1 标准库与keyword ArbitraryType在这里只是用于文档目的，实际上并不属于unsafe包，它可以表示任意的Go表达式类型。 Sizeof()函数用来返回任意类型的大小 Offsetof()函数用来返回任意结构体类型的某个字段在结构体内的偏移 Alignof()函数用来返回任意类型的对齐边界 最重要的是这3个函数的返回值都是常量。 这条MOVQ指令直接向返回值o中写入了立即数8，也就说明Sizeof()函数在编译阶段就被转换成了立即数。 上述测试方法同样适用于Offsetof()函数和Alignof()函数。 2.3.2 关于uintptr 很多人都认为uintptr是个指针，其实不然。不要对这个名字感到疑惑，它只不过是个uint，大小与当前平台的指针宽度一致。因为unsafe.Pointer可 以跟uintptr互相转换，所以Go语言中可以把指针转换为uintptr进行数值运算，然后转换回原类型，以此来模拟C语言中的指针运算。\n需要注意的是，不要用uintptr来存储堆上对象的地址。具体原因和GC有关，GC在标记对象的时候会跟踪指针类型，而 uintptr不属于指针，所以会被GC忽略, 造成堆上的对象被认为不可达，进而被释放。用unsafe.Pointer就不会存在这个问题了，unsafe.Pointer类 似于C语言中的void∗，虽然未指定元素类型，但是本身类型就是个指针。\n参考聊一个string和[]byte转换问题\n2.3.3 内存对齐 硬件的实现一般会将内存的读写对齐到数据总线的宽度，这样既可以降低硬件实现的复杂度，又可以提升传输的效率。 Go语言的内存对齐规则参考了两方面因素：一是数据类型自身的大小，复合类型会参考最大成员大小；二是硬件平台机器字长。 机器字长是指计算机进行一次整数运算所能处理的二进制数据的位数，在x86平台可以理解成数据总线的宽度。当数据类型自身大小小于机器字长时，会被对齐 到自身大小的整数倍；当自身大小大于机器字长时，会被对齐到机器字长的整数倍。\n通过unsafe.Sizeof()函数和unsafe.Alignof()函数可以得到目标数据类型的大小和对齐边界\n地址应该是Alignof的倍数.\n表2-1 常见内置类型的大小和对齐边界\n通过调整结构体成员的位置，尽量避免编译器添加padding\n2.4 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC2%E7%AB%A0-%E6%8C%87%E9%92%88/","summary":"2.1 指针构成 1 var p *int 无论指针的元素类型是什么，指针变量本身的格式都是一致的，即一个无符号整型，变量大小能够容纳当前平台的地址。例如在386架构","title":"第2章 指针"},{"content":"1.1 消费行业的特点 消费涵盖了人们生活的方方面面，范围广、韧性强\n消费对应了大多数行业的终端需求\n不论是上游周期行业，还是中游科技制造行业，最终都将会以某种形式对应到终端的消费上 消费行业牛股辈出，基业长青\n具备明显的经营壁垒，能占据人们的认知和心智，通过品牌认知、网络效应不断为投资者带来超额收益\n1.2 消费研究，始于日常 在众多的行业中，消费行业可谓是最容易理解的赛道之一。理解消费行业，不需要太多的数理化专业知识，不需要相关的从业经验，甚至不一定需要第一手的行 业数据。只要能够做到对周围生活敏锐洞察和深刻理解，每个人都能够从自身周围感受、感知到投资的机会。\n1.3 中美消费行业复盘对比 总的来说，中美两国的消费品发展，都出现过三个典型的阶段。\n第一个阶段是生活必需品普及阶段，主要是食品和生活用品的普及； 第二个阶段是家庭消费阶段，体现为大家电、汽车渗透率的提升； 第三个阶段是个人消费阶段，体现为品牌商品的增长，在这个阶段，人们消费更加注重个性化的需求和消费主张的宣扬。 美国消费行业发展复盘\n第一个阶段是1900～1930年的生活必需品普及阶段 第二个阶段是1930～1960年的家庭消费阶段 第三个阶段是1960～1990年的个人消费阶段 第四个阶段是1990年至今的新消费阶段。 图1-6 美国各类主要消费品的历史渗透率 回顾改革开放以来的中国消费发展历史\n至2021年，我国的消费发展历史大致可以分为生活必需品、家庭消费、个性化消费三个阶段。 中国消费的下一个阶段\n美国的主题是新消费习惯、新消费主张的兴起，这带来了大量的新需求与新品牌崛起的机会； 日本的主题是低欲望，是对于朴素、精巧、实用、去品牌化的追求。 笔者认为，中国消费行业未来的发展会更像美国，而不像日本 1.4 欧美消费股群雄志 总的来说，欧美股市投资回报率比较高的标的主要是奢侈品、有一定溢价能力的品牌、餐饮等服务公司、持续扩张的渠道商，而投资回报率比较一般的标的主要 是市场空间趋于饱和的大众消费品、成熟渠道。在回报率较高的标的中有大量的“十倍股”，而投资回报率一般的标的也能给投资者带来两三倍的稳定回报。从风 险回报比上看，消费品投资是一个值得下注的赛道。\n消费品企业的估值存在共性：如图1-19所示，企业P/E中枢大体上稳定在15～35倍，其中奢侈品的估值较高，而大众消费品的估值较低。\n1.5 结语 第一，奢侈品具备长期的价值。 茅台 第二，有功能性、品牌力强的消费品。 李宁 安踏 珀莱雅 贝泰妮 第三，在服务消费中，能够实现连锁化、标准化的行业是好的投资方向。 第四，渠道和大众消费品的投资机会主要来源于业务的扩张。 ","permalink":"https://jdxj.github.io/posts/books/%E5%90%B4%E5%8A%B2%E8%8D%89%E8%AE%B2%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%9A-%E5%8F%91%E7%8E%B0%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%95%BF%E7%BA%BF%E5%A4%A7%E7%89%9B%E8%82%A1/%E7%AC%AC1%E7%AB%A0-%E4%B8%BA%E4%BD%95%E9%80%89%E6%8B%A9%E6%B6%88%E8%B4%B9%E5%93%81%E6%8A%95%E8%B5%84/","summary":"1.1 消费行业的特点 消费涵盖了人们生活的方方面面，范围广、韧性强 消费对应了大多数行业的终端需求 不论是上游周期行业，还是中游科技制造行业，最终都将","title":"第1章 为何选择消费品投资"},{"content":"1.1 x86通用寄存器 32位x86是intel推出的,64位x86_64是amd推出的(amd64)\n1.1.1 32位架构 在汇编中使用名称来引用寄存器.\n表1-1 Intel指令编码中8个通用寄存器的编号和名称\n编号 名称 编号 名称 0 EAX 4 ESP 1 ECX 5 EBP 2 EDX 6 ESI 3 EBX 7 EDI 0~3号寄存器可以拆分\n图1-1 EAX寄存器的结构 表1-2 编号为0～3的寄存器的结构设计\n32位 16位 高8位 低8位 EAX AX AH AL ECX CX CH CL EDX DX DH DL EBX BX BH BL 4~7号寄存器没有8位独立名称\n表1-3 编号为4～7的寄存器的结构设计\n32位 16位 32位 16位 ESP SP ESI SI EBP BP EDI DI 通用寄存器的特殊用途\nEAX寄存器会被乘法和除法指令自动使用，通常称为扩展累加寄存器。 ECX被LOOP系列指令用作循环计数器，但是多数上层语言不会使用LOOP指令，一般通过条件跳转系列指令实现。 ESP用来寻址栈上的数据，很少用于普通算数或数据传输，通常称为扩展栈指针寄存器。 ESI和EDI被高速内存传输指令分别用来指向源地址和目的地址，被称为扩展源索引寄存器和扩展目标索引寄存器。 EBP在高级语言中被用来引用栈上的函数参数和局部变量，一般不用于普通算数或数据传输，称为扩展帧指针寄存器。 EFLAGS标志寄存器\n汇编语言中用于比较的CMP和TEST会修改标志寄存器里的相关标志，再结合条件跳转系列指令，就能实现上层语言中的大部分流程控制语句 EIP指令指针寄存器\n存储的是下一条将要被执行的指令的地址，而且汇编语言中不能通过名称直接引用EIP，只能通过跳转、CALL和RET等指令间接地修改EIP的值。 1.1.2 64位架构 64位架构把通用寄存器的个数扩展到16个，之前的8个通用寄存器也被扩展成了64位，每个寄存器的低8位、16位、32位都可以单独使用。\n表1-4 64位架构下16个通用寄存器的结构设计\n64位 32位 16位 8位 RAX EAX AX AL RCX ECX CX CL RDX EDX DX DL RBX EBX BX BL RSP ESP SP SPL RBP EBP BP BPL RSI ESI SI SIL RDI EDI DI DIL R8~R15 R8D~R15D R8W~R15W R8B~R15B 指令指针EIP被扩展为64位的RIP，但依然不能在代码中直接引用。标志寄存器EFLAGS被扩展为64位的RFLAGS，里面的标志位保持向前兼容。\n1.2 常用汇编指令 x86的汇编指令一般由一个opcode（操作码）和0到多个operand（操作数）组成，大多数指令包含两个操作数，一个目的操作数和一个源操作数。\n1.2.1 整数加减指令 源操作数可以是寄存器, 内存, 立即数, 目的操作数可以是寄存器, 内存. 两个操作数不能同时为内存\nADD EAX, 16 ; EAX = EAX + 16 SUB ESP, 32 ; ESP = ESP - 32 ADD AL, CL ADD AX, CX 1.2.2 数据传输指令 MOV指令主要用来在寄存器之间及寄存器和内存之间传输数据，也可以用来把一个立即数写到寄存器或内存中。\nMOV EAX, ECX ; EAX = ECX MOV EDX, 1234 ; EDX = 1234 内存寻址方式\nDisplacement：位移，是一个8位、16位或32位的值。 Base：基址，存放在某个通用寄存器中。 Index：索引，存放在某个通用寄存器中，ESP不可用作索引。 Scale：比例因子，用来与索引相乘，可以取值1、2、4、8。经过计算得到的地址称为有效地址。 Effective Address = Base + (Index x Scale) + Displacement (1-1) 基于Base和Displacement的寻址\n位移(Displacement)：一个单独的位移表示距离操作数的直接偏移量。因为位移被编码在指令中，所以一般用于编译阶段静态分配的全局变量之类。 基址(Base)：将内存地址存储在某个通用寄存器中，寄存器的值可以变化，所以一般用于运行时动态分配的变量、数据结构等。 基址＋位移(Base＋Displacement)：基址加位移，尤其适合寻址运行时动态分配的数据结构的字段，以及函数栈帧上的变量。 MOV EAX, [16] ; 位移 MOV EAX, [ESP] ; 基址 MOV EAX, [ESP + 16] ; 基址 + 位移 1.2.3 入栈和出栈指令 PUSH EAX ; 等价于 SUB ESP, 4 MOV [ESP], EAX POP EAX ; 等价于 MOV EAX, [ESP] ADD ESP, 4 1.2.4 分支跳转指令 JMP指令会修改EIP的值\n只有一个操作数, 可以是立即数, 通用寄存器, 内存位置 JMP 32 JMP EAX JMP [EAX+32] 1.2.5 过程调用指令 可以认为CALL在JMP的基础上多了一步记录返回地址的操作\nCALL指令先把返回地址入栈，然后跳转到目的地址执行 目的地址也可以经由一个立即数、通用寄存器或内存位置来给出。\nCALL EAX ; 等价于 PUSH 32 JMP EAX 子过程执行完成后通过RET指令返回，RET指令会从栈上弹出返回地址，并跳转到该地址处继续执行。\nRET 可以不带参数 RET 8 ; 等价于 RET ADD ESP, 8 1.3 内存分页机制 在分页模式下，应用程序中使用的地址被称为线性地址，需要由MMU(Memory Management Unit)基于页表映射转换为物理地址，整个转换过程对于应用程序 是完全透明的。\n1.3.2 80386两级页表 每个页面4KB, 地址总线32bit, 物理地址32bit 每个页面存1024个地址 = 4KB/32bit(4B) = 1K 图1-2 80386线性地址到物理地址的转换 1.3.3 PAE三级页表 Physical Address Extension，PAE 物理地址扩展\nPAE地址总线36bit, 使硬件能够寻址64GB 仍使用32bit线性地址宽度(进程地址空间大小不变) 每个页面4KB, PAE地址总线36bit, 物理地址64bit 每个页面存储512个地址 = 4KB/64bit(8B) = 0.5K 图1-3 PAE线性地址到物理地址的转换 1.3.4 x64四级页表 Intel推出的IA64架构因为与原来的x86架构不兼容，所以没能普及，而AMD公司通过扩展x86推出的x64架构，因为良好的向下兼容性而被广泛采用。常见的 x64、x86_64都是指amd64架构，如今的个人计算机基本是基于amd64架构的。\n在amd64上，寄存器的宽度变成了64位，而线性地址实际只用到48位，也就是最大可寻址256TB的内存。很少有单台计算机会安装如此大量的内存，所以没有必 要实现48位的地址总线，常见的个人计算机的CPU的地址总线实际还不到40位，例如笔者的计算机的Core i7实际只有36位。服务器的CPU的地址总线的宽度会 更大，例如Xeon E5系列能达到46位。\n每个页面4KB, 地址总线48bit, 物理地址64bit 每个页面存储512个地址 = 4KB/64bit(8B) = 0.5K 1.3.5 虚拟内存 猜测前面的地址转换图中的CR3是每个进程页表的起始物理地址\n进程是以页面为单位向操作系统申请内存的，操作系统一般只是对进程已申请的区间进行记账，并不会立刻映射所有页面。等到进程真正去访问某个未映射的页 面时，才会触发Page Fault异常，操作系统注册的Page Fault Handler会检查内存记账：如果目标地址已申请，就是合法访问，系统会分配一个物理页面并 完成映射，然后恢复被中断的程序，程序对这一切都是无感的；如果目标地址未申请，就是非法访问，系统一般会通过信号、异常等机制结束目标进程。\n当物理内存不够用的时候，操作系统可以把一些不常使用的物理页面写到磁盘交换分区或交换文件，从而能够将空出的页面给有需要的进程使用。当被交换到磁 盘的页面再次被访问时，也会触发Page Fault，由Page Fault Handler负责从交换分区把数据加载回内存。程序对这一切都是无感的，并不知道某个内存页 面到底是在磁盘上，还是在物理内存中，所以称为进程的虚拟内存。\n1.4 汇编代码风格 1.操作数的宽度\n在Go汇编中通过指令的后缀来判断操作数的宽度，后缀W代表16位，后缀L代表32位，后缀Q代表64位，不像Intel汇编中有AX、EAX、RAX不同的寄存器名称。 例如对于整数自增指令，Intel汇编风格的代码如下：\nINC EAX INC RCX 对应的Go汇编风格的代码如下：\nINCL AX INCQ CX 2.操作数的顺序\n对于常见的有两个操作数的指令，Go汇编中操作数的顺序与Intel汇编中操作数的顺序是相反的，源操作数在前而目的操作数在后。\n例如Intel汇编的代码如下：\nMOV EAX, ECX 转换成Go汇编的代码如下：\nMOVL CX, AX 3.地址的表示\n有效地址的计算公式如式(1-1)所示，如果要用ESP作为基址寄存器，EBX作为索引寄存器，比例系数取2，位移为16，则可以分别给出两种风格的代码。\nIntel汇编的代码如下：\n[ESP + EBX*2 + 16] Go汇编的代码如下：\n16(SP)(BX*2) 4.立即数格式\nGo汇编中的立即数类似于AT\u0026amp;T风格的立即数，需要加上$前缀。\nIntel汇编的代码如下：\nMOV EAX, 1234 Go汇编的代码如下：\nMOVL $1234, AX 1.5 本章小结 ","permalink":"https://jdxj.github.io/posts/books/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2go%E8%AF%AD%E8%A8%80--%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Eruntime%E7%9A%84%E5%8E%9F%E7%90%86%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%AC%AC1%E7%AB%A0-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/","summary":"1.1 x86通用寄存器 32位x86是intel推出的,64位x86_64是amd推出的(amd64) 1.1.1 32位架构 在汇编中使用名称来引用寄存器. 表","title":"第1章 汇编基础"},{"content":"构建适合自己的盈利体系 对普通投资者来说，要构建什么样的盈利体系呢？\n首先，它要适合自己的能力圈。对普通投资者来说，学习基本面投资的方法，在自己熟悉的行业或领域内坚持价值投资，是很好的盈利方法。 其次，它要逻辑自洽。 再次，它要符合市场规律和趋势。 最后，它要可持续、可复制。 投资的2.5分原则——接受不完美的股票 满足 \u0026ldquo;好赛道+好公司+好估值\u0026rdquo; 的股票几乎不存在.\n不一定非要找到得3分的股票才投资，得2.5分的股票也可以考虑。得2.5分的股票，是满足3个条件中的两个，其中一个条件不太差、不得零分的股票。 让我想起了 CAP定理\n具备常识和逻辑能力 常识例子\n在基本面不变的情况下，买入的价格越低，风险就越低，未来的投资回报就越高 “十送十”、“十送二十”这样的“高送转”，只是数字游戏，对股票的投资价值没有任何影响 投资者的持仓成本不影响股价未来的涨跌 感悟\n投资无法偷懒，想做好投资必须勤奋 做投资一定要避免管中窥豹，避免利用局部的信息直接做出投资决策，完整、详尽的研究非常有必要 要做可预测性强的决策 预测链条越长，可预测性就越差. 预测宏观经济 -\u0026gt; 预测行业周期 -\u0026gt; 预测公司基本面 影响因素越多，预测越难. 股票指数, 宏观经济、货币政策（流动性）、大国关系、海外市场、大宗商品价格、市场情绪、监管政策等 影响因素的可变性越强，预测越难. 国际关系 价值投资是预测链条短, 影响因素少且相对稳定的投资方法. 把预测变量范围缩小至单个公司，而且只选择有护城河的龙头公司进行跟踪和预测，大 大降低了预测的难度 模糊正确和精确错误. 很多时候大家会陷入过于在意细节的旋涡, 而忽视更高维度的信息 资金性质决定投资策略 如果资金期限足够长，投资策略就可以关注行业的长期趋势、企业的长期竞争力和发展空间，忽略短期的股价波动。 如果资金规模大，投资策略就要求所投资的领域有较大的市场容量，构建资产配置方案并多元化投资。 如果资金期限短、规模小，投资策略应偏向于趋势投资、短期博弈，更关注短期的机会。 投资中安全边际极度重要 股票内在价值与市场价格之间的差距，就是安全边际。 价值投资者是利用市场的非理性和错误定价，在资产价格低于其潜在价值时买入该资产，这样就获得了安全边际。 择时不靠谱 杠杆是价值投资的大敌. 如果你加了杠杆，就有期限限制，就有止损机制，这时候时间不再是你的朋友，而是你的敌人。 区分能力和运气. 当你没有至少5年的业绩来证明的时候，你就不能认为自己能力有多强。 投资中“昂贵”的一句话: 这次情况有所不同！ 不看后视镜开车，拥挤的地方不去，不懂的股票不碰 善于第二层次思维 例子 第一层次思维这样想：这是一家好公司，所以我们可以买这家公司的股票。第二层次思维这么认为：这是一家好公司，市场上很多人也认为它是好公司，所以它 的股价已经很高，它的股票不一定值得买。\n第一层次思维认为：现在经济不好，通货膨胀率很高，股市行情不好，我们要卖股票。第二层次思维认为：现在经济不好，很多人恐慌，都在卖股票，说不定有 买入的机会。\n第一层次思维认为：公司利润下跌，所以我们要卖出股票。第二层次思维认为：这家公司利润确实下跌了，但是它的下跌幅度比大家预期的小，说不定是一个投 资机会。\n第一层思维认为：A股市场是一个投机市，所以基本面研究是没有用的。第二层次思维认为：A股市场确实有很多投机者，也有定价错误，所以我们能用基本面研 究的方法找到定价错误，获得超额收益。\n第二层次思维是帮助大家发现定价错误，而不能代替系统研究和严密决策。\n《投资最重要的事》的核心观点, 霍华德从自己40多年的投资经验中，提炼总结出投资最重要的18件事。\n最重要的不是盲目相信股市总是有效或者总是无效，而是清醒认识到股市相当高效而且相当难以击败，只有真正的高手才能长期战胜市场。 最重要的投资决策不是以价格为本而是以价值为本。 最重要的不是买好的而是买得好。 最重要的不是波动性风险而是永久损失的可能性风险。 最重要的巨大风险不是人人恐惧而是人人都觉得风险很小。 最重要的不是追求高风险高收益而是追求低风险高收益。 最重要的不是趋势而是周期。 最重要的不是市场心理钟摆的中点而是终点的反转。 最重要的不是顺势而为而是逆势而为。 最重要的不是想到而是做到逆向投资。 最重要的不是价格、价值而是相对的性价比，即安全边际。 最重要的不是主动寻找机会而是耐心等待机会上门。 最重要的不是预测未来而是认识到未来无法预测但可以准备。 最重要的不是关注未来而是关注现在。 最重要的是认识短期业绩靠运气、长期业绩靠技术。 最重要的不是进攻而是防守。 最重要的不是追求伟大成功而是避免重大错误。 最重要的不是牛市跑赢市场而是熊市跑赢市场。 坚持简单实用的价值投资 第一，选择简单行业里的好公司。 消费品、公用事业等行业 第二，在股市低迷甚至恐慌时买入。这样大概率就能买到价格比较低、估值比较合理的股票。 第三，组合投资，不集中持股。 第四，耐心持有，做好公司的朋友，等待时间帮助公司实现价值。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%81%9A%E4%B8%AA%E8%81%AA%E6%98%8E%E7%9A%84%E6%8A%95%E8%B5%84%E8%80%85/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%81%AA%E6%98%8E%E6%8A%95%E8%B5%84%E8%80%85%E7%9A%84%E6%8A%95%E8%B5%84%E5%87%86%E5%88%99/","summary":"全书总结","title":"第十章 聪明投资者的投资准则"},{"content":"把股市当作赌场 资本市场的三类钱 聪明钱是那些有深刻洞察力、前瞻判断力的资金。一般来说，聪明钱赚的是上市公司成长的钱。中国A股市场有很多公司给投资者创造了丰厚回报。当然，聪明钱 有时候也会利用人的恐惧和贪婪，在市场低迷时买入，在市场疯狂时卖出，赚一部分其他投资者亏的钱。\n邪恶钱是各类游资，它们不太看公司基本面，善于制造题材和热点，吸引个人投资者跟风，并趁机获利。它们赚的不是上市公司成长的钱，赚的是博弈的钱。它 们赚的钱，基本上是个人投资者亏的钱。\n傻钱，是不懂基本面，不懂估值，无知无畏的钱。A股市场这样的资金很多，而且源源不断。\n图9-1 A股市场生态图 基于错误的原因买入股票 轻信所谓“内部消息”买入股票 因为“题材”买入股票 因为“高送转”买入股票 “高送转”只是一个数字游戏，相当于把一张20元纸币分成两张10元纸币，对投资者没有任何意义 因为股价放量突破买入股票 因为股票连续下跌买入股票 因为喜欢某公司的产品买入其股票 持仓成本影响决策 你应该继续持有还是卖出某只股票，和你的持仓成本、盈亏没有任何关系，只和这只股票未来的涨跌预期有关。\n股票的价格未来会涨还是会跌，取决于基本面和估值 对股价止损，而不是对基本面止损 投资要对基本面止损，而不是对股价止损。\n如果发现自己对一家公司的基本面判断错误，或者一家公司的基本面发生了逆转，这时候你要坚决止损，哪怕自己已经亏了很多钱。 顽固坚持已经失效的策略 表9-1 2016年年底市盈率分布情况（剔除亏损股） 小盘股是否真的意味着高成长? 不管从国内经验看，还是从国际经验看，产业在不断走向集中。而行业龙头，依靠着它的品牌、渠道、规模效应，会获得比小市值公司更高、更确定的业绩增长。\n这两年小盘股溢价正在快速消失。 表9-2 2018年年底市盈率分布情况（剔除亏损股） 随着小盘股溢价消失，小市值的公司越来越多。 表9-3 2016年年底和2018年年底市盈率对比（没有剔除亏损股） 并购或者重组策略，还是好的投资策略吗? 第一，IPO新政实施后，监管部门对并购加强了监管，不再允许随意的并购。 第二，IPO速度加快后，原来因为IPO时间久而被迫选择和上市公司并购的优秀资产，现在自己排队进行IPO。相比并购，IPO对优质资产的股东来说，收益更 大。 我们如何得知公司的并购是否合理呢？\n第一，并入资产是否具有可持续增长能力。 第二，并入资产是否具有协同效应。 第三，估值是否合理。并入资产的估值如果太高，也会损害上市公司股东的利益。 既要绝对收益，又要相对收益 很多投资者在牛市里要相对收益，希望业绩跑赢指数，在熊市里要绝对收益，自己不能亏损，这就既要相对收益，又要绝对收益。\n好公司的股价低，差公司的股价反而高，这种现象叫定价错误。\n盲目相信神秘“主力”和政策 中国股市大部分时间是“疯牛 + 股灾 + 慢熊”的组合。可见，我们不能简单地认为，中国的股市是政策市。 我国政府特别重视关键会议、关键时间点的维稳工作，在维稳工作中，股市维稳是重头戏。重要事件期间，A股却是跌多涨少。 2007年的时候，政府在上半年就开始警惕泡沫过大，2007年5月30日凌晨，财政部突然将证券交易印花税税率由1‰上调至3‰，股市暴跌。但股市短暂调整之 后，一口气从4 000点涨到6 000多点。 我们到底怎么正确看待政府在股市中的作用？\n第一，我们现在股市的盘子越来越大，总市值已经接近60万亿元，这么大的市场，政府调控起来也有难度。 第二，这些年，政府在积累经验，不断进步，大部分时间是不干预指数的，当然，也不可能控制指数的涨跌。 第三，政府要回归本源，要回到强化监管、保护投资者利益上。保护投资者利益，不是操纵股市涨跌，而是加强监管，让信息披露更加透明，让造假公司无处 遁形。当然，市场如果出现极端情况，如出现特别大的股灾，可能影响整个金融体系的稳定，政府也应该果断进行干预。 对于我们做基本面投资的人，除了政策，我们更要关心行业趋势、公司竞争力、财务健康度、估值等基本面因素，这些才是影响公司发展、影响公司长期股价的 根本性因素。\n大部分股票根本就不存在“主力”，在绝大部分情况下，“主力”是大家臆想出来的。\n市场上没有人坐庄，那还有没有所谓的“主力”？股价又是由谁决定的呢？\n股市中有一些持仓量比较大的机构投资者，它们和个人投资者臆想的“主力”是完全不一样的。因为这些机构投资者基本上用的是买入持有策略，很少会走以前 庄家吸筹、打压、拉升、出货的方法。 股价其实是千千万万投资者，即机构投资者和个人投资者共同影响、共同交易出来的。 股价的短期波动有很大的偶然性。 基本面选股，技术面择时 在现实投资中，“基本面”和“技术面”经常水火不相容，根本原因在于基本面和技术指标结论一致的时候，投资者做决策是很容易的，但大部分时候，技术指标发 出的买入或卖出信号，和投资者依据基本面做出的判断，是不一致的。\n图9-4 短线交易中基本面分析的辅助作用 图9-5 基本面投资中技术指标提示预期差 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%81%9A%E4%B8%AA%E8%81%AA%E6%98%8E%E7%9A%84%E6%8A%95%E8%B5%84%E8%80%85/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%8A%95%E8%B5%84%E8%80%85%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/","summary":"把股市当作赌场 资本市场的三类钱 聪明钱是那些有深刻洞察力、前瞻判断力的资金。一般来说，聪明钱赚的是上市公司成长的钱。中国A股市场有很多公司给投","title":"第九章 投资者常犯的错误"},{"content":" 1 $ git merge --squash \u0026lt;branch\u0026gt; ","permalink":"https://jdxj.github.io/posts/cmd/git/%E5%8E%8B%E7%BC%A9%E5%85%B6%E4%BB%96%E5%88%86%E6%94%AF%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9C%AC%E5%88%86%E6%94%AF/","summary":"1 $ git merge --squash \u0026lt;branch\u0026gt;","title":"压缩其他分支提交到本分支"},{"content":"解决could not read Username for \u0026lsquo;https://github.com\u0026rsquo;: terminal prompts disabled\n1 $ git config --global --add url.\u0026#34;git@github.com:\u0026#34;.insteadOf \u0026#34;https://github.com/\u0026#34; ","permalink":"https://jdxj.github.io/posts/cmd/git/terminal-prompts-disabled/","summary":"解决could not read Username for \u0026lsquo;https://github.com\u0026rsquo;: terminal prompts disabled 1 $ git config --global --add url.\u0026#34;git@github.com:\u0026#34;.insteadOf \u0026#34;https://github.com/\u0026#34;","title":"terminal prompts disabled"},{"content":"识别关键驱动因素 对股价有持续、重要影响的因素\n鉴别信号和噪声，就是要判断某个信息会不会对公司的收入、成本、业绩等产生比较大的持续影响。 不同的行业、不同发展阶段的公司，有不同的关键驱动因素。 驱动因素举例\n互联网初创公司，我们要关注它的App下载量、日活跃周活跃月活跃数据等 对于一些发展初期的电商公司，成交总额很重要 对于连锁行业，我们要看开店数量和坪效 对于服装行业，我们看库存 对于白酒行业，我们看预收账款 除了关心公司本身的经营情况，还要关注重要客户和重要供应商的动态。\n一般来说，上市公司的客户集中度越高，风险越大。 除了跟踪重要客户，投资者还要关心竞争对手的动态。\n对有些公司来说，政策有举足轻重的影响\nPPP公司的商业本质是“类金融公司”，一边大规模负债融资，一边投向能产生稳定回报的资产，通过加杠杆实现高净资产收益率。 PPP公司的关键驱动因素\n（1）企业的融资成本。企业的融资成本越低，PPP公司越赚钱。 （2）所投资产的回报率。企业所投资产的回报率越高，PPP公司越赚钱。 （3）坏账率。坏账率越低越好。 总之，我们寻找关键驱动因素，就要抓大放小，关注主要产品的销量和价格、主要成本的边际变化、主要客户和主要竞争对手的动态和政策的变化。\n跟踪关键驱动因素 我们跟踪关键驱动因素的变化，能帮助我们提前判断公司的业绩变动趋势。\n跟踪关键驱动因素的方法很多，可是普通投资者没有那么多资源和时间，该怎么办？\n一是尽量选择自己能力圈内的公司投资 二是尽量用好那些能得到的资源, 比如上市公司公告、券商分析师的分析报告 三是多做基本调研。跟踪贵州茅台的投资者，可以找经销商交流，这是最直接的信息渠道。 识别和利用预期差 “预期差”是市场还没有充分预期到，股价还没有充分反应。\n表8-1 信号和噪声 正确应对“黑天鹅” “黑天鹅”是负的预期差。\n图8-1 正确应对“黑天鹅”的方法 股票买卖之后，我们要做的事情是：一不“死捂”股票，二不天天盯着K线，而要跟踪关键驱动因素的变化，并结合股价变化，理性做出决策。\n","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9F%BA%E6%9C%AC%E9%9D%A2%E6%8A%95%E8%B5%84%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%B7%9F%E8%B8%AA%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E9%9D%A2%E7%9A%84%E5%8F%98%E5%8C%96/","summary":"识别关键驱动因素 对股价有持续、重要影响的因素 鉴别信号和噪声，就是要判断某个信息会不会对公司的收入、成本、业绩等产生比较大的持续影响。 不同的行","title":"第八章 跟踪股票基本面的变化"},{"content":"设定买入股票的条件 一般来说，买入股票的条件包括股价进入合理区间，一些重要的基本面因素发生积极变化（“催化剂”事件发生）。\n等股价下跌到预期价格时不能马上买入, 要分析下跌原因. 股价下跌的原因有多种，大致有以下几类：\n一是公司基本面没有任何变化，因为大盘下跌，股价跟着大盘跌下来； 二是公司发生了一些事情，这些事情对公司基本面只有很小的影响，但市场放大了悲观情绪，导致股价下跌； 三是公司基本面发生恶化，股价下跌。 经过验证之后，你发现了一家好公司，但你不太确定，需要等待一些因素（如基本面“催化剂”）更加明朗才能判断其是否有投资价值，这时候你也需要等待。\n图7-1 确定和跟踪“催化剂”的流程 只有当“催化剂”事件发生，而且还没有被市场充分消化、还没有充分反映在股价中时，才是买入的机会。\n确定合理的买入金额或者仓位 你要确定合理的买入金额或仓位，确定整体仓位和个股仓位，并事先确定动态调整仓位的方法。\n对绝大多数投资者来说，甚至对绝大多数机构投资者来说，宏观经济就是“重要但是能力圈外”的事情。\n所谓能力圈内的事情，是你能研究清楚、你能跟踪的东西，也就是股票的基本面。\n哪些是重要但不是能力圈内的东西呢？那就是宏观经济、指数、汇率、利率等，投资者花时间研究和预测这些东西，只会事倍功半。\n哪些是能力圈内但不重要的东西呢？比如投资者手中股票的盈亏状况，研究这个很容易，但它与股价未来走势没有相关性，所以我们不必过于关注。但很多投资 者会根据自己手中股票的盈亏状况来决定买卖。\n哪些是能力圈外不重要的东西呢？我认为股票市场的短期波动既不重要，也很难预测，但个人投资者偏偏喜欢预测短期涨跌，天天盯着K线做交易。把时间花在这 些既不重要又是能力圈外事情上的人，很难做好投资。\n股票市场的相对吸引力，我们可以用“全市场市盈率的倒数−5年期国债收益率”来衡量，一般来说这个值在4%以上，股票市场就有吸引力。\n表7-1 一个简明的仓位策略 两种经常被使用的仓位策略\n固定股票比例策略 背后的逻辑是“高抛低吸” 适合比较平稳的市场, 如果遇到大牛市，随着市场不断上涨，你会不断卖出股票，可能会“错失”好时机；如果遇到大熊市，随着市场不断下跌，你会不断补 仓买入股票，你可能要忍受较大幅度的套牢或亏损。 安全垫策略 背后的逻辑是本金不能发生亏损, 等组合有了盈利，再加大风险暴露程度 本质是“追涨杀跌”，适合大波动、大震荡的市场 表7-2 固定股票比例策略和安全垫策略对比 现代组合理论告诉我们，要分散风险，过度集中持股（比如只持有2～3只股票），风险太高。那么，分散到什么程度是合适的呢？有人通过实证分析得出， 20～30只股票就基本能分散非系统性风险。但对于个人投资者来说，资金、时间有限，分散到8～10只股票可能就够了。\n具体到某只股票，确定性越大，空间越大，仓位可以更高。当然，任何一只股票的仓位不要超过总仓位的15%～20%，超过这个比例，风险就有点儿高。 “3—6—9”的个股仓位配置方法\n第一步，当他觉得某公司很不错，但还不是特别确定，就先买入3%的仓位。有了3%的仓位，他就会紧密跟踪这家公司的基本面变化，增加对它的了解。 第二步，当他对这家公司理解加深、更加有信心之后，会把仓位加到6%，这是单只股票的中性仓位。 第三步，当这家公司的基本面有超预期发展，或者估值更有吸引力的时候，他会把仓位加到9%，这是他重仓个股的仓位。 然后使用固定股票比例策略, 控制比例.\n预先设定股票的卖出条件 一般来说，卖出股票的条件包括估值不再有吸引力、基本面恶化，或者你找到了更好的股票。\n道理说起来容易，但实际操作起来并不容易，为什么？\n一是公司基本面发生明显恶化的时候，你会发现股价往往已经跌了不少，因为市场上总有一些投资者比你先知先觉。这时候，你要判断坏消息是否已经充分反 映在股价中，而这很难。 二是公司股价上涨超出你预先评判的合理估值区间，有可能是公司基本面发生了超预期的变化，但你不知道。这时候如果你卖出股票，可能错失了一只大牛股。 不论止盈还是止损，核心是两点，第一要看基本面有没有变化，第二要看估值是不是已经到位了，而不是简单地在涨了多少时止盈，在跌了多少时止损\n三个卖出股票的原因，那就是你发现了一只空间更大、确定性更高的股票，投资者的资金有限，这时候选择换股也是明智之举。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9F%BA%E6%9C%AC%E9%9D%A2%E6%8A%95%E8%B5%84%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%B9%B0%E5%85%A5%E4%B9%8B%E5%89%8D%E5%81%9A%E5%A5%BD%E5%85%85%E5%88%86%E5%86%B3%E7%AD%96/","summary":"设定买入股票的条件 一般来说，买入股票的条件包括股价进入合理区间，一些重要的基本面因素发生积极变化（“催化剂”事件发生）。 等股价下跌到预期价格","title":"第七章 买入之前做好充分决策"},{"content":"Redis setup tips Linux 设置内核参数 vm.overcommit_memory = 1\n表示 Always overcommit 写到 /etc/sysctl.conf 配置中后重启 或者直接激活 sysctl vm.overcommit_memory=1 linux的vm.overcommit_memory的内存分配参数详解 理解LINUX的MEMORY OVERCOMMIT 关闭 Transparent Huge Pages\necho never \u0026gt; /sys/kernel/mm/transparent_hugepage/enabled 避免碎片化访问 page Memory 启用交换区, 大小等于物理内存 配置 maxmemory 选项, 要到达内存限制时报错而不是失败 ","permalink":"https://jdxj.github.io/posts/docs/redis/managing-redis/administration/","summary":"Redis setup tips Linux 设置内核参数 vm.overcommit_memory = 1 表示 Always overcommit 写到 /etc/sysctl.conf 配置中后重启 或者直接激活 sysctl vm.overcommit_memory=1 linux的vm.overcommit_memory的内存分配参数详解 理","title":"Redis administration"},{"content":"How is Redis different from other key-value stores? 拥有复杂的数据类型, 及其上的原子操作 是可持久化的内存型数据库, 在数据集比内存大的限制下可以权衡读写速度 What\u0026rsquo;s the Redis memory footprint? 空实例~3MB 1百万小 key 的 string 类型~85MB 1百万个有5个字段的 hash ~160MB What happens if Redis runs out of memory? 不接受写, 但是可以读 可以配置 key 淘汰策略 How can Redis use multiple CPUs or cores? Redis 通常受内存和网络的限制 如果想使用多个 CPU, 那么应该今早使用 Redis Cluster Redis 未来会越来越线程化 What is the maximum number of keys a single Redis instance can hold? What is the maximum number of elements in a Hash, List, Set, and Sorted Set? 理论上2^32个 key, 经过测试可以保存2.5亿个 key hash, list, set, sorted set 每种类型可以保存2^32个 key Where does the name \u0026ldquo;Redis\u0026rdquo; come from? REmote DIctionary Server.\nHow is Redis pronounced? /ˈrɛd-ɪs/\n","permalink":"https://jdxj.github.io/posts/docs/redis/getting-started/faq/","summary":"How is Redis different from other key-value stores? 拥有复杂的数据类型, 及其上的原子操作 是可持久化的内存型数据库, 在数据集比内存大的限制下可以权衡读写速度 What\u0026rsquo;s the Redis memory footprint? 空实例~3M","title":"Redis FAQ"},{"content":"主页\n","permalink":"https://jdxj.github.io/posts/articles/cheney/","summary":"主页","title":"Dave Cheney"},{"content":"原文\n在提问之前 尝试在你准备提问的论坛的旧文章中搜索答案。 尝试上网搜索以找到答案。 尝试阅读手册以找到答案。 尝试阅读常见问题文件（FAQ）以找到答案。 尝试自己检查或试验以找到答案。 向你身边的强者朋友打听以找到答案。 如果你是程序开发者，请尝试阅读源代码以找到答案。 在邮件列表或新闻组寻求帮助时加上一句 我在 Google 中搜过下列句子但没有找到什么有用的东西 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮 助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。\n好问题是答者的回报\n当你提问时 慎选提问的论坛 如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：\n在与主题不合的论坛上贴出你的问题。 在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。 在太多的不同新闻群组上重复转贴同样的问题（cross-post）。 向既非熟人也没有义务解决你问题的人发送私人电邮。 网站和 IRC 论坛 第二步，使用项目邮件列表 当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。\n使用有意义且描述明确的标题 一个好标题范例是目标 —— 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望 的行为不一致的地方。\n如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题\n使问题容易回复 在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你 只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如追踪此讨论串、有回复时发送邮件提醒等功能。\n使用清晰、正确、精准且合乎语法的语句 使用易于读取且标准的文件格式发送问题 别动辄声称找到 Bug 低声下气不能代替你的功课 描述问题症状而非你的猜测 按发生时间先后列出问题症状 描述目标而不是过程 问题解决后，加个简短的补充说明 如果还是搞不懂 如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需 要对方解释，记得表现出你已经从中学到了点什么。\n处理无礼的回应 很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直截了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。\n如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这没有发生而你却发火了，那么 你发火对象的言语可能在黑客社区中看起来是正常的，而你将被视为有错的一方，这将伤害到你获取信息或帮助的机会。\n另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之 前一定要非常非常的有根据。\n不该问的问题 我能在哪找到 X 程序或 X 资源？ 我怎样用 X 做 Y？ 如何设定我的 shell 提示？ 我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？ 我的程序/设定/SQL 语句没有用 我的 Windows 电脑有问题，你能帮我吗？ 我的程序不会动了，我认为系统工具 X 有问题 我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？ 如果得不到回答 如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。\n","permalink":"https://jdxj.github.io/posts/articles/ryanhanwu/how-to-ask-questions/","summary":"原文 在提问之前 尝试在你准备提问的论坛的旧文章中搜索答案。 尝试上网搜索以找到答案。 尝试阅读手册以找到答案。 尝试阅读常见问题文件（FAQ）以找到","title":"How to Ask Questions The Smart Way"},{"content":"原文\n","permalink":"https://jdxj.github.io/posts/articles/polarisxu/go1.18%E5%BF%AB%E8%AE%AF-%E6%96%B0%E7%9A%84ip%E5%8C%85/","summary":"原文","title":"Go1.18快讯 新的IP包"},{"content":"用“望远镜”验证公司的赛道 好股票的标准可以用“好赛道+好公司+好价格（估值）”来概括\n什么是赛道？赛道是公司所处的行业或者业务领域。\n赛道吸引力是最重要的基本面之一 图6-1 2001—2017年贵州茅台和张裕的业绩和股价 白酒赛道为什么要比其他酒的赛道好？\n首先，白酒是受我国文化影响很大的行业，没有外国产品的竞争。白酒相对于其他酒有不同的地位，它具有悠久的历史和独特的民族文化内涵，这也是白酒 行业的壁垒和护城河。 其次，白酒是一种情感消费，消费者除了考虑口感等因素，更多考虑的是社交需求、面子需要。中国是一个强社交的社会，使得白酒消费呈现不完全追求 “性价比”的特点。 最后，白酒没有库存问题。白酒行业有一个与其他行业不一样的特点，消费者认为白酒储藏的时间越久，会越香醇、越值钱。所以白酒企业不用担心库存管理。 验证公司所处的“赛道”好不好，我们需要看得远一些，不能只看公司目前的收入和盈利状况。\n戴维斯双击、戴维斯双杀与赛道紧密相关。\n市盈率=股价/利润，那么股价=利润×市盈率，行业和公司的发展前景对盈利和市盈率都有影响。 判断清楚公司所处赛道的吸引力如何。我认为可以从两个维度去判断：第一个维度看它所在的赛道的空间有多大，第二个维度要看赛道中的竞争状况如何。\n评判赛道的空间 我们在评判赛道好不好的时候，先要分析赛道的发展空间。而我们评判赛道空间，则可以从目前市场容量和未来增长趋势两个维度来考虑：首先看这个行业目前 的容量，是100亿元、500亿元，还是1 000亿元。其次看未来增长的趋势，是向上、稳定，还是向下。\n我们应该怎么去判断赛道空间有多大呢？很简单，我们先上网搜索信息，对行业进行基本了解。搜索之后，我们还有4个方法：一是看招股说明书，二是看券商的 分析报告，三是看一些专业网站，四是和行业内的人谈一谈，获得更多的信息。\n招股说明书是最好的了解行业空间的帮手。招股说明书的特点是，券商和中介机构要对其严格审核，一般很难造假，所以里面的数据都是有来源和依据的，相 对来说可信度是比较高的。缺点是比较陈旧. 但是，越是新股，上市时间离现在越近，我们越要看招股说明书。 看业务和技术部分. 这个部分是讲这家公司所在行业的前景如何、行业规模有多大等。 图6-3 景旺电子所属行业状况 券商报告、专业网站及行业专家是不错的辅助工具。除了招股说明书，我们还要看券商报告，看券商研究报告的窍门是什么呢？我们看券商研究报告，基本原 则是不看它的目标价，不看它的评级，而要看它对行业和公司的分析。 关于专业的资讯网站，我推荐知乎和雪球。 最后的途径是找行业专家了解行业的情况，这个难度最大、成本最高，但效果最好。一般券商组织的策略会会邀请细分行业的专家来演讲，这是最好的积累行 业知识的机会，只是参与难度比较高。 对不同赛道的不同关注点 分析赛道的三个维度: 消费, 周期, 成长\n消费 消费品的需求是最稳定的。\n消费行业为什么容易出现长期牛股呢？\n第一，消费行业的周期属性相对较弱，经营业绩不太受宏观经济周期的影响。 第二，消费品公司经过长期经营和资金投入形成较强的品牌壁垒和规模优势，获得了行业垄断地位，且这种垄断地位相对稳定。 消费品公司一旦形成品牌护城河和规模护城河，不太需要进行持续的大规模资本支出，也不太容易被新技术、新模式颠覆 图6-4 菲利普-莫里斯国际股价走势图 在投资消费品公司的时候，要注意它们的品牌护城河是否被侵蚀（品牌老化），这是消费品公司的大敌。\n成长 在研究科技股的时候，我们要着重关注需求和技术：只有下游的应用空间足够大，公司所处的赛道才会足够宽敞；只有公司持续进行研发投入，公司才能在未来 新技术上占得先机。\n周期 周期股受宏观经济影响大，即受需求波动影响大，而产品价格和产能利用率的波动会严重影响公司业绩。\n周期性行业的强周期来自哪里？\n一是需求本身就有周期。周期性行业的需求，受宏观经济影响很大，宏观经济本身有周期，即需求本身就有周期。 二是周期性行业往往是重资本行业，沉没成本很高，虽然竞争激烈的产品已经不盈利，但只要产品价格大于变动成本，企业就有继续生产的动力。这导致周期 性行业产能退出很难。 三是周期性行业产品往往无差异化，企业属于同质化竞争，一旦供过于求，价格战是唯一手段。 四是周期性行业都是顺周期扩张产能，当宏观经济繁荣度下滑时，市场对产品需求降低，但之前的新增产能却陆续完成，供给过剩的问题越发严重，全行业陷 入恶性竞争。 评判赛道的竞争格局 关注市场集中度 市场份额是我们所说的市占率，它表示公司收入占行业收入的比重，比重越高，说明公司在行业中地位越高。 而集中度是指该行业内前几家大公司所占市场份额的总和，一般我们认为CR4（行业排名前4的公司的累计市场占有率）小于30%～40%，则该行业为竞争型； 而如果CR4大于等于30%～40%，则该行业为寡头垄断型。 图6-5 乳制品行业竞争格局 关注新进入者的挑战 即使在一个已实现寡头垄断的行业，面对全新商业逻辑的新进入者，我们同样要注意相关的竞争状况。\n图6-6 中国咖啡市场份额分布情况 图6-7 中国咖啡市场规模和平均年复合增长率 关注价格战的激烈程度 “价格战”是企业之间通过竞相降低商品的市场价格展开的一种商业竞争行为，其主要内部动力有市场拉动、成本推动和技术推动，目的是打压竞争对手、占领更 多市场份额、消化库存等。\n容易打价格战的行业\n航空 味精 黑电行业 关注上下游是否强势 强大的上下游是企业的噩梦。一家公司的上下游越集中、越强大（强大的上游客户可以随时涨价甚至断货，强大的下游客户可以随时找到竞争对手来替代），这 家公司定价权就越弱，盈利能力和盈利前景就越差。\n手机零部件 -\u0026gt; 苹果 沥青行业 -\u0026gt; 防水涂料 -\u0026gt; 房地产行业 英特尔 -\u0026gt; 浪潮信息(一个公司) -\u0026gt; 阿里云 因为议价能力都很强的上下游可能会压制赛道，所以我们在评估赛道时，一定要考虑到这一点。当你所研究的公司有强大的上下游时，你一定要想一想，这家公 司有没有反制上下游的核心能力。\n大行业小龙头和小行业大龙头 表6-2 大行业小龙头和小行业大龙头的区别 不同的股票由于它的行业空间不一样，适合的投资者也是不一样的。成长型投资者，更喜欢大行业小龙头。价值型投资者，更喜欢小行业大龙头。对于大行业小 龙头，市场往往会给更高的估值。\n用“透视镜”寻找公司的护城河 表6-3 五粮液和贵州茅台的财务数据对比 护城河指的是企业在相当长的一段时间内无法被模仿被替代的竞争优势。护城河是把竞争对手挡在外面的东西。\n当你看到一家公司盈利能力很强的时候，一定要问两个问题：“它凭什么能做得这么好？未来它是否能持续做好？”这两个问题都是关于公司护城河的。 我们判断公司有没有护城河、有什么样的护城河，一定要透过收入、利润、增长率等表象，找到真正让这家公司持续保持高盈利能力的东西。 哪些是公司的护城河呢？品牌、网络效应、成本优势、高客户转换成本以及渠道优势，是常见的护城河，一家优秀的公司至少要具备其中一项。\n品牌 品牌作为无形资产，能给企业带来宽广的护城河。有品牌影响力的企业，产品畅销，拥有强大的定价权，能让消费者为品牌支付更高的价格，利润率更高。\n贵州茅台无疑是品牌护城河最深的公司之一\n图6-8 2008—2019年贵州茅台的股价走势 图6-9 2008—2017年贵州茅台的毛利率 贵州茅台如此高的毛利率，如此强劲的利润增长，为什么没有竞争对手模仿它，和它竞争？茅台酒成本这么低，为什么有那么多消费者愿意花高价购买？核心在 于品牌影响力。贵州茅台由于悠久的历史、独特的酿造工艺，在消费者心中成为高端白酒的代名词。\n即使公司有品牌，我们还要跟踪和判断：品牌会不会老化？会不会被消费者抛弃？\n百雀羚 雅戈尔 杉杉 网络效应 网络效应，或者说“双边效应”，一旦形成，是最深的护城河。什么是网络效应？如果一家平台公司，随着用户人数的增加，用户之间发生交易的可能性和频率是 以几何级数增加的，这就是网络效应。而网络效应一旦形成，无论是供给端，还是需求端，都会被牢牢吸附在这张网络中，很难脱离，在这种黏性下，供需两端 的迁移成本都是巨大的。而这家平台公司，也构成了非常深的网络效应护城河。\n微信 滴滴 Airbnb 具有网络效应的公司面临的最大挑战，一是来自颠覆性的技术或者商业模式；二是来自监管\n“互联网思维”是近几年最热的词语之一，大致意思是“通过免费策略或者用户补贴，获得海量用户，养成用户习惯，之后基于海量用户慢慢变现”。淘宝、滴滴、 美团等互联网巨头，都是“互联网思维”的产物。\n“互联网思维”是有前提的，那就是靠补贴吸引用户，并形成强大的“网络效应”或者“双边平台效应”，才能在没有补贴的时候保持用户黏性，让用户离不开。淘宝 、支付宝、微信、滴滴、美团等，都符合这个特征。\n各种互联网金融平台因为不符合这个特征，所以没有通过“烧钱”的方式形成超级公司。 房地产中介这个行业并不适合互联网思维 第一，房地产交易金额大，又涉及很多环节，线上不能完全替代线下的信任和服务； 第二，房地产交易是较“低频”的业务，靠补贴获得的客户，很长时间才会第二次交易（大部分人一生只进行一次房地产交易）。 成本优势 成本优势, 就是一家公司的产品的成本比另一家的低。如果成本低，公司的产品就可以比竞争对手的卖得便宜，那消费者就会来买这家公司的产品。如果竞争对 手的产品价格和这家公司的一样，那该公司因为成本低能赚到更多利润，更有发展后劲。\n图6-10 格力电器的股价走势 格力电器的毛利率是30%，而行业的平均值是20%；格力电器的净利率是15%，而行业的平均值不到10%。\n格力电器为什么成本低？\n它经营的钱都是借来的，而且借来的钱都不用付利息，什么意思？格力电器的运营资本，要么是原材料供应商的垫资，因为它可以先用几个月的原材料，不付 钱；要么是下面渠道商的钱，格力电器可以先收钱再给渠道商发货。格力电器能无偿占用上下游资金，这是它低成本的秘密之一。 规模效应带来议价权，议价权带来低成本，从而形成格力电器强有力的护城河。 图6-11 海螺水泥的股价走势 海螺水泥的核心竞争力也来自成本端的绝对优势。\n2017年海螺水泥的毛利率是35%，而行业的平均值是30%；海螺水泥的净利率是22%，而行业的平均值是11%。\n海螺水泥的成本为什么这么低？\n因为低廉的矿山成本和公司的规模优势。另外，不得不提的是，海螺水泥独创的T型战略布局。 高客户转换成本 什么是客户转换成本？客户转换成本，既包括金钱，也包括学习成本等隐性成本。如果消费者学习使用新产品和新服务需要大量的时间投入，那么就会降低消费 者转用竞争对手的产品和服务的概率。\n图6-12 广联达股价走势 什么样的产品、公司和行业具有很高的客户转换成本呢？\n第一，制造业里需要经过严格品质认证的产品。比如汽车产业供应链中的公司。汽车行业对安全性要求很高，所以涉及安全的产品，都有严格的进入壁垒。但 产品一旦进入，客户就不会轻易更换供应商，供应商就能获得持续的订单和利润。 第二，消费品领域的公司通过增值服务来留住客户。比如现在的智能手机公司，它们都提供云服务，让用户把照片、通讯录、记事本等免费同步到云上，很大 一个原因是增强用户黏性。用户如果不用它的产品，要处理这些东西很麻烦。 第三，金融服务业. 银行, 因为客户重新开户要填写一大堆表格，而银行卡可能还关联了支付宝、微信、水电费账户、工资账户、房贷账户等，所以很多客户 并不愿意改变。 第四，学习成本特别高的产品，如Office软件等。 渠道优势 拥有更多的渠道，意味着企业能抢占更多与消费者接触的机会，就有可能占有更多的市场份额。所以，对消费品企业来说，渠道优势是非常深的护城河。\n图6-13 苏宁电器（苏宁易购）股价走势（后复权） 在A股市场，拥有渠道优势的公司主要有以下几种类型。\n一是占据流量入口的互联网公司，如阿里巴巴、京东。 二是占据线下流量入口的连锁超市、连锁卖场等，如高鑫零售、永辉超市。三是产品有规模效应，并且和前两者形成战略合作，抢占它们入口的产品方，如海 天味业。 技术领先是不是护城河 乐视之后，谁将可能是下一个破灭的大泡泡？！\n科大讯飞的技术领先能否持续？它的领先技术能不能转化为吸引用户的产品？能不能转化为持续赚钱的商业模式？最后的结论是，单纯的领先技术并不能保证科 大讯飞获得护城河。\n科大讯飞的股价从2017年最高点的近50元，一路下跌到2018年年底的23元 图6-15 科大讯飞股价走势 科大讯飞的领先技术为什么没有形成护城河呢？\n首先，我们来看科大讯飞引以为傲的语音识别技术。它的语音识别技术在多项比赛中蝉联第一，目前在国际领先，但是各大公司的识别率差距并不大，许多公 司的语音识别率都已经达到95%以上，这样微弱的领先优势不足以使科大讯飞形成强大的护城河。 其次，BAT等巨头开始在人工智能领域发力，快速追赶技术甚至赶超，科大讯飞的技术领先优势迅速缩小甚至消失，但BAT的流量、应用场景、资金实力等优 势，是科大讯飞远远不能比的。 最后，科大讯飞的财务报表没有体现高科技公司应有的特点。 曾有财务专家说道：“从财务报表来看，科大讯飞在经营层面是一家快速增长但含金量不高的公司； 在管理层面，是一家扩张很快但效率低下的公司；在财务层面，是一家擅长募资但却不擅长赚钱的公司； 在业绩层面，是一家大手笔花钱但股东回报率低的公司。其光鲜增长的背后，其实隐藏了巨大的风险。” 科技股为什么看上去值得持有，却不是好的长期投资标的呢？原因有以下几点。\n第一，单纯的技术公司的护城河不深。“一招鲜”的领先技术，容易被模仿甚至被超越，一般来说，两三年的技术，基本上已经没有优势。技术只有能落地为产 品能力、营销能力和品牌力，才能给公司创造可观的利润，公司再利用自己的盈利能力，建立起强大的、持续的技术研发能力，才是护城河。海康威视就 是典型的案例。在A股市场，有些公司头顶高科技的光环，如人工智能、生物技术等，但销量和利润却很少。 第二，不少科技公司，在商业模式上称雄，但在核心技术上却受制于人。某基因测序公司 第三，科技股的估值往往偏高。估值高，未来的投资回报率自然就低。 能干的管理团队非常重要 在研究一家公司的时候，我们要注重激励的有效性、长期性，激励不够和过度的短期激励都是公司治理的大敌。\n当心被侵蚀的护城河 护城河消失的原因\n第一个是技术变革。 第二个是行业变迁，即很多的商业模式发生了变化。最典型的是苏宁，原来它是一家非常有实力的公司，在电商的冲击下开始亏损。 第三个是公司的自杀性增长。这是指公司盲目扩张，之前格力电器要做半导体，这让很多投资者不明白，因为半导体需要很大的开支，同时会影响格力电器未 来的分红计划，短期的股价已经证明市场对这一想法不买单。 如何识别公司有无护城河 如何了解公司的核心竞争力呢？\n我们可以看招股说明书、券商报告、专业网站，还可以找行业专家、下游用户等谈一谈， 分析公司核心竞争力可以用指标分析\n市场占有率、主营业务收入增长率、毛利率、净利率、净资产收益率等 还要找几家对标公司进行比较分析 表6-4 不同行业和不同竞争力公司的估值情况 但是A股市场经常是反过来的情况，很多公司，所属行业很差，自身也没有竞争力，但是市盈率很高，有80倍，甚至100倍，所以从基本面投资的角度，我们就不 要购买这种股票。反过来，有些不错行业的龙头公司，有很强的核心竞争力，估值却很低，这说明市场定价是错的。 市场出错时，就是我们投资机会出现的时候。\n用“显微镜”检验公司财务状况 所有的定性研究和定性逻辑都要落实到公司的财务数据上，我们要学会用财务指标来验证公司到底经营得怎么样。\n简单了解3张报表 （1）资产负债表: 反映的是某个特定时点公司的状态。 （2）利润表: 反映了公司在这个时间段里，收入怎么样，支出怎么样，利润怎么样 （3）现金流量表: 反映了公司在这个时间段里, 现金流入和流出情况 表6-5 2017年小王的家庭资产负债表\n总资产: 541万元 净资产(股东权益): 326万元 表6-6 2018年小王的家庭资产负债表\n总资产: 525万元 净资产(股东权益): 325万元, 净资产减少1万元 表6-7 2018年小王的家庭收入支出表\n全年收入: 35万元 全年支出: 36万元 多支出1万元对应净资产减少1万元 现金流量是一个公式: 年末的现金余额=年初的现金余额 + 当年的现金流入 - 当年的现金流出\n不太明白为啥要用公式算, 年末时应该也能查到账户上有多少现金吧.\n表6-8 2018年小王的家庭现金流量表 注意\n15万元本金是要还银行的钱, 所以不在利润表 利息是成本, 要进利润表 8万元亏损要进利润表, 但没有现金流出, 所以不在现金流量表 四大维度验证公司质地 成长能力、盈利能力、经营效率和经营风险。\n判断成长能力的指标有哪些？\n比如主营业务收入增长率、营业利润增长率和净利润增长率。 反映公司盈利能力的指标有哪些？ 毛利率、净利率和净资产收益率等。 反映公司经营效率的指标有 周转率、存货周转率、应收账款周转率、固定资产周转率等。 反映公司经营风险的指标 主要是负债率等。 如何评估公司的成长能力 评估公司的成长能力的指标，主要有主营业务收入增长率、营业利润增长率和净利润增长率。\n当年的增长率和过去3～5年的平均或复合增长率的计算公式为： A股市场上市公司的平均增长率水平, 大部分年份的增长率在5%至10%这个区间。\n图6-16 A股市场上市公司增长率情况 投资者不仅要看整个A股市场，还要和同行业公司做具体比较。如果同行业公司的增长率都在30%以上，那即便是20%的增长率，也是低速增长。\n我们还要分析一些异常因素，这些异常因素会导致增长率的失真。\n借壳. 分众传媒, 2013~1014借壳七喜控股 图6-17 分众传媒归母公司净利润 重大资产重组. 天润数娱，原名是天润控股, 2016年第二季度实现并表 图6-18 天润数娱归母公司净利润 非经常性损益, 是指和企业的主营业务没有直接关系的各项收支。 广东甘化, 表6-9 广东甘化净利润 从财务角度来看，公司创造价值的最佳衡量指标是投入资本回报率，它直接反映了公司投入和产出的效果。一家公司的投入资本回报率只有大于投入资本的资金 成本时，它才真正创造价值。只有在这样的前提下，成长才是有质量的。\n如何评估公司的盈利能力 毛利率、营业利润率以及净资产收益率\n1 毛利率 =（主营业务收入 - 主营业务成本）/主营业务收入×100% 表6-10 云南白药营业收入 表6-11 云南白药营业成本 图6-19 A股市场上市公司毛利率情况 表6-12 两面针主营业务分产品情况 1 2 营业利润率=营业利润 / 营业收入 × 100% 营业利润=营业收入 - 营业成本 - 营业税金及附加 - 管理费用 - 财务费用 - 资产减值损失 + /- 公允价值变动收益/损失 + 投资收益 营业利润可以在公司的利润表里直接找到这一项\n表6-13 云南白药和两面针的营业利润率对比 图6-20 A股市场上市公司利润率情况 1 净资产收益率=净利润 / 股东权益(净资产) 这个指标反映的是股东投入资金的回报率\n表6-14 云南白药和两面针净资产收益率对比 云南白药的盈利优势\n一方面是云南白药的秘方以及它的商标权，这使得它的品牌优势比较明显，定价可以比竞品高很多； 另一方面是云南白药“轻资产 + 快速周转”的类消费公司的经营模式。 1 市净率 =股价 / 净资产 中国A股市场有很多高净资产收益率公司，它们的市净率反而低；很多低净资产收益率公司，包括很多垃圾股，它们的市净率反而高. 我们投资一定要远离那些净资产收益率很低，但市净率很高的公司。\n图6-21 A股上市公司净资产收益率情况 我们在计算净资产收益率的时候，要把非经常性损益扣除掉。\n如何评估一家公司的经营效率 用周转率衡量公司的经营效率。\n存货周转率、应收账款周转率、固定资产周转率 一般来说，存货周转率越高越好。\n1 存货周转率=销货成本 / 平均存货余额 × 100% 这个比率也是越高越好，应收账款周转率越高，表明产品销售情况越好，公司就不需要通过赊销这样的方法提高销量。\n1 应收账款周转率=赊销净收入 / 平均应收账款余额×100% 固定资产周转率反映公司固定资产的使用效率。固定资产周转率越高，表明公司对厂房和设备等固定资产的利用效率越高。\n1 固定资产周转率=营业收入 / 固定资产净值×100% 表6-15 6家调味品公司的经营指标对比 如何评估一家公司的经营风险 建议大家看两个指标，一个是资产负债率，另一个是有息负债率。\n图6-22 负债是一把双刃剑 图6-23 公司资产负债表 1 公司的资产负债率 =（无息负债 + 有息负债）/总资产×100% 一般来说，这个比例在60%以内算是合理的。如果这个比例超过80%，也就是负债金额是所有者权益的4倍以上，那么公司的经营风险就偏高了。\n无息负债在整体负债中的占比越高，说明公司对供应商和经销商的谈判地位越高、控制能力越强。\n表6-16 贵州茅台和五粮液预收账款占比 识别财务欺诈 两个概念\n盈余管理，是公司合理合法地利用制度和规则，对财务数据进行适当“美容”，这是在制度和规则允许的范围之内做的。 财务造假包括报表粉饰、管理舞弊、会计欺诈，是超出制度和规则范围的。 做高收入和做低成本是主要的造假方式 图6-24 常见的财务造假动机 提高收入的手段比较多，比如通过关联交易增加营业收入，提前确认营业收入等。 降低成本的手段也很多，比如通过管理方支付本应由公司支付的成本，延后确认成本等。 我们建议多看几年的财务报表，因为持续造假超过5年是不容易的。我们只有分析了某公司连续5年以上的财务报表，才能看清楚它的真正经营情况。\n表6-17 2013—2015年乐视研发费用资本化情况 乐视对影视剧版权采购费采取直线摊销法\n如果按照收入和成本匹配原则，它就应该使用加速法来进行摊销，也就是第一年多计算成本，以后年份少计算成本，而不是每年平均计算成本。 表6-18 2013—2015年乐视版权费用摊销情况 财务“洗澡” 公司本年度大幅计提固定资产损失，未来几年就无须再计提固定资产损失。商誉、应收账款、存货、权益投资等都可以成为业绩“大洗澡”的计提项目。\n图6-25 业绩粉饰常见方法 财务“洗澡”什么时候发生？\n一种情况，公司当年的亏损已经不可避免，反正是亏，公司就进行一次性亏损。我们的监管制度规定，上市公司不能连续亏损，连续亏损要被ST、要退市，但 监管制度未规定一次能亏多少钱。 另一种情况，公司管理层换人，首席执行官上任后，发现公司有很多问题账，就让公司在当年一次性亏损，因为责任全在前 任首席执行官身上，这种现象是 较普遍的。 表6-19 2013—2015年4家ST公司的财务数据 表6-20 2018年预告大幅商誉减值的公司 如何发现财务造假 首先，我们可以对同行业的公司进行对比分析，识别潜在的造假。 其次，我们不要只盯着利润表，也要留意资产负债表。财务造假的目标是提高收入和利润，但改变了利润表的项目，一定会对资产负债表产生影响。这是因为， 通过造假使得利润虚增，资产负债表中的所有者权益也应该增加。所有者权益增加后，相应的资产就要增加，否则资产负债表就无法配平。 最后，还有一些信号，大家一定要重视。 第一个信号是财务总监辞职，这可能说明财务总监对造假感到害怕。 第二个信号是公司更换会计师事务所，这往往意味着会计师事务所可能不愿意配合上市公司做账，或者公司另外找到一家愿意配合的会计师事务所。 第三个信号是会计师事务所发表了保留意见或者拒绝发表意见，这表明这家公司基本上是造假了。因为一般来说，会计师事务所都会出无保留意见，也就是 说报表是真实的，没有问题。会计师事务所如果发表了保留意见或拒绝发表意见，表明这家公司的财务报表应该有大问题。 用“公平秤”评估股票性价比 常见的估值方法 推荐大家看达莫达兰（Damodaran）的《估值》（The Dark Side of Valuation）这本书\n原始成本估值法\n原始成本是资产被取得时所支付的对价。 原始成本估值法是不合理的，在现实的估值中几乎用不到。 上市公司报表里的很多资产，如房地产、土地使用权等，是按照原始成本入账的，有时候这些资产是被严重低估的。 重置成本估值法\n重置成本是重新取得相同或类似资产所需要支付的对价。 房地产公司经常用重置成本估值法 也很少用 绝对估值法\n绝对估值法，也叫“地老天荒”的现金流贴现法，是把未来某只股票能产生并分配给投资者的现金流贴现到今天的价值。 做估值的时候，会假设这家公司会永续经营下去 表6-21 不同贴现率下的房子估值 绝对估值法的挑战有两个：\n一是对股票的未来现金流预测很难； 二是贴现率差一点儿，结果就会差很多。 合理的贴现率到底应该是多少呢？\n经验数据是：5年期的国债收益率 +（3%～5%）。这里的3%～5%是“风险溢价”。 绝对估值法有缺点。\n其中的假设和预测，投资者很难学习。 当你用绝对估值法去衡量股票的时候，你会发现绝大部分股票的价格，都比它算出来的绝对估值要高，这时候你找不到可买的股票。 相对估值法\n是以类似资产在市场上的定价为基础，进行比较估值。 表6-22 绝对估值和相对估值的区别 具体到股票投资，相对估值法可以分为3个步骤：\n第一，选取可比公司 选取的可比公司有两个标准：第一，要有可比性；第二，要有足够的代表性。 第二，选取并计算比较指标 市盈率（市值/净利润） 市销率（市值/营业收入） 市净率（市值/净资产） 第三，根据公司质地调整估值。 行业内公司的竞争力、发展前景、盈利稳定性的差异还是很大的，这时候你要根据公司的竞争力、发展前景、盈利稳定性等情况，对估值进行适当调整。 表6-23 白酒行业各公司的估值情况 相对估值的问题\n一旦市场整体被严重高估或者被严重低估，某家公司的估值也就会跟着被高估或者被低估 无法对公司成长能力等进行准确估值 综合应用绝对估值法和相对估值法 绝对估值法，用来确定“安全边际”，也就是确定绝对估值有吸引力的公司，长期“估值有吸引力”，才有安全边际。相对估值法用来进行“个股选择”，确定相对估 值低的公司，即在可比公司中性价比较高的公司。\n表6-25 相对估值和绝对估值的应用 影响股票估值的因素 绝对估值: 贴现率(利率水平) 公司成长能力 市盈增长比率，是市盈率除以未来的复合增长率。在计算的时候，增长率不能是1年的数据，至少是3年的复合增长率才有意义。 市盈增长比率的缺点是预测未来的复合增长率很难。 估值和盈利稳定性的关系是，一家公司的盈利越稳定，意味着投资这家公司的风险越小；投资风险越小，贴现率就可以低一点儿，估值就可以高一点儿。\n一个简单易行的“绝对估值法” 公司合理股价=3年后的预测每股利润 × 公司未来合理市盈率3年后的预测每股利润\n表6-27 合理估值区间（单位：倍） 行业成长空间\n如果行业未来8～10年能保持15%左右的增长率，那就属于超高增长行业； 如果未来8～10年能保持10%左右的增长率，那就属于高增长行业； 如果能保持5%左右的增长率，那就属于低增长行业。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9F%BA%E6%9C%AC%E9%9D%A2%E6%8A%95%E8%B5%84%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%9B%E5%A4%A7%E5%B7%A5%E5%85%B7%E9%AA%8C%E8%AF%81%E5%A5%BD%E8%82%A1%E7%A5%A8/","summary":"用“望远镜”验证公司的赛道 好股票的标准可以用“好赛道+好公司+好价格（估值）”来概括 什么是赛道？赛道是公司所处的行业或者业务领域。 赛道吸引力","title":"第六章 四大工具验证好股票"},{"content":"错误的使用uintptr转换结果可能被 GC.\n原文\n","permalink":"https://jdxj.github.io/posts/articles/huoding/%E8%81%8A%E4%B8%80%E4%B8%AAstring%E5%92%8Cbyte%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/","summary":"错误的使用uintptr转换结果可能被 GC. 原文","title":"聊一个 string 和 []byte 转换问题"},{"content":"原文 1. Primary Concerns 1.1. Usability 建立惯例使库的特性可发现 潜在的错误使用 易于完成常见任务 Case Study: net/http 看起来有些繁琐\n1 2 3 4 5 6 7 8 9 10 // import \u0026#34;net/http\u0026#34; req, err := http.NewRequest(http.MethodGet, \u0026#34;http://example.com\u0026#34;, nil /* body */) if err != nil { return err } var client http.Client res, err := client.Do(req) // ... 更简单的方法\n1 2 3 // import \u0026#34;net/http\u0026#34; res, err := http.Get(\u0026#34;http://example.com\u0026#34;) 但是不应该使用全局 HTTP Client.\n1.2. Readability 在实现之前写伪代码和文档有助于设计出可读性好的 API. 随着经验的增加可能会减少这个习惯.\n1.3. Flexibility 灵活性决定能否加入新功能来满足新用例, 允许用户自定义和扩展来适应他们的需要.\n生态系统 第三方扩展 Case Study: net/http 1 2 var client http.Client res, err := client.Get(\u0026#34;http://example.com\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 package http type Client struct { // Transport specifies the mechanism by which individual // HTTP requests are made. // If nil, DefaultTransport is used. Transport RoundTripper // ... } type RoundTripper interface { RoundTrip(*Request) (*Response, error) } 封装一层, 添加日志功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type loggingRT struct { http.RoundTripper } func (rt *loggingRT) RoundTrip(req *http.Request) (*http.Response, error) { log.Printf(\u0026#34;%v %v\u0026#34;, req.Method, req.URL) return rt.RoundTripper.RoundTrip(req) } roundTripper := \u0026amp;loggingRT{ RoundTripper: http.DefaultTransport, } client := http.Client{ Transport: roundTripper, } res, err := client.Get(\u0026#34;http://example.com\u0026#34;) 1.4. Testability 不要事后想到可测试性, 而是在设计时.\n2. Backwards compatibility 新版本软件可以使用旧版本软件的数据.\n使用某个库的重要因素是该库承诺后向兼容 绝对的后向兼容有缺点 不能使用语言特性 不能使用标准库的新 API 偿还技术债务 设置向后兼容的范围, 例子\n维护当前和前一版本的 releases 遵循 Semantic versioning 2.1. Breaking changes Go 1 and the Future of Go Programs 给出了一些 breaking changes 定义\n向公开的 interface 添加方法是 breaking change\n2.2. Semantic versioning 1.0之前被视为不稳定版本\n3. Recommendations 3.1. Work backwards 在实现之前要考虑\nAPI 可能的使用方法 能否被误用 如何测试功能符合预期 考虑灵活性以适应未来可能的新需求 API 对输入的要求是什么, 对输出的保证是什么 3.2. Minimize surface area 公开的\u0026quot;表面积\u0026quot;越小, 你的库在实现上会获得很大灵活性 公开的\u0026quot;表面积\u0026quot;越大, 需要保证稳定的东西越多 3.2.1 Internal packages 使用 internal 包减少表面积\n不要在公开的 API 中包含 internal 中的实体 3.3. Avoid unknown outputs 对输入进行严格检查 必要情况下 copy 传入的 slice/map, 以免受元素内部状态变更所导致的问题 函数出错时返回类型的零值\u0026amp;err 考虑返回的 slice 的元素顺序 3.4. No global state 全局状态的缺点\n不易测试 高耦合 减少灵活性 Bad\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var cache map[string]*Value func init() { cache = make(map[string]*Value) } func Lookup(name string) (*Value, error) { if v, ok := cache[name]; ok { return v, nil } // ... v := /* ... */ cache[name] = v return v, nil } Good\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Handle struct { cache map[string]*Value } func NewHandle() *Handle { return \u0026amp;Handle{ cache: make(map[string]*Value), } } func (h *Handle) Lookup(name string) (*Value, error) { if v, ok := h.cache[name]; ok { return v, nil } // ... v := /* ... */ h.cache[name] = v return v, nil } 3.5. Accept, don’t instantiate Bad\n1 2 3 4 func New(fname string) (*Parser, error) { f, err := os.Open(fname) // ... } Good\n1 2 3 func New(f *os.File) (*Parser, error) { // ... } 3.6. Accept interfaces Bad\n1 2 3 func New(f *os.File) (*Parser, error) { // ... } Good\n1 2 3 func New(r io.Reader) (*Parser, error) { // ... } 组合接口\n1 2 3 4 5 6 7 8 9 10 11 type Source interface { io.Reader Name() string } var _ Source = (*os.File)(nil) func New(src Source) (*Parser, error) { // ... } 3.7. Interfaces are forever 对接口的增删改都是 break change.\n3.8. Return structs 返回 struct 而不是 interface 可以获得灵活性和向后兼容能力\nBad\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Client interface { Set(k string, v []byte) error Get(k string) ([]byte, error) } type clientImpl struct { // ... } func (c *clientImpl) Set(...) error func (c *clientImpl) Get(...) ([]byte, error) func New(/* ... */) Client { return \u0026amp;clientImpl{ // ... } } Good\n1 2 3 4 5 6 7 8 9 10 11 type Client struct { // ... } func (c *Client) Set(...) error func (c *Client) Get(...) ([]byte, error) func New(/* ... */) *Client { return \u0026amp;Client{ // ... } } 3.9. Upgrade with upcasting 不能给公开的 interface 添加方法\n1 2 3 4 5 6 type Source interface { io.Reader Name() string + Offset() int64 // bad: breaking change } 要创建新的 interface\n1 2 3 4 5 type OffsetSource interface { Source Offset() int64 } 向后兼容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func New(src Source) *Parser { osrc, ok := src.(OffsetSource) if !ok { osrc = \u0026amp;nopOffsetSource{src} } return \u0026amp;Parser{ osrc: osrc, // ... } } type nopOffsetSource struct{ Source } func (*nopOffsetSource) Offset() int64 { return 0 } 3.10. Parameter objects Bad\n1 2 3 func New(url string) *Client { // ... } Good\n1 2 3 4 5 6 7 type Config struct { URL string } func New(c *Config) *Client { // ... } 3.11. Functional options 1 2 3 4 5 6 7 8 9 package db type Option /* ... */ func Connect(addr string, opts ...Option) (*Connection, error) func WithTimeout(time.Duration) Option { /* ... */ } func WithCache() Option { /* ... */ } 1 2 3 4 5 6 7 db.Connect(addr) db.Connect(addr, db.WithTimeout(time.Second)) db.Connect(addr, db.WithCache()) db.Connect(addr, db.WithTimeout(time.Second), db.WithCache(), ) 3.11.1. How to implement functional options 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 定义 option type connectOptions struct { timeout time.Duration cache bool } // 定义操作 option 的接口 type Option interface { apply(*connectOptions) } // 实现 option 接口 type timeoutOption struct{ d time.Duration } func (t timeoutOption) apply(o *connectOptions) { o.timeout = t.d } func WithTimeout(d time.Duration) Option { return timeoutOption{d: d} } // 默认值 func Connect(addr string, os ...Option) (*Connection, error) { opts := connectOptions{ timeout: time.Second, } for _, o := range os { o.apply(\u0026amp;opts) } // ... } 3.11.2. Planning for functional options 预留\n1 2 3 4 5 6 7 8 // Option configures the behavior of Connect. // // There are no options at this time. type Option interface { unimplemented() } func Connect(addr string, opts ..Option) *Connection 3.12. Result objects 向后兼容的\n1 2 3 4 5 6 7 8 9 10 type UpsertResponse struct { Entries []*Entry } func (c *Client) Upsert(ctx context.Context, req *UpsertRequest) (*UpsertResponse, error) { // ... return \u0026amp;UpsertResponse{ Entries: entries, }, nil } 3.13. Errors 要么返回 err, 要么打印 log, 不要都有 不要使用 pkg/errors, 有性能问题 3.14. Goroutines 不要无限启 goroutine\n处理一个请求所启动的 goroutine 数量应该与请求的内容无关 使用 goroutine 池 注意 goroutine 泄露 应该能够 graceful stop goroutine goleak 3.15. Reflection 谨慎地使用反射.\n3.16. Naming Effective Go \u0026gt; Names What’s in a name? 不要使用 common, util.\n3.17. Documentation 有文档也是采用某个库的重要原因.\n使用文档而不是开发文档 使用段落和列表突出信息 提供例子 不要写没用的注释 3.18. Keep a changelog 面向用户的 changelog changelog 格式 ","permalink":"https://jdxj.github.io/posts/articles/abhinavg/designing-go-libraries/","summary":"原文 1. Primary Concerns 1.1. Usability 建立惯例使库的特性可发现 潜在的错误使用 易于完成常见任务 Case Study: net/http 看起来有些繁琐 1 2 3 4 5 6 7 8 9 10 // import \u0026#34;net/http\u0026#34; req, err := http.NewRequest(http.MethodGet, \u0026#34;http://example.com\u0026#34;, nil /* body */) if err != nil","title":"Designing Go Libraries"},{"content":"各列详解 Extra 展示额外信息\nNo tables used 没有 from 子句\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT 1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | No tables used | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ 1 row in set, 1 warning (0.00 sec) Impossible WHERE where 子句永远为 false\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE 1 != 1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+ | 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | Impossible WHERE | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+ 1 row in set, 1 warning (0.01 sec) No matching min/max row 当查询列表处有 min 或者 max 聚集函数，但是并没有符合 where 子句中的搜索条件的记录\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = \u0026#39;abcdefg\u0026#39;; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+ | 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | No matching min/max row | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+ 1 row in set, 1 warning (0.00 sec) Using index 使用索引覆盖\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT key1 FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | Using index | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) Using index condition 使用了索引条件下推 (Index Condition Pushdown)\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39; AND key1 LIKE \u0026#39;%b\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 266 | 100.00 | Using index condition | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.01 sec) 范围区间做下推\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 266 | 100.00 | Using index condition | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.02 sec) 等值不做下推\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.03 sec) Using where where 中的条件包含非索引列, 需要 server 层判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE common_field = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 10.00 | Using where | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1 row in set, 1 warning (0.01 sec) mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39; AND common_field = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 10.00 | Using where | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) Using join buffer (Block Nested Loop) 在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL 一般会为其分配一块名叫 join buffer 的内存块来加快查询速度，也就是我们所讲的 基于块的嵌套循环算法\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 10.00 | Using where; Using join buffer (Block Nested Loop) | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+ 2 rows in set, 1 warning (0.03 sec) Not exists 使用左（外）连接时，如果 WHERE 子句中包含要求被驱动表的某个列等于 NULL 值的搜索条件，而且那个列又是不允许存储 NULL 值的，那么在该表的执行计划的 Extra 列就会提示 Not exists 额外信息\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL; +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | ref | idx_key1 | idx_key1 | 303 | xiaohaizi.s1.key1 | 1 | 10.00 | Using where; Not exists | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+ 2 rows in set, 1 warning (0.00 sec) Using filesort 很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | Using filesort | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ 1 row in set, 1 warning (0.00 sec) Using temporary 在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含 DISTINCT、GROUP BY、UNION 等子句的查 询过程中\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT DISTINCT common_field FROM s1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | Using temporary | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+ 1 row in set, 1 warning (0.00 sec) ","permalink":"https://jdxj.github.io/posts/books/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84-%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3mysql/17-explain%E8%AF%A6%E8%A7%A3%E4%B8%8B/","summary":"各列详解 Extra 展示额外信息 No tables used 没有 from 子句 1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT 1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | 1 | SIMPLE | NULL | NULL | NULL | NULL |","title":"17 Explain详解(下)"},{"content":" A股上市公司数量接近4000只 有研究报告覆盖的公司数量也不超过2000家 第一种武器：跟着券商研报选股 基本方法: 三看两不看\n三看: 一看基本情况分析，二看推荐逻辑，三看财务预测。 两不看: 不看券商研究报告的目标价和评级。 选择研报的窍门\n选择深度报告. 页数多, 或者包含\u0026quot;深度报告\u0026quot;, \u0026ldquo;首次报告\u0026quot;字样 研究员对盈利预测或投资评级进行调整的报告, 往往意味着研究员观点的变化，可能存在“预期差”，也就是存在市场没有意识到的机会 如果有关某公司的报告很久都没有，突然有一篇报告发布，而且是深度报告，这样的报告我们要特别关注。 第二种武器：跟着财报选股 利用财务指标的组合选出潜力好公司\n净资产收益率，企业的赚钱能力 A股的净资产收益率均值现在在7%至8%之间，所以一家公司的净资产收益率能达到15%就不错了。\n表5-1 2009—2018年股价涨幅靠前公司的平均净资产收益率 经营性现金流，企业的盈利质量 一般来说，公司的经营性现金流净额和净利润的比大于1，表示盈利质量高，反之，则表示盈利质量较差。 也可以用经营性现金流入额和公司的销售收入的比值，来考察公司的盈利质量。在实际交易中，由于赊账情况的产生，实际产生的经营性现金流入额要小于销 售收入。两者的比值越接近1，就说明公司资金回笼的速度越快，反之则会造成大量资金的挤压。 表5-3 乐视2015—2017年部分财务数据 市盈率，估值的合理性 用“净资产收益率—经营性现金流—市盈率”3个指标筛选股票的例子\n过去3年净资产收益率连续高于20%，过去3年经营性现金流/净利润大于1，最新市盈率不超过25倍。 预收账款，这个指标是评估公司竞争力和行业最重要的动态指标。\n表5-4 贵州茅台预收账款 如何利用财报中的“管理层讨论”选出潜力好公司。\n财报中的“管理层讨论”主要包含公司管理层对公司过去一年经营情况的概述，以及管理层对未来的行业分析和战略规划。 图5-1 圣农发展2017年年报管理层讨论的部分内容 第三种武器：跟着聪明钱选股 股票市场上总有这样一些资金，它们能在资本市场上先知先觉，赚取很好的投资回报。这类资金被我们称为“聪明钱”。聪明钱一般来自专业机构，包括社保基金、 保险资金、外资，以及知名的公募基金、私募基金的资产等。\n聪明钱的特点\n（1）政策洞察力强。聪明钱团队往往和决策层保持紧密沟通，并对国家各种政策进行持续跟踪。简单来说，大机构对宏观政策面的把握比普通投资者更为深刻。 （2）团队实力强。聪明钱团队的研究、风险控制、投资等流程的分工有序，团队的专业知识和实践经验也是个人投资者所不能比的。所谓“好汉难敌四手”， 就是这个道理。 （3）偏好行业龙头，偏好大而美公司。由于资金庞大，聪明钱偏向选择规模大、流动性强、盈利能力强的大而美公司。如果市值很小，难以容纳大资金，这 样的股票就很难进入机构的核心股票池。 （4）长线投资。聪明钱的资金规模、资金性质决定了团队要做长线投资，大机构的持股周期一般都在2～3年以上，而我们个人投资者往往是追涨杀跌，能持 股几个月就不错了。 （5）逆向投资。聪明钱团队利用人性的贪婪、恐惧和欲望，往往会做出“在市场萧条时进场，在市场繁荣时出场”这种逆向操作的决定。而普通投资者往往会 因为贪婪或恐惧，采取追涨杀跌的方式，让操作处于被动局面。 哪些机构才是聪明钱呢？\n看机构的长期业绩 第四种武器：跟着“内部人”选股 公司内部人士最清楚公司的经营情况，所以内部人，特别是大股东、高管等的大规模增持、回购行为，通常会透露重要信息。\n投资者可以格外关注以下几点，仔细甄别增持、回购是信号还是噪声。\n第一，我们要分析增持的动机。 第二，我们需要关注增持、回购的金额或比例。 第三，我们要结合基本面进行分析。 在跟着“内部人”选股的过程中，我们要注意以下风险。\n第一，我们要注意雷声大、雨点小的增持、回购。A股市场中那些只有上限没有下限的增持回购计划，我们要警惕，因为这些计划基本都不靠谱。 第二，我们要注意假增持、假回购。 第三，我们要格外注意公司的基本面，如果公司的基本面已经恶化，不管内部人是何种意图去增持、回购公司股票，我们都应该绕道，避开风险个股。 第五种武器：跟着生活经验选股 留意日常 坚持能力圈原则 要学会区别信号和噪声 第六种武器：跟着新闻选股 看新闻，是每个投资者必备的一项技能。\n以下几类新闻值得投资者格外关注。\n第一，国家政策类新闻需要格外关注，因为政策对行业、市场可能有非常重要的影响。例: 供给侧改革 第二，国家领导人调研考察类新闻需要格外关注，因为这表明国家对某公司、行业的重视。例: 国家领导人首次调研考察徐工机械 第三，行业性新闻需要格外关注，因为行业格局的变化也会带动一大拨机会。例: 以药养医 每个人接收的投资信息却差异巨大，区别在哪里？\n一是区别信号和噪声的能力。 二是判断股价是否已经提前反应的能力。 三是从 A 推导出 B 的逻辑推理能力。 根据新闻选股，投资者需要长期的知识积累和高度的敏感性，这样才能洞察其中的机会。\n第七种武器：跟着专业投顾团队选股 股票投顾市场通常有两大派：一派是传统的投顾服务，另一派是机构研究服务。投顾和研究员之间的差别，就像全科医生和专科医生的差别。\n服务团队所在公司持有证监会颁发的证券投资咨询执照，服务人员拥有投顾职业编号，这是投顾提供服务的基本要求，投资者也可以据此排除一大批冒牌投顾。\n好的投顾\n专业的投顾服务是帮助客户做好资产配置并构建股票组合，而不是单纯推荐某只股票。 在构建股票组合的过程中，投顾要充分了解客户的风险承受能力，帮助客户构建适合自己、匹配自己的股票组合。 在资产配置和构建组合的过程中，投顾一定要坚持“长期投资”原则，而不是短线博弈。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9F%BA%E6%9C%AC%E9%9D%A2%E6%8A%95%E8%B5%84%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%80%89%E5%87%BA%E6%BD%9C%E5%8A%9B%E5%A5%BD%E8%82%A1%E7%A5%A8%E7%9A%847%E7%A7%8D%E6%AD%A6%E5%99%A8/","summary":"A股上市公司数量接近4000只 有研究报告覆盖的公司数量也不超过2000家 第一种武器：跟着券商研报选股 基本方法: 三看两不看 三看: 一看基本情况分","title":"第五章 选出潜力好股票的\"7种武器\""},{"content":"“知—择—行”，构建自己的投资体系 知\n清楚自己的能力圈, 包括专业背景, 知识结构 清楚自己的风险承受能力, 年龄, 收入, 投资占收入和其他资产的比重 形成对股票市场的正确认知, 2016年开始, 基本面的作用越来越大 择\n了解各种盈利体系的适用性 没有大涨大跌的平衡市 大幅震荡的波动行情 价值风格盛行的行情 了解各种盈利体系的风险度 评判所建立的盈利体系和你的能力圈及风险承受能力是否匹配 行\n知行合一. 在实际投资中，你遇到的最大挑战是，当你的投资方法论遭遇困难，特别是投资非常不顺的时候，你开始对自己的盈利体系产生怀疑和动摇。这时 候你该怎么办？这时我们要有良好的心态，并坚持自己的体系。 “与时俱进”要求我们经常回顾和评估自己的方法论是否满足市场的发展趋势，以及自己是否真正执行了既定策略。 股市新常态下，基本面投资体系的重要性 A股市场进入新常态的原因\n第一，中国经济进入新常态。首先，中国经济从高速增长阶段进入中速增长阶段，以前动辄8%甚至10%以上的高增长率一去不复返，取而代之的是6%甚至更低 的增长率。其次，结构优化、结构升级取代速度增长，成为中国经济的主旋律。 第二，上市公司发展进入新常态。随着中国经济进入中速增长，很多产业的增长空间变得有限，产业的竞争格局变得相对固化，行业内更多是“存量竞争”的状 态。与此同时，中国股市开始进入“良币驱逐劣币”的阶段。 第三，股市环境进入新常态。市场化、国际化、法制化正在深刻影响着中国股市的生态，推动中国股市越来越健康地发展。在这样的背景下，A股市场的投资 理念、投资风格一定会越来越向成熟市场靠拢。 投资的目的是盈利，追求长久、可持续的盈利。所以我们选择价值投资，用价值投资的可复制性来维持盈利的可持续性。而价值投资可复制的根本原因，是价 值投资逻辑简单，交易不拥挤。\n价值投资的核心逻辑是寻找“好赛道+好公司+好价格”的股票, 其需要考虑的变量相对较少，而且变量相对稳定、相对容易把控。 而其他很多投资方法论，影响决策的变量特别多，比如宏观经济、大宗商品价格、汇率和美国经济等多种“重要但难以预测”的因素。投资者考虑这些因素的难 度更大，成功更多靠运气，而不是靠体系和能力。 价值投资看上去很简单，但为什么追随巴菲特的投资者如此之多，做到的却寥寥无几呢？\n因为价值投资需要极强的忍耐力：对股价回撤的忍耐力，对股价长期不涨的忍耐力。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%8E%E6%97%B6%E4%BF%B1%E8%BF%9B%E5%8F%91%E5%B1%95%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/","summary":"“知—择—行”，构建自己的投资体系 知 清楚自己的能力圈, 包括专业背景, 知识结构 清楚自己的风险承受能力, 年龄, 收入, 投资占收入和其他资产的比重 形","title":"第四章 与时俱进发展自己的盈利体系"},{"content":"示例表 使用例子\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT 1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | No tables used | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ 1 row in set, 1 warning (0.01 sec) 各列作用\n列名 描述 id 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id select_type SELECT关键字对应的那个查询的类型 table 表名 partitions 匹配的分区信息 type 针对单表的访问方法 possible_keys 可能用到的索引 key 实际上使用的索引 key_len 实际使用到的索引长度 ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 rows 预估的需要读取的记录条数 filtered 某个表经过搜索条件过滤后剩余记录条数的百分比 Extra 一些额外的信息 例表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CREATE TABLE single_table ( id INT NOT NULL AUTO_INCREMENT, key1 VARCHAR(100), key2 INT, key3 VARCHAR(100), key_part1 VARCHAR(100), key_part2 VARCHAR(100), key_part3 VARCHAR(100), common_field VARCHAR(100), PRIMARY KEY (id), KEY idx_key1 (key1), UNIQUE KEY idx_key2 (key2), KEY idx_key3 (key3), KEY idx_key_part(key_part1, key_part2, key_part3) ) Engine=InnoDB CHARSET=utf8; 假设有两个和 single_table 表构造一模一样的 s1、s2 表，而且这两个表里边儿有10000条记录，除 id 列外其余的列都插入随机值。\n各列详解 table explain 中的每条记录对应某个单表访问方法, table 就表示所访问的表\n一条查询语句 1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) join 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | Using join buffer (Block Nested Loop) | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ 2 rows in set, 1 warning (0.01 sec) id sql 语句中每出现一个 select, 就会分配一个 id\n只有一个 select 语句 1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.03 sec) 对于连接查询来说, 一个 select 中有多个 table, 所以 explain 有多条记录, 但 id 相同 出现在前面的表是驱动表(s1) 出现在后面的表是被驱动表(s2) 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | Using join buffer (Block Nested Loop) | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+ 2 rows in set, 1 warning (0.01 sec) 包含子查询的语句涉及多个 select, 所以每个 id 是不同的 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | SUBQUERY | s2 | NULL | index | idx_key1 | idx_key1 | 303 | NULL | 9954 | 100.00 | Using index | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ 2 rows in set, 1 warning (0.02 sec) 子查询可能会被 mysql 转换为连接查询, 导致 id 相同 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = \u0026#39;a\u0026#39;); +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+ | 1 | SIMPLE | s2 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9954 | 10.00 | Using where; Start temporary | | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | xiaohaizi.s2.key3 | 1 | 100.00 | End temporary | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+ 2 rows in set, 1 warning (0.00 sec) union 查询合并两个表的结果并去重 id 为 null 表示创建了用于合并的临时表 table 为 \u0026lt;union1,2\u0026gt; 表示临时表的名称 1 2 3 4 5 6 7 8 9 mysql\u0026gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2; +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 2 | UNION | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | NULL | | NULL | UNION RESULT | \u0026lt;union1,2\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ 3 rows in set, 1 warning (0.00 sec) union all 查询合并两个表, 但不去重 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 2 | UNION | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ 2 rows in set, 1 warning (0.01 sec) select_type 有多种值\n名称 描述 SIMPLE Simple SELECT (not using UNION or subqueries) PRIMARY Outermost SELECT UNION Second or later SELECT statement in a UNION UNION RESULT Result of a UNION SUBQUERY First SELECT in subquery DEPENDENT SUBQUERY First SELECT in subquery, dependent on outer query DEPENDENT UNION Second or later SELECT statement in a UNION, dependent on outer query DERIVED Derived table MATERIALIZED Materialized subquery UNCACHEABLE SUBQUERY A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query UNCACHEABLE UNION The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY) SIMPLE 查询语句中不包含 union 或子查询\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) PRIMARY 包含 union, union all, 子查询的语句, 最左边的小查询的 select_type 是 primary\n1 2 3 4 5 6 7 8 9 mysql\u0026gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2; +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 2 | UNION | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | NULL | | NULL | UNION RESULT | \u0026lt;union1,2\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ 3 rows in set, 1 warning (0.00 sec) UNION 包含 union 或 union all 的查询语句, 除了最左边的是 primary, 其余是 union\n1 2 3 4 5 6 7 8 9 mysql\u0026gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2; +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 2 | UNION | s2 | NULL | ALL | NULL | NULL | NULL | NULL | 9954 | 100.00 | NULL | | NULL | UNION RESULT | \u0026lt;union1,2\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+ 3 rows in set, 1 warning (0.00 sec) SUBQUERY 如果包含子查询的查询语句不能够转为对应的 semi-join 的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案 来执行该子查询时，该子查询的第一个 select 关键字代表的那个查询的 select_type 就是 subquery\n由于 select_type 为 subquery 的子查询会被物化，所以只需要执行一遍 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | SUBQUERY | s2 | NULL | index | idx_key1 | idx_key1 | 303 | NULL | 9954 | 100.00 | Using index | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ 2 rows in set, 1 warning (0.00 sec) DEPENDENT SUBQUERY 如果包含子查询的查询语句不能够转为对应的 semi-join 的形式，并且该子查询是相关子查询，则该子查询的第一个 select 关键字代表的那个 查询的 select_type 就是 dependent subquery\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = \u0026#39;a\u0026#39;; +----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | DEPENDENT SUBQUERY | s2 | NULL | ref | idx_key2,idx_key1 | idx_key2 | 5 | xiaohaizi.s1.key2 | 1 | 10.00 | Using where | +----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+ 2 rows in set, 2 warnings (0.00 sec) DEPENDENT UNION 在包含 union 或者 union all 的大查询中，如果各个小查询都依赖于外层查询的话，除了最左边的那个小查询之外，其余的小查询的 select_type 的值 就是 dependent union\n1 2 3 4 5 6 7 8 9 10 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = \u0026#39;a\u0026#39; UNION SELECT key1 FROM s1 WHERE key1 = \u0026#39;b\u0026#39;); +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+ | 1 | PRIMARY | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | DEPENDENT SUBQUERY | s2 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 12 | 100.00 | Using where; Using index | | 3 | DEPENDENT UNION | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | Using where; Using index | | NULL | UNION RESULT | \u0026lt;union2,3\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary | +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+ 4 rows in set, 1 warning (0.03 sec) 这个例子给的不太清晰\nDERIVED 对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的 select_type 就是 derived\n派生表 物化 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c \u0026gt; 1; +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ | 1 | PRIMARY | \u0026lt;derived2\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 33.33 | Using where | | 2 | DERIVED | s1 | NULL | index | idx_key1 | idx_key1 | 303 | NULL | 9688 | 100.00 | Using index | +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+ 2 rows in set, 1 warning (0.00 sec) MATERIALIZED 当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 select_type 属性就是 materialized\nid 为2的记录是单表查询, 并被物化 id 为1的两条记录是连接查询 table 为 的记录表示其是 id 为2的记录对应的查询结果 1 2 3 4 5 6 7 8 9 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2); +----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ALL | idx_key1 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 1 | SIMPLE | \u0026lt;subquery2\u0026gt; | NULL | eq_ref | \u0026lt;auto_key\u0026gt; | \u0026lt;auto_key\u0026gt; | 303 | xiaohaizi.s1.key1 | 1 | 100.00 | NULL | | 2 | MATERIALIZED | s2 | NULL | index | idx_key1 | idx_key1 | 303 | NULL | 9954 | 100.00 | Using index | +----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+ 3 rows in set, 1 warning (0.01 sec) UNCACHEABLE SUBQUERY 不常用\nUNCACHEABLE UNION 不常用\npartitions 没讲\ntype 单表访问方法\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.04 sec) system 表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如 MyISAM、Memory，那么对该表的访问方法就是 system\n1 2 3 4 5 6 7 8 9 10 11 12 13 mysql\u0026gt; CREATE TABLE t(i int) Engine=MyISAM; Query OK, 0 rows affected (0.05 sec) mysql\u0026gt; INSERT INTO t VALUES(1); Query OK, 1 row affected (0.01 sec) mysql\u0026gt; EXPLAIN SELECT * FROM t; +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+ | 1 | SIMPLE | t | NULL | system | NULL | NULL | NULL | NULL | 1 | 100.00 | NULL | +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) const 根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是 const\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE id = 5; +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | NULL | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.01 sec) eq_ref 在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须 进行等值比较），则对该被驱动表的访问方法就是 eq_ref\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id; +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | PRIMARY | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | eq_ref | PRIMARY | PRIMARY | 4 | xiaohaizi.s1.id | 1 | 100.00 | NULL | +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ 2 rows in set, 1 warning (0.01 sec) ref 当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是 ref\nfulltext 没讲\nref_or_null 对普通二级索引进行等值匹配查询，该索引列的值也可以是 NULL 值时，那么对该表的访问方法就可能是 ref_or_null\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39; OR key1 IS NULL; +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | ref_or_null | idx_key1 | idx_key1 | 303 | const | 9 | 100.00 | Using index condition | +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+ 1 row in set, 1 warning (0.01 sec) index_merge 1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39; OR key3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+ | 1 | SIMPLE | s1 | NULL | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL | 14 | 100.00 | Using union(idx_key1,idx_key3); Using where | +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+ 1 row in set, 1 warning (0.01 sec) unique_subquery 针对在一些包含 IN 子查询的查询语句中，如果查询优化器决定将 IN 子查询转换为 EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该 子查询执行计划的 type 列的值就是 unique_subquery\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = \u0026#39;a\u0026#39;; +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | DEPENDENT SUBQUERY | s2 | NULL | unique_subquery | PRIMARY,idx_key1 | PRIMARY | 4 | func | 1 | 10.00 | Using where | +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+ 2 rows in set, 2 warnings (0.00 sec) index_subquery index_subquery 与unique_subquery 类似，只不过访问子查询中的表时使用的是普通的索引\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 = s2.key1) OR key3 = \u0026#39;a\u0026#39;; +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+ | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 | NULL | NULL | NULL | 9688 | 100.00 | Using where | | 2 | DEPENDENT SUBQUERY | s2 | NULL | index_subquery | idx_key1,idx_key3 | idx_key3 | 303 | func | 1 | 10.00 | Using where | +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+ 2 rows in set, 2 warnings (0.01 sec) 例子不清楚\nrange 使用索引获取某些范围区间的记录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;); +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 27 | 100.00 | Using index condition | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.01 sec) mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;a\u0026#39; AND key1 \u0026lt; \u0026#39;b\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 294 | 100.00 | Using index condition | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.00 sec) index 当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ | 1 | SIMPLE | s1 | NULL | index | NULL | idx_key_part | 909 | NULL | 9688 | 10.00 | Using where; Using index | +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ 1 row in set, 1 warning (0.00 sec) ALL 全表扫描\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) possible_keys 和 key possible_keys 列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，key 列表示实际用到的索引有哪些\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39; AND key3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1,idx_key3 | idx_key3 | 303 | const | 6 | 2.75 | Using where | +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+ 1 row in set, 1 warning (0.01 sec) 使用 index 访问方法来查询某个表时，possible_keys 列是空的，而 key 列展示的是实际使用到的索引\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ | 1 | SIMPLE | s1 | NULL | index | NULL | idx_key_part | 909 | NULL | 9688 | 10.00 | Using where; Using index | +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+ 1 row in set, 1 warning (0.00 sec) possible_keys 列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的 索引。\nkey_len 索引记录的长度, 由三部分组成\n对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是 VARCHAR(100)，使用的字符集是utf8，那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。 如果该索引列可以存储 NULL 值，则 key_len 比不可以存储 NULL 值时多1个字节。 对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。 由于 id 列的类型是 INT，并且不可以存储 NULL 值，所以在使用该列的索引时 key_len 大小就是4。\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE id = 5; +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | NULL | +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.01 sec) 当索引列可以存储 NULL 值时\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key2 = 5; +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | const | idx_key2 | idx_key2 | 5 | const | 1 | 100.00 | NULL | +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) 对于可变长度的索引列来说\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) 在执行计划中输出 key_len 列主要是为了让我们区分某个使用联合索引的查询具体用了几个索引列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key_part | idx_key_part | 303 | const | 12 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = \u0026#39;a\u0026#39; AND key_part2 = \u0026#39;b\u0026#39;; +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key_part | idx_key_part | 606 | const,const | 1 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+ 1 row in set, 1 warning (0.01 sec) ref 当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是 const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery 其中之 一时，ref 列展示的就是与索引列作等值匹配的数据是什么, 常见的有常数或者某个列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | const | 8 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.01 sec) mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id; +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ | 1 | SIMPLE | s1 | NULL | ALL | PRIMARY | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | eq_ref | PRIMARY | PRIMARY | 4 | xiaohaizi.s1.id | 1 | 100.00 | NULL | +----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+ 2 rows in set, 1 warning (0.00 sec) 与索引列进行等值匹配的值是个函数\n1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1); +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 9688 | 100.00 | NULL | | 1 | SIMPLE | s2 | NULL | ref | idx_key1 | idx_key1 | 303 | func | 1 | 100.00 | Using index condition | +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+ 2 rows in set, 1 warning (0.00 sec) rows 如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的 rows 列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的 rows 列就代表预计扫描的索引记录行数。\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 266 | 100.00 | Using index condition | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.00 sec) filtered MySQL 在计算驱动表扇出时采用的一个策略：\n如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。 该查询使用 idx_key1 索引来执行查询，从 rows 列可以看出满足 key1 \u0026gt; \u0026lsquo;z\u0026rsquo; 的记录有266条。执行计划的 filtered 列就代表查询优化器预测在这 266条记录中，有多少条记录满足其余的搜索条件，也就是 common_field = \u0026lsquo;a\u0026rsquo; 这个条件的百分比。此处 filtered 列的值是10.00，说明查询优 化器预测在266条记录中有10.00%的记录满足 common_field = \u0026lsquo;a\u0026rsquo; 这个条件。\n1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39; AND common_field = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+ | 1 | SIMPLE | s1 | NULL | range | idx_key1 | idx_key1 | 303 | NULL | 266 | 10.00 | Using index condition; Using where | +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+ 1 row in set, 1 warning (0.00 sec) 对于单表查询来说，这个 filtered 列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的 filtered 值\n从执行计划中可以看出来，查询优化器打算把 s1 当作驱动表，s2 当作被驱动表。 我们可以看到驱动表 s1 表的执行计划的 rows 列为9688，filtered 列为10.00，这意味着驱动表 s1 的扇出值就是9688 × 10.00% = 968.8，这说 明还要对被驱动表执行大约968次查询。 1 2 3 4 5 6 7 8 mysql\u0026gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = \u0026#39;a\u0026#39;; +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+ | 1 | SIMPLE | s1 | NULL | ALL | idx_key1 | NULL | NULL | NULL | 9688 | 10.00 | Using where | | 1 | SIMPLE | s2 | NULL | ref | idx_key1 | idx_key1 | 303 | xiaohaizi.s1.key1 | 1 | 100.00 | NULL | +----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+ 2 rows in set, 1 warning (0.00 sec) ","permalink":"https://jdxj.github.io/posts/books/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84-%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3mysql/16-explain%E8%AF%A6%E8%A7%A3%E4%B8%8A/","summary":"示例表 使用例子 1 2 3 4 5 6 7 mysql\u0026gt; EXPLAIN SELECT 1; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+ | 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | No tables","title":"16 Explain详解(上)"},{"content":"技术分析 所有的技术分析都是建立在三大假设之上的。\n第一，市场行为包含一切。这句话的含义是所有的基础事件——经济事件、社会事件、战争、自然灾害等作用于市场都会反映到价格和交易量的变化中，特别是 与一家公司收入、利润和未来业绩有关的所有信息都已自动反映在公司股票的价格和交易量上。 第二，价格以趋势方式演变：价格会沿着原有的趋势继续运行，也就是说，价格正在上涨的股票会继续上涨，价格正在下跌的股票会继续下跌，而横盘整理的 股票会继续盘整，直到趋势改变。 第三，历史会重演：人们可以借助市场的历史信息和历史规律，对今后市场的变化进行推断预测。 技术分析的三大假设并没有被主流学术界所接受 在实践当中，单纯的技术分析在预测股价的实用性方面是存疑的 量化投资在中国兴起的时候，一群从海外回来的基金经理，用电脑技术打败国内投资者，赚钱很轻松。但随着越来越多的高智商、精通电脑技术的人加入量化投 资的行列，这几年量化投资赚钱也越来越难。\n未来技术分析的发展方向，可能向“行为金融学”寻求理论支持，并和基本面分析做结合 股票该持有还是该卖出，只和股价的未来走势有关，而股价的未来走势和投资者成本没有任何关系，所以理性的投资者不应该根据自己的持仓成本和盈亏来做买 卖决策。但行为金融学告诉我们，人是不理性的，人一定会根据自己的持仓成本和盈亏来做买卖决策。这时候，密集成交区的股价就构成了技术分析中的压力线 和支撑线。\n技术分析发现交易信号，基本面分析剔除高危垃圾股\n基本面投资 基本面投资的流派\n价值投资 成长股投资 价值投资就是买入被低估的股票，等待价值回归 买入价格低于价值的股票，等待价值回归\n核心问题\n什么是低估 被低估的股票会不会回归价值 低估的多种含义\n相对低估是它的估值相对同类公司便宜 绝对低估又可以分为两种情形 一种是低于净资产或者重置成本 另一种是低于内在价值 推荐大家读一读《投资最重要的事》\n成长股投资就是寻找能持续高成长的公司，享受业绩和估值双重提升带来的获利机会 市盈率=股价 / 每股盈利 股价=每股盈利×市盈率 成长股投资的核心理念是，从静态估值看，股价已经不便宜，但如果其业绩有持续高增长的潜力，静态估值贵一点儿，也值得投资。\n成长股投资最大的风险是，当高成长性逆转后，股价可能会跌得非常厉害。\n股价=每股盈利×市盈率，每股盈利和市盈率都上涨，股价自然会快速上涨。但是，成长股的成长性一旦逆转，就会遭遇“戴维斯双杀”。每股盈利下跌，估值也下 跌，这时候股价就会跌得很厉害。\n价值投资和成长股投资进行比较得知，价值投资更看重现在，成长股投资更看重未来。所\n“买卖逻辑自洽”，就是你买和卖的理由要逻辑一致。\n那么对价值投资来说，买入的理由是什么？低估。对成长股投资来说，买入的理由是什么？高成长。 那什么时候卖出股票呢？对价值投资来说，是不再低估。对成长股投资来说是不再高成长。 价值投资最大的问题是，很多股票被低估是有合理原因的。\n行业可能在下坡路了 投资者只有将公司的成长性、竞争力和公司的合理估值相结合，才是价值投资。\n在用估值指标的时候，投资者需要注意3点。\n第一，估值必须和未来可持续的复合增长率匹配，也就是说，投资者要找到估值和成长性合理匹配的公司。 第二，投资者计算估值时要剔除非经常性损益的影响。很多公司的盈利里有一些非经常性损益，比如一次性出售房地产的收益，这类收益要剔除掉，特别是在 用市盈率估值的时候。 第三，投资者要注意财务造假的可能性。如果盈利都是假的，那估值就完全没有意义了。 表3-1 价值投资和成长股投资的区别 基本面投资为什么能够战胜市场，为什么能够取得超额收益。\n第一，基本面投资讲究安全边际。什么叫安全边际？通俗一点儿说，你买的股票的价格便宜、合理，就有安全边际。 第二，基本面投资讲究投资逻辑，买卖逻辑要自洽。逻辑自洽是买一只股票和卖这只股票的逻辑要一致。 第三，基本面投资能够让投资者避免追涨杀跌，避免过度交易。 第四，在中国做基本面投资的人不多，所以更有机会成功。 基本面博弈 为什么叫“基本面博弈”？因为如果将它归类于技术分析，它关注的东西、用的语言都和基本面相关，比如它会关心经济形势、政府政策、公司盈利等基本面因素； 如果将它归类于基本面投资，它的持股周期并不长，往往只有几个月，很少超过1年，和基本面投资的“买入持有”策略有很大差异。“基本面博弈”这一称呼，表 明它用的是基本面的语言，但本质上是一种博弈。\n在基本面博弈中，最常见的是主题投资策略和轮动策略。\n主题投资策略 主题有点儿类似大家常说的“题材”，主题投资是通过挖掘对股票市场有较大影响的因素，对潜在受益的行业和公司进行投资的一种策略。但和纯粹的题材炒作或 者概念炒作不一样，主题投资依赖于对基本面的判断，寻找有较大概率能兑现业绩高增长的投资机会，延续的时间周期可能较长，而题材炒作或者概念炒作则完 全是资金推动的短期炒作，基本上是“昙花一现”。\n主题投资的特点在于它并不按照一般的行业划分来区分股票，而是将驱动经济发展的某个因素作为“主题”，以此来选择地域、行业、板块或个股。\n表3-2 2011-2016年主题投资类型 一般来说，主题投资更适合早期的产业。正因为早期，所以想象空间大、无法在短时间内证伪，投资者对收入和利润的要求相对没那么高，或者产业内竞争不那 么激烈，率先进入这个产业的公司能取得不错的利润。随着产业演进，产业内公司充分竞争，公司盈利能力经常会出现一个阶段性低点，兼并重组开始出现，部 分经营不善的公司甚至退出产业，集中度开始提升，龙头公司盈利能力也逐步回升，出现所谓的成长股投资阶段。\n图3-1 产业演进曲线 表3-3 主题投资和成长股投资的区别 在A股市场投资，主流机构一般会选择哪些主题进行重点投资？什么样的主题是优质的主题？\n第一，主题选择要高大上，具备想象空间。选择的主题想象空间越大，越能引起市场的参与热情。比如2015年的互联网+主题，想象空间就足够大。反过来共 享单车这样的主题，想象空间就小很多。 第二，主题容量要足够大。主题相关的标的股票要能容纳足够多的资金，如果太小，就不能吸引主流机构资金大规模参与。 第三，主题要能被普通投资者理解并关注和传播。一个能被普通投资者理解和传播的主题，较容易形成市场热点并扩散，太专业的主题只能由少数专业机构参 与，很难形成大行情。 第四，主题持续的时间要足够长，特别是较长时间内难以被证伪。 轮动策略 根据宏观经济景气周期、行业盈利周期、股票市场变动趋势等因素，轮流选择不同板块、不同行业、不同风格股票进行投资的策略。\n“美林时钟”理论按照经济增长与通胀的不同搭配，将经济周期划分为4个阶段。\n（1）“经济上行，通胀下行”构成复苏阶段，此阶段由于股票对经济的弹性更大，其相对债券和现金具备明显的超额收益。 （2）“经济上行，通胀上行”构成过热阶段，此阶段由于通胀上升，增加了持有现金的机会成本，可能出台的加息政策降低了债券的吸引力，股票的配置价值 相对较强。 （3）“经济下行，通胀上行”构成滞胀阶段，此阶段现金收益率提高，持有现金最明智，经济下行对企业盈利的冲击将对股票构成负面影响，债券相对股票的 收益率提高。 （4）“经济下行，通胀下行”构成衰退阶段，此阶段通胀压力下降，货币政策趋松，债券表现最突出，随着经济即将见底的预期逐步形成，股票的吸引力逐步 增强。 图3-2 “美林时钟”的经济周期和投资策略 在股票市场中，轮动策略可以进一步分为以下方法。\n板块轮动：根据大的经济周期，在成长、消费、周期、金融地产等大板块之间进行择时投资。 行业轮动：根据不同行业的不同景气周期，在行业之间进行择时投资。 风格轮动：根据股票市场的变化趋势，在不同风格之间进行择时投资，比如大小盘风格轮动、成长价值风格轮动等。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/","summary":"技术分析 所有的技术分析都是建立在三大假设之上的。 第一，市场行为包含一切。这句话的含义是所有的基础事件——经济事件、社会事件、战争、自然灾害等","title":"第三章 股票投资常见的盈利体系"},{"content":"盈利体系的基石：正确认知 对股票的认知: 投资股票靠什么赚钱 对风险的认知: 如何应对投资亏损 对股票的认知 一种认知是：股票就是博弈的筹码。 零和游戏 另一种认知是：股票是投资上市公司的载体。 你赚的钱是上市公司的成长带给你的利润增长 股票是一个财富转移的工具。 对风险的认知 现代金融学理论用股价的波动率来衡量风险，股价的波动程度代表着风险的高低。股价波动性越大，意味着股票的风险越大。 巴菲特认为投资的风险并不来源于波动，波动反而是机会，因为股价波动的幅度越大，好公司越会出现被低估的机会。 巴菲特认为本金的永久性损失才是真正的风险。什么是本金的永久性损失？是你所买入股票的公司基本面恶化，股价永远回不到你买入的价格，这才是真正的风 险。所以，真正的风险并非股价的波动，而是来自公司的“内在价值风险”。所以，选择安全边际高的股票，才是避免风险的最好投资方法。\n盈利体系的基本内容：“选股—验证—决策—跟踪”四大环节 第一步：选股，就是发现潜在的好股票 最常见的就是从财务指标中进行初选。\n净资产收益率 (ROE) A股市场3000多家上市公司，平均净资产收益率在7%至8%之间。 我们设定一个简单指标，选出净资产收益率连续3年大于20%的股票，就能剔除掉90%的股票，只剩下大约300只，这就能大大降低我们选择的难度。 从新闻中发现好股票的线索，从生活中发现好股票的线索，从券商研报中发现好股票的线索。 第二步：验证，当你初选出好股票之后，需要验证它是不是真的好股票 首先，我们要看这个行业的空间大不大，行业空间决定公司的发展空间。\n技术发展趋势 智能手机 -\u0026gt; 改变手机产业 -\u0026gt; 移动社交/支付/手机游戏 人工智能, 大数据, 物联网 供求关系. 是变化的, 需要不断跟踪 政策扶持 其次，我们要验证公司的核心竞争力。\n足够深的护城河. 企业相当长一段时间内无法被模仿和替代的竞争优势，如品牌、专利、垄断性牌照、规模优势等 优秀的管理团队. 需要考察管理层的眼光、能力和管理思路，还要考察管理层是否有把企业做大做强的决心 再次，我们要重视财务分析，因为财务分析是验证公司是否有竞争力的重要手段。\n最后，我们还要看估值。\n投资者做基本面投资就必须要研究估值，不管是价值股投资还是成长股投资，都必须研究估值，因为好股票=好公司+合理估值。 我们只有了解了公司的合理估值，才能通过与现有股价进行对比，判断目前股价是被高估、合理还是被低估。 如果股价被高估，即使基本面再好，也不是买入的机会。 第三步：决策，就是做出是否买、如何买的判断 在买入之前，你要想清楚以下问题。\n第一，我准备在什么价格区间买入？或者我在哪些条件具备的情况下买入这只股票？ 第二，我准备用多少资金买入这只股票？这只股票占我整个组合的比例是多少？ 第三，我准备持有这只股票多长时间？到什么价格或发生什么情况，我会准备卖出这只股票？ 第四，买入之后可能会出现什么样的意外？如果出现了意外，我应该怎样应对？ 第四步：跟踪，持续关注和研究公司的基本面变化 如何止盈和止损\n重点\n股票的价格与其曾经的价格无关, 只和估值有关 忘掉成本, 唯一决定这只股票涨跌的是它的基本面未来会怎么样，跟你被套牢还是盈利没有任何关系 要学会利用各种资源，尤其是券商分析师的报告 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%9E%84%E5%BB%BA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/","summary":"盈利体系的基石：正确认知 对股票的认知: 投资股票靠什么赚钱 对风险的认知: 如何应对投资亏损 对股票的认知 一种认知是：股票就是博弈的筹码。 零和游戏 另","title":"第二章 我们需要构建什么样的盈利体系"},{"content":"股票投资看似简单却很复杂 股票投资难，在于股票投资是一个概率游戏，正确决策（过程）未必带来好的结果，错误决策（过程）有时候会让你赚钱。也就是说，决策（过程）正误和投资 结果好坏没有必然联系，这就会导致以下3种情况。\n一是赚了钱，却很难归因或者错误归因 比如“十送十”买入股票，股价上涨后投资者很开心，觉得自己决策正确。但股价真正上涨的原因可能是业绩超预期，或者政策变化，但投资者却把上涨原因归结 为“十送十”。下次投资，投资者就会去找“十送十”的股票，而不是业绩超预期的股票。\n二是赚了钱，却不可重复，运气成分大于能力成分 投资是一个概率游戏\n三是因为运气，错误决策（过程）产生了好结果，强化了错误决策 长期按照这个思路操作下去，投资者一定会亏损累累，因为很可能有这样的结果：多次“成功操作”赚来的钱被一次连本带利地亏完。\n投资最重要的事：建立可重复、大概率能赚钱的盈利体系 大数定律\n表1-1 单次博弈和重复博弈 DFH盈利体系的内容，概括起来有以下几点。\n选股：幸运的行业+能干的公司 投资者要看公司所处的行业特征如何，是否有较大的发展空间； 公司的商业模式如何，是否具有可持续的发展能力，是否经得起未来的考验； 管理层是否足够优秀，是否拥有与自己行业特征相匹配的能力。 投资者要尽量不买上市不到两年的新股，不追逐主题、热点，不买市盈率特别高的股票。 策略：长期投资，陪伴好公司成长 投资者坚持“自下而上”地选择优秀公司，深入研究公司的基本面，关注公司的本身，关注公司的核心竞争力的提升和行业地位的稳固； 坚信有核心竞争力的优质上市公司的回报率会远高于社会平均回报率； 避免高换手率，不频繁交易，坚持长期投资，陪伴好公司成长，赚取上市公司长期盈利增长的钱，赚取上市公司分红的钱。 风控：专注于择股，大部分时间不择时 时间是优质公司的朋友 眼于长期的投资机会而不过多考虑股价的短期波动 敢于逆向思维、逆向投资 时间是好体系的朋友，是差体系的敌人 任何投资，脱离时间维度，都是没有意义的:\n对于价值投资来说，至少要有2～3年的持股周期。 对于技术分析来说，时间长则要数月，短则要数天。 而对于量化高频交易来说，考虑的时间可能是几秒，甚至是零点几秒。 从长期来看，股价是由价值决定的，股价永远围绕着公司价值波动。什么是公司价值？它是公司基本面决定的合理估值。但在短期内，股价往往会和公司价值发 生偏离，甚至是很大的偏离。对优秀公司来说，随着时间的推移，它的盈利会不断增长，价值会不断提升。\n投资者亏钱的最大问题：没有盈利体系或者拥有错误的盈利体系 正确的盈利体系应该符合3个标准\n适合自己的能力圈. 个人投资者在构建自己的盈利体系的过程中，要综合考虑自己的职业、财务状况、风险承受能力，以及自己的性格特点。 逻辑自洽 买股票的逻辑和卖股票的逻辑要一致。 我经常会碰到一些个人投资者跟我说他买了哪只股票，我问他为什么买这只股票，他说看好这个行业，公司业绩也很好，讲了一堆理由，都是基本面的逻辑。 过了3天，他又跟我说他把那只股票卖了，因为股价跌穿5日线、“死叉”出来了，这又是技术分析的逻辑。这样的买卖逻辑自洽吗？买卖逻辑不自洽的人， 99%的概率是做不好投资的，能做好投资的一定是买卖逻辑自洽的人。 符合市场规律和趋势 可持续、可复制. 一个正确的盈利体系，一定是在相当长一段时间内可持续、可复制的。有些策略或者方法，虽然也能赚钱，但不能持续。 ","permalink":"https://jdxj.github.io/posts/books/%E9%95%BF%E6%9C%9F%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%9B%88%E5%88%A9%E4%BD%93%E7%B3%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E8%A6%81/","summary":"股票投资看似简单却很复杂 股票投资难，在于股票投资是一个概率游戏，正确决策（过程）未必带来好的结果，错误决策（过程）有时候会让你赚钱。也就是说","title":"第一章 盈利体系为什么重要"},{"content":"15.1 Introduction to InnoDB 15.1.2 Best Practices for InnoDB Tables 使用索引 关闭自动提交 (写速度限制) 15.1.3 Verifying that InnoDB is the Default Storage Engine DEFAULT 字样\n1 2 SHOW ENGINES; SELECT * FROM INFORMATION_SCHEMA.ENGINES; 15.2 InnoDB and the ACID Model A: atomicity. C: consistency. I: isolation. D: durability. 15.3 InnoDB Multi-Versioning InnoDB 在每行记录上添加三个字段\nDB_TRX_ID: 最新进行操作(insert, update, delete)的事务 id DB_ROLL_PTR: 指向 undo log 的指针 DB_ROW_ID: row id, InnoDB 自动生成的聚集索引才有 insert undo log 在事务提交后删除, update undo log 在没有依赖后删除.\n15.7 InnoDB Locking and Transaction Model 15.7.1 InnoDB Locking Shared and Exclusive Locks 就是读写锁\nIntention Locks 表级锁, 表明一个事务稍后要对该表某行请求的锁\nintention shared lock (IS) intention exclusive lock (IX) SELECT ... FOR SHARE sets an IS lock, and SELECT ... FOR UPDATE sets an IX lock.\nRecord Locks SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE, 阻止其他事务 insert, update, delete t.c1 = 10 的行\nGap Locks 锁定索引记录间的间隙, 或者第一条记录之前的间隙, 或者最后一条记录后的间隙\nSELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE, t.c1 = 15 不能被插入\nNext-Key Locks record lock 和索引记录之前的 gap lock 组合\nInsert Intention Locks AUTO-INC Locks AUTO_INCREMENT 列\nPredicate Locks for Spatial Indexes 15.7.5 Deadlocks in InnoDB 隔离级别不影响死锁的可能性, 因为隔离级别负责读操作, 然而死锁发生在写操作\n","permalink":"https://jdxj.github.io/posts/docs/mysql/chapter15-the-innodb-storage-engine/","summary":"15.1 Introduction to InnoDB 15.1.2 Best Practices for InnoDB Tables 使用索引 关闭自动提交 (写速度限制) 15.1.3 Verifying that InnoDB is the Default Storage Engine DEFAULT 字样 1 2 SHOW ENGINES; SELECT * FROM INFORMATION_SCHEMA.ENGINES; 15.2 InnoDB and the ACID Model A: atomicity. C: consistency. I: isolation. D: durability. 15.3 InnoDB Multi-Versioning InnoDB 在每行记录","title":"Chapter15 The InnoDB Storage Engine"},{"content":"原文\nOptions -K, --config \u0026lt;file\u0026gt; 在文件中指定 curl 的参数\n选项和其参数可以用 空格, :, = 分隔 如果选项前有 - 或 --, 则可以省略 :, = 长选项可省略 -- 参数中包含空格 (或者以 :, = 开头), 则需要用引号包围 -x, --proxy [protocol://]host[:port] -A, --user-agent \u0026lt;name\u0026gt; -A \u0026quot;\u0026quot;, 请求中将不会有该 header -A \u0026quot; \u0026quot;, 有该 header, 但是值为空白 -H, --header \u0026lt;header/@file\u0026gt; 清除某个 header\n-H \u0026#34;Host:\u0026#34; 发送不带值的自定义 header, 必须以 ; 结尾\n-H \u0026#34;X-Custom-Header;\u0026#34; 使用 @filename 可以在文件中读取 header\n// todo 例子 -b, --cookie \u0026lt;data|filename\u0026gt; 在命令行中所指定的 cookie 的格式\n\u0026#34;NAME1=VALUE1; NAME2=VALUE2\u0026#34; 从文件中读取\n文件的 cookie 格式应该是 Netscape/Mozilla cookie file format 1 curl -b cookiefile https://example.com 从文件中读取 cookie 并写回\n1 curl -b cookiefile -c cookiefile https://example.com -c, --cookie-jar \u0026lt;filename\u0026gt; 存储 cookie\n-L, --location 跟随重定向\n-d, --data \u0026lt;data\u0026gt; 发送 application/x-www-form-urlencoded 数据\n1 2 curl -d \u0026#34;name=curl\u0026#34; -d \u0026#34;tool=cmdline\u0026#34; https://example.com curl -d @filename https://example.com --data-binary \u0026lt;data\u0026gt; 发送 application/x-www-form-urlencoded 数据\n-F, --form \u0026lt;name=content\u0026gt; 发送 multipart/form-data 数据\n@, 作为文件上传\n1 2 3 curl -F profile=@portrait.jpg https://example.com/upload.cgi # Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;nameinpost\u0026#34; curl -F \u0026#34;file=@localfile;filename=nameinpost\u0026#34; example.com 发送 form\n1 curl -F name=John -F shoesize=11 https://example.com/ \u0026lt;, 从文件中读 form\n1 curl -F \u0026#34;story=\u0026lt;hugefile.txt\u0026#34; https://example.com/ -e, --referer \u0026lt;URL\u0026gt; 添加 referer header\n1 curl --referer \u0026#34;https://fake.example;auto\u0026#34; -L https://example.com -G, --get 更改 HTTP 方法为 GET\n-i, --include 输出包括响应 header\n注意, 如果使用 -o 选项, 那么会把 header 也输出到文件中\n-v, --verbose 更多传输信息\n-k, --insecure 跳过证书检查\n-w, --write-out \u0026lt;format\u0026gt; -D, --dump-header \u0026lt;filename\u0026gt; 保存 header 到文件\n1 2 curl --json \u0026#39;{ \u0026#34;drink\u0026#34;:\u0026#39; --json \u0026#39; \u0026#34;coffe\u0026#34; }\u0026#39; https://example.com curl --json @prepared https://example.com --json \u0026lt;data\u0026gt; Files ~/.curlrc Environment Proxy protocol prefixes ","permalink":"https://jdxj.github.io/posts/cmd/curl/","summary":"原文 Options -K, --config \u0026lt;file\u0026gt; 在文件中指定 curl 的参数 选项和其参数可以用 空格, :, = 分隔 如果选项前有 - 或 --, 则可以省略 :, = 长选项可省略 -- 参数中包含空格 (或者以 :, = 开头","title":"curl"}]